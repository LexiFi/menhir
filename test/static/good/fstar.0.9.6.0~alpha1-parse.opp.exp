%{
(*
 We are expected to have only 5 shift-reduce conflicts.
 A lot (176) of end-of-stream conflicts are also reported and
 should be investigated...
*)
(* (c) Microsoft Corporation. All rights reserved *)
open Prims
open FStar_Errors
open FStar_List
open FStar_Util
open FStar_Range
open FStar_Options
(* TODO : these files should be deprecated and removed *)
open FStar_Syntax_Syntax
open FStar_Parser_Const
open FStar_Syntax_Util
open FStar_Parser_AST
open FStar_Parser_Util
open FStar_Const
open FStar_Ident
open FStar_String
%}
%start inputFragment
%start term
%start warn_error_list
%token ABSTRACT
%token AMP
%token AND
%token ASSERT
%token ASSUME
%token ATTRIBUTES
%token BACKTICK
%token BACKTICK_AT
%token BACKTICK_HASH
%token BANG_LBRACE
%token BAR
%token BAR_RBRACK
%token BEGIN
%token BY
%token <bytes> BYTEARRAY
%token <char> CHAR
%token COLON
%token COLON_COLON
%token COLON_EQUALS
%token COMMA
%token CONJUNCTION
%token DEFAULT
%token DISJUNCTION
%token DOLLAR
%token DOT
%token DOT_LBRACK
%token DOT_LBRACK_BAR
%token DOT_LENS_PAREN_LEFT
%token DOT_LPAREN
%token EFFECT
%token ELSE
%token END
%token ENSURES
%token EOF
%token EQUALS
%token EXCEPTION
%token EXISTS
%token FALSE
%token FORALL
%token <FStar_Parser_AST.fsdoc> FSDOC
%token <FStar_Parser_AST.fsdoc> FSDOC_STANDALONE
%token FUN
%token FUNCTION
%token HASH
%token <string> IDENT
%token <float> IEEE64
%token IF
%token IFF
%token IMPLIES
%token IN
%token INCLUDE
%token INLINE
%token INLINE_FOR_EXTRACTION
%token <string * bool> INT
%token <string * bool> INT16
%token <string * bool> INT32
%token <string * bool> INT64
%token <string * bool> INT8
%token IRREDUCIBLE
%token LARROW
%token LBRACE
%token LBRACE_COLON_PATTERN
%token LBRACK
%token LBRACK_AT
%token LBRACK_BAR
%token LENS_PAREN_LEFT
%token LENS_PAREN_RIGHT
%token <bool> LET
%token LOGIC
%token LONG_LEFT_ARROW
%token LPAREN
%token LPAREN_RPAREN
%token MATCH
%token MINUS
%token MODULE
%token MUTABLE
%token <string> NAME
%token NEW
%token NEW_EFFECT
%token NOEQUALITY
%token NOEXTRACT
%token OF
%token OPAQUE
%token OPEN
%token <string> OPINFIX0a
%token <string> OPINFIX0b
%token <string> OPINFIX0c
%token <string> OPINFIX0d
%token <string> OPINFIX1
%token <string> OPINFIX2
%token <string> OPINFIX3
%token <string> OPINFIX4
%token <string> OPPREFIX
%token <string> OP_MIXFIX_ACCESS
%token <string> OP_MIXFIX_ASSIGNMENT
%token PERCENT_LBRACK
%token PERC_BACKTICK
%token PIPE_RIGHT
%token PRAGMALIGHT
%token PRAGMA_RESET_OPTIONS
%token PRAGMA_SET_OPTIONS
%token PRIVATE
%token QMARK
%token QMARK_DOT
%token QUOTE
%token <string> RANGE
%token RANGE_OF
%token RARROW
%token RBRACE
%token RBRACK
%token REC
%token REFLECTABLE
%token REIFIABLE
%token REIFY
%token REQUIRES
%token RPAREN
%token SEMICOLON
%token SEMICOLON_SEMICOLON
%token SET_RANGE_OF
%token SPLICE
%token SQUIGGLY_RARROW
%token <string> STRING
%token SUBKIND
%token SUBTYPE
%token SUB_EFFECT
%token SYNTH
%token THEN
%token <string> TILDE
%token TOTAL
%token TRUE
%token TRY
%token <string> TVAR
%token TYPE
%token TYP_APP_GREATER
%token TYP_APP_LESS
%token <string> UINT16
%token <string> UINT32
%token <string> UINT64
%token <string> UINT8
%token UNDERSCORE
%token UNFOLD
%token UNFOLDABLE
%token UNIV_HASH
%token UNOPTEQUALITY
%token VAL
%token WHEN
%token WITH
%nonassoc THEN
%nonassoc ELSE
%right COLON_COLON
%right AMP
%nonassoc COLON_EQUALS
%left OPINFIX0a
%left OPINFIX0b
%left EQUALS OPINFIX0c
%left OPINFIX0d
%left PIPE_RIGHT
%right OPINFIX1
%left MINUS OPINFIX2 QUOTE
%left OPINFIX3
%left BACKTICK BACKTICK_AT BACKTICK_HASH
%right OPINFIX4
%type <FStar_Parser_AST.inputFragment> inputFragment
%type <FStar_Ident.ident> lident
%type <FStar_Parser_AST.term> term
%type <(FStar_Errors.flag * string) list> warn_error_list
%%

option_FSDOC_:
  
    {    ( None )}
| x = FSDOC
    {    ( Some x )}

option___anonymous_1_:
  
    {    ( None )}
| _1 = OF t = typ
    {let x =                                                (t) in
    ( Some x )}

option___anonymous_2_:
  
    {    ( None )}
| _1 = OF t = typ
    {let x =                                                         (t) in
    ( Some x )}

option___anonymous_5_:
  
    {    ( None )}
| _1 = BY tactic = atomicTerm
    {let x =                                                                (tactic) in
    ( Some x )}

option___anonymous_6_:
  
    {    ( None )}
| _1 = BY tactic = typ
    {let x =                                                             (tactic) in
    ( Some x )}

option___anonymous_8_:
  
    {    ( None )}
| _1 = BY tactic = typ
    {let x =                                                         (tactic) in
    ( Some x )}

option___anonymous_9_:
  
    {    ( None )}
| _1 = LBRACE e = noSeqTerm _3 = RBRACE
    {let x =
  let phi =                 ( {e with level=Formula} ) in
                                               (phi)
in
    ( Some x )}

option_ascribeKind_:
  
    {    ( None )}
| x = ascribeKind
    {    ( Some x )}

option_ascribeTyp_:
  
    {    ( None )}
| x = ascribeTyp
    {    ( Some x )}

option_fsTypeArgs_:
  
    {    ( None )}
| x = fsTypeArgs
    {    ( Some x )}

option_pair_hasSort_simpleTerm__:
  
    {    ( None )}
| x = hasSort y = simpleTerm
    {let x =     ( (x, y) ) in
    ( Some x )}

option_string_:
  
    {    ( None )}
| s = STRING
    {let x =              ( s ) in
    ( Some x )}

boption_SQUIGGLY_RARROW_:
  
    {    ( false )}
| _1 = SQUIGGLY_RARROW
    {    ( true )}

boption___anonymous_0_:
  
    {    ( false )}
| _1 = PRAGMALIGHT _2 = STRING
    {let _1 =                                         ( ) in
    ( true )}

loption_separated_nonempty_list_COMMA_appTerm__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_appTerm_
    {    ( x )}

loption_separated_nonempty_list_SEMICOLON_lidentOrOperator__:
  
    {    ( [] )}
| x = separated_nonempty_list_SEMICOLON_lidentOrOperator_
    {    ( x )}

loption_separated_nonempty_list_SEMICOLON_tuplePattern__:
  
    {    ( [] )}
| x = separated_nonempty_list_SEMICOLON_tuplePattern_
    {    ( x )}

list___anonymous_10_:
  
    {    ( [] )}
| _1 = DOT id = qlident xs = list___anonymous_10_
    {let x =                                                     (id) in
    ( x :: xs )}

list___anonymous_4_:
  
    {    ( [] )}
| b = binder xs = list___anonymous_4_
    {let x =                            ([b]) in
    ( x :: xs )}
| bs = multiBinder xs = list___anonymous_4_
    {let x =                                                   (bs) in
    ( x :: xs )}

list_argTerm_:
  
    {    ( [] )}
| x = argTerm xs = list_argTerm_
    {    ( x :: xs )}

list_atomicTerm_:
  
    {    ( [] )}
| x = atomicTerm xs = list_atomicTerm_
    {    ( x :: xs )}

list_attr_letbinding_:
  
    {    ( [] )}
| x = attr_letbinding xs = list_attr_letbinding_
    {    ( x :: xs )}

list_constructorDecl_:
  
    {    ( [] )}
| x = constructorDecl xs = list_constructorDecl_
    {    ( x :: xs )}

list_decl_:
  
    {    ( [] )}
| x = decl xs = list_decl_
    {    ( x :: xs )}

list_decoration_:
  
    {    ( [] )}
| x = decoration xs = list_decoration_
    {    ( x :: xs )}

list_multiBinder_:
  
    {    ( [] )}
| x = multiBinder xs = list_multiBinder_
    {    ( x :: xs )}

nonempty_list_aqualified_lident__:
  x = aqualified_lident_
    {    ( [ x ] )}
| x = aqualified_lident_ xs = nonempty_list_aqualified_lident__
    {    ( x :: xs )}

nonempty_list_aqualified_lidentOrUnderscore__:
  x = aqualified_lidentOrUnderscore_
    {    ( [ x ] )}
| x = aqualified_lidentOrUnderscore_ xs = nonempty_list_aqualified_lidentOrUnderscore__
    {    ( x :: xs )}

nonempty_list_atomicPattern_:
  x = atomicPattern
    {    ( [ x ] )}
| x = atomicPattern xs = nonempty_list_atomicPattern_
    {    ( x :: xs )}

nonempty_list_atomicTerm_:
  x = atomicTerm
    {    ( [ x ] )}
| x = atomicTerm xs = nonempty_list_atomicTerm_
    {    ( x :: xs )}

nonempty_list_atomicUniverse_:
  x = atomicUniverse
    {    ( [ x ] )}
| x = atomicUniverse xs = nonempty_list_atomicUniverse_
    {    ( x :: xs )}

nonempty_list_dotOperator_:
  _1 = DOT_LPAREN e = term _3 = RPAREN
    {let x =                              ( mk_ident (".()", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( [ x ] )}
| _1 = DOT_LBRACK e = term _3 = RBRACK
    {let x =                              ( mk_ident (".[]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( [ x ] )}
| _1 = DOT_LBRACK_BAR e = term _3 = RBRACE
    {let x =                                  ( mk_ident (".[||]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( [ x ] )}
| _1 = DOT_LENS_PAREN_LEFT e = term _3 = LENS_PAREN_RIGHT
    {let x =                                                 ( mk_ident (".(||)", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( [ x ] )}
| _1 = DOT_LPAREN e = term _3 = RPAREN xs = nonempty_list_dotOperator_
    {let x =                              ( mk_ident (".()", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( x :: xs )}
| _1 = DOT_LBRACK e = term _3 = RBRACK xs = nonempty_list_dotOperator_
    {let x =                              ( mk_ident (".[]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( x :: xs )}
| _1 = DOT_LBRACK_BAR e = term _3 = RBRACE xs = nonempty_list_dotOperator_
    {let x =                                  ( mk_ident (".[||]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( x :: xs )}
| _1 = DOT_LENS_PAREN_LEFT e = term _3 = LENS_PAREN_RIGHT xs = nonempty_list_dotOperator_
    {let x =                                                 ( mk_ident (".(||)", rhs parseState 1), e, rhs2 parseState 1 3 ) in
    ( x :: xs )}

nonempty_list_patternOrMultibinder_:
  x = patternOrMultibinder
    {    ( [ x ] )}
| x = patternOrMultibinder xs = nonempty_list_patternOrMultibinder_
    {    ( x :: xs )}

separated_nonempty_list_AND_letbinding_:
  x = letbinding
    {    ( [ x ] )}
| x = letbinding _2 = AND xs = separated_nonempty_list_AND_letbinding_
    {    ( x :: xs )}

separated_nonempty_list_AND_pair_option_FSDOC__typeDecl__:
  x = option_FSDOC_ y = typeDecl
    {let x =     ( (x, y) ) in
    ( [ x ] )}
| x = option_FSDOC_ y = typeDecl _2 = AND xs = separated_nonempty_list_AND_pair_option_FSDOC__typeDecl__
    {let x =     ( (x, y) ) in
    ( x :: xs )}

separated_nonempty_list_BAR_tuplePattern_:
  x = tuplePattern
    {    ( [ x ] )}
| x = tuplePattern _2 = BAR xs = separated_nonempty_list_BAR_tuplePattern_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_appTerm_:
  x = appTerm
    {    ( [ x ] )}
| x = appTerm _2 = COMMA xs = separated_nonempty_list_COMMA_appTerm_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_atomicTerm_:
  x = atomicTerm
    {    ( [ x ] )}
| x = atomicTerm _2 = COMMA xs = separated_nonempty_list_COMMA_atomicTerm_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_constructorPattern_:
  x = constructorPattern
    {    ( [ x ] )}
| x = constructorPattern _2 = COMMA xs = separated_nonempty_list_COMMA_constructorPattern_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_tmEq_:
  x = tmEq
    {    ( [ x ] )}
| x = tmEq _2 = COMMA xs = separated_nonempty_list_COMMA_tmEq_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_tvar_:
  x = tvar
    {    ( [ x ] )}
| x = tvar _2 = COMMA xs = separated_nonempty_list_COMMA_tvar_
    {    ( x :: xs )}

separated_nonempty_list_DISJUNCTION_conjunctivePat_:
  x = conjunctivePat
    {    ( [ x ] )}
| x = conjunctivePat _2 = DISJUNCTION xs = separated_nonempty_list_DISJUNCTION_conjunctivePat_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_appTerm_:
  x = appTerm
    {    ( [ x ] )}
| x = appTerm _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_appTerm_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_effectDecl_:
  x = effectDecl
    {    ( [ x ] )}
| x = effectDecl _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_effectDecl_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_fieldPattern_:
  x = fieldPattern
    {    ( [ x ] )}
| x = fieldPattern _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_fieldPattern_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_lidentOrOperator_:
  x = lidentOrOperator
    {    ( [ x ] )}
| x = lidentOrOperator _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_lidentOrOperator_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_tuplePattern_:
  x = tuplePattern
    {    ( [ x ] )}
| x = tuplePattern _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_tuplePattern_
    {    ( x :: xs )}

inputFragment:
  is_light = boption___anonymous_0_ decls = list_decl_ _3 = EOF
    {      (
        as_frag is_light (rhs parseState 1) decls
      )}

pragma:
  _1 = PRAGMA_SET_OPTIONS s = STRING
    {let s =              ( s ) in
      ( SetOptions s )}
| _1 = PRAGMA_RESET_OPTIONS s_opt = option_string_
    {      ( ResetOptions s_opt )}

attribute:
  _1 = LBRACK_AT x = list_atomicTerm_ _3 = RBRACK
    {      ( x )}

decoration:
  x = FSDOC
    {      ( Doc x )}
| x = attribute
    {      ( DeclAttributes x )}
| x = qualifier
    {      ( Qualifier x )}

decl:
  _1 = ASSUME lid = uident _3 = COLON e = noSeqTerm
    {let phi =                 ( {e with level=Formula} ) in
      ( mk_decl (Assume(lid, phi)) (rhs2 parseState 1 4) [ Qualifier Assumption ] )}
| ds = list_decoration_ decl = rawDecl
    {      ( mk_decl decl (rhs parseState 2) ds )}

rawDecl:
  p = pragma
    {      ( Pragma p )}
| _1 = OPEN uid = quident
    {      ( Open uid )}
| _1 = INCLUDE uid = quident
    {      ( Include uid )}
| _1 = MODULE uid1 = uident _3 = EQUALS uid2 = quident
    {      ( ModuleAbbrev(uid1, uid2) )}
| _1 = MODULE uid = quident
    {      (  TopLevelModule uid )}
| _1 = TYPE tcdefs = separated_nonempty_list_AND_pair_option_FSDOC__typeDecl__
    {      ( Tycon (false, List.map (fun (doc, f) -> (f, doc)) tcdefs) )}
| _1 = EFFECT uid = uident tparams = typars _4 = EQUALS t = typ
    {      ( Tycon(true, [(TyconAbbrev(uid, tparams, None, t), None)]) )}
| _1 = LET q = letqualifier lbs = separated_nonempty_list_AND_letbinding_
    {      (
        let r = rhs2 parseState 1 3 in
        let lbs = focusLetBindings lbs r in
        if q <> Rec && List.length lbs <> 1
        then raise_error (Fatal_MultipleLetBinding, "Unexpected multiple let-binding (Did you forget some rec qualifier ?)") r;
        TopLevelLet(q, lbs)
      )}
| _1 = VAL lid = lidentOrOperator bss = list_multiBinder_ _4 = COLON t = typ
    {      (
        let t = match flatten bss with
          | [] -> t
          | bs -> mk_term (Product(bs, t)) (rhs2 parseState 3 5) Type_level
        in Val(lid, t)
      )}
| _1 = SPLICE _2 = LBRACK xs = loption_separated_nonempty_list_SEMICOLON_lidentOrOperator__ _4 = RBRACK t = atomicTerm
    {let ids =     ( xs ) in
      ( Splice (ids, t) )}
| _1 = EXCEPTION lid = uident t_opt = option___anonymous_1_
    {      ( Exception(lid, t_opt) )}
| _1 = NEW_EFFECT ne = newEffect
    {      ( NewEffect ne )}
| _1 = SUB_EFFECT se = subEffect
    {      ( SubEffect se )}
| doc = FSDOC_STANDALONE
    {      ( Fsdoc doc )}

typeDecl:
  lid = ident tparams = typars ascr_opt = option_ascribeKind_ tcdef = typeDefinition
    {      ( tcdef lid tparams ascr_opt )}

typars:
  x = tvarinsts
    {                             ( x )}
| x = binders
    {                             ( x )}

tvarinsts:
  _1 = TYP_APP_LESS tvs = separated_nonempty_list_COMMA_tvar_ _3 = TYP_APP_GREATER
    {      ( map (fun tv -> mk_binder (TVariable(tv)) tv.idRange Kind None) tvs )}

typeDefinition:
  
    {      ( (fun id binders kopt -> check_id id; TyconAbstract(id, binders, kopt)) )}
| _1 = EQUALS t = typ
    {      ( (fun id binders kopt ->  check_id id; TyconAbbrev(id, binders, kopt, t)) )}
| _1 = EQUALS _2 = LBRACE record_field_decls = right_flexible_nonempty_list_SEMICOLON_recordFieldDecl_ _4 = RBRACE
    {      ( (fun id binders kopt -> check_id id; TyconRecord(id, binders, kopt, record_field_decls)) )}
| _1 = EQUALS ct_decls = list_constructorDecl_
    {      ( (fun id binders kopt -> check_id id; TyconVariant(id, binders, kopt, ct_decls)) )}

recordFieldDecl:
  lid = lident _3 = COLON t = typ
    {let doc_opt =     ( None ) in
      ( (lid, t, doc_opt) )}
| x = FSDOC lid = lident _3 = COLON t = typ
    {let doc_opt =     ( Some x ) in
      ( (lid, t, doc_opt) )}

constructorDecl:
  _1 = BAR doc_opt = option_FSDOC_ uid = uident _4 = COLON t = typ
    {                                                             ( (uid, Some t, doc_opt, false) )}
| _1 = BAR doc_opt = option_FSDOC_ uid = uident t_opt = option___anonymous_2_
    {                                                             ( (uid, t_opt, doc_opt, true) )}

attr_letbinding:
  _2 = AND lb = letbinding
    {let attr =     ( None ) in
    ( attr, lb )}
| x = attribute _2 = AND lb = letbinding
    {let attr =     ( Some x ) in
    ( attr, lb )}

letbinding:
  focus_opt = maybeFocus lid = lidentOrOperator lbp = nonempty_list_patternOrMultibinder_ ascr_opt = option_ascribeTyp_ _5 = EQUALS tm = term
    {      (
        let pat = mk_pattern (PatVar(lid, None)) (rhs parseState 2) in
        let pat = mk_pattern (PatApp (pat, flatten lbp)) (rhs2 parseState 1 3) in
        let pos = rhs2 parseState 1 6 in
        match ascr_opt with
        | None -> (focus_opt, (pat, tm))
        | Some t -> (focus_opt, (mk_pattern (PatAscribed(pat, t)) pos, tm))
      )}
| focus_opt = maybeFocus pat = tuplePattern ascr = ascribeTyp _4 = EQUALS tm = term
    {      ( focus_opt, (mk_pattern (PatAscribed(pat, ascr)) (rhs2 parseState 1 4), tm) )}
| focus_opt = maybeFocus pat = tuplePattern _3 = EQUALS tm = term
    {      ( focus_opt, (pat, tm) )}

newEffect:
  ed = effectRedefinition
    {    ( ed )}
| ed = effectDefinition
    {    ( ed )}

effectRedefinition:
  lid = uident _2 = EQUALS t = simpleTerm
    {    ( RedefineEffect(lid, [], t) )}

effectDefinition:
  _1 = LBRACE lid = uident bs = binders _4 = COLON typ = tmArrow_tmNoEq_ _6 = WITH eds = separated_nonempty_list_SEMICOLON_effectDecl_ _8 = RBRACE
    {    ( DefineEffect(lid, bs, typ, eds) )}

effectDecl:
  lid = lident action_params = binders _3 = EQUALS t = simpleTerm
    {    ( mk_decl (Tycon (false, [TyconAbbrev(lid, action_params, None, t), None])) (rhs2 parseState 1 3) [] )}

subEffect:
  src_eff = quident _2 = SQUIGGLY_RARROW tgt_eff = quident _4 = EQUALS lift = simpleTerm
    {      ( { msource = src_eff; mdest = tgt_eff; lift_op = NonReifiableLift lift } )}
| src_eff = quident _2 = SQUIGGLY_RARROW tgt_eff = quident _4 = LBRACE x = IDENT _2_inlined1 = EQUALS y = simpleTerm _7 = RBRACE
    {let lift2_opt =     ( None ) in
let lift1 =     ( (x, y) ) in
     (
       match lift2_opt with
       | None ->
          begin match lift1 with
          | ("lift", lift) ->
             { msource = src_eff; mdest = tgt_eff; lift_op = LiftForFree lift }
          | ("lift_wp", lift_wp) ->
             { msource = src_eff; mdest = tgt_eff; lift_op = NonReifiableLift lift_wp }
          | _ ->
             raise_error (Fatal_UnexpectedIdentifier, "Unexpected identifier; expected {'lift', and possibly 'lift_wp'}") (lhs parseState)
          end
       | Some (id2, tm2) ->
          let (id1, tm1) = lift1 in
          let lift, lift_wp = match (id1, id2) with
                  | "lift_wp", "lift" -> tm1, tm2
                  | "lift", "lift_wp" -> tm2, tm1
                  | _ -> raise_error (Fatal_UnexpectedIdentifier, "Unexpected identifier; expected {'lift', 'lift_wp'}") (lhs parseState)
          in
          { msource = src_eff; mdest = tgt_eff; lift_op = ReifiableLift (lift, lift_wp) }
     )}
| src_eff = quident _2 = SQUIGGLY_RARROW tgt_eff = quident _4 = LBRACE x = IDENT _2_inlined1 = EQUALS y = simpleTerm _1 = SEMICOLON id = IDENT _2_inlined2 = EQUALS y_inlined1 = simpleTerm _7 = RBRACE
    {let lift2_opt =
  let y = y_inlined1 in
  let x =
    let x =                                                           (id) in
        ( (x, y) )
  in
      ( Some x )
in
let lift1 =     ( (x, y) ) in
     (
       match lift2_opt with
       | None ->
          begin match lift1 with
          | ("lift", lift) ->
             { msource = src_eff; mdest = tgt_eff; lift_op = LiftForFree lift }
          | ("lift_wp", lift_wp) ->
             { msource = src_eff; mdest = tgt_eff; lift_op = NonReifiableLift lift_wp }
          | _ ->
             raise_error (Fatal_UnexpectedIdentifier, "Unexpected identifier; expected {'lift', and possibly 'lift_wp'}") (lhs parseState)
          end
       | Some (id2, tm2) ->
          let (id1, tm1) = lift1 in
          let lift, lift_wp = match (id1, id2) with
                  | "lift_wp", "lift" -> tm1, tm2
                  | "lift", "lift_wp" -> tm2, tm1
                  | _ -> raise_error (Fatal_UnexpectedIdentifier, "Unexpected identifier; expected {'lift', 'lift_wp'}") (lhs parseState)
          in
          { msource = src_eff; mdest = tgt_eff; lift_op = ReifiableLift (lift, lift_wp) }
     )}

qualifier:
  _1 = ASSUME
    {                  ( Assumption )}
| _1 = INLINE
    {                  (
    raise_error (Fatal_InlineRenamedAsUnfold, "The 'inline' qualifier has been renamed to 'unfold'") (lhs parseState)
   )}
| _1 = UNFOLDABLE
    {                  (
              raise_error (Fatal_UnfoldableDeprecated, "The 'unfoldable' qualifier is no longer denotable; it is the default qualifier so just omit it") (lhs parseState)
   )}
| _1 = INLINE_FOR_EXTRACTION
    {                          (
     Inline_for_extraction
  )}
| _1 = UNFOLD
    {           (
     Unfold_for_unification_and_vcgen
  )}
| _1 = IRREDUCIBLE
    {                  ( Irreducible )}
| _1 = NOEXTRACT
    {                  ( NoExtract )}
| _1 = DEFAULT
    {                  ( DefaultEffect )}
| _1 = TOTAL
    {                  ( TotalEffect )}
| _1 = PRIVATE
    {                  ( Private )}
| _1 = ABSTRACT
    {                  ( Abstract )}
| _1 = NOEQUALITY
    {                  ( Noeq )}
| _1 = UNOPTEQUALITY
    {                  ( Unopteq )}
| _1 = NEW
    {                  ( New )}
| _1 = LOGIC
    {                  ( Logic )}
| _1 = OPAQUE
    {                  ( Opaque )}
| _1 = REIFIABLE
    {                  ( Reifiable )}
| _1 = REFLECTABLE
    {                  ( Reflectable )}

maybeFocus:
  b = boption_SQUIGGLY_RARROW_
    {                               ( b )}

letqualifier:
  _1 = REC
    {                ( Rec )}
| _1 = MUTABLE
    {                ( Mutable )}
| 
    {                ( NoLetQualifier )}

aqual:
  _1 = EQUALS
    {              (  log_issue (lhs parseState) (Warning_DeprecatedEqualityOnBinder, "The '=' notation for equality constraints on binders is deprecated; use '$' instead");
                                        Equality )}
| q = aqualUniverses
    {                     ( q )}

aqualUniverses:
  _1 = HASH
    {              ( Implicit )}
| _1 = DOLLAR
    {              ( Equality )}

disjunctivePattern:
  pats = separated_nonempty_list_BAR_tuplePattern_
    {                                                    ( pats )}

tuplePattern:
  pats = separated_nonempty_list_COMMA_constructorPattern_
    {      ( match pats with | [x] -> x | l -> mk_pattern (PatTuple (l, false)) (rhs parseState 1) )}

constructorPattern:
  pat = constructorPattern _2 = COLON_COLON pats = constructorPattern
    {      ( mk_pattern (consPat (rhs parseState 3) pat pats) (rhs2 parseState 1 3) )}
| uid = quident args = nonempty_list_atomicPattern_
    {      (
        let head_pat = mk_pattern (PatName uid) (rhs parseState 1) in
        mk_pattern (PatApp (head_pat, args)) (rhs2 parseState 1 2)
      )}
| pat = atomicPattern
    {      ( pat )}

atomicPattern:
  _1 = LPAREN pat = tuplePattern _3 = COLON t = simpleArrow phi_opt = refineOpt _6 = RPAREN
    {      (
        let pos_t = rhs2 parseState 2 4 in
        let pos = rhs2 parseState 1 6 in
        mkRefinedPattern pat t true phi_opt pos_t pos
      )}
| _1 = LBRACK xs = loption_separated_nonempty_list_SEMICOLON_tuplePattern__ _3 = RBRACK
    {let pats =     ( xs ) in
      ( mk_pattern (PatList pats) (rhs2 parseState 1 3) )}
| _1 = LBRACE record_pat = separated_nonempty_list_SEMICOLON_fieldPattern_ _3 = RBRACE
    {      ( mk_pattern (PatRecord record_pat) (rhs2 parseState 1 3) )}
| _1 = LENS_PAREN_LEFT pat0 = constructorPattern _3 = COMMA pats = separated_nonempty_list_COMMA_constructorPattern_ _5 = LENS_PAREN_RIGHT
    {      ( mk_pattern (PatTuple(pat0::pats, true)) (rhs2 parseState 1 5) )}
| _1 = LPAREN pat = tuplePattern _3 = RPAREN
    {                                     ( pat )}
| tv = tvar
    {                              ( mk_pattern (PatTvar (tv, None)) (rhs parseState 1) )}
| _1 = LPAREN op = OPPREFIX _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX3 _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX4 _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX0a _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX0b _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX0c _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX0d _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX1 _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OPINFIX2 _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = PIPE_RIGHT _3 = RPAREN
    {let op =      ( mk_ident("|>", rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = COLON_EQUALS _3 = RPAREN
    {let op =      ( mk_ident(":=", rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = COLON_COLON _3 = RPAREN
    {let op =      ( mk_ident("::", rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OP_MIXFIX_ASSIGNMENT _3 = RPAREN
    {let op =      ( mk_ident(op, rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = LPAREN op = OP_MIXFIX_ACCESS _3 = RPAREN
    {let op =      ( mk_ident(op, rhs parseState 1) ) in
      ( mk_pattern (PatOp op) (rhs2 parseState 1 3) )}
| _1 = UNDERSCORE
    {      ( mk_pattern PatWild (rhs parseState 1) )}
| _1 = HASH _2 = UNDERSCORE
    {      ( mk_pattern (PatVar (gen (rhs2 parseState 1 2), Some Implicit)) (rhs parseState 1) )}
| c = constant
    {      ( mk_pattern (PatConst c) (rhs parseState 1) )}
| qual_id = aqualified_lident_
    {      ( mk_pattern (PatVar (snd qual_id, fst qual_id)) (rhs parseState 1) )}
| uid = quident
    {      ( mk_pattern (PatName uid) (rhs parseState 1) )}

fieldPattern:
  x = qlident _2 = EQUALS y = tuplePattern
    {let p =     ( (x, y) ) in
      ( p )}
| lid = qlident
    {      ( lid, mk_pattern (PatVar (lid.ident, None)) (rhs parseState 1) )}

patternOrMultibinder:
  pat = atomicPattern
    {                      ( [pat] )}
| _1 = LPAREN qual_id0 = aqualified_lident_ qual_ids = nonempty_list_aqualified_lident__ _4 = COLON t = simpleArrow r = refineOpt _7 = RPAREN
    {      (
        let pos = rhs2 parseState 1 7 in
        let t_pos = rhs parseState 5 in
        let qual_ids = qual_id0 :: qual_ids in
        List.map (fun (q, x) -> mkRefinedPattern (mk_pattern (PatVar (x, q)) pos) t false r t_pos pos) qual_ids
      )}

binder:
  aqualified_lid = aqualified_lidentOrUnderscore_
    {     (
       let (q, lid) = aqualified_lid in
       mk_binder (Variable lid) (rhs parseState 1) Type_level q
     )}
| tv = tvar
    {             ( mk_binder (TVariable tv) (rhs parseState 1) Kind None  )}

multiBinder:
  _1 = LPAREN qual_ids = nonempty_list_aqualified_lidentOrUnderscore__ _3 = COLON t = simpleArrow r = refineOpt _6 = RPAREN
    {     (
       let should_bind_var = match qual_ids with | [ _ ] -> true | _ -> false in
       List.map (fun (q, x) -> mkRefinedBinder x t should_bind_var r (rhs2 parseState 1 6) q) qual_ids
     )}

binders:
  bss = list___anonymous_4_
    {                                                        ( flatten bss )}

aqualified_lident_:
  y = lident
    {let x =
  let x =     ( None ) in
      ( (x, y) )
in
                                                  ( x )}
| x = aqualUniverses y = lident
    {let x =
  let x =     ( Some x ) in
      ( (x, y) )
in
                                                  ( x )}

aqualified_lidentOrUnderscore_:
  y = lidentOrUnderscore
    {let x =
  let x =     ( None ) in
      ( (x, y) )
in
                                                  ( x )}
| x = aqualUniverses y = lidentOrUnderscore
    {let x =
  let x =     ( Some x ) in
      ( (x, y) )
in
                                                  ( x )}

qlident:
  ids = path_lident_
    {                     ( lid_of_ids ids )}

quident:
  ids = path_uident_
    {                     ( lid_of_ids ids )}

path_lident_:
  id = lident
    {          ( [id] )}
| uid = uident _2 = DOT p = path_lident_
    {                              ( uid::p )}

path_uident_:
  id = uident
    {          ( [id] )}
| uid = uident _2 = DOT p = path_uident_
    {                              ( uid::p )}

ident:
  x = lident
    {             ( x )}
| x = uident
    {              ( x )}

lidentOrOperator:
  id = IDENT
    {    ( mk_ident(id, rhs parseState 1) )}
| _1 = LPAREN op = OPPREFIX _3 = RPAREN
    {let id =      ( mk_ident (op, rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX3 _3 = RPAREN
    {let id =      ( mk_ident (op, rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX4 _3 = RPAREN
    {let id =      ( mk_ident (op, rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX0a _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX0b _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX0c _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX0d _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX1 _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OPINFIX2 _3 = RPAREN
    {let id =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = PIPE_RIGHT _3 = RPAREN
    {let id =      ( mk_ident("|>", rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = COLON_EQUALS _3 = RPAREN
    {let id =      ( mk_ident(":=", rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = COLON_COLON _3 = RPAREN
    {let id =      ( mk_ident("::", rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OP_MIXFIX_ASSIGNMENT _3 = RPAREN
    {let id =      ( mk_ident(op, rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}
| _1 = LPAREN op = OP_MIXFIX_ACCESS _3 = RPAREN
    {let id =      ( mk_ident(op, rhs parseState 1) ) in
    ( {id with idText = compile_op' id.idText id.idRange} )}

lidentOrUnderscore:
  id = IDENT
    {             ( mk_ident(id, rhs parseState 1))}
| _1 = UNDERSCORE
    {               ( gen (rhs parseState 1) )}

lident:
  id = IDENT
    {             ( mk_ident(id, rhs parseState 1))}

uident:
  id = NAME
    {            ( mk_ident(id, rhs parseState 1) )}

tvar:
  tv = TVAR
    {            ( mk_ident(tv, rhs parseState 1) )}

ascribeTyp:
  _1 = COLON t = tmArrow_tmNoEq_ tacopt = option___anonymous_5_
    {                                                                         ( t, tacopt )}

ascribeKind:
  _1 = COLON k = kind
    {                  ( k )}

kind:
  t = tmArrow_tmNoEq_
    {                      ( {t with level=Kind} )}

term:
  e = noSeqTerm
    {      ( e )}
| e1 = noSeqTerm _2 = SEMICOLON e2 = term
    {      ( mk_term (Seq(e1, e2)) (rhs2 parseState 1 3) Expr )}
| e1 = noSeqTerm _2 = SEMICOLON_SEMICOLON e2 = term
    {      ( mk_term (Bind(gen (rhs parseState 2), e1, e2)) (rhs2 parseState 1 3) Expr )}
| x = lidentOrUnderscore _2 = LONG_LEFT_ARROW e1 = noSeqTerm _4 = SEMICOLON e2 = term
    {      ( mk_term (Bind(x, e1, e2)) (rhs2 parseState 1 5) Expr )}

noSeqTerm:
  t = typ
    {           ( t )}
| e = tmIff _2 = SUBTYPE t = tmIff tactic_opt = option___anonymous_6_
    {      ( mk_term (Ascribed(e,{t with level=Expr},tactic_opt)) (rhs2 parseState 1 4) Expr )}
| e1 = atomicTermNotQUident _1 = DOT_LPAREN e = term _3_inlined1 = RPAREN _3 = LARROW e3 = noSeqTerm
    {let op_expr =                              ( mk_ident (".()", rhs parseState 1), e, rhs2 parseState 1 3 ) in
      (
        let (op, e2, _) = op_expr in
        mk_term (Op({op with idText = op.idText ^ "<-"}, [ e1; e2; e3 ])) (rhs2 parseState 1 4) Expr
      )}
| e1 = atomicTermNotQUident _1 = DOT_LBRACK e = term _3_inlined1 = RBRACK _3 = LARROW e3 = noSeqTerm
    {let op_expr =                              ( mk_ident (".[]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
      (
        let (op, e2, _) = op_expr in
        mk_term (Op({op with idText = op.idText ^ "<-"}, [ e1; e2; e3 ])) (rhs2 parseState 1 4) Expr
      )}
| e1 = atomicTermNotQUident _1 = DOT_LBRACK_BAR e = term _3_inlined1 = RBRACE _3 = LARROW e3 = noSeqTerm
    {let op_expr =                                  ( mk_ident (".[||]", rhs parseState 1), e, rhs2 parseState 1 3 ) in
      (
        let (op, e2, _) = op_expr in
        mk_term (Op({op with idText = op.idText ^ "<-"}, [ e1; e2; e3 ])) (rhs2 parseState 1 4) Expr
      )}
| e1 = atomicTermNotQUident _1 = DOT_LENS_PAREN_LEFT e = term _3_inlined1 = LENS_PAREN_RIGHT _3 = LARROW e3 = noSeqTerm
    {let op_expr =                                                 ( mk_ident (".(||)", rhs parseState 1), e, rhs2 parseState 1 3 ) in
      (
        let (op, e2, _) = op_expr in
        mk_term (Op({op with idText = op.idText ^ "<-"}, [ e1; e2; e3 ])) (rhs2 parseState 1 4) Expr
      )}
| _1 = REQUIRES t = typ
    {      ( mk_term (Requires(t, None)) (rhs2 parseState 1 2) Type_level )}
| _1 = ENSURES t = typ
    {      ( mk_term (Ensures(t, None)) (rhs2 parseState 1 2) Type_level )}
| _1 = ATTRIBUTES es = nonempty_list_atomicTerm_
    {      ( mk_term (Attributes es) (rhs2 parseState 1 2) Type_level )}
| _1 = IF e1 = noSeqTerm _3 = THEN e2 = noSeqTerm _5 = ELSE e3 = noSeqTerm
    {      ( mk_term (If(e1, e2, e3)) (rhs2 parseState 1 6) Expr )}
| _1 = IF e1 = noSeqTerm _3 = THEN e2 = noSeqTerm
    {      (
        let e3 = mk_term (Const Const_unit) (rhs2 parseState 4 4) Expr in
        mk_term (If(e1, e2, e3)) (rhs2 parseState 1 4) Expr
      )}
| _1 = TRY e1 = term _3 = WITH xs = reverse_left_flexible_nonempty_list_BAR_patternBranch_
    {let pbs =    ( List.rev xs ) in
      (
         let branches = focusBranches (pbs) (rhs2 parseState 1 4) in
         mk_term (TryWith(e1, branches)) (rhs2 parseState 1 4) Expr
      )}
| _1 = MATCH e = term _3 = WITH xs = reverse_left_flexible_list_BAR___anonymous_7_
    {let pbs =    ( List.rev xs ) in
      (
        let branches = focusBranches pbs (rhs2 parseState 1 4) in
        mk_term (Match(e, branches)) (rhs2 parseState 1 4) Expr
      )}
| _1 = LET _2 = OPEN uid = quident _4 = IN e = term
    {      ( mk_term (LetOpen(uid, e)) (rhs2 parseState 1 5) Expr )}
| _2 = LET q = letqualifier lb = letbinding lbs = list_attr_letbinding_ _6 = IN e = term
    {let attrs =     ( None ) in
      (
        let lbs = (attrs, lb)::lbs in
        let lbs = focusAttrLetBindings lbs (rhs2 parseState 2 3) in
        mk_term (Let(q, lbs, e)) (rhs2 parseState 1 5) Expr
      )}
| x = attribute _2 = LET q = letqualifier lb = letbinding lbs = list_attr_letbinding_ _6 = IN e = term
    {let attrs =     ( Some x ) in
      (
        let lbs = (attrs, lb)::lbs in
        let lbs = focusAttrLetBindings lbs (rhs2 parseState 2 3) in
        mk_term (Let(q, lbs, e)) (rhs2 parseState 1 5) Expr
      )}
| _1 = FUNCTION xs = reverse_left_flexible_nonempty_list_BAR_patternBranch_
    {let pbs =    ( List.rev xs ) in
      (
        let branches = focusBranches pbs (rhs2 parseState 1 2) in
        mk_function branches (lhs parseState) (rhs2 parseState 1 2)
      )}
| _1 = ASSUME e = atomicTerm
    {      ( let a = set_lid_range assume_lid (rhs parseState 1) in
        mkExplicitApp (mk_term (Var a) (rhs parseState 1) Expr) [e] (rhs2 parseState 1 2) )}
| _1 = ASSERT e = atomicTerm tactic_opt = option___anonymous_8_
    {      (
        match tactic_opt with
        | None ->
          let a = set_lid_range assert_lid (rhs parseState 1) in
          mkExplicitApp (mk_term (Var a) (rhs parseState 1) Expr) [e] (rhs2 parseState 1 2)
        | Some tac ->
          let a = set_lid_range assert_by_tactic_lid (rhs parseState 1) in
          mkExplicitApp (mk_term (Var a) (rhs parseState 1) Expr) [e; tac] (rhs2 parseState 1 4)
      )}
| _1 = SYNTH tactic = atomicTerm
    {     (
         let a = set_lid_range synth_lid (rhs parseState 1) in
         mkExplicitApp (mk_term (Var a) (rhs parseState 1) Expr) [tactic] (rhs2 parseState 1 2)

     )}

typ:
  t = simpleTerm
    {                  ( t )}
| _1 = FORALL bs = binders _3 = DOT trigger = trigger e = noSeqTerm
    {let q =            ( fun x -> QForall x ) in
      (
        match bs with
            | [] -> raise_error (Fatal_MissingQuantifierBinder, "Missing binders for a quantifier") (rhs2 parseState 1 3)
            | _ -> mk_term (q (bs, trigger, e)) (rhs2 parseState 1 5) Formula
      )}
| _1 = EXISTS bs = binders _3 = DOT trigger = trigger e = noSeqTerm
    {let q =            ( fun x -> QExists x) in
      (
        match bs with
            | [] -> raise_error (Fatal_MissingQuantifierBinder, "Missing binders for a quantifier") (rhs2 parseState 1 3)
            | _ -> mk_term (q (bs, trigger, e)) (rhs2 parseState 1 5) Formula
      )}

trigger:
  
    {      ( [] )}
| _1 = LBRACE_COLON_PATTERN pats = disjunctivePats _3 = RBRACE
    {                                                     ( pats )}

disjunctivePats:
  pats = separated_nonempty_list_DISJUNCTION_conjunctivePat_
    {                                                              ( pats )}

conjunctivePat:
  pats = separated_nonempty_list_SEMICOLON_appTerm_
    {                                                              ( pats )}

simpleTerm:
  e = tmIff
    {            ( e )}
| _1 = FUN pats = nonempty_list_patternOrMultibinder_ _3 = RARROW e = term
    {      ( mk_term (Abs(flatten pats, e)) (rhs2 parseState 1 4) Un )}

maybeFocusArrow:
  _1 = RARROW
    {                    ( false )}
| _1 = SQUIGGLY_RARROW
    {                    ( true )}

patternBranch:
  pat = disjunctivePattern focus = maybeFocusArrow e = term
    {let when_opt =                          ( None ) in
      (
        let pat = match pat with
          | [p] -> p
          | ps -> mk_pattern (PatOr ps) (rhs2 parseState 1 1)
        in
        (focus, (pat, when_opt, e))
      )}
| pat = disjunctivePattern _1 = WHEN e_inlined1 = tmFormula focus = maybeFocusArrow e = term
    {let when_opt =
  let e = e_inlined1 in
                           ( Some e )
in
      (
        let pat = match pat with
          | [p] -> p
          | ps -> mk_pattern (PatOr ps) (rhs2 parseState 1 1)
        in
        (focus, (pat, when_opt, e))
      )}

tmIff:
  e1 = tmImplies _2 = IFF e2 = tmIff
    {      ( mk_term (Op(mk_ident("<==>", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Formula )}
| e = tmImplies
    {                ( e )}

tmImplies:
  e1 = tmArrow_tmFormula_ _2 = IMPLIES e2 = tmImplies
    {      ( mk_term (Op(mk_ident("==>", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Formula )}
| e = tmArrow_tmFormula_
    {      ( e )}

tmArrow_tmFormula_:
  _1 = LPAREN q = aqual dom_tm = tmFormula _4 = RPAREN _2 = RARROW tgt = tmArrow_tmFormula_
    {let dom =                                     ( Some q, dom_tm ) in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| dom_tm = tmFormula _2 = RARROW tgt = tmArrow_tmFormula_
    {let dom =
  let aq_opt =     ( None ) in
                                      ( aq_opt, dom_tm )
in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| x = aqual dom_tm = tmFormula _2 = RARROW tgt = tmArrow_tmFormula_
    {let dom =
  let aq_opt =     ( Some x ) in
                                      ( aq_opt, dom_tm )
in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| e = tmFormula
    {         ( e )}

tmArrow_tmNoEq_:
  _1 = LPAREN q = aqual dom_tm = tmNoEq _4 = RPAREN _2 = RARROW tgt = tmArrow_tmNoEq_
    {let dom =                                     ( Some q, dom_tm ) in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| dom_tm = tmNoEq _2 = RARROW tgt = tmArrow_tmNoEq_
    {let dom =
  let aq_opt =     ( None ) in
                                      ( aq_opt, dom_tm )
in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| x = aqual dom_tm = tmNoEq _2 = RARROW tgt = tmArrow_tmNoEq_
    {let dom =
  let aq_opt =     ( Some x ) in
                                      ( aq_opt, dom_tm )
in
     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| e = tmNoEq
    {         ( e )}

simpleArrow:
  dom = simpleArrowDomain _2 = RARROW tgt = simpleArrow
    {     (
       let (aq_opt, dom_tm) = dom in
       let b = match extract_named_refinement dom_tm with
         | None -> mk_binder (NoName dom_tm) (rhs parseState 1) Un aq_opt
         | Some (x, t, f) -> mkRefinedBinder x t true f (rhs2 parseState 1 1) aq_opt
       in
       mk_term (Product([b], tgt)) (rhs2 parseState 1 3)  Un
     )}
| e = tmEqNoRefinement
    {                       ( e )}

simpleArrowDomain:
  dom_tm = tmEqNoRefinement
    {let aq_opt =     ( None ) in
                                                  ( aq_opt, dom_tm )}
| x = aqual dom_tm = tmEqNoRefinement
    {let aq_opt =     ( Some x ) in
                                                  ( aq_opt, dom_tm )}

tmFormula:
  e1 = tmFormula _2 = DISJUNCTION e2 = tmConjunction
    {      ( mk_term (Op(mk_ident("\/", rhs parseState 2), [e1;e2])) (rhs2 parseState 1 3) Formula )}
| e = tmConjunction
    {                    ( e )}

tmConjunction:
  e1 = tmConjunction _2 = CONJUNCTION e2 = tmTuple
    {      ( mk_term (Op(mk_ident("/\\", rhs parseState 2), [e1;e2])) (rhs2 parseState 1 3) Formula )}
| e = tmTuple
    {              ( e )}

tmTuple:
  el = separated_nonempty_list_COMMA_tmEq_
    {      (
        match el with
          | [x] -> x
          | components -> mkTuple components (rhs2 parseState 1 1)
      )}

tmEqWith_appTerm_:
  e1 = tmEqWith_appTerm_ _2 = EQUALS e2 = tmEqWith_appTerm_
    {      ( mk_term (Op(mk_ident("=", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ _2 = COLON_EQUALS e2 = tmEqWith_appTerm_
    {      ( mk_term (Op(mk_ident(":=", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ _2 = PIPE_RIGHT e2 = tmEqWith_appTerm_
    {      ( mk_term (Op(mk_ident("|>", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX0a e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX0b e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX0c e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX0d e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX1 e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ op = OPINFIX2 e2 = tmEqWith_appTerm_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_appTerm_ _2 = MINUS e2 = tmEqWith_appTerm_
    {      ( mk_term (Op(mk_ident("-", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| _1 = MINUS e = tmEqWith_appTerm_
    {      ( mk_uminus e (rhs parseState 1) (rhs2 parseState 1 2) Expr )}
| _1 = QUOTE e = tmEqWith_appTerm_
    {      ( mk_term (Quote (e, Dynamic)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK e = tmEqWith_appTerm_
    {      ( mk_term (Quote (e, Static)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK_AT e = atomicTerm
    {      ( mk_term (Antiquote (true, e)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK_HASH e = atomicTerm
    {      ( mk_term (Antiquote (false, e)) (rhs2 parseState 1 3) Un )}
| e = tmNoEqWith_appTerm_
    {      ( e )}

tmEqWith_tmRefinement_:
  e1 = tmEqWith_tmRefinement_ _2 = EQUALS e2 = tmEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident("=", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ _2 = COLON_EQUALS e2 = tmEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident(":=", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ _2 = PIPE_RIGHT e2 = tmEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident("|>", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX0a e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX0b e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX0c e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX0d e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX1 e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ op = OPINFIX2 e2 = tmEqWith_tmRefinement_
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmEqWith_tmRefinement_ _2 = MINUS e2 = tmEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident("-", rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| _1 = MINUS e = tmEqWith_tmRefinement_
    {      ( mk_uminus e (rhs parseState 1) (rhs2 parseState 1 2) Expr )}
| _1 = QUOTE e = tmEqWith_tmRefinement_
    {      ( mk_term (Quote (e, Dynamic)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK e = tmEqWith_tmRefinement_
    {      ( mk_term (Quote (e, Static)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK_AT e = atomicTerm
    {      ( mk_term (Antiquote (true, e)) (rhs2 parseState 1 3) Un )}
| _1 = BACKTICK_HASH e = atomicTerm
    {      ( mk_term (Antiquote (false, e)) (rhs2 parseState 1 3) Un )}
| e = tmNoEqWith_tmRefinement_
    {      ( e )}

tmNoEqWith_appTerm_:
  e1 = tmNoEqWith_appTerm_ _2 = COLON_COLON e2 = tmNoEqWith_appTerm_
    {      ( consTerm (rhs parseState 2) e1 e2 )}
| e1 = tmNoEqWith_appTerm_ _2 = AMP e2 = tmNoEqWith_appTerm_
    {      (
        let x, t, f = match extract_named_refinement e1 with
            | Some (x, t, f) -> x, t, f
            | _ -> raise_error (Fatal_MissingQuantifierBinder, "Missing binder for the first component of a dependent tuple") (rhs parseState 1) in
        let dom = mkRefinedBinder x t true f (rhs parseState 1) None in
        let tail = e2 in
        let dom, res = match tail.tm with
            | Sum(dom', res) -> dom::dom', res
            | _ -> [dom], tail in
        mk_term (Sum(dom, res)) (rhs2 parseState 1 3) Type_level
      )}
| e1 = tmNoEqWith_appTerm_ op = OPINFIX3 e2 = tmNoEqWith_appTerm_
    {      ( mk_term (Op(mk_ident(op, rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmNoEqWith_appTerm_ _2 = BACKTICK id = qlident _4 = BACKTICK e2 = tmNoEqWith_appTerm_
    {      ( mkApp (mk_term (Var id) (rhs2 parseState 2 4) Un) [ e1, Nothing; e2, Nothing ] (rhs2 parseState 1 5) )}
| e1 = tmNoEqWith_appTerm_ op = OPINFIX4 e2 = tmNoEqWith_appTerm_
    {      ( mk_term (Op(mk_ident(op, rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| _1 = LBRACE e = recordExp _3 = RBRACE
    {                              ( e )}
| _1 = PERC_BACKTICK e = atomicTerm
    {      ( mk_term (VQuote e) (rhs2 parseState 1 3) Un )}
| op = TILDE e = atomicTerm
    {      ( mk_term (Op(mk_ident (op, rhs parseState 1), [e])) (rhs2 parseState 1 2) Formula )}
| e = appTerm
    {        ( e )}

tmNoEqWith_tmRefinement_:
  e1 = tmNoEqWith_tmRefinement_ _2 = COLON_COLON e2 = tmNoEqWith_tmRefinement_
    {      ( consTerm (rhs parseState 2) e1 e2 )}
| e1 = tmNoEqWith_tmRefinement_ _2 = AMP e2 = tmNoEqWith_tmRefinement_
    {      (
        let x, t, f = match extract_named_refinement e1 with
            | Some (x, t, f) -> x, t, f
            | _ -> raise_error (Fatal_MissingQuantifierBinder, "Missing binder for the first component of a dependent tuple") (rhs parseState 1) in
        let dom = mkRefinedBinder x t true f (rhs parseState 1) None in
        let tail = e2 in
        let dom, res = match tail.tm with
            | Sum(dom', res) -> dom::dom', res
            | _ -> [dom], tail in
        mk_term (Sum(dom, res)) (rhs2 parseState 1 3) Type_level
      )}
| e1 = tmNoEqWith_tmRefinement_ op = OPINFIX3 e2 = tmNoEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident(op, rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| e1 = tmNoEqWith_tmRefinement_ _2 = BACKTICK id = qlident _4 = BACKTICK e2 = tmNoEqWith_tmRefinement_
    {      ( mkApp (mk_term (Var id) (rhs2 parseState 2 4) Un) [ e1, Nothing; e2, Nothing ] (rhs2 parseState 1 5) )}
| e1 = tmNoEqWith_tmRefinement_ op = OPINFIX4 e2 = tmNoEqWith_tmRefinement_
    {      ( mk_term (Op(mk_ident(op, rhs parseState 2), [e1; e2])) (rhs2 parseState 1 3) Un)}
| _1 = LBRACE e = recordExp _3 = RBRACE
    {                              ( e )}
| _1 = PERC_BACKTICK e = atomicTerm
    {      ( mk_term (VQuote e) (rhs2 parseState 1 3) Un )}
| op = TILDE e = atomicTerm
    {      ( mk_term (Op(mk_ident (op, rhs parseState 1), [e])) (rhs2 parseState 1 2) Formula )}
| e = tmRefinement
    {        ( e )}

tmEqNoRefinement:
  e = tmEqWith_appTerm_
    {                        ( e )}

tmEq:
  e = tmEqWith_tmRefinement_
    {                              ( e )}

tmNoEq:
  e = tmNoEqWith_tmRefinement_
    {                               ( e )}

tmRefinement:
  id = lidentOrUnderscore _2 = COLON e = appTerm phi_opt = refineOpt
    {      (
        let t = match phi_opt with
          | None -> NamedTyp(id, e)
          | Some phi -> Refine(mk_binder (Annotated(id, e)) (rhs2 parseState 1 3) Type_level None, phi)
        in mk_term t (rhs2 parseState 1 4) Type_level
      )}
| e = appTerm
    {               ( e )}

refineOpt:
  phi_opt = option___anonymous_9_
    {                                                    (phi_opt)}

recordExp:
  record_fields = right_flexible_nonempty_list_SEMICOLON_simpleDef_
    {      ( mk_term (Record (None, record_fields)) (rhs parseState 1) Expr )}
| e = appTerm _2 = WITH record_fields = right_flexible_nonempty_list_SEMICOLON_simpleDef_
    {      ( mk_term (Record (Some e, record_fields)) (rhs2 parseState 1 3) Expr )}

simpleDef:
  x = qlident _2 = EQUALS y = noSeqTerm
    {let e =     ( (x, y) ) in
                                                 ( e )}
| lid = qlident
    {                ( lid, mk_term (Name (lid_of_ids [ lid.ident ])) (rhs parseState 1) Un )}

appTerm:
  head = indexingTerm args = list_argTerm_
    {      ( mkApp head (map (fun (x,y) -> (y,x)) args) (rhs2 parseState 1 2) )}

argTerm:
  y = indexingTerm
    {let x =
  let x =          ( Nothing ) in
      ( (x, y) )
in
                                    ( x )}
| _1 = HASH y = indexingTerm
    {let x =
  let x =          ( Hash ) in
      ( (x, y) )
in
                                    ( x )}
| u = universe
    {               ( u )}

indexingTerm:
  e1 = atomicTermNotQUident op_exprs = nonempty_list_dotOperator_
    {      (
        List.fold_left (fun e1 (op, e2, r) ->
            mk_term (Op(op, [ e1; e2 ])) (union_ranges e1.range r) Expr)
            e1 op_exprs
      )}
| e = atomicTerm
    {    ( e )}

atomicTerm:
  x = atomicTermNotQUident
    {    ( x )}
| x = atomicTermQUident
    {    ( x )}
| x = opPrefixTerm_atomicTermQUident_
    {    ( x )}

atomicTermQUident:
  id = quident
    {    (
        let t = Name id in
        let e = mk_term t (rhs parseState 1) Un in
              e
    )}
| id = quident _2 = DOT_LPAREN t = term _4 = RPAREN
    {    (
      mk_term (LetOpen (id, t)) (rhs2 parseState 1 4) Expr
    )}

atomicTermNotQUident:
  _1 = UNDERSCORE
    {               ( mk_term Wild (rhs parseState 1) Un )}
| tv = tvar
    {                ( mk_term (Tvar tv) (rhs parseState 1) Type_level )}
| c = constant
    {               ( mk_term (Const c) (rhs parseState 1) Expr )}
| x = opPrefixTerm_atomicTermNotQUident_
    {    ( x )}
| _1 = LPAREN op = OPPREFIX _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX3 _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX4 _3 = RPAREN
    {let op =      ( mk_ident (op, rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX0a _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX0b _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX0c _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX0d _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX1 _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OPINFIX2 _3 = RPAREN
    {let op =
  let op =      ( mk_ident (op, rhs parseState 1) ) in
       ( op )
in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = PIPE_RIGHT _3 = RPAREN
    {let op =      ( mk_ident("|>", rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = COLON_EQUALS _3 = RPAREN
    {let op =      ( mk_ident(":=", rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = COLON_COLON _3 = RPAREN
    {let op =      ( mk_ident("::", rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OP_MIXFIX_ASSIGNMENT _3 = RPAREN
    {let op =      ( mk_ident(op, rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LPAREN op = OP_MIXFIX_ACCESS _3 = RPAREN
    {let op =      ( mk_ident(op, rhs parseState 1) ) in
      ( mk_term (Op(op, [])) (rhs2 parseState 1 3) Un )}
| _1 = LENS_PAREN_LEFT e0 = tmEq _3 = COMMA el = separated_nonempty_list_COMMA_tmEq_ _5 = LENS_PAREN_RIGHT
    {      ( mkDTuple (e0::el) (rhs2 parseState 1 5) )}
| e = projectionLHS field_projs = list___anonymous_10_
    {      ( fold_left (fun e lid -> mk_term (Project(e, lid)) (rhs2 parseState 1 2) Expr ) e field_projs )}
| _1 = BEGIN e = term _3 = END
    {      ( e )}

opPrefixTerm_atomicTermNotQUident_:
  op = OPPREFIX e = atomicTermNotQUident
    {      ( mk_term (Op(mk_ident(op, rhs parseState 1), [e])) (rhs2 parseState 1 2) Expr )}

opPrefixTerm_atomicTermQUident_:
  op = OPPREFIX e = atomicTermQUident
    {      ( mk_term (Op(mk_ident(op, rhs parseState 1), [e])) (rhs2 parseState 1 2) Expr )}

projectionLHS:
  e = qidentWithTypeArgs_qlident_option_fsTypeArgs__
    {      ( e )}
| e = qidentWithTypeArgs_quident_some_fsTypeArgs__
    {      ( e )}
| _1 = LPAREN e = term sort_opt = option_pair_hasSort_simpleTerm__ _4 = RPAREN
    {      (
        (* Note: we have to keep the parentheses here. Consider t * u * v. This
         * is parsed as Op2( *, Op2( *, t, u), v). The desugaring phase then looks
         * up * and figures out that it hasn't been overridden, meaning that
         * it's a tuple type, and proceeds to flatten out the whole tuple. Now
         * consider (t * u) * v. We keep the Paren node, which prevents the
         * flattening from happening, hence ensuring the proper type is
         * generated. *)
        let e1 = match sort_opt with
          | None -> e
          | Some (level, t) -> mk_term (Ascribed(e,{t with level=level},None)) (rhs2 parseState 1 4) level
        in mk_term (Paren e1) (rhs2 parseState 1 4) (e.level)
      )}
| _1 = LBRACK_BAR l = right_flexible_list_SEMICOLON_noSeqTerm_ _3 = BAR_RBRACK
    {let es =                                                 ( l ) in
      (
        let l = mkConsList (rhs2 parseState 1 3) es in
        let pos = (rhs2 parseState 1 3) in
        mkExplicitApp (mk_term (Var (array_mk_array_lid)) pos Expr) [l] pos
      )}
| _1 = LBRACK l = right_flexible_list_SEMICOLON_noSeqTerm_ _3 = RBRACK
    {let es =                                                 ( l ) in
      ( mkConsList (rhs2 parseState 1 3) es )}
| _1 = PERCENT_LBRACK l = right_flexible_list_SEMICOLON_noSeqTerm_ _3 = RBRACK
    {let es =                                                 ( l ) in
      ( mkLexList (rhs2 parseState 1 3) es )}
| _1 = BANG_LBRACE xs = loption_separated_nonempty_list_COMMA_appTerm__ _3 = RBRACE
    {let es =     ( xs ) in
      ( mkRefSet (rhs2 parseState 1 3) es )}
| ns = quident _2 = QMARK_DOT id = lident
    {      ( mk_term (Projector (ns, id)) (rhs2 parseState 1 3) Expr )}
| lid = quident _2 = QMARK
    {      ( mk_term (Discrim lid) (rhs2 parseState 1 2) Un )}

fsTypeArgs:
  _1 = TYP_APP_LESS targs = separated_nonempty_list_COMMA_atomicTerm_ _3 = TYP_APP_GREATER
    {    (targs)}

qidentWithTypeArgs_qlident_option_fsTypeArgs__:
  id = qlident targs_opt = option_fsTypeArgs_
    {      (
        let t = if is_name id then Name id else Var id in
        let e = mk_term t (rhs parseState 1) Un in
        match targs_opt with
        | None -> e
        | Some targs -> mkFsTypApp e targs (rhs2 parseState 1 2)
      )}

qidentWithTypeArgs_quident_some_fsTypeArgs__:
  id = quident targs_opt = some_fsTypeArgs_
    {      (
        let t = if is_name id then Name id else Var id in
        let e = mk_term t (rhs parseState 1) Un in
        match targs_opt with
        | None -> e
        | Some targs -> mkFsTypApp e targs (rhs2 parseState 1 2)
      )}

hasSort:
  _1 = SUBKIND
    {            ( Type_level )}

constant:
  _1 = LPAREN_RPAREN
    {                  ( Const_unit )}
| n = INT
    {     (
        if snd n then
          log_issue (lhs parseState) (Error_OutOfRange, "This number is outside the allowable range for representable integer constants");
        Const_int (fst n, None)
     )}
| c = CHAR
    {           ( Const_char c )}
| s = STRING
    {             ( Const_string (s,lhs(parseState)) )}
| bs = BYTEARRAY
    {                 ( Const_bytearray (bs,lhs(parseState)) )}
| _1 = TRUE
    {         ( Const_bool true )}
| _1 = FALSE
    {          ( Const_bool false )}
| f = IEEE64
    {             ( Const_float f )}
| n = UINT8
    {            ( Const_int (n, Some (Unsigned, Int8)) )}
| n = INT8
    {      (
        if snd n then
          log_issue (lhs(parseState)) (Error_OutOfRange, "This number is outside the allowable range for 8-bit signed integers");
        Const_int (fst n, Some (Signed, Int8))
      )}
| n = UINT16
    {             ( Const_int (n, Some (Unsigned, Int16)) )}
| n = INT16
    {      (
        if snd n then
          log_issue (lhs(parseState)) (Error_OutOfRange, "This number is outside the allowable range for 16-bit signed integers");
        Const_int (fst n, Some (Signed, Int16))
      )}
| n = UINT32
    {             ( Const_int (n, Some (Unsigned, Int32)) )}
| n = INT32
    {      (
        if snd n then
          log_issue (lhs(parseState)) (Error_OutOfRange, "This number is outside the allowable range for 32-bit signed integers");
        Const_int (fst n, Some (Signed, Int32))
      )}
| n = UINT64
    {             ( Const_int (n, Some (Unsigned, Int64)) )}
| n = INT64
    {      (
        if snd n then
          log_issue (lhs(parseState)) (Error_OutOfRange, "This number is outside the allowable range for 64-bit signed integers");
        Const_int (fst n, Some (Signed, Int64))
      )}
| _1 = REIFY
    {            ( Const_reify )}
| _1 = RANGE_OF
    {                 ( Const_range_of )}
| _1 = SET_RANGE_OF
    {                 ( Const_set_range_of )}

universe:
  _1 = UNIV_HASH ua = atomicUniverse
    {                                ( (UnivApp, ua) )}

universeFrom:
  ua = atomicUniverse
    {                      ( ua )}
| u1 = universeFrom op_plus = OPINFIX2 u2 = universeFrom
    {       (
         if op_plus <> "+"
         then log_issue (rhs parseState 2) (Error_OpPlusInUniverse, ("The operator " ^ op_plus ^ " was found in universe context."
                           ^ "The only allowed operator in that context is +."));
         mk_term (Op(mk_ident (op_plus, rhs parseState 2), [u1 ; u2])) (rhs2 parseState 1 3) Expr
       )}
| max = ident us = nonempty_list_atomicUniverse_
    {      (
        if text_of_id max <> text_of_lid max_lid
        then log_issue (rhs parseState 1) (Error_InvalidUniverseVar, "A lower case ident " ^ text_of_id max ^
                          " was found in a universe context. " ^
                          "It should be either max or a universe variable 'usomething.");
        let max = mk_term (Var (lid_of_ids [max])) (rhs parseState 1) Expr in
        mkApp max (map (fun u -> u, Nothing) us) (rhs2 parseState 1 2)
      )}

atomicUniverse:
  _1 = UNDERSCORE
    {      ( mk_term Wild (rhs parseState 1) Expr )}
| n = INT
    {      (
        if snd n then
          log_issue (lhs(parseState)) (Error_OutOfRange, "This number is outside the allowable range for representable integer constants");
        mk_term (Const (Const_int (fst n, None))) (rhs parseState 1) Expr
      )}
| u = lident
    {             ( mk_term (Uvar u) u.idRange Expr )}
| _1 = LPAREN u = universeFrom _3 = RPAREN
    {    ( u (*mk_term (Paren u) (rhs2 parseState 1 3) Expr*) )}

warn_error_list:
  e = warn_error _2 = EOF
    {                     ( e )}

warn_error:
  f = flag r = range
    {    ( [(f, r)] )}
| f = flag r = range e = warn_error
    {    ( (f, r) :: e )}

flag:
  op = OPINFIX1
    {    ( if op = "@" then CAlwaysError else failwith (format1 "unexpected token %s in warn-error list" op))}
| op = OPINFIX2
    {    ( if op = "+" then CWarning else failwith (format1 "unexpected token %s in warn-error list" op))}
| _1 = MINUS
    {          ( CSilent )}

range:
  i = INT
    {    ( format2 "%s..%s" (fst i) (fst i) )}
| r = RANGE
    {    ( r )}

some_fsTypeArgs_:
  x = fsTypeArgs
    {        ( Some x )}

right_flexible_list_SEMICOLON_noSeqTerm_:
  
    {        ( [] )}
| x = noSeqTerm
    {        ( [x] )}
| x = noSeqTerm _2 = SEMICOLON xs = right_flexible_list_SEMICOLON_noSeqTerm_
    {                                           ( x :: xs )}

right_flexible_list_SEMICOLON_recordFieldDecl_:
  
    {        ( [] )}
| x = recordFieldDecl
    {        ( [x] )}
| x = recordFieldDecl _2 = SEMICOLON xs = right_flexible_list_SEMICOLON_recordFieldDecl_
    {                                           ( x :: xs )}

right_flexible_list_SEMICOLON_simpleDef_:
  
    {        ( [] )}
| x = simpleDef
    {        ( [x] )}
| x = simpleDef _2 = SEMICOLON xs = right_flexible_list_SEMICOLON_simpleDef_
    {                                           ( x :: xs )}

right_flexible_nonempty_list_SEMICOLON_recordFieldDecl_:
  x = recordFieldDecl
    {        ( [x] )}
| x = recordFieldDecl _2 = SEMICOLON xs = right_flexible_list_SEMICOLON_recordFieldDecl_
    {                                           ( x :: xs )}

right_flexible_nonempty_list_SEMICOLON_simpleDef_:
  x = simpleDef
    {        ( [x] )}
| x = simpleDef _2 = SEMICOLON xs = right_flexible_list_SEMICOLON_simpleDef_
    {                                           ( x :: xs )}

reverse_left_flexible_list_BAR___anonymous_7_:
  
    {   ( [] )}
| pb = patternBranch
    {let x =                                                                    (pb) in
   ( [x] )}
| xs = reverse_left_flexible_list_BAR___anonymous_7_ _2 = BAR pb = patternBranch
    {let x =                                                                    (pb) in
   ( x :: xs )}

reverse_left_flexible_nonempty_list_BAR_patternBranch_:
  x = patternBranch
    {let _1 =     ( None ) in
   ( [x] )}
| x_inlined1 = BAR x = patternBranch
    {let _1 =
  let x = x_inlined1 in
      ( Some x )
in
   ( [x] )}
| xs = reverse_left_flexible_nonempty_list_BAR_patternBranch_ _2 = BAR x = patternBranch
    {   ( x :: xs )}

%%
