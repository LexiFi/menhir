State 0:
## Known stack suffix:
##
## LR(1) items:
inputFragment' -> . inputFragment [ # ]
## Transitions:
-- On TOTAL shift to state 1
-- On SUB_EFFECT shift to state 2
-- On PRIVATE shift to state 357
-- On PRAGMA_SET_OPTIONS shift to state 358
-- On PRAGMA_RESET_OPTIONS shift to state 360
-- On PRAGMALIGHT shift to state 361
-- On OPEN shift to state 363
-- On OPAQUE shift to state 365
-- On LOGIC shift to state 366
-- On LET shift to state 367
-- On KIND shift to state 371
-- On EXCEPTION shift to state 377
-- On DEFAULT shift to state 382
-- On ASSUME shift to state 383
-- On tycon shift to state 384
-- On qualifiers shift to state 385
-- On qualifier shift to state 455
-- On pragma shift to state 458
-- On maybe_pragma_light shift to state 459
-- On kind_abbrev shift to state 464
-- On inputFragment shift to state 479
-- On file shift to state 480
-- On decl2 shift to state 468
-- On decl shift to state 481
-- On assumeTag shift to state 471
## Reductions:
-- On MODULE EOF
--   reduce production maybe_pragma_light ->
-- On VAL TYPE NEW_EFFECT EFFECT
--   reduce production qualifiers ->

State 1:
## Known stack suffix:
## TOTAL
## LR(1) items:
qualifier -> TOTAL . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> TOTAL

State 2:
## Known stack suffix:
## SUB_EFFECT
## LR(1) items:
decl2 -> SUB_EFFECT . sub_effect [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On sub_effect shift to state 4
-- On qname shift to state 5
-- On namepath shift to state 64
-- On name shift to state 65
## Reductions:

State 3:
## Known stack suffix:
## NAME
## LR(1) items:
name -> NAME . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE OF NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> NAME

State 4:
## Known stack suffix:
## SUB_EFFECT sub_effect
## LR(1) items:
decl2 -> SUB_EFFECT sub_effect . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> SUB_EFFECT sub_effect

State 5:
## Known stack suffix:
## qname
## LR(1) items:
sub_effect -> qname . SQUIGGLY_RARROW qname EQUALS simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 6
## Reductions:

State 6:
## Known stack suffix:
## qname SQUIGGLY_RARROW
## LR(1) items:
sub_effect -> qname SQUIGGLY_RARROW . qname EQUALS simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On qname shift to state 7
-- On namepath shift to state 64
-- On name shift to state 65
## Reductions:

State 7:
## Known stack suffix:
## qname SQUIGGLY_RARROW qname
## LR(1) items:
sub_effect -> qname SQUIGGLY_RARROW qname . EQUALS simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On EQUALS shift to state 8
## Reductions:

State 8:
## Known stack suffix:
## qname SQUIGGLY_RARROW qname EQUALS
## LR(1) items:
sub_effect -> qname SQUIGGLY_RARROW qname EQUALS . simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 356
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 9:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
atomicTerm -> UNDERSCORE . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> UNDERSCORE

State 10:
## Known stack suffix:
## UINT8
## LR(1) items:
constant -> UINT8 . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> UINT8

State 11:
## Known stack suffix:
## TVAR
## LR(1) items:
tvar -> TVAR . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tvar -> TVAR

State 12:
## Known stack suffix:
## TRUE
## LR(1) items:
constant -> TRUE . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> TRUE

State 13:
## Known stack suffix:
## TILDE
## LR(1) items:
unaryTerm -> TILDE . atomicTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 355
## Reductions:

State 14:
## Known stack suffix:
## STRING
## LR(1) items:
constant -> STRING . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> STRING

State 15:
## Known stack suffix:
## PERCENT_LBRACK
## LR(1) items:
projectionLHS -> PERCENT_LBRACK . semiColonTermList RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On semiColonTermList shift to state 353
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 306
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:
-- On RBRACK
--   reduce production semiColonTermList ->

State 16:
## Known stack suffix:
## TRY
## LR(1) items:
noSeqTerm -> TRY . term WITH firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 349
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 17:
## Known stack suffix:
## REQUIRES
## LR(1) items:
noSeqTerm -> REQUIRES . label_opt typ [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On DOLLAR shift to state 18
-- On label_opt shift to state 20
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FORALL FALSE EXISTS EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT
--   reduce production label_opt ->

State 18:
## Known stack suffix:
## DOLLAR
## LR(1) items:
label_opt -> DOLLAR . STRING [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FORALL FALSE EXISTS EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
-- On STRING shift to state 19
## Reductions:

State 19:
## Known stack suffix:
## DOLLAR STRING
## LR(1) items:
label_opt -> DOLLAR STRING . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FORALL FALSE EXISTS EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production label_opt -> DOLLAR STRING

State 20:
## Known stack suffix:
## REQUIRES label_opt
## LR(1) items:
noSeqTerm -> REQUIRES label_opt . typ [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 348
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 21:
## Known stack suffix:
## PLUS_OP
## LR(1) items:
unaryTerm -> PLUS_OP . atomicTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 347
## Reductions:

State 22:
## Known stack suffix:
## LPAREN_RPAREN
## LR(1) items:
constant -> LPAREN_RPAREN . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> LPAREN_RPAREN

State 23:
## Known stack suffix:
## LPAREN
## LR(1) items:
projectionLHS -> LPAREN . term maybeWithSort RPAREN [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 340
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 24:
## Known stack suffix:
## MINUS_OP
## LR(1) items:
unaryTerm -> MINUS_OP . atomicTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 339
## Reductions:

State 25:
## Known stack suffix:
## LENS_PAREN_LEFT
## LR(1) items:
atomicTerm -> LENS_PAREN_LEFT . tupleN LENS_PAREN_RIGHT [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 337
-- On tmOr shift to state 201
-- On tmEq shift to state 235
-- On tmCons shift to state 203
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 26:
## Known stack suffix:
## LBRACK_BAR
## LR(1) items:
projectionLHS -> LBRACK_BAR . semiColonTermList BAR_RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On semiColonTermList shift to state 335
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 306
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:
-- On BAR_RBRACK
--   reduce production semiColonTermList ->

State 27:
## Known stack suffix:
## MATCH
## LR(1) items:
noSeqTerm -> MATCH . term WITH firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 331
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 28:
## Known stack suffix:
## LET
## LR(1) items:
noSeqTerm -> LET . recopt letbinding letbindings IN term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 29
-- On recopt shift to state 30
-- On maybeFocus shift to state 329
## Reductions:
-- On REC
--   reduce production maybeFocus ->
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production recopt ->

State 29:
## Known stack suffix:
## SQUIGGLY_RARROW
## LR(1) items:
maybeFocus -> SQUIGGLY_RARROW . [ UNDERSCORE UINT8 TVAR TRUE STRING REC NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeFocus -> SQUIGGLY_RARROW

State 30:
## Known stack suffix:
## LET recopt
## LR(1) items:
noSeqTerm -> LET recopt . letbinding letbindings IN term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 315
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On letbinding shift to state 321
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 31:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
nonTvarPattern2 -> UNDERSCORE . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> UNDERSCORE

State 32:
## Known stack suffix:
## LPAREN
## LR(1) items:
nonTvarPattern2 -> LPAREN . ascriptionOrPattern RPAREN [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 99
-- On nonTvarPattern2 shift to state 100
-- On nonTvarPattern shift to state 101
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On ascriptionOrPattern shift to state 313
-- On appPattern shift to state 79
## Reductions:

State 33:
## Known stack suffix:
## LENS_PAREN_LEFT
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT . listPattern COMMA listPattern patternListComma LENS_PAREN_RIGHT [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 94
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 34:
## Known stack suffix:
## LBRACK
## LR(1) items:
nonTvarPattern2 -> LBRACK . patternListSemiColon RBRACK [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On patternListSemiColon shift to state 87
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 89
## Reductions:
-- On RBRACK
--   reduce production patternListSemiColon ->

State 35:
## Known stack suffix:
## LBRACE
## LR(1) items:
nonTvarPattern2 -> LBRACE . recordPattern RBRACE [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On recordPattern shift to state 37
-- On name shift to state 39
-- On lid shift to state 43
-- On idpath shift to state 85
-- On ident shift to state 42
## Reductions:

State 36:
## Known stack suffix:
## IDENT
## LR(1) items:
ident -> IDENT . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ident -> IDENT

State 37:
## Known stack suffix:
## LBRACE recordPattern
## LR(1) items:
nonTvarPattern2 -> LBRACE recordPattern . RBRACE [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On RBRACE shift to state 38
## Reductions:

State 38:
## Known stack suffix:
## LBRACE recordPattern RBRACE
## LR(1) items:
nonTvarPattern2 -> LBRACE recordPattern RBRACE . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> LBRACE recordPattern RBRACE

State 39:
## Known stack suffix:
## name
## LR(1) items:
idpath -> name . DOT idpath [ EQUALS ]
## Transitions:
-- On DOT shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## name DOT
## LR(1) items:
idpath -> name DOT . idpath [ EQUALS ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On name shift to state 39
-- On idpath shift to state 41
-- On ident shift to state 42
## Reductions:

State 41:
## Known stack suffix:
## name DOT idpath
## LR(1) items:
idpath -> name DOT idpath . [ EQUALS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production idpath -> name DOT idpath

State 42:
## Known stack suffix:
## ident
## LR(1) items:
idpath -> ident . [ EQUALS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production idpath -> ident

State 43:
## Known stack suffix:
## lid
## LR(1) items:
recordPattern -> lid . EQUALS pattern moreFieldPatterns [ RBRACE ]
## Transitions:
-- On EQUALS shift to state 44
## Reductions:

State 44:
## Known stack suffix:
## lid EQUALS
## LR(1) items:
recordPattern -> lid EQUALS . pattern moreFieldPatterns [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 57
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 45:
## Known stack suffix:
## INT64
## LR(1) items:
constant -> INT64 . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> INT64

State 46:
## Known stack suffix:
## INT32
## LR(1) items:
constant -> INT32 . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> INT32

State 47:
## Known stack suffix:
## INT
## LR(1) items:
constant -> INT . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> INT

State 48:
## Known stack suffix:
## IEEE64
## LR(1) items:
constant -> IEEE64 . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> IEEE64

State 49:
## Known stack suffix:
## HASH
## LR(1) items:
nonTvarPattern2 -> HASH . ident [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## HASH ident
## LR(1) items:
nonTvarPattern2 -> HASH ident . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> HASH ident

State 51:
## Known stack suffix:
## FALSE
## LR(1) items:
constant -> FALSE . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> FALSE

State 52:
## Known stack suffix:
## CHAR
## LR(1) items:
constant -> CHAR . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> CHAR

State 53:
## Known stack suffix:
## BYTEARRAY
## LR(1) items:
constant -> BYTEARRAY . [ WITH WHEN VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constant -> BYTEARRAY

State 54:
## Known stack suffix:
## tvar
## LR(1) items:
atomicPattern2 -> tvar . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicPattern2 -> tvar

State 55:
## Known stack suffix:
## tuplePattern
## LR(1) items:
pattern -> tuplePattern . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW EQUALS COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pattern -> tuplePattern

State 56:
## Known stack suffix:
## qname
## LR(1) items:
nonTvarPattern2 -> qname . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> qname

State 57:
## Known stack suffix:
## lid EQUALS pattern
## LR(1) items:
recordPattern -> lid EQUALS pattern . moreFieldPatterns [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 58
-- On moreFieldPatterns shift to state 86
## Reductions:
-- On RBRACE
--   reduce production moreFieldPatterns ->

State 58:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
moreFieldPatterns -> SEMICOLON . lid EQUALS pattern moreFieldPatterns [ RBRACE ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On name shift to state 39
-- On lid shift to state 59
-- On idpath shift to state 85
-- On ident shift to state 42
## Reductions:

State 59:
## Known stack suffix:
## SEMICOLON lid
## LR(1) items:
moreFieldPatterns -> SEMICOLON lid . EQUALS pattern moreFieldPatterns [ RBRACE ]
## Transitions:
-- On EQUALS shift to state 60
## Reductions:

State 60:
## Known stack suffix:
## SEMICOLON lid EQUALS
## LR(1) items:
moreFieldPatterns -> SEMICOLON lid EQUALS . pattern moreFieldPatterns [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 61
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 61:
## Known stack suffix:
## SEMICOLON lid EQUALS pattern
## LR(1) items:
moreFieldPatterns -> SEMICOLON lid EQUALS pattern . moreFieldPatterns [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 58
-- On moreFieldPatterns shift to state 62
## Reductions:
-- On RBRACE
--   reduce production moreFieldPatterns ->

State 62:
## Known stack suffix:
## SEMICOLON lid EQUALS pattern moreFieldPatterns
## LR(1) items:
moreFieldPatterns -> SEMICOLON lid EQUALS pattern moreFieldPatterns . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production moreFieldPatterns -> SEMICOLON lid EQUALS pattern moreFieldPatterns

State 63:
## Known stack suffix:
## nonTvarPattern2
## LR(1) items:
atomicPattern2 -> nonTvarPattern2 . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicPattern2 -> nonTvarPattern2

State 64:
## Known stack suffix:
## namepath
## LR(1) items:
qname -> namepath . [ WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qname -> namepath

State 65:
## Known stack suffix:
## name
## LR(1) items:
namepath -> name . [ WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME ]
namepath -> name . DOT namepath [ WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME ]
## Transitions:
-- On DOT shift to state 66
## Reductions:
-- On WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME
--   reduce production namepath -> name

State 66:
## Known stack suffix:
## name DOT
## LR(1) items:
namepath -> name DOT . namepath [ WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On namepath shift to state 67
-- On name shift to state 65
## Reductions:

State 67:
## Known stack suffix:
## name DOT namepath
## LR(1) items:
namepath -> name DOT namepath . [ WHEN VAL UNDERSCORE UINT8 TYPE TVAR TRUE TOTAL SUB_EFFECT STRING SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT NAME MODULE LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE KIND INT64 INT32 INT IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END EFFECT DEFAULT COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production namepath -> name DOT namepath

State 68:
## Known stack suffix:
## listPattern
## LR(1) items:
tuplePattern -> listPattern . patternListComma [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW EQUALS COLON BAR ]
## Transitions:
-- On COMMA shift to state 69
-- On patternListComma shift to state 84
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW EQUALS COLON BAR
--   reduce production patternListComma ->

State 69:
## Known stack suffix:
## COMMA
## LR(1) items:
patternListComma -> COMMA . listPattern patternListComma [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COLON BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 70
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 70:
## Known stack suffix:
## COMMA listPattern
## LR(1) items:
patternListComma -> COMMA listPattern . patternListComma [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COLON BAR ]
## Transitions:
-- On COMMA shift to state 69
-- On patternListComma shift to state 71
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COLON BAR
--   reduce production patternListComma ->

State 71:
## Known stack suffix:
## COMMA listPattern patternListComma
## LR(1) items:
patternListComma -> COMMA listPattern patternListComma . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patternListComma -> COMMA listPattern patternListComma

State 72:
## Known stack suffix:
## ident
## LR(1) items:
nonTvarPattern2 -> ident . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> ident

State 73:
## Known stack suffix:
## constant
## LR(1) items:
nonTvarPattern2 -> constant . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> constant

State 74:
## Known stack suffix:
## atomicPattern2
## LR(1) items:
atomicPattern -> atomicPattern2 . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicPattern -> atomicPattern2

State 75:
## Known stack suffix:
## atomicPattern
## LR(1) items:
appPattern -> atomicPattern . atomicPatterns [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPatterns shift to state 76
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 77
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR
--   reduce production atomicPatterns ->

State 76:
## Known stack suffix:
## atomicPattern atomicPatterns
## LR(1) items:
appPattern -> atomicPattern atomicPatterns . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production appPattern -> atomicPattern atomicPatterns

State 77:
## Known stack suffix:
## atomicPattern
## LR(1) items:
atomicPatterns -> atomicPattern . atomicPatterns [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPatterns shift to state 78
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 77
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR
--   reduce production atomicPatterns ->

State 78:
## Known stack suffix:
## atomicPattern atomicPatterns
## LR(1) items:
atomicPatterns -> atomicPattern atomicPatterns . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON_COLON COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicPatterns -> atomicPattern atomicPatterns

State 79:
## Known stack suffix:
## appPattern
## LR(1) items:
listPattern -> appPattern . consPattern [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR ]
## Transitions:
-- On COLON_COLON shift to state 80
-- On consPattern shift to state 83
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR
--   reduce production consPattern ->

State 80:
## Known stack suffix:
## COLON_COLON
## LR(1) items:
consPattern -> COLON_COLON . appPattern consPattern [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 81
## Reductions:

State 81:
## Known stack suffix:
## COLON_COLON appPattern
## LR(1) items:
consPattern -> COLON_COLON appPattern . consPattern [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR ]
## Transitions:
-- On COLON_COLON shift to state 80
-- On consPattern shift to state 82
## Reductions:
-- On WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR
--   reduce production consPattern ->

State 82:
## Known stack suffix:
## COLON_COLON appPattern consPattern
## LR(1) items:
consPattern -> COLON_COLON appPattern consPattern . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production consPattern -> COLON_COLON appPattern consPattern

State 83:
## Known stack suffix:
## appPattern consPattern
## LR(1) items:
listPattern -> appPattern consPattern . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW LENS_PAREN_RIGHT EQUALS COMMA COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production listPattern -> appPattern consPattern

State 84:
## Known stack suffix:
## listPattern patternListComma
## LR(1) items:
tuplePattern -> listPattern patternListComma . [ WHEN SQUIGGLY_RARROW SEMICOLON RPAREN RBRACE RARROW EQUALS COLON BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tuplePattern -> listPattern patternListComma

State 85:
## Known stack suffix:
## idpath
## LR(1) items:
lid -> idpath . [ EQUALS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lid -> idpath

State 86:
## Known stack suffix:
## lid EQUALS pattern moreFieldPatterns
## LR(1) items:
recordPattern -> lid EQUALS pattern moreFieldPatterns . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordPattern -> lid EQUALS pattern moreFieldPatterns

State 87:
## Known stack suffix:
## LBRACK patternListSemiColon
## LR(1) items:
nonTvarPattern2 -> LBRACK patternListSemiColon . RBRACK [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On RBRACK shift to state 88
## Reductions:

State 88:
## Known stack suffix:
## LBRACK patternListSemiColon RBRACK
## LR(1) items:
nonTvarPattern2 -> LBRACK patternListSemiColon RBRACK . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> LBRACK patternListSemiColon RBRACK

State 89:
## Known stack suffix:
## appPattern
## LR(1) items:
patternListSemiColon -> appPattern . patternListSemiColonRest [ RBRACK ]
## Transitions:
-- On SEMICOLON shift to state 90
-- On patternListSemiColonRest shift to state 93
## Reductions:
-- On RBRACK
--   reduce production patternListSemiColonRest ->

State 90:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
patternListSemiColonRest -> SEMICOLON . appPattern patternListSemiColonRest [ RBRACK ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## SEMICOLON appPattern
## LR(1) items:
patternListSemiColonRest -> SEMICOLON appPattern . patternListSemiColonRest [ RBRACK ]
## Transitions:
-- On SEMICOLON shift to state 90
-- On patternListSemiColonRest shift to state 92
## Reductions:
-- On RBRACK
--   reduce production patternListSemiColonRest ->

State 92:
## Known stack suffix:
## SEMICOLON appPattern patternListSemiColonRest
## LR(1) items:
patternListSemiColonRest -> SEMICOLON appPattern patternListSemiColonRest . [ RBRACK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patternListSemiColonRest -> SEMICOLON appPattern patternListSemiColonRest

State 93:
## Known stack suffix:
## appPattern patternListSemiColonRest
## LR(1) items:
patternListSemiColon -> appPattern patternListSemiColonRest . [ RBRACK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patternListSemiColon -> appPattern patternListSemiColonRest

State 94:
## Known stack suffix:
## LENS_PAREN_LEFT listPattern
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT listPattern . COMMA listPattern patternListComma LENS_PAREN_RIGHT [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On COMMA shift to state 95
## Reductions:

State 95:
## Known stack suffix:
## LENS_PAREN_LEFT listPattern COMMA
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT listPattern COMMA . listPattern patternListComma LENS_PAREN_RIGHT [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 96
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 96:
## Known stack suffix:
## LENS_PAREN_LEFT listPattern COMMA listPattern
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT listPattern COMMA listPattern . patternListComma LENS_PAREN_RIGHT [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On COMMA shift to state 69
-- On patternListComma shift to state 97
## Reductions:
-- On LENS_PAREN_RIGHT
--   reduce production patternListComma ->

State 97:
## Known stack suffix:
## LENS_PAREN_LEFT listPattern COMMA listPattern patternListComma
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT listPattern COMMA listPattern patternListComma . LENS_PAREN_RIGHT [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On LENS_PAREN_RIGHT shift to state 98
## Reductions:

State 98:
## Known stack suffix:
## LENS_PAREN_LEFT listPattern COMMA listPattern patternListComma LENS_PAREN_RIGHT
## LR(1) items:
nonTvarPattern2 -> LENS_PAREN_LEFT listPattern COMMA listPattern patternListComma LENS_PAREN_RIGHT . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> LENS_PAREN_LEFT listPattern COMMA listPattern patternListComma LENS_PAREN_RIGHT

State 99:
## Known stack suffix:
## pattern
## LR(1) items:
ascriptionOrPattern -> pattern . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ascriptionOrPattern -> pattern

State 100:
## Known stack suffix:
## nonTvarPattern2
## LR(1) items:
atomicPattern2 -> nonTvarPattern2 . [ UNDERSCORE UINT8 TVAR TRUE STRING RPAREN NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE COMMA COLON_COLON CHAR BYTEARRAY ]
nonTvarPattern -> nonTvarPattern2 . [ COLON ]
## Transitions:
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE STRING RPAREN NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE COMMA COLON_COLON CHAR BYTEARRAY
--   reduce production atomicPattern2 -> nonTvarPattern2
-- On COLON
--   reduce production nonTvarPattern -> nonTvarPattern2

State 101:
## Known stack suffix:
## nonTvarPattern
## LR(1) items:
ascriptionOrPattern -> nonTvarPattern . COLON typ refineOpt [ RPAREN ]
## Transitions:
-- On COLON shift to state 102
## Reductions:

State 102:
## Known stack suffix:
## nonTvarPattern COLON
## LR(1) items:
ascriptionOrPattern -> nonTvarPattern COLON . typ refineOpt [ RPAREN ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 311
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 103:
## Known stack suffix:
## LBRACK
## LR(1) items:
projectionLHS -> LBRACK . semiColonTermList RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On semiColonTermList shift to state 304
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 306
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:
-- On RBRACK
--   reduce production semiColonTermList ->

State 104:
## Known stack suffix:
## LBRACE
## LR(1) items:
refinementTerm -> LBRACE . recordExp RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On recordExp shift to state 288
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 290
## Reductions:

State 105:
## Known stack suffix:
## BEGIN
## LR(1) items:
atomicTerm -> BEGIN . term END [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 286
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 106:
## Known stack suffix:
## IF
## LR(1) items:
noSeqTerm -> IF . noSeqTerm THEN noSeqTerm ELSE noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
noSeqTerm -> IF . noSeqTerm THEN noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 281
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 107:
## Known stack suffix:
## HASH
## LR(1) items:
aqual -> HASH . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT FALSE CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production aqual -> HASH

State 108:
## Known stack suffix:
## FUNCTION
## LR(1) items:
noSeqTerm -> FUNCTION . firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 109
-- On maybeBar shift to state 110
-- On firstPatternBranch shift to state 273
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production maybeBar ->

State 109:
## Known stack suffix:
## BAR
## LR(1) items:
maybeBar -> BAR . [ UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeBar -> BAR

State 110:
## Known stack suffix:
## maybeBar
## LR(1) items:
firstPatternBranch -> maybeBar . disjunctivePattern maybeWhen maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 111
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On disjunctivePattern shift to state 114
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 111:
## Known stack suffix:
## pattern
## LR(1) items:
disjunctivePattern -> pattern . [ WHEN SQUIGGLY_RARROW RARROW ]
disjunctivePattern -> pattern . BAR disjunctivePattern [ WHEN SQUIGGLY_RARROW RARROW ]
## Transitions:
-- On BAR shift to state 112
## Reductions:
-- On WHEN SQUIGGLY_RARROW RARROW
--   reduce production disjunctivePattern -> pattern

State 112:
## Known stack suffix:
## pattern BAR
## LR(1) items:
disjunctivePattern -> pattern BAR . disjunctivePattern [ WHEN SQUIGGLY_RARROW RARROW ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 111
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On disjunctivePattern shift to state 113
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 113:
## Known stack suffix:
## pattern BAR disjunctivePattern
## LR(1) items:
disjunctivePattern -> pattern BAR disjunctivePattern . [ WHEN SQUIGGLY_RARROW RARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production disjunctivePattern -> pattern BAR disjunctivePattern

State 114:
## Known stack suffix:
## maybeBar disjunctivePattern
## LR(1) items:
firstPatternBranch -> maybeBar disjunctivePattern . maybeWhen maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On WHEN shift to state 115
-- On maybeWhen shift to state 154
## Reductions:
-- On SQUIGGLY_RARROW RARROW
--   reduce production maybeWhen ->

State 115:
## Known stack suffix:
## WHEN
## LR(1) items:
maybeWhen -> WHEN . appTerm [ SQUIGGLY_RARROW RARROW ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 153
## Reductions:

State 116:
## Known stack suffix:
## BANG_LBRACE
## LR(1) items:
projectionLHS -> BANG_LBRACE . commaTermList RBRACE [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On commaTermList shift to state 140
-- On atomicTerm shift to state 142
-- On appTerm shift to state 148
## Reductions:
-- On RBRACE
--   reduce production commaTermList ->

State 117:
## Known stack suffix:
## BANG
## LR(1) items:
atomicTerm -> BANG . atomicTerm [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 139
## Reductions:

State 118:
## Known stack suffix:
## ASSERT
## LR(1) items:
atomicTerm -> ASSERT . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> ASSERT

State 119:
## Known stack suffix:
## tvar
## LR(1) items:
atomicTerm -> tvar . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> tvar

State 120:
## Known stack suffix:
## projectionLHS
## LR(1) items:
atomicTerm -> projectionLHS . maybeFieldProjections [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On maybeFieldProjections shift to state 121
## Default reduction:
-- After reading the next token, reduce production maybeFieldProjections ->

State 121:
## Known stack suffix:
## projectionLHS maybeFieldProjections
## LR(1) items:
atomicTerm -> projectionLHS maybeFieldProjections . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
maybeFieldProjections -> maybeFieldProjections . DOT ident [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On DOT shift to state 122
## Reductions:
-- On WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP
--   reduce production atomicTerm -> projectionLHS maybeFieldProjections

State 122:
## Known stack suffix:
## maybeFieldProjections DOT
## LR(1) items:
maybeFieldProjections -> maybeFieldProjections DOT . ident [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 123
## Reductions:

State 123:
## Known stack suffix:
## maybeFieldProjections DOT ident
## LR(1) items:
maybeFieldProjections -> maybeFieldProjections DOT ident . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeFieldProjections -> maybeFieldProjections DOT ident

State 124:
## Known stack suffix:
## name
## LR(1) items:
eitherpath -> name . maybeMorePath [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On DOT shift to state 125
-- On maybeMorePath shift to state 128
## Reductions:
-- On WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP
--   reduce production maybeMorePath ->

State 125:
## Known stack suffix:
## DOT
## LR(1) items:
maybeMorePath -> DOT . eitherpath [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 127
## Reductions:

State 126:
## Known stack suffix:
## ident
## LR(1) items:
eitherpath -> ident . [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eitherpath -> ident

State 127:
## Known stack suffix:
## DOT eitherpath
## LR(1) items:
maybeMorePath -> DOT eitherpath . [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeMorePath -> DOT eitherpath

State 128:
## Known stack suffix:
## name maybeMorePath
## LR(1) items:
eitherpath -> name maybeMorePath . [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eitherpath -> name maybeMorePath

State 129:
## Known stack suffix:
## eitherpath
## LR(1) items:
eitherQname -> eitherpath . [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eitherQname -> eitherpath

State 130:
## Known stack suffix:
## eitherQname
## LR(1) items:
projectionLHS -> eitherQname . maybeInsts [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On TYP_APP_LESS shift to state 131
-- On maybeInsts shift to state 138
## Reductions:
-- On WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP
--   reduce production maybeInsts ->

State 131:
## Known stack suffix:
## TYP_APP_LESS
## LR(1) items:
maybeInsts -> TYP_APP_LESS . targs TYP_APP_GREATER [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On targs shift to state 132
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 135
## Reductions:

State 132:
## Known stack suffix:
## TYP_APP_LESS targs
## LR(1) items:
maybeInsts -> TYP_APP_LESS targs . TYP_APP_GREATER [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On TYP_APP_GREATER shift to state 133
## Reductions:

State 133:
## Known stack suffix:
## TYP_APP_LESS targs TYP_APP_GREATER
## LR(1) items:
maybeInsts -> TYP_APP_LESS targs TYP_APP_GREATER . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeInsts -> TYP_APP_LESS targs TYP_APP_GREATER

State 134:
## Known stack suffix:
## constant
## LR(1) items:
atomicTerm -> constant . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> constant

State 135:
## Known stack suffix:
## atomicTerm
## LR(1) items:
targs -> atomicTerm . [ TYP_APP_GREATER ]
targs -> atomicTerm . COMMA targs [ TYP_APP_GREATER ]
## Transitions:
-- On COMMA shift to state 136
## Reductions:
-- On TYP_APP_GREATER
--   reduce production targs -> atomicTerm

State 136:
## Known stack suffix:
## atomicTerm COMMA
## LR(1) items:
targs -> atomicTerm COMMA . targs [ TYP_APP_GREATER ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On targs shift to state 137
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 135
## Reductions:

State 137:
## Known stack suffix:
## atomicTerm COMMA targs
## LR(1) items:
targs -> atomicTerm COMMA targs . [ TYP_APP_GREATER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production targs -> atomicTerm COMMA targs

State 138:
## Known stack suffix:
## eitherQname maybeInsts
## LR(1) items:
projectionLHS -> eitherQname maybeInsts . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> eitherQname maybeInsts

State 139:
## Known stack suffix:
## BANG atomicTerm
## LR(1) items:
atomicTerm -> BANG atomicTerm . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> BANG atomicTerm

State 140:
## Known stack suffix:
## BANG_LBRACE commaTermList
## LR(1) items:
projectionLHS -> BANG_LBRACE commaTermList . RBRACE [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On RBRACE shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## BANG_LBRACE commaTermList RBRACE
## LR(1) items:
projectionLHS -> BANG_LBRACE commaTermList RBRACE . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> BANG_LBRACE commaTermList RBRACE

State 142:
## Known stack suffix:
## atomicTerm
## LR(1) items:
appTerm -> atomicTerm . hashAtomicTerms [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On HASH shift to state 143
-- On maybeHash shift to state 144
-- On hashAtomicTerms shift to state 147
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production hashAtomicTerms ->
-- On UNDERSCORE UINT8 TVAR TRUE STRING PERCENT_LBRACK NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK INT64 INT32 INT IEEE64 IDENT FALSE CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT
--   reduce production maybeHash ->

State 143:
## Known stack suffix:
## HASH
## LR(1) items:
maybeHash -> HASH . [ UNDERSCORE UINT8 TVAR TRUE STRING PERCENT_LBRACK NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK INT64 INT32 INT IEEE64 IDENT FALSE CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeHash -> HASH

State 144:
## Known stack suffix:
## maybeHash
## LR(1) items:
hashAtomicTerms -> maybeHash . atomicTerm hashAtomicTerms [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## maybeHash atomicTerm
## LR(1) items:
hashAtomicTerms -> maybeHash atomicTerm . hashAtomicTerms [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On HASH shift to state 143
-- On maybeHash shift to state 144
-- On hashAtomicTerms shift to state 146
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production hashAtomicTerms ->
-- On UNDERSCORE UINT8 TVAR TRUE STRING PERCENT_LBRACK NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK INT64 INT32 INT IEEE64 IDENT FALSE CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT
--   reduce production maybeHash ->

State 146:
## Known stack suffix:
## maybeHash atomicTerm hashAtomicTerms
## LR(1) items:
hashAtomicTerms -> maybeHash atomicTerm hashAtomicTerms . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production hashAtomicTerms -> maybeHash atomicTerm hashAtomicTerms

State 147:
## Known stack suffix:
## atomicTerm hashAtomicTerms
## LR(1) items:
appTerm -> atomicTerm hashAtomicTerms . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production appTerm -> atomicTerm hashAtomicTerms

State 148:
## Known stack suffix:
## appTerm
## LR(1) items:
commaTermList -> appTerm . moreCommaTerms [ RBRACE ]
## Transitions:
-- On COMMA shift to state 149
-- On moreCommaTerms shift to state 152
## Reductions:
-- On RBRACE
--   reduce production moreCommaTerms ->

State 149:
## Known stack suffix:
## COMMA
## LR(1) items:
moreCommaTerms -> COMMA . appTerm moreCommaTerms [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 150
## Reductions:

State 150:
## Known stack suffix:
## COMMA appTerm
## LR(1) items:
moreCommaTerms -> COMMA appTerm . moreCommaTerms [ RBRACE ]
## Transitions:
-- On COMMA shift to state 149
-- On moreCommaTerms shift to state 151
## Reductions:
-- On RBRACE
--   reduce production moreCommaTerms ->

State 151:
## Known stack suffix:
## COMMA appTerm moreCommaTerms
## LR(1) items:
moreCommaTerms -> COMMA appTerm moreCommaTerms . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production moreCommaTerms -> COMMA appTerm moreCommaTerms

State 152:
## Known stack suffix:
## appTerm moreCommaTerms
## LR(1) items:
commaTermList -> appTerm moreCommaTerms . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production commaTermList -> appTerm moreCommaTerms

State 153:
## Known stack suffix:
## WHEN appTerm
## LR(1) items:
maybeWhen -> WHEN appTerm . [ SQUIGGLY_RARROW RARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeWhen -> WHEN appTerm

State 154:
## Known stack suffix:
## maybeBar disjunctivePattern maybeWhen
## LR(1) items:
firstPatternBranch -> maybeBar disjunctivePattern maybeWhen . maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 155
-- On RARROW shift to state 156
-- On maybeFocusArrow shift to state 157
## Reductions:

State 155:
## Known stack suffix:
## SQUIGGLY_RARROW
## LR(1) items:
maybeFocusArrow -> SQUIGGLY_RARROW . [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeFocusArrow -> SQUIGGLY_RARROW

State 156:
## Known stack suffix:
## RARROW
## LR(1) items:
maybeFocusArrow -> RARROW . [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeFocusArrow -> RARROW

State 157:
## Known stack suffix:
## maybeBar disjunctivePattern maybeWhen maybeFocusArrow
## LR(1) items:
firstPatternBranch -> maybeBar disjunctivePattern maybeWhen maybeFocusArrow . term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 272
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 158:
## Known stack suffix:
## FUN
## LR(1) items:
simpleTerm -> FUN . atomicPattern atomicPatterns funArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## FUN atomicPattern
## LR(1) items:
simpleTerm -> FUN atomicPattern . atomicPatterns funArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On qname shift to state 56
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPatterns shift to state 160
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 77
## Reductions:
-- On RARROW
--   reduce production atomicPatterns ->

State 160:
## Known stack suffix:
## FUN atomicPattern atomicPatterns
## LR(1) items:
simpleTerm -> FUN atomicPattern atomicPatterns . funArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On RARROW shift to state 161
-- On funArrow shift to state 162
## Reductions:

State 161:
## Known stack suffix:
## RARROW
## LR(1) items:
funArrow -> RARROW . [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production funArrow -> RARROW

State 162:
## Known stack suffix:
## FUN atomicPattern atomicPatterns funArrow
## LR(1) items:
simpleTerm -> FUN atomicPattern atomicPatterns funArrow . term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 268
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 163:
## Known stack suffix:
## FORALL
## LR(1) items:
typ -> FORALL . binders DOT qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 264
-- On binder shift to state 256
## Reductions:
-- On DOT
--   reduce production binders ->

State 164:
## Known stack suffix:
## LPAREN
## LR(1) items:
binder -> LPAREN . aqual_opt ident COLON typ refineOpt RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On HASH shift to state 165
-- On EQUALS shift to state 166
-- On aqual_opt shift to state 167
## Reductions:
-- On IDENT
--   reduce production aqual_opt ->

State 165:
## Known stack suffix:
## HASH
## LR(1) items:
aqual_opt -> HASH . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production aqual_opt -> HASH

State 166:
## Known stack suffix:
## EQUALS
## LR(1) items:
aqual_opt -> EQUALS . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production aqual_opt -> EQUALS

State 167:
## Known stack suffix:
## LPAREN aqual_opt
## LR(1) items:
binder -> LPAREN aqual_opt . ident COLON typ refineOpt RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## LPAREN aqual_opt ident
## LR(1) items:
binder -> LPAREN aqual_opt ident . COLON typ refineOpt RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On COLON shift to state 169
## Reductions:

State 169:
## Known stack suffix:
## LPAREN aqual_opt ident COLON
## LR(1) items:
binder -> LPAREN aqual_opt ident COLON . typ refineOpt RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 258
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 170:
## Known stack suffix:
## EXISTS
## LR(1) items:
typ -> EXISTS . binders DOT qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 173
-- On binder shift to state 256
## Reductions:
-- On DOT
--   reduce production binders ->

State 171:
## Known stack suffix:
## tvar
## LR(1) items:
binder -> tvar . [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binder -> tvar

State 172:
## Known stack suffix:
## ident
## LR(1) items:
binder -> ident . [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binder -> ident

State 173:
## Known stack suffix:
## EXISTS binders
## LR(1) items:
typ -> EXISTS binders . DOT qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On DOT shift to state 174
## Reductions:

State 174:
## Known stack suffix:
## EXISTS binders DOT
## LR(1) items:
typ -> EXISTS binders DOT . qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On LBRACE_COLON_PATTERN shift to state 175
-- On qpat shift to state 182
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT
--   reduce production qpat ->

State 175:
## Known stack suffix:
## LBRACE_COLON_PATTERN
## LR(1) items:
qpat -> LBRACE_COLON_PATTERN . appTerm morePats RBRACE [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 176
## Reductions:

State 176:
## Known stack suffix:
## LBRACE_COLON_PATTERN appTerm
## LR(1) items:
qpat -> LBRACE_COLON_PATTERN appTerm . morePats RBRACE [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 177
-- On morePats shift to state 180
## Reductions:
-- On RBRACE
--   reduce production morePats ->

State 177:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
morePats -> SEMICOLON . appTerm morePats [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## SEMICOLON appTerm
## LR(1) items:
morePats -> SEMICOLON appTerm . morePats [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 177
-- On morePats shift to state 179
## Reductions:
-- On RBRACE
--   reduce production morePats ->

State 179:
## Known stack suffix:
## SEMICOLON appTerm morePats
## LR(1) items:
morePats -> SEMICOLON appTerm morePats . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production morePats -> SEMICOLON appTerm morePats

State 180:
## Known stack suffix:
## LBRACE_COLON_PATTERN appTerm morePats
## LR(1) items:
qpat -> LBRACE_COLON_PATTERN appTerm morePats . RBRACE [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
-- On RBRACE shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## LBRACE_COLON_PATTERN appTerm morePats RBRACE
## LR(1) items:
qpat -> LBRACE_COLON_PATTERN appTerm morePats RBRACE . [ UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qpat -> LBRACE_COLON_PATTERN appTerm morePats RBRACE

State 182:
## Known stack suffix:
## EXISTS binders DOT qpat
## LR(1) items:
typ -> EXISTS binders DOT qpat . noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 255
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 183:
## Known stack suffix:
## EQUALS
## LR(1) items:
aqual -> EQUALS . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT FALSE CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production aqual -> EQUALS

State 184:
## Known stack suffix:
## ENSURES
## LR(1) items:
noSeqTerm -> ENSURES . label_opt typ [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On DOLLAR shift to state 18
-- On label_opt shift to state 185
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FORALL FALSE EXISTS EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT
--   reduce production label_opt ->

State 185:
## Known stack suffix:
## ENSURES label_opt
## LR(1) items:
noSeqTerm -> ENSURES label_opt . typ [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 254
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 186:
## Known stack suffix:
## unaryTerm
## LR(1) items:
refinementTerm -> unaryTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
starDivModTerm -> unaryTerm . DIV_MOD_OP starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On DIV_MOD_OP shift to state 187
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production refinementTerm -> unaryTerm

State 187:
## Known stack suffix:
## unaryTerm DIV_MOD_OP
## LR(1) items:
starDivModTerm -> unaryTerm DIV_MOD_OP . starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 188
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 214
## Reductions:

State 188:
## Known stack suffix:
## unaryTerm DIV_MOD_OP starDivModTerm
## LR(1) items:
starDivModTerm -> unaryTerm DIV_MOD_OP starDivModTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production starDivModTerm -> unaryTerm DIV_MOD_OP starDivModTerm

State 189:
## Known stack suffix:
## refinementTerm
## LR(1) items:
starDivModTerm -> refinementTerm . STAR starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
starDivModTerm -> refinementTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On STAR shift to state 190
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production starDivModTerm -> refinementTerm

State 190:
## Known stack suffix:
## refinementTerm STAR
## LR(1) items:
starDivModTerm -> refinementTerm STAR . starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 191
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 214
## Reductions:

State 191:
## Known stack suffix:
## refinementTerm STAR starDivModTerm
## LR(1) items:
starDivModTerm -> refinementTerm STAR starDivModTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production starDivModTerm -> refinementTerm STAR starDivModTerm

State 192:
## Known stack suffix:
## ident
## LR(1) items:
eitherpath -> ident . [ WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
refinementTerm -> ident . COLON appTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
refinementTerm -> ident . COLON appTerm LBRACE formula RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On COLON shift to state 193
## Reductions:
-- On WITH VAL UNDERSCORE UINT8 TYP_APP_LESS TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP
--   reduce production eitherpath -> ident

State 193:
## Known stack suffix:
## ident COLON
## LR(1) items:
refinementTerm -> ident COLON . appTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
refinementTerm -> ident COLON . appTerm LBRACE formula RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 194
## Reductions:

State 194:
## Known stack suffix:
## ident COLON appTerm
## LR(1) items:
refinementTerm -> ident COLON appTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
refinementTerm -> ident COLON appTerm . LBRACE formula RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On LBRACE shift to state 195
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production refinementTerm -> ident COLON appTerm

State 195:
## Known stack suffix:
## ident COLON appTerm LBRACE
## LR(1) items:
refinementTerm -> ident COLON appTerm LBRACE . formula RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 251
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On formula shift to state 252
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 196:
## Known stack suffix:
## ASSUME
## LR(1) items:
noSeqTerm -> ASSUME . atomicTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 126
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## ASSUME atomicTerm
## LR(1) items:
noSeqTerm -> ASSUME atomicTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> ASSUME atomicTerm

State 198:
## Known stack suffix:
## typ
## LR(1) items:
noSeqTerm -> typ . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> typ

State 199:
## Known stack suffix:
## tupleN
## LR(1) items:
tmTuple -> tupleN . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmTuple -> tupleN

State 200:
## Known stack suffix:
## tmTuple
## LR(1) items:
tmConjunction -> tmTuple . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmConjunction -> tmTuple

State 201:
## Known stack suffix:
## tmOr
## LR(1) items:
tmEq -> tmOr . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND ]
tmOr -> tmOr . BAR_BAR tmAnd [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND ]
## Transitions:
-- On BAR_BAR shift to state 202
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND
--   reduce production tmEq -> tmOr

State 202:
## Known stack suffix:
## tmOr BAR_BAR
## LR(1) items:
tmOr -> tmOr BAR_BAR . tmAnd [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tmCons shift to state 203
-- On tmAnd shift to state 204
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 203:
## Known stack suffix:
## tmCons
## LR(1) items:
cmpTerm -> tmCons . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cmpTerm -> tmCons

State 204:
## Known stack suffix:
## tmOr BAR_BAR tmAnd
## LR(1) items:
tmAnd -> tmAnd . AMP_AMP cmpTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
tmOr -> tmOr BAR_BAR tmAnd . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND ]
## Transitions:
-- On AMP_AMP shift to state 205
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND
--   reduce production tmOr -> tmOr BAR_BAR tmAnd

State 205:
## Known stack suffix:
## tmAnd AMP_AMP
## LR(1) items:
tmAnd -> tmAnd AMP_AMP . cmpTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tmCons shift to state 203
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 226
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 206:
## Known stack suffix:
## starDivModTerm
## LR(1) items:
minusOp -> starDivModTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production minusOp -> starDivModTerm

State 207:
## Known stack suffix:
## productDomain
## LR(1) items:
product -> productDomain . RARROW product [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On RARROW shift to state 208
## Reductions:

State 208:
## Known stack suffix:
## productDomain RARROW
## LR(1) items:
product -> productDomain RARROW . product [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 209
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 209:
## Known stack suffix:
## productDomain RARROW product
## LR(1) items:
product -> productDomain RARROW product . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production product -> productDomain RARROW product

State 210:
## Known stack suffix:
## plusOp
## LR(1) items:
arithTerm -> plusOp . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arithTerm -> plusOp

State 211:
## Known stack suffix:
## minusOp
## LR(1) items:
minusOp -> minusOp . MINUS_OP starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
plusOp -> minusOp . PLUS_OP plusOp [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
plusOp -> minusOp . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On PLUS_OP shift to state 212
-- On MINUS_OP shift to state 215
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP
--   reduce production plusOp -> minusOp

State 212:
## Known stack suffix:
## minusOp PLUS_OP
## LR(1) items:
plusOp -> minusOp PLUS_OP . plusOp [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On plusOp shift to state 213
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 214
## Reductions:

State 213:
## Known stack suffix:
## minusOp PLUS_OP plusOp
## LR(1) items:
plusOp -> minusOp PLUS_OP plusOp . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production plusOp -> minusOp PLUS_OP plusOp

State 214:
## Known stack suffix:
## appTerm
## LR(1) items:
unaryTerm -> appTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unaryTerm -> appTerm

State 215:
## Known stack suffix:
## minusOp MINUS_OP
## LR(1) items:
minusOp -> minusOp MINUS_OP . starDivModTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 216
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 214
## Reductions:

State 216:
## Known stack suffix:
## minusOp MINUS_OP starDivModTerm
## LR(1) items:
minusOp -> minusOp MINUS_OP starDivModTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production minusOp -> minusOp MINUS_OP starDivModTerm

State 217:
## Known stack suffix:
## dtupleTerm
## LR(1) items:
product -> dtupleTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
productDomain -> dtupleTerm . [ RARROW ]
## Transitions:
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP
--   reduce production product -> dtupleTerm
-- On RARROW
--   reduce production productDomain -> dtupleTerm

State 218:
## Known stack suffix:
## arithTerm
## LR(1) items:
dtupleTerm -> arithTerm . AMP dtupleTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
dtupleTerm -> arithTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On AMP shift to state 219
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP
--   reduce production dtupleTerm -> arithTerm

State 219:
## Known stack suffix:
## arithTerm AMP
## LR(1) items:
dtupleTerm -> arithTerm AMP . dtupleTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 220
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On appTerm shift to state 214
## Reductions:

State 220:
## Known stack suffix:
## arithTerm AMP dtupleTerm
## LR(1) items:
dtupleTerm -> arithTerm AMP dtupleTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dtupleTerm -> arithTerm AMP dtupleTerm

State 221:
## Known stack suffix:
## aqual
## LR(1) items:
productDomain -> aqual . dtupleTerm [ RARROW ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 222
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On appTerm shift to state 214
## Reductions:

State 222:
## Known stack suffix:
## aqual dtupleTerm
## LR(1) items:
productDomain -> aqual dtupleTerm . [ RARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production productDomain -> aqual dtupleTerm

State 223:
## Known stack suffix:
## product
## LR(1) items:
tmCons -> product . COLON_COLON tmCons [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
tmCons -> product . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On COLON_COLON shift to state 224
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP
--   reduce production tmCons -> product

State 224:
## Known stack suffix:
## product COLON_COLON
## LR(1) items:
tmCons -> product COLON_COLON . tmCons [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tmCons shift to state 225
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 225:
## Known stack suffix:
## product COLON_COLON tmCons
## LR(1) items:
tmCons -> product COLON_COLON tmCons . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmCons -> product COLON_COLON tmCons

State 226:
## Known stack suffix:
## tmAnd AMP_AMP cmpTerm
## LR(1) items:
cmpTerm -> cmpTerm . comparisonOp tmCons [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
tmAnd -> tmAnd AMP_AMP cmpTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On EQUALS shift to state 227
-- On CUSTOM_OP shift to state 228
-- On comparisonOp shift to state 229
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP
--   reduce production tmAnd -> tmAnd AMP_AMP cmpTerm

State 227:
## Known stack suffix:
## EQUALS
## LR(1) items:
comparisonOp -> EQUALS . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparisonOp -> EQUALS

State 228:
## Known stack suffix:
## CUSTOM_OP
## LR(1) items:
comparisonOp -> CUSTOM_OP . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparisonOp -> CUSTOM_OP

State 229:
## Known stack suffix:
## cmpTerm comparisonOp
## LR(1) items:
cmpTerm -> cmpTerm comparisonOp . tmCons [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tmCons shift to state 230
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 230:
## Known stack suffix:
## cmpTerm comparisonOp tmCons
## LR(1) items:
cmpTerm -> cmpTerm comparisonOp tmCons . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cmpTerm -> cmpTerm comparisonOp tmCons

State 231:
## Known stack suffix:
## cmpTerm
## LR(1) items:
cmpTerm -> cmpTerm . comparisonOp tmCons [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
tmAnd -> cmpTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
## Transitions:
-- On EQUALS shift to state 227
-- On CUSTOM_OP shift to state 228
-- On comparisonOp shift to state 229
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP
--   reduce production tmAnd -> cmpTerm

State 232:
## Known stack suffix:
## tmImplies
## LR(1) items:
tmIff -> tmImplies . IFF tmIff [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
tmIff -> tmImplies . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On IFF shift to state 233
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production tmIff -> tmImplies

State 233:
## Known stack suffix:
## tmImplies IFF
## LR(1) items:
tmIff -> tmImplies IFF . tmIff [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 234
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 234:
## Known stack suffix:
## tmImplies IFF tmIff
## LR(1) items:
tmIff -> tmImplies IFF tmIff . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmIff -> tmImplies IFF tmIff

State 235:
## Known stack suffix:
## tmEq
## LR(1) items:
tmEq -> tmEq . COLON_EQUALS tmOr [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND ]
tupleN -> tmEq . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
tupleN -> tmEq . COMMA tupleN [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On COMMA shift to state 236
-- On COLON_EQUALS shift to state 239
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND
--   reduce production tupleN -> tmEq

State 236:
## Known stack suffix:
## tmEq COMMA
## LR(1) items:
tupleN -> tmEq COMMA . tupleN [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 237
-- On tmOr shift to state 201
-- On tmEq shift to state 235
-- On tmCons shift to state 203
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 237:
## Known stack suffix:
## tmEq COMMA tupleN
## LR(1) items:
tupleN -> tmEq COMMA tupleN . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tupleN -> tmEq COMMA tupleN

State 238:
## Known stack suffix:
## tmAnd
## LR(1) items:
tmAnd -> tmAnd . AMP_AMP cmpTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP ]
tmOr -> tmAnd . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND ]
## Transitions:
-- On AMP_AMP shift to state 205
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND
--   reduce production tmOr -> tmAnd

State 239:
## Known stack suffix:
## tmEq COLON_EQUALS
## LR(1) items:
tmEq -> tmEq COLON_EQUALS . tmOr [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tmOr shift to state 240
-- On tmCons shift to state 203
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 240:
## Known stack suffix:
## tmEq COLON_EQUALS tmOr
## LR(1) items:
tmEq -> tmEq COLON_EQUALS tmOr . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND ]
tmOr -> tmOr . BAR_BAR tmAnd [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR_BAR BAR ASSUME AND ]
## Transitions:
-- On BAR_BAR shift to state 202
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION COMMA COLON_EQUALS BAR_RBRACK BAR ASSUME AND
--   reduce production tmEq -> tmEq COLON_EQUALS tmOr

State 241:
## Known stack suffix:
## tmDisjunction
## LR(1) items:
tmDisjunction -> tmDisjunction . DISJUNCTION tmConjunction [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND ]
tmImplies -> tmDisjunction . IMPLIES tmImplies [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IFF EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
tmImplies -> tmDisjunction . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IFF EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On IMPLIES shift to state 242
-- On DISJUNCTION shift to state 247
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IFF EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production tmImplies -> tmDisjunction

State 242:
## Known stack suffix:
## tmDisjunction IMPLIES
## LR(1) items:
tmImplies -> tmDisjunction IMPLIES . tmImplies [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IFF EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 243
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 243:
## Known stack suffix:
## tmDisjunction IMPLIES tmImplies
## LR(1) items:
tmImplies -> tmDisjunction IMPLIES tmImplies . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IFF EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmImplies -> tmDisjunction IMPLIES tmImplies

State 244:
## Known stack suffix:
## tmConjunction
## LR(1) items:
tmConjunction -> tmConjunction . CONJUNCTION tmTuple [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
tmDisjunction -> tmConjunction . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On CONJUNCTION shift to state 245
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production tmDisjunction -> tmConjunction

State 245:
## Known stack suffix:
## tmConjunction CONJUNCTION
## LR(1) items:
tmConjunction -> tmConjunction CONJUNCTION . tmTuple [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 246
-- On tmOr shift to state 201
-- On tmEq shift to state 235
-- On tmCons shift to state 203
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 246:
## Known stack suffix:
## tmConjunction CONJUNCTION tmTuple
## LR(1) items:
tmConjunction -> tmConjunction CONJUNCTION tmTuple . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tmConjunction -> tmConjunction CONJUNCTION tmTuple

State 247:
## Known stack suffix:
## tmDisjunction DISJUNCTION
## LR(1) items:
tmDisjunction -> tmDisjunction DISJUNCTION . tmConjunction [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmEq shift to state 235
-- On tmCons shift to state 203
-- On tmConjunction shift to state 248
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 248:
## Known stack suffix:
## tmDisjunction DISJUNCTION tmConjunction
## LR(1) items:
tmConjunction -> tmConjunction . CONJUNCTION tmTuple [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT CONJUNCTION BAR_RBRACK BAR ASSUME AND ]
tmDisjunction -> tmDisjunction DISJUNCTION tmConjunction . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On CONJUNCTION shift to state 245
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN IMPLIES IFF EXCEPTION EOF END ELSE EFFECT DISJUNCTION DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production tmDisjunction -> tmDisjunction DISJUNCTION tmConjunction

State 249:
## Known stack suffix:
## tmIff
## LR(1) items:
simpleTerm -> tmIff . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simpleTerm -> tmIff

State 250:
## Known stack suffix:
## simpleTerm
## LR(1) items:
typ -> simpleTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typ -> simpleTerm

State 251:
## Known stack suffix:
## noSeqTerm
## LR(1) items:
formula -> noSeqTerm . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> noSeqTerm

State 252:
## Known stack suffix:
## ident COLON appTerm LBRACE formula
## LR(1) items:
refinementTerm -> ident COLON appTerm LBRACE formula . RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On RBRACE shift to state 253
## Reductions:

State 253:
## Known stack suffix:
## ident COLON appTerm LBRACE formula RBRACE
## LR(1) items:
refinementTerm -> ident COLON appTerm LBRACE formula RBRACE . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production refinementTerm -> ident COLON appTerm LBRACE formula RBRACE

State 254:
## Known stack suffix:
## ENSURES label_opt typ
## LR(1) items:
noSeqTerm -> ENSURES label_opt typ . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> ENSURES label_opt typ

State 255:
## Known stack suffix:
## EXISTS binders DOT qpat noSeqTerm
## LR(1) items:
typ -> EXISTS binders DOT qpat noSeqTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typ -> EXISTS binders DOT qpat noSeqTerm

State 256:
## Known stack suffix:
## binder
## LR(1) items:
binders -> binder . binders [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 257
-- On binder shift to state 256
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND
--   reduce production binders ->

State 257:
## Known stack suffix:
## binder binders
## LR(1) items:
binders -> binder binders . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binders -> binder binders

State 258:
## Known stack suffix:
## LPAREN aqual_opt ident COLON typ
## LR(1) items:
binder -> LPAREN aqual_opt ident COLON typ . refineOpt RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On LBRACE shift to state 259
-- On refineOpt shift to state 262
## Reductions:
-- On RPAREN
--   reduce production refineOpt ->

State 259:
## Known stack suffix:
## LBRACE
## LR(1) items:
refineOpt -> LBRACE . formula RBRACE [ RPAREN ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 251
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On formula shift to state 260
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 260:
## Known stack suffix:
## LBRACE formula
## LR(1) items:
refineOpt -> LBRACE formula . RBRACE [ RPAREN ]
## Transitions:
-- On RBRACE shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## LBRACE formula RBRACE
## LR(1) items:
refineOpt -> LBRACE formula RBRACE . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production refineOpt -> LBRACE formula RBRACE

State 262:
## Known stack suffix:
## LPAREN aqual_opt ident COLON typ refineOpt
## LR(1) items:
binder -> LPAREN aqual_opt ident COLON typ refineOpt . RPAREN [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On RPAREN shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## LPAREN aqual_opt ident COLON typ refineOpt RPAREN
## LR(1) items:
binder -> LPAREN aqual_opt ident COLON typ refineOpt RPAREN . [ VAL TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DOT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binder -> LPAREN aqual_opt ident COLON typ refineOpt RPAREN

State 264:
## Known stack suffix:
## FORALL binders
## LR(1) items:
typ -> FORALL binders . DOT qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On DOT shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## FORALL binders DOT
## LR(1) items:
typ -> FORALL binders DOT . qpat noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On LBRACE_COLON_PATTERN shift to state 175
-- On qpat shift to state 266
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRY TRUE TILDE STRING REQUIRES PLUS_OP PERCENT_LBRACK NAME MINUS_OP MATCH LPAREN_RPAREN LPAREN LET LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IF IEEE64 IDENT HASH FUNCTION FUN FORALL FALSE EXISTS EQUALS ENSURES CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSUME ASSERT
--   reduce production qpat ->

State 266:
## Known stack suffix:
## FORALL binders DOT qpat
## LR(1) items:
typ -> FORALL binders DOT qpat . noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 267
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 267:
## Known stack suffix:
## FORALL binders DOT qpat noSeqTerm
## LR(1) items:
typ -> FORALL binders DOT qpat noSeqTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typ -> FORALL binders DOT qpat noSeqTerm

State 268:
## Known stack suffix:
## FUN atomicPattern atomicPatterns funArrow term
## LR(1) items:
simpleTerm -> FUN atomicPattern atomicPatterns funArrow term . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simpleTerm -> FUN atomicPattern atomicPatterns funArrow term

State 269:
## Known stack suffix:
## noSeqTerm
## LR(1) items:
term -> noSeqTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
term -> noSeqTerm . SEMICOLON term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On SEMICOLON shift to state 270
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production term -> noSeqTerm

State 270:
## Known stack suffix:
## noSeqTerm SEMICOLON
## LR(1) items:
term -> noSeqTerm SEMICOLON . term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 271
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 271:
## Known stack suffix:
## noSeqTerm SEMICOLON term
## LR(1) items:
term -> noSeqTerm SEMICOLON term . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> noSeqTerm SEMICOLON term

State 272:
## Known stack suffix:
## maybeBar disjunctivePattern maybeWhen maybeFocusArrow term
## LR(1) items:
firstPatternBranch -> maybeBar disjunctivePattern maybeWhen maybeFocusArrow term . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production firstPatternBranch -> maybeBar disjunctivePattern maybeWhen maybeFocusArrow term

State 273:
## Known stack suffix:
## FUNCTION firstPatternBranch
## LR(1) items:
noSeqTerm -> FUNCTION firstPatternBranch . patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On patternBranches shift to state 274
## Default reduction:
-- After reading the next token, reduce production patternBranches ->

State 274:
## Known stack suffix:
## FUNCTION firstPatternBranch patternBranches
## LR(1) items:
noSeqTerm -> FUNCTION firstPatternBranch patternBranches . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
patternBranches -> patternBranches . patternBranch [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 275
-- On patternBranch shift to state 280
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK ASSUME AND
--   reduce production noSeqTerm -> FUNCTION firstPatternBranch patternBranches

State 275:
## Known stack suffix:
## BAR
## LR(1) items:
patternBranch -> BAR . disjunctivePattern maybeWhen maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 111
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On ident shift to state 72
-- On disjunctivePattern shift to state 276
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 276:
## Known stack suffix:
## BAR disjunctivePattern
## LR(1) items:
patternBranch -> BAR disjunctivePattern . maybeWhen maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On WHEN shift to state 115
-- On maybeWhen shift to state 277
## Reductions:
-- On SQUIGGLY_RARROW RARROW
--   reduce production maybeWhen ->

State 277:
## Known stack suffix:
## BAR disjunctivePattern maybeWhen
## LR(1) items:
patternBranch -> BAR disjunctivePattern maybeWhen . maybeFocusArrow term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 155
-- On RARROW shift to state 156
-- On maybeFocusArrow shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## BAR disjunctivePattern maybeWhen maybeFocusArrow
## LR(1) items:
patternBranch -> BAR disjunctivePattern maybeWhen maybeFocusArrow . term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 279
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 279:
## Known stack suffix:
## BAR disjunctivePattern maybeWhen maybeFocusArrow term
## LR(1) items:
patternBranch -> BAR disjunctivePattern maybeWhen maybeFocusArrow term . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patternBranch -> BAR disjunctivePattern maybeWhen maybeFocusArrow term

State 280:
## Known stack suffix:
## patternBranches patternBranch
## LR(1) items:
patternBranches -> patternBranches patternBranch . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patternBranches -> patternBranches patternBranch

State 281:
## Known stack suffix:
## IF noSeqTerm
## LR(1) items:
noSeqTerm -> IF noSeqTerm . THEN noSeqTerm ELSE noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
noSeqTerm -> IF noSeqTerm . THEN noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On THEN shift to state 282
## Reductions:

State 282:
## Known stack suffix:
## IF noSeqTerm THEN
## LR(1) items:
noSeqTerm -> IF noSeqTerm THEN . noSeqTerm ELSE noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
noSeqTerm -> IF noSeqTerm THEN . noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 283
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 283:
## Known stack suffix:
## IF noSeqTerm THEN noSeqTerm
## LR(1) items:
noSeqTerm -> IF noSeqTerm THEN noSeqTerm . ELSE noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
noSeqTerm -> IF noSeqTerm THEN noSeqTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On ELSE shift to state 284
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND
--   reduce production noSeqTerm -> IF noSeqTerm THEN noSeqTerm

State 284:
## Known stack suffix:
## IF noSeqTerm THEN noSeqTerm ELSE
## LR(1) items:
noSeqTerm -> IF noSeqTerm THEN noSeqTerm ELSE . noSeqTerm [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 285
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 285:
## Known stack suffix:
## IF noSeqTerm THEN noSeqTerm ELSE noSeqTerm
## LR(1) items:
noSeqTerm -> IF noSeqTerm THEN noSeqTerm ELSE noSeqTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> IF noSeqTerm THEN noSeqTerm ELSE noSeqTerm

State 286:
## Known stack suffix:
## BEGIN term
## LR(1) items:
atomicTerm -> BEGIN term . END [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On END shift to state 287
## Reductions:

State 287:
## Known stack suffix:
## BEGIN term END
## LR(1) items:
atomicTerm -> BEGIN term END . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> BEGIN term END

State 288:
## Known stack suffix:
## LBRACE recordExp
## LR(1) items:
refinementTerm -> LBRACE recordExp . RBRACE [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
-- On RBRACE shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## LBRACE recordExp RBRACE
## LR(1) items:
refinementTerm -> LBRACE recordExp RBRACE . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production refinementTerm -> LBRACE recordExp RBRACE

State 290:
## Known stack suffix:
## appTerm
## LR(1) items:
recordExp -> appTerm . recordExpRest [ RBRACE ]
## Transitions:
-- On WITH shift to state 291
-- On EQUALS shift to state 300
-- On recordExpRest shift to state 303
## Reductions:

State 291:
## Known stack suffix:
## WITH
## LR(1) items:
recordExpRest -> WITH . recordFieldAssignment recordFieldAssignments [ RBRACE ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On recordFieldAssignment shift to state 292
-- On name shift to state 39
-- On lid shift to state 296
-- On idpath shift to state 85
-- On ident shift to state 42
## Reductions:

State 292:
## Known stack suffix:
## WITH recordFieldAssignment
## LR(1) items:
recordExpRest -> WITH recordFieldAssignment . recordFieldAssignments [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 293
-- On recordFieldAssignments shift to state 299
## Reductions:
-- On RBRACE
--   reduce production recordFieldAssignments ->

State 293:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
recordFieldAssignments -> SEMICOLON . [ RBRACE ]
recordFieldAssignments -> SEMICOLON . recordFieldAssignment recordFieldAssignments [ RBRACE ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On recordFieldAssignment shift to state 294
-- On name shift to state 39
-- On lid shift to state 296
-- On idpath shift to state 85
-- On ident shift to state 42
## Reductions:
-- On RBRACE
--   reduce production recordFieldAssignments -> SEMICOLON

State 294:
## Known stack suffix:
## SEMICOLON recordFieldAssignment
## LR(1) items:
recordFieldAssignments -> SEMICOLON recordFieldAssignment . recordFieldAssignments [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 293
-- On recordFieldAssignments shift to state 295
## Reductions:
-- On RBRACE
--   reduce production recordFieldAssignments ->

State 295:
## Known stack suffix:
## SEMICOLON recordFieldAssignment recordFieldAssignments
## LR(1) items:
recordFieldAssignments -> SEMICOLON recordFieldAssignment recordFieldAssignments . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordFieldAssignments -> SEMICOLON recordFieldAssignment recordFieldAssignments

State 296:
## Known stack suffix:
## lid
## LR(1) items:
recordFieldAssignment -> lid . EQUALS simpleTerm [ SEMICOLON RBRACE ]
## Transitions:
-- On EQUALS shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## lid EQUALS
## LR(1) items:
recordFieldAssignment -> lid EQUALS . simpleTerm [ SEMICOLON RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 298
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 298:
## Known stack suffix:
## lid EQUALS simpleTerm
## LR(1) items:
recordFieldAssignment -> lid EQUALS simpleTerm . [ SEMICOLON RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordFieldAssignment -> lid EQUALS simpleTerm

State 299:
## Known stack suffix:
## WITH recordFieldAssignment recordFieldAssignments
## LR(1) items:
recordExpRest -> WITH recordFieldAssignment recordFieldAssignments . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordExpRest -> WITH recordFieldAssignment recordFieldAssignments

State 300:
## Known stack suffix:
## EQUALS
## LR(1) items:
recordExpRest -> EQUALS . simpleTerm recordFieldAssignments [ RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 301
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 301:
## Known stack suffix:
## EQUALS simpleTerm
## LR(1) items:
recordExpRest -> EQUALS simpleTerm . recordFieldAssignments [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 293
-- On recordFieldAssignments shift to state 302
## Reductions:
-- On RBRACE
--   reduce production recordFieldAssignments ->

State 302:
## Known stack suffix:
## EQUALS simpleTerm recordFieldAssignments
## LR(1) items:
recordExpRest -> EQUALS simpleTerm recordFieldAssignments . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordExpRest -> EQUALS simpleTerm recordFieldAssignments

State 303:
## Known stack suffix:
## appTerm recordExpRest
## LR(1) items:
recordExp -> appTerm recordExpRest . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordExp -> appTerm recordExpRest

State 304:
## Known stack suffix:
## LBRACK semiColonTermList
## LR(1) items:
projectionLHS -> LBRACK semiColonTermList . RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On RBRACK shift to state 305
## Reductions:

State 305:
## Known stack suffix:
## LBRACK semiColonTermList RBRACK
## LR(1) items:
projectionLHS -> LBRACK semiColonTermList RBRACK . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> LBRACK semiColonTermList RBRACK

State 306:
## Known stack suffix:
## noSeqTerm
## LR(1) items:
semiColonTermList -> noSeqTerm . moreSemiColonTerms [ RBRACK BAR_RBRACK ]
## Transitions:
-- On SEMICOLON shift to state 307
-- On moreSemiColonTerms shift to state 310
## Reductions:
-- On RBRACK BAR_RBRACK
--   reduce production moreSemiColonTerms ->

State 307:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
moreSemiColonTerms -> SEMICOLON . [ RBRACK BAR_RBRACK ]
moreSemiColonTerms -> SEMICOLON . noSeqTerm moreSemiColonTerms [ RBRACK BAR_RBRACK ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 308
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:
-- On RBRACK BAR_RBRACK
--   reduce production moreSemiColonTerms -> SEMICOLON

State 308:
## Known stack suffix:
## SEMICOLON noSeqTerm
## LR(1) items:
moreSemiColonTerms -> SEMICOLON noSeqTerm . moreSemiColonTerms [ RBRACK BAR_RBRACK ]
## Transitions:
-- On SEMICOLON shift to state 307
-- On moreSemiColonTerms shift to state 309
## Reductions:
-- On RBRACK BAR_RBRACK
--   reduce production moreSemiColonTerms ->

State 309:
## Known stack suffix:
## SEMICOLON noSeqTerm moreSemiColonTerms
## LR(1) items:
moreSemiColonTerms -> SEMICOLON noSeqTerm moreSemiColonTerms . [ RBRACK BAR_RBRACK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production moreSemiColonTerms -> SEMICOLON noSeqTerm moreSemiColonTerms

State 310:
## Known stack suffix:
## noSeqTerm moreSemiColonTerms
## LR(1) items:
semiColonTermList -> noSeqTerm moreSemiColonTerms . [ RBRACK BAR_RBRACK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production semiColonTermList -> noSeqTerm moreSemiColonTerms

State 311:
## Known stack suffix:
## nonTvarPattern COLON typ
## LR(1) items:
ascriptionOrPattern -> nonTvarPattern COLON typ . refineOpt [ RPAREN ]
## Transitions:
-- On LBRACE shift to state 259
-- On refineOpt shift to state 312
## Reductions:
-- On RPAREN
--   reduce production refineOpt ->

State 312:
## Known stack suffix:
## nonTvarPattern COLON typ refineOpt
## LR(1) items:
ascriptionOrPattern -> nonTvarPattern COLON typ refineOpt . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ascriptionOrPattern -> nonTvarPattern COLON typ refineOpt

State 313:
## Known stack suffix:
## LPAREN ascriptionOrPattern
## LR(1) items:
nonTvarPattern2 -> LPAREN ascriptionOrPattern . RPAREN [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
-- On RPAREN shift to state 314
## Reductions:

State 314:
## Known stack suffix:
## LPAREN ascriptionOrPattern RPAREN
## LR(1) items:
nonTvarPattern2 -> LPAREN ascriptionOrPattern RPAREN . [ WHEN UNDERSCORE UINT8 TVAR TRUE STRING SQUIGGLY_RARROW SEMICOLON RPAREN RBRACK RBRACE RARROW NAME LPAREN_RPAREN LPAREN LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS COMMA COLON_COLON COLON CHAR BYTEARRAY BAR ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTvarPattern2 -> LPAREN ascriptionOrPattern RPAREN

State 315:
## Known stack suffix:
## pattern
## LR(1) items:
letbinding -> pattern . ascribeTypOpt EQUALS term [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On COLON shift to state 316
-- On ascribeTypOpt shift to state 318
## Reductions:
-- On EQUALS
--   reduce production ascribeTypOpt ->

State 316:
## Known stack suffix:
## COLON
## LR(1) items:
ascribeTypOpt -> COLON . product [ EQUALS ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 317
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 317:
## Known stack suffix:
## COLON product
## LR(1) items:
ascribeTypOpt -> COLON product . [ EQUALS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ascribeTypOpt -> COLON product

State 318:
## Known stack suffix:
## pattern ascribeTypOpt
## LR(1) items:
letbinding -> pattern ascribeTypOpt . EQUALS term [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On EQUALS shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## pattern ascribeTypOpt EQUALS
## LR(1) items:
letbinding -> pattern ascribeTypOpt EQUALS . term [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 320
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 320:
## Known stack suffix:
## pattern ascribeTypOpt EQUALS term
## LR(1) items:
letbinding -> pattern ascribeTypOpt EQUALS term . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production letbinding -> pattern ascribeTypOpt EQUALS term

State 321:
## Known stack suffix:
## LET recopt letbinding
## LR(1) items:
noSeqTerm -> LET recopt letbinding . letbindings IN term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On AND shift to state 322
-- On letbindings shift to state 326
## Reductions:
-- On IN
--   reduce production letbindings ->

State 322:
## Known stack suffix:
## AND
## LR(1) items:
letbindings -> AND . maybeFocus letbinding letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 29
-- On maybeFocus shift to state 323
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production maybeFocus ->

State 323:
## Known stack suffix:
## AND maybeFocus
## LR(1) items:
letbindings -> AND maybeFocus . letbinding letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 315
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On letbinding shift to state 324
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 324:
## Known stack suffix:
## AND maybeFocus letbinding
## LR(1) items:
letbindings -> AND maybeFocus letbinding . letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On AND shift to state 322
-- On letbindings shift to state 325
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME
--   reduce production letbindings ->

State 325:
## Known stack suffix:
## AND maybeFocus letbinding letbindings
## LR(1) items:
letbindings -> AND maybeFocus letbinding letbindings . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND IN EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production letbindings -> AND maybeFocus letbinding letbindings

State 326:
## Known stack suffix:
## LET recopt letbinding letbindings
## LR(1) items:
noSeqTerm -> LET recopt letbinding letbindings . IN term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On IN shift to state 327
## Reductions:

State 327:
## Known stack suffix:
## LET recopt letbinding letbindings IN
## LR(1) items:
noSeqTerm -> LET recopt letbinding letbindings IN . term [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 328
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 328:
## Known stack suffix:
## LET recopt letbinding letbindings IN term
## LR(1) items:
noSeqTerm -> LET recopt letbinding letbindings IN term . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> LET recopt letbinding letbindings IN term

State 329:
## Known stack suffix:
## maybeFocus
## LR(1) items:
recopt -> maybeFocus . REC [ UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY ]
## Transitions:
-- On REC shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## maybeFocus REC
## LR(1) items:
recopt -> maybeFocus REC . [ UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recopt -> maybeFocus REC

State 331:
## Known stack suffix:
## MATCH term
## LR(1) items:
noSeqTerm -> MATCH term . WITH firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On WITH shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## MATCH term WITH
## LR(1) items:
noSeqTerm -> MATCH term WITH . firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 109
-- On maybeBar shift to state 110
-- On firstPatternBranch shift to state 333
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production maybeBar ->

State 333:
## Known stack suffix:
## MATCH term WITH firstPatternBranch
## LR(1) items:
noSeqTerm -> MATCH term WITH firstPatternBranch . patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On patternBranches shift to state 334
## Default reduction:
-- After reading the next token, reduce production patternBranches ->

State 334:
## Known stack suffix:
## MATCH term WITH firstPatternBranch patternBranches
## LR(1) items:
noSeqTerm -> MATCH term WITH firstPatternBranch patternBranches . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
patternBranches -> patternBranches . patternBranch [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 275
-- On patternBranch shift to state 280
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK ASSUME AND
--   reduce production noSeqTerm -> MATCH term WITH firstPatternBranch patternBranches

State 335:
## Known stack suffix:
## LBRACK_BAR semiColonTermList
## LR(1) items:
projectionLHS -> LBRACK_BAR semiColonTermList . BAR_RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On BAR_RBRACK shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## LBRACK_BAR semiColonTermList BAR_RBRACK
## LR(1) items:
projectionLHS -> LBRACK_BAR semiColonTermList BAR_RBRACK . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> LBRACK_BAR semiColonTermList BAR_RBRACK

State 337:
## Known stack suffix:
## LENS_PAREN_LEFT tupleN
## LR(1) items:
atomicTerm -> LENS_PAREN_LEFT tupleN . LENS_PAREN_RIGHT [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On LENS_PAREN_RIGHT shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## LENS_PAREN_LEFT tupleN LENS_PAREN_RIGHT
## LR(1) items:
atomicTerm -> LENS_PAREN_LEFT tupleN LENS_PAREN_RIGHT . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomicTerm -> LENS_PAREN_LEFT tupleN LENS_PAREN_RIGHT

State 339:
## Known stack suffix:
## MINUS_OP atomicTerm
## LR(1) items:
unaryTerm -> MINUS_OP atomicTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unaryTerm -> MINUS_OP atomicTerm

State 340:
## Known stack suffix:
## LPAREN term
## LR(1) items:
projectionLHS -> LPAREN term . maybeWithSort RPAREN [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On SUBTYPE shift to state 341
-- On SUBKIND shift to state 342
-- On maybeWithSort shift to state 343
-- On hasSort shift to state 345
## Reductions:
-- On RPAREN
--   reduce production maybeWithSort ->

State 341:
## Known stack suffix:
## SUBTYPE
## LR(1) items:
hasSort -> SUBTYPE . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FALSE EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production hasSort -> SUBTYPE

State 342:
## Known stack suffix:
## SUBKIND
## LR(1) items:
hasSort -> SUBKIND . [ UNDERSCORE UINT8 TVAR TRUE TILDE STRING PLUS_OP PERCENT_LBRACK NAME MINUS_OP LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FUN FALSE EQUALS CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production hasSort -> SUBKIND

State 343:
## Known stack suffix:
## LPAREN term maybeWithSort
## LR(1) items:
projectionLHS -> LPAREN term maybeWithSort . RPAREN [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On RPAREN shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## LPAREN term maybeWithSort RPAREN
## LR(1) items:
projectionLHS -> LPAREN term maybeWithSort RPAREN . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> LPAREN term maybeWithSort RPAREN

State 345:
## Known stack suffix:
## hasSort
## LR(1) items:
maybeWithSort -> hasSort . simpleTerm [ RPAREN ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 346
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 346:
## Known stack suffix:
## hasSort simpleTerm
## LR(1) items:
maybeWithSort -> hasSort simpleTerm . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybeWithSort -> hasSort simpleTerm

State 347:
## Known stack suffix:
## PLUS_OP atomicTerm
## LR(1) items:
unaryTerm -> PLUS_OP atomicTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unaryTerm -> PLUS_OP atomicTerm

State 348:
## Known stack suffix:
## REQUIRES label_opt typ
## LR(1) items:
noSeqTerm -> REQUIRES label_opt typ . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production noSeqTerm -> REQUIRES label_opt typ

State 349:
## Known stack suffix:
## TRY term
## LR(1) items:
noSeqTerm -> TRY term . WITH firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On WITH shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## TRY term WITH
## LR(1) items:
noSeqTerm -> TRY term WITH . firstPatternBranch patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 109
-- On maybeBar shift to state 110
-- On firstPatternBranch shift to state 351
## Reductions:
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production maybeBar ->

State 351:
## Known stack suffix:
## TRY term WITH firstPatternBranch
## LR(1) items:
noSeqTerm -> TRY term WITH firstPatternBranch . patternBranches [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On patternBranches shift to state 352
## Default reduction:
-- After reading the next token, reduce production patternBranches ->

State 352:
## Known stack suffix:
## TRY term WITH firstPatternBranch patternBranches
## LR(1) items:
noSeqTerm -> TRY term WITH firstPatternBranch patternBranches . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
patternBranches -> patternBranches . patternBranch [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK BAR ASSUME AND ]
## Transitions:
-- On BAR shift to state 275
-- On patternBranch shift to state 280
## Reductions:
-- On WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET LBRACE KIND IN EXCEPTION EOF END ELSE EFFECT DEFAULT BAR_RBRACK ASSUME AND
--   reduce production noSeqTerm -> TRY term WITH firstPatternBranch patternBranches

State 353:
## Known stack suffix:
## PERCENT_LBRACK semiColonTermList
## LR(1) items:
projectionLHS -> PERCENT_LBRACK semiColonTermList . RBRACK [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
-- On RBRACK shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## PERCENT_LBRACK semiColonTermList RBRACK
## LR(1) items:
projectionLHS -> PERCENT_LBRACK semiColonTermList RBRACK . [ WITH VAL UNDERSCORE UINT8 TYP_APP_GREATER TYPE TVAR TRUE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STRING STAR SQUIGGLY_RARROW SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP PERCENT_LBRACK OPEN OPAQUE NEW_EFFECT NAME MODULE MINUS_OP LPAREN_RPAREN LPAREN LOGIC LET LENS_PAREN_RIGHT LENS_PAREN_LEFT LBRACK_BAR LBRACK LBRACE KIND INT64 INT32 INT IN IMPLIES IFF IEEE64 IDENT HASH FALSE EXCEPTION EQUALS EOF END ELSE EFFECT DOT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON CHAR BYTEARRAY BEGIN BAR_RBRACK BAR_BAR BAR BANG_LBRACE BANG ASSUME ASSERT AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production projectionLHS -> PERCENT_LBRACK semiColonTermList RBRACK

State 355:
## Known stack suffix:
## TILDE atomicTerm
## LR(1) items:
unaryTerm -> TILDE atomicTerm . [ WITH VAL TYPE TOTAL THEN SUB_EFFECT SUBTYPE SUBKIND STAR SEMICOLON_SEMICOLON SEMICOLON RPAREN RBRACK RBRACE RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET LENS_PAREN_RIGHT LBRACE KIND IN IMPLIES IFF EXCEPTION EQUALS EOF END ELSE EFFECT DIV_MOD_OP DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_RBRACK BAR_BAR BAR ASSUME AND AMP_AMP AMP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unaryTerm -> TILDE atomicTerm

State 356:
## Known stack suffix:
## qname SQUIGGLY_RARROW qname EQUALS simpleTerm
## LR(1) items:
sub_effect -> qname SQUIGGLY_RARROW qname EQUALS simpleTerm . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sub_effect -> qname SQUIGGLY_RARROW qname EQUALS simpleTerm

State 357:
## Known stack suffix:
## PRIVATE
## LR(1) items:
qualifier -> PRIVATE . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> PRIVATE

State 358:
## Known stack suffix:
## PRAGMA_SET_OPTIONS
## LR(1) items:
pragma -> PRAGMA_SET_OPTIONS . STRING [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On STRING shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## PRAGMA_SET_OPTIONS STRING
## LR(1) items:
pragma -> PRAGMA_SET_OPTIONS STRING . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pragma -> PRAGMA_SET_OPTIONS STRING

State 360:
## Known stack suffix:
## PRAGMA_RESET_OPTIONS
## LR(1) items:
pragma -> PRAGMA_RESET_OPTIONS . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pragma -> PRAGMA_RESET_OPTIONS

State 361:
## Known stack suffix:
## PRAGMALIGHT
## LR(1) items:
maybe_pragma_light -> PRAGMALIGHT . STRING [ MODULE EOF ]
## Transitions:
-- On STRING shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## PRAGMALIGHT STRING
## LR(1) items:
maybe_pragma_light -> PRAGMALIGHT STRING . [ MODULE EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_pragma_light -> PRAGMALIGHT STRING

State 363:
## Known stack suffix:
## OPEN
## LR(1) items:
decl2 -> OPEN . qname [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On qname shift to state 364
-- On namepath shift to state 64
-- On name shift to state 65
## Reductions:

State 364:
## Known stack suffix:
## OPEN qname
## LR(1) items:
decl2 -> OPEN qname . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> OPEN qname

State 365:
## Known stack suffix:
## OPAQUE
## LR(1) items:
qualifier -> OPAQUE . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> OPAQUE

State 366:
## Known stack suffix:
## LOGIC
## LR(1) items:
qualifier -> LOGIC . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> LOGIC

State 367:
## Known stack suffix:
## LET
## LR(1) items:
decl2 -> LET . recopt letbinding letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On SQUIGGLY_RARROW shift to state 29
-- On recopt shift to state 368
-- On maybeFocus shift to state 329
## Reductions:
-- On REC
--   reduce production maybeFocus ->
-- On UNDERSCORE UINT8 TVAR TRUE STRING NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK LBRACE INT64 INT32 INT IEEE64 IDENT HASH FALSE CHAR BYTEARRAY
--   reduce production recopt ->

State 368:
## Known stack suffix:
## LET recopt
## LR(1) items:
decl2 -> LET recopt . letbinding letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 31
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 32
-- On LENS_PAREN_LEFT shift to state 33
-- On LBRACK shift to state 34
-- On LBRACE shift to state 35
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 49
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On tvar shift to state 54
-- On tuplePattern shift to state 55
-- On qname shift to state 56
-- On pattern shift to state 315
-- On nonTvarPattern2 shift to state 63
-- On namepath shift to state 64
-- On name shift to state 65
-- On listPattern shift to state 68
-- On letbinding shift to state 369
-- On ident shift to state 72
-- On constant shift to state 73
-- On atomicPattern2 shift to state 74
-- On atomicPattern shift to state 75
-- On appPattern shift to state 79
## Reductions:

State 369:
## Known stack suffix:
## LET recopt letbinding
## LR(1) items:
decl2 -> LET recopt letbinding . letbindings [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On AND shift to state 322
-- On letbindings shift to state 370
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME
--   reduce production letbindings ->

State 370:
## Known stack suffix:
## LET recopt letbinding letbindings
## LR(1) items:
decl2 -> LET recopt letbinding letbindings . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> LET recopt letbinding letbindings

State 371:
## Known stack suffix:
## KIND
## LR(1) items:
kind_abbrev -> KIND . name binders EQUALS kind [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On name shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## KIND name
## LR(1) items:
kind_abbrev -> KIND name . binders EQUALS kind [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 373
-- On binder shift to state 256
## Reductions:
-- On EQUALS
--   reduce production binders ->

State 373:
## Known stack suffix:
## KIND name binders
## LR(1) items:
kind_abbrev -> KIND name binders . EQUALS kind [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On EQUALS shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## KIND name binders EQUALS
## LR(1) items:
kind_abbrev -> KIND name binders EQUALS . kind [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 375
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On kind shift to state 376
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 375:
## Known stack suffix:
## product
## LR(1) items:
kind -> product . [ WITH VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production kind -> product

State 376:
## Known stack suffix:
## KIND name binders EQUALS kind
## LR(1) items:
kind_abbrev -> KIND name binders EQUALS kind . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production kind_abbrev -> KIND name binders EQUALS kind

State 377:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
decl2 -> EXCEPTION . name of_typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On name shift to state 378
## Reductions:

State 378:
## Known stack suffix:
## EXCEPTION name
## LR(1) items:
decl2 -> EXCEPTION name . of_typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On OF shift to state 379
-- On of_typ shift to state 381
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME
--   reduce production of_typ ->

State 379:
## Known stack suffix:
## OF
## LR(1) items:
of_typ -> OF . typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 380
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 380:
## Known stack suffix:
## OF typ
## LR(1) items:
of_typ -> OF typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production of_typ -> OF typ

State 381:
## Known stack suffix:
## EXCEPTION name of_typ
## LR(1) items:
decl2 -> EXCEPTION name of_typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> EXCEPTION name of_typ

State 382:
## Known stack suffix:
## DEFAULT
## LR(1) items:
qualifier -> DEFAULT . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> DEFAULT

State 383:
## Known stack suffix:
## ASSUME
## LR(1) items:
assumeTag -> ASSUME . [ NAME ]
qualifier -> ASSUME . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Reductions:
-- On NAME
--   reduce production assumeTag -> ASSUME
-- On VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME
--   reduce production qualifier -> ASSUME

State 384:
## Known stack suffix:
## tycon
## LR(1) items:
decl2 -> tycon . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> tycon

State 385:
## Known stack suffix:
## qualifiers
## LR(1) items:
decl2 -> qualifiers . VAL ident COLON typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
decl2 -> qualifiers . NEW_EFFECT new_effect [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
tycon -> qualifiers . TYPE tyconDefinition tyconDefinitions [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
tycon -> qualifiers . EFFECT tyconDefinition [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On VAL shift to state 386
-- On TYPE shift to state 390
-- On NEW_EFFECT shift to state 432
-- On EFFECT shift to state 453
## Reductions:

State 386:
## Known stack suffix:
## qualifiers VAL
## LR(1) items:
decl2 -> qualifiers VAL . ident COLON typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 387
## Reductions:

State 387:
## Known stack suffix:
## qualifiers VAL ident
## LR(1) items:
decl2 -> qualifiers VAL ident . COLON typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On COLON shift to state 388
## Reductions:

State 388:
## Known stack suffix:
## qualifiers VAL ident COLON
## LR(1) items:
decl2 -> qualifiers VAL ident COLON . typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 389
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 389:
## Known stack suffix:
## qualifiers VAL ident COLON typ
## LR(1) items:
decl2 -> qualifiers VAL ident COLON typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> qualifiers VAL ident COLON typ

State 390:
## Known stack suffix:
## qualifiers TYPE
## LR(1) items:
tycon -> qualifiers TYPE . tyconDefinition tyconDefinitions [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On tyconDefinition shift to state 391
-- On name shift to state 395
-- On ident shift to state 396
-- On eitherName shift to state 397
## Reductions:

State 391:
## Known stack suffix:
## qualifiers TYPE tyconDefinition
## LR(1) items:
tycon -> qualifiers TYPE tyconDefinition . tyconDefinitions [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On AND shift to state 392
-- On tyconDefinitions shift to state 431
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME
--   reduce production tyconDefinitions ->

State 392:
## Known stack suffix:
## AND
## LR(1) items:
tyconDefinitions -> AND . tyconDefinition tyconDefinitions [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On tyconDefinition shift to state 393
-- On name shift to state 395
-- On ident shift to state 396
-- On eitherName shift to state 397
## Reductions:

State 393:
## Known stack suffix:
## AND tyconDefinition
## LR(1) items:
tyconDefinitions -> AND tyconDefinition . tyconDefinitions [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On AND shift to state 392
-- On tyconDefinitions shift to state 394
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME
--   reduce production tyconDefinitions ->

State 394:
## Known stack suffix:
## AND tyconDefinition tyconDefinitions
## LR(1) items:
tyconDefinitions -> AND tyconDefinition tyconDefinitions . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tyconDefinitions -> AND tyconDefinition tyconDefinitions

State 395:
## Known stack suffix:
## name
## LR(1) items:
eitherName -> name . [ VAL TYP_APP_LESS TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eitherName -> name

State 396:
## Known stack suffix:
## ident
## LR(1) items:
eitherName -> ident . [ VAL TYP_APP_LESS TYPE TVAR TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LPAREN LOGIC LET KIND IDENT EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production eitherName -> ident

State 397:
## Known stack suffix:
## eitherName
## LR(1) items:
tyconDefinition -> eitherName . typars ascribeKindOpt tyconDefn [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On TYP_APP_LESS shift to state 398
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On typars shift to state 404
-- On tvarinsts shift to state 429
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 430
-- On binder shift to state 256
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND
--   reduce production binders ->

State 398:
## Known stack suffix:
## TYP_APP_LESS
## LR(1) items:
tvarinsts -> TYP_APP_LESS . tvars TYP_APP_GREATER [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On TVAR shift to state 399
-- On tvars shift to state 402
## Reductions:

State 399:
## Known stack suffix:
## TVAR
## LR(1) items:
tvars -> TVAR . [ TYP_APP_GREATER ]
tvars -> TVAR . COMMA tvars [ TYP_APP_GREATER ]
## Transitions:
-- On COMMA shift to state 400
## Reductions:
-- On TYP_APP_GREATER
--   reduce production tvars -> TVAR

State 400:
## Known stack suffix:
## TVAR COMMA
## LR(1) items:
tvars -> TVAR COMMA . tvars [ TYP_APP_GREATER ]
## Transitions:
-- On TVAR shift to state 399
-- On tvars shift to state 401
## Reductions:

State 401:
## Known stack suffix:
## TVAR COMMA tvars
## LR(1) items:
tvars -> TVAR COMMA tvars . [ TYP_APP_GREATER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tvars -> TVAR COMMA tvars

State 402:
## Known stack suffix:
## TYP_APP_LESS tvars
## LR(1) items:
tvarinsts -> TYP_APP_LESS tvars . TYP_APP_GREATER [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
-- On TYP_APP_GREATER shift to state 403
## Reductions:

State 403:
## Known stack suffix:
## TYP_APP_LESS tvars TYP_APP_GREATER
## LR(1) items:
tvarinsts -> TYP_APP_LESS tvars TYP_APP_GREATER . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tvarinsts -> TYP_APP_LESS tvars TYP_APP_GREATER

State 404:
## Known stack suffix:
## eitherName typars
## LR(1) items:
tyconDefinition -> eitherName typars . ascribeKindOpt tyconDefn [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On COLON shift to state 405
-- On ascribeKindOpt shift to state 407
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT ASSUME AND
--   reduce production ascribeKindOpt ->

State 405:
## Known stack suffix:
## COLON
## LR(1) items:
ascribeKindOpt -> COLON . kind [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 375
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On kind shift to state 406
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 406:
## Known stack suffix:
## COLON kind
## LR(1) items:
ascribeKindOpt -> COLON kind . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ascribeKindOpt -> COLON kind

State 407:
## Known stack suffix:
## eitherName typars ascribeKindOpt
## LR(1) items:
tyconDefinition -> eitherName typars ascribeKindOpt . tyconDefn [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On EQUALS shift to state 408
-- On tyconDefn shift to state 428
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND
--   reduce production tyconDefn ->

State 408:
## Known stack suffix:
## EQUALS
## LR(1) items:
tyconDefn -> EQUALS . typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
tyconDefn -> EQUALS . LBRACE recordFieldDecl recordFields RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
tyconDefn -> EQUALS . constructors [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 409
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 420
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constructors shift to state 421
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND
--   reduce production constructors ->

State 409:
## Known stack suffix:
## EQUALS LBRACE
## LR(1) items:
refinementTerm -> LBRACE . recordExp RBRACE [ VAL TYPE TOTAL SUB_EFFECT STAR SEMICOLON_SEMICOLON RARROW PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS PLUS_OP OPEN OPAQUE NEW_EFFECT MODULE MINUS_OP LOGIC LET KIND IMPLIES IFF EXCEPTION EQUALS EOF END EFFECT DISJUNCTION DEFAULT CUSTOM_OP CONJUNCTION COMMA COLON_EQUALS COLON_COLON BAR_BAR ASSUME AND AMP_AMP AMP ]
tyconDefn -> EQUALS LBRACE . recordFieldDecl recordFields RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On STRING shift to state 14
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On FALSE shift to state 51
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On tvar shift to state 119
-- On recordFieldDecl shift to state 410
-- On recordExp shift to state 288
-- On projectionLHS shift to state 120
-- On name shift to state 124
-- On ident shift to state 419
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On appTerm shift to state 290
## Reductions:

State 410:
## Known stack suffix:
## EQUALS LBRACE recordFieldDecl
## LR(1) items:
tyconDefn -> EQUALS LBRACE recordFieldDecl . recordFields RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On SEMICOLON shift to state 411
-- On recordFields shift to state 417
## Reductions:
-- On RBRACE
--   reduce production recordFields ->

State 411:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
recordFields -> SEMICOLON . recordFieldDecl recordFields [ RBRACE ]
recordFields -> SEMICOLON . [ RBRACE ]
## Transitions:
-- On IDENT shift to state 36
-- On recordFieldDecl shift to state 412
-- On ident shift to state 414
## Reductions:
-- On RBRACE
--   reduce production recordFields -> SEMICOLON

State 412:
## Known stack suffix:
## SEMICOLON recordFieldDecl
## LR(1) items:
recordFields -> SEMICOLON recordFieldDecl . recordFields [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 411
-- On recordFields shift to state 413
## Reductions:
-- On RBRACE
--   reduce production recordFields ->

State 413:
## Known stack suffix:
## SEMICOLON recordFieldDecl recordFields
## LR(1) items:
recordFields -> SEMICOLON recordFieldDecl recordFields . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordFields -> SEMICOLON recordFieldDecl recordFields

State 414:
## Known stack suffix:
## ident
## LR(1) items:
recordFieldDecl -> ident . COLON tmTuple [ SEMICOLON RBRACE ]
## Transitions:
-- On COLON shift to state 415
## Reductions:

State 415:
## Known stack suffix:
## ident COLON
## LR(1) items:
recordFieldDecl -> ident COLON . tmTuple [ SEMICOLON RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 416
-- On tmOr shift to state 201
-- On tmEq shift to state 235
-- On tmCons shift to state 203
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 416:
## Known stack suffix:
## ident COLON tmTuple
## LR(1) items:
recordFieldDecl -> ident COLON tmTuple . [ SEMICOLON RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production recordFieldDecl -> ident COLON tmTuple

State 417:
## Known stack suffix:
## EQUALS LBRACE recordFieldDecl recordFields
## LR(1) items:
tyconDefn -> EQUALS LBRACE recordFieldDecl recordFields . RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On RBRACE shift to state 418
## Reductions:

State 418:
## Known stack suffix:
## EQUALS LBRACE recordFieldDecl recordFields RBRACE
## LR(1) items:
tyconDefn -> EQUALS LBRACE recordFieldDecl recordFields RBRACE . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tyconDefn -> EQUALS LBRACE recordFieldDecl recordFields RBRACE

State 419:
## Known stack suffix:
## ident
## LR(1) items:
eitherpath -> ident . [ WITH UNDERSCORE UINT8 TYP_APP_LESS TVAR TRUE STRING PERCENT_LBRACK NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS DOT CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT ]
recordFieldDecl -> ident . COLON tmTuple [ SEMICOLON RBRACE ]
## Transitions:
-- On COLON shift to state 415
## Reductions:
-- On WITH UNDERSCORE UINT8 TYP_APP_LESS TVAR TRUE STRING PERCENT_LBRACK NAME LPAREN_RPAREN LPAREN LENS_PAREN_LEFT LBRACK_BAR LBRACK INT64 INT32 INT IEEE64 IDENT HASH FALSE EQUALS DOT CHAR BYTEARRAY BEGIN BANG_LBRACE BANG ASSERT
--   reduce production eitherpath -> ident

State 420:
## Known stack suffix:
## EQUALS typ
## LR(1) items:
tyconDefn -> EQUALS typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tyconDefn -> EQUALS typ

State 421:
## Known stack suffix:
## EQUALS constructors
## LR(1) items:
constructors -> constructors . constructorDecl [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
tyconDefn -> EQUALS constructors . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
-- On BAR shift to state 422
-- On constructorDecl shift to state 427
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND
--   reduce production tyconDefn -> EQUALS constructors

State 422:
## Known stack suffix:
## BAR
## LR(1) items:
constructorDecl -> BAR . name COLON typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
constructorDecl -> BAR . name of_typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
-- On NAME shift to state 3
-- On name shift to state 423
## Reductions:

State 423:
## Known stack suffix:
## BAR name
## LR(1) items:
constructorDecl -> BAR name . COLON typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
constructorDecl -> BAR name . of_typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
-- On OF shift to state 379
-- On COLON shift to state 424
-- On of_typ shift to state 426
## Reductions:
-- On VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND
--   reduce production of_typ ->

State 424:
## Known stack suffix:
## BAR name COLON
## LR(1) items:
constructorDecl -> BAR name COLON . typ [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 425
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 425:
## Known stack suffix:
## BAR name COLON typ
## LR(1) items:
constructorDecl -> BAR name COLON typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructorDecl -> BAR name COLON typ

State 426:
## Known stack suffix:
## BAR name of_typ
## LR(1) items:
constructorDecl -> BAR name of_typ . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructorDecl -> BAR name of_typ

State 427:
## Known stack suffix:
## constructors constructorDecl
## LR(1) items:
constructors -> constructors constructorDecl . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT BAR ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constructors -> constructors constructorDecl

State 428:
## Known stack suffix:
## eitherName typars ascribeKindOpt tyconDefn
## LR(1) items:
tyconDefinition -> eitherName typars ascribeKindOpt tyconDefn . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tyconDefinition -> eitherName typars ascribeKindOpt tyconDefn

State 429:
## Known stack suffix:
## tvarinsts
## LR(1) items:
typars -> tvarinsts . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typars -> tvarinsts

State 430:
## Known stack suffix:
## binders
## LR(1) items:
typars -> binders . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EQUALS EOF END EFFECT DEFAULT COLON ASSUME AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typars -> binders

State 431:
## Known stack suffix:
## qualifiers TYPE tyconDefinition tyconDefinitions
## LR(1) items:
tycon -> qualifiers TYPE tyconDefinition tyconDefinitions . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tycon -> qualifiers TYPE tyconDefinition tyconDefinitions

State 432:
## Known stack suffix:
## qualifiers NEW_EFFECT
## LR(1) items:
decl2 -> qualifiers NEW_EFFECT . new_effect [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On LBRACE shift to state 433
-- On new_effect shift to state 448
-- On name shift to state 449
## Reductions:

State 433:
## Known stack suffix:
## LBRACE
## LR(1) items:
new_effect -> LBRACE . name binders COLON kind WITH effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On name shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## LBRACE name
## LR(1) items:
new_effect -> LBRACE name . binders COLON kind WITH effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 435
-- On binder shift to state 256
## Reductions:
-- On COLON
--   reduce production binders ->

State 435:
## Known stack suffix:
## LBRACE name binders
## LR(1) items:
new_effect -> LBRACE name binders . COLON kind WITH effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On COLON shift to state 436
## Reductions:

State 436:
## Known stack suffix:
## LBRACE name binders COLON
## LR(1) items:
new_effect -> LBRACE name binders COLON . kind WITH effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On starDivModTerm shift to state 206
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 375
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On kind shift to state 437
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 437:
## Known stack suffix:
## LBRACE name binders COLON kind
## LR(1) items:
new_effect -> LBRACE name binders COLON kind . WITH effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On WITH shift to state 438
## Reductions:

State 438:
## Known stack suffix:
## LBRACE name binders COLON kind WITH
## LR(1) items:
new_effect -> LBRACE name binders COLON kind WITH . effect_decl more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 439
-- On effect_decl shift to state 442
## Reductions:

State 439:
## Known stack suffix:
## ident
## LR(1) items:
effect_decl -> ident . EQUALS simpleTerm [ SEMICOLON RBRACE ]
## Transitions:
-- On EQUALS shift to state 440
## Reductions:

State 440:
## Known stack suffix:
## ident EQUALS
## LR(1) items:
effect_decl -> ident EQUALS . simpleTerm [ SEMICOLON RBRACE ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 441
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 441:
## Known stack suffix:
## ident EQUALS simpleTerm
## LR(1) items:
effect_decl -> ident EQUALS simpleTerm . [ SEMICOLON RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production effect_decl -> ident EQUALS simpleTerm

State 442:
## Known stack suffix:
## LBRACE name binders COLON kind WITH effect_decl
## LR(1) items:
new_effect -> LBRACE name binders COLON kind WITH effect_decl . more_effect_decls RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On SEMICOLON shift to state 443
-- On more_effect_decls shift to state 446
## Reductions:
-- On RBRACE
--   reduce production more_effect_decls ->

State 443:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
more_effect_decls -> SEMICOLON . effect_decl more_effect_decls [ RBRACE ]
## Transitions:
-- On IDENT shift to state 36
-- On ident shift to state 439
-- On effect_decl shift to state 444
## Reductions:

State 444:
## Known stack suffix:
## SEMICOLON effect_decl
## LR(1) items:
more_effect_decls -> SEMICOLON effect_decl . more_effect_decls [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 443
-- On more_effect_decls shift to state 445
## Reductions:
-- On RBRACE
--   reduce production more_effect_decls ->

State 445:
## Known stack suffix:
## SEMICOLON effect_decl more_effect_decls
## LR(1) items:
more_effect_decls -> SEMICOLON effect_decl more_effect_decls . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production more_effect_decls -> SEMICOLON effect_decl more_effect_decls

State 446:
## Known stack suffix:
## LBRACE name binders COLON kind WITH effect_decl more_effect_decls
## LR(1) items:
new_effect -> LBRACE name binders COLON kind WITH effect_decl more_effect_decls . RBRACE [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On RBRACE shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## LBRACE name binders COLON kind WITH effect_decl more_effect_decls RBRACE
## LR(1) items:
new_effect -> LBRACE name binders COLON kind WITH effect_decl more_effect_decls RBRACE . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production new_effect -> LBRACE name binders COLON kind WITH effect_decl more_effect_decls RBRACE

State 448:
## Known stack suffix:
## qualifiers NEW_EFFECT new_effect
## LR(1) items:
decl2 -> qualifiers NEW_EFFECT new_effect . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> qualifiers NEW_EFFECT new_effect

State 449:
## Known stack suffix:
## name
## LR(1) items:
new_effect -> name . binders EQUALS simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On TVAR shift to state 11
-- On LPAREN shift to state 164
-- On IDENT shift to state 36
-- On tvar shift to state 171
-- On ident shift to state 172
-- On binders shift to state 450
-- On binder shift to state 256
## Reductions:
-- On EQUALS
--   reduce production binders ->

State 450:
## Known stack suffix:
## name binders
## LR(1) items:
new_effect -> name binders . EQUALS simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On EQUALS shift to state 451
## Reductions:

State 451:
## Known stack suffix:
## name binders EQUALS
## LR(1) items:
new_effect -> name binders EQUALS . simpleTerm [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUN shift to state 158
-- On FALSE shift to state 51
-- On EQUALS shift to state 183
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 452
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 452:
## Known stack suffix:
## name binders EQUALS simpleTerm
## LR(1) items:
new_effect -> name binders EQUALS simpleTerm . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production new_effect -> name binders EQUALS simpleTerm

State 453:
## Known stack suffix:
## qualifiers EFFECT
## LR(1) items:
tycon -> qualifiers EFFECT . tyconDefinition [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On IDENT shift to state 36
-- On tyconDefinition shift to state 454
-- On name shift to state 395
-- On ident shift to state 396
-- On eitherName shift to state 397
## Reductions:

State 454:
## Known stack suffix:
## qualifiers EFFECT tyconDefinition
## LR(1) items:
tycon -> qualifiers EFFECT tyconDefinition . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tycon -> qualifiers EFFECT tyconDefinition

State 455:
## Known stack suffix:
## qualifier
## LR(1) items:
qualifiers -> qualifier . qualifiers [ VAL TYPE NEW_EFFECT EFFECT ]
## Transitions:
-- On TOTAL shift to state 1
-- On PRIVATE shift to state 357
-- On OPAQUE shift to state 365
-- On LOGIC shift to state 366
-- On DEFAULT shift to state 382
-- On ASSUME shift to state 456
-- On qualifiers shift to state 457
-- On qualifier shift to state 455
## Reductions:
-- On VAL TYPE NEW_EFFECT EFFECT
--   reduce production qualifiers ->

State 456:
## Known stack suffix:
## ASSUME
## LR(1) items:
qualifier -> ASSUME . [ VAL TYPE TOTAL PRIVATE OPAQUE NEW_EFFECT LOGIC EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifier -> ASSUME

State 457:
## Known stack suffix:
## qualifier qualifiers
## LR(1) items:
qualifiers -> qualifier qualifiers . [ VAL TYPE NEW_EFFECT EFFECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualifiers -> qualifier qualifiers

State 458:
## Known stack suffix:
## pragma
## LR(1) items:
decl2 -> pragma . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> pragma

State 459:
## Known stack suffix:
## maybe_pragma_light
## LR(1) items:
file -> maybe_pragma_light . moduleList [ # ]
## Transitions:
-- On MODULE shift to state 460
-- On EOF shift to state 475
-- On moduleList shift to state 476
-- On modul shift to state 477
## Reductions:

State 460:
## Known stack suffix:
## MODULE
## LR(1) items:
modul -> MODULE . qname decls endopt [ MODULE EOF ]
## Transitions:
-- On NAME shift to state 3
-- On qname shift to state 461
-- On namepath shift to state 64
-- On name shift to state 65
## Reductions:

State 461:
## Known stack suffix:
## MODULE qname
## LR(1) items:
modul -> MODULE qname . decls endopt [ MODULE EOF ]
## Transitions:
-- On TOTAL shift to state 1
-- On SUB_EFFECT shift to state 2
-- On SEMICOLON_SEMICOLON shift to state 462
-- On PRIVATE shift to state 357
-- On PRAGMA_SET_OPTIONS shift to state 358
-- On PRAGMA_RESET_OPTIONS shift to state 360
-- On OPEN shift to state 363
-- On OPAQUE shift to state 365
-- On LOGIC shift to state 366
-- On LET shift to state 367
-- On KIND shift to state 371
-- On EXCEPTION shift to state 377
-- On DEFAULT shift to state 382
-- On ASSUME shift to state 383
-- On tycon shift to state 384
-- On qualifiers shift to state 385
-- On qualifier shift to state 455
-- On pragma shift to state 458
-- On kind_abbrev shift to state 464
-- On decls shift to state 465
-- On decl2 shift to state 468
-- On decl shift to state 469
-- On assumeTag shift to state 471
## Reductions:
-- On MODULE EOF END
--   reduce production decls ->
-- On VAL TYPE NEW_EFFECT EFFECT
--   reduce production qualifiers ->

State 462:
## Known stack suffix:
## SEMICOLON_SEMICOLON
## LR(1) items:
decls -> SEMICOLON_SEMICOLON . term [ MODULE EOF END ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On term shift to state 463
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 269
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 463:
## Known stack suffix:
## SEMICOLON_SEMICOLON term
## LR(1) items:
decls -> SEMICOLON_SEMICOLON term . [ MODULE EOF END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decls -> SEMICOLON_SEMICOLON term

State 464:
## Known stack suffix:
## kind_abbrev
## LR(1) items:
decl2 -> kind_abbrev . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> kind_abbrev

State 465:
## Known stack suffix:
## MODULE qname decls
## LR(1) items:
modul -> MODULE qname decls . endopt [ MODULE EOF ]
## Transitions:
-- On END shift to state 466
-- On endopt shift to state 467
## Reductions:
-- On MODULE EOF
--   reduce production endopt ->

State 466:
## Known stack suffix:
## END
## LR(1) items:
endopt -> END . [ MODULE EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production endopt -> END

State 467:
## Known stack suffix:
## MODULE qname decls endopt
## LR(1) items:
modul -> MODULE qname decls endopt . [ MODULE EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modul -> MODULE qname decls endopt

State 468:
## Known stack suffix:
## decl2
## LR(1) items:
decl -> decl2 . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl -> decl2

State 469:
## Known stack suffix:
## decl
## LR(1) items:
decls -> decl . decls [ MODULE EOF END ]
## Transitions:
-- On TOTAL shift to state 1
-- On SUB_EFFECT shift to state 2
-- On SEMICOLON_SEMICOLON shift to state 462
-- On PRIVATE shift to state 357
-- On PRAGMA_SET_OPTIONS shift to state 358
-- On PRAGMA_RESET_OPTIONS shift to state 360
-- On OPEN shift to state 363
-- On OPAQUE shift to state 365
-- On LOGIC shift to state 366
-- On LET shift to state 367
-- On KIND shift to state 371
-- On EXCEPTION shift to state 377
-- On DEFAULT shift to state 382
-- On ASSUME shift to state 383
-- On tycon shift to state 384
-- On qualifiers shift to state 385
-- On qualifier shift to state 455
-- On pragma shift to state 458
-- On kind_abbrev shift to state 464
-- On decls shift to state 470
-- On decl2 shift to state 468
-- On decl shift to state 469
-- On assumeTag shift to state 471
## Reductions:
-- On MODULE EOF END
--   reduce production decls ->
-- On VAL TYPE NEW_EFFECT EFFECT
--   reduce production qualifiers ->

State 470:
## Known stack suffix:
## decl decls
## LR(1) items:
decls -> decl decls . [ MODULE EOF END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decls -> decl decls

State 471:
## Known stack suffix:
## assumeTag
## LR(1) items:
decl2 -> assumeTag . name COLON formula [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On NAME shift to state 3
-- On name shift to state 472
## Reductions:

State 472:
## Known stack suffix:
## assumeTag name
## LR(1) items:
decl2 -> assumeTag name . COLON formula [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On COLON shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## assumeTag name COLON
## LR(1) items:
decl2 -> assumeTag name COLON . formula [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
-- On UNDERSCORE shift to state 9
-- On UINT8 shift to state 10
-- On TVAR shift to state 11
-- On TRY shift to state 16
-- On TRUE shift to state 12
-- On TILDE shift to state 13
-- On STRING shift to state 14
-- On REQUIRES shift to state 17
-- On PLUS_OP shift to state 21
-- On PERCENT_LBRACK shift to state 15
-- On NAME shift to state 3
-- On MINUS_OP shift to state 24
-- On MATCH shift to state 27
-- On LPAREN_RPAREN shift to state 22
-- On LPAREN shift to state 23
-- On LET shift to state 28
-- On LENS_PAREN_LEFT shift to state 25
-- On LBRACK_BAR shift to state 26
-- On LBRACK shift to state 103
-- On LBRACE shift to state 104
-- On INT64 shift to state 45
-- On INT32 shift to state 46
-- On INT shift to state 47
-- On IF shift to state 106
-- On IEEE64 shift to state 48
-- On IDENT shift to state 36
-- On HASH shift to state 107
-- On FUNCTION shift to state 108
-- On FUN shift to state 158
-- On FORALL shift to state 163
-- On FALSE shift to state 51
-- On EXISTS shift to state 170
-- On EQUALS shift to state 183
-- On ENSURES shift to state 184
-- On CHAR shift to state 52
-- On BYTEARRAY shift to state 53
-- On BEGIN shift to state 105
-- On BANG_LBRACE shift to state 116
-- On BANG shift to state 117
-- On ASSUME shift to state 196
-- On ASSERT shift to state 118
-- On unaryTerm shift to state 186
-- On typ shift to state 198
-- On tvar shift to state 119
-- On tupleN shift to state 199
-- On tmTuple shift to state 200
-- On tmOr shift to state 201
-- On tmImplies shift to state 232
-- On tmIff shift to state 249
-- On tmEq shift to state 235
-- On tmDisjunction shift to state 241
-- On tmCons shift to state 203
-- On tmConjunction shift to state 244
-- On tmAnd shift to state 238
-- On starDivModTerm shift to state 206
-- On simpleTerm shift to state 250
-- On refinementTerm shift to state 189
-- On projectionLHS shift to state 120
-- On productDomain shift to state 207
-- On product shift to state 223
-- On plusOp shift to state 210
-- On noSeqTerm shift to state 251
-- On name shift to state 124
-- On minusOp shift to state 211
-- On ident shift to state 192
-- On formula shift to state 474
-- On eitherpath shift to state 129
-- On eitherQname shift to state 130
-- On dtupleTerm shift to state 217
-- On constant shift to state 134
-- On cmpTerm shift to state 231
-- On atomicTerm shift to state 142
-- On arithTerm shift to state 218
-- On aqual shift to state 221
-- On appTerm shift to state 214
## Reductions:

State 474:
## Known stack suffix:
## assumeTag name COLON formula
## LR(1) items:
decl2 -> assumeTag name COLON formula . [ VAL TYPE TOTAL SUB_EFFECT SEMICOLON_SEMICOLON PRIVATE PRAGMA_SET_OPTIONS PRAGMA_RESET_OPTIONS OPEN OPAQUE NEW_EFFECT MODULE LOGIC LET KIND EXCEPTION EOF END EFFECT DEFAULT ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl2 -> assumeTag name COLON formula

State 475:
## Known stack suffix:
## EOF
## LR(1) items:
moduleList -> EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production moduleList -> EOF

State 476:
## Known stack suffix:
## maybe_pragma_light moduleList
## LR(1) items:
file -> maybe_pragma_light moduleList . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production file -> maybe_pragma_light moduleList

State 477:
## Known stack suffix:
## modul
## LR(1) items:
moduleList -> modul . moduleList [ # ]
## Transitions:
-- On MODULE shift to state 460
-- On EOF shift to state 475
-- On moduleList shift to state 478
-- On modul shift to state 477
## Reductions:

State 478:
## Known stack suffix:
## modul moduleList
## LR(1) items:
moduleList -> modul moduleList . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production moduleList -> modul moduleList

State 479:
## Known stack suffix:
## inputFragment
## LR(1) items:
inputFragment' -> inputFragment . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept inputFragment

State 480:
## Known stack suffix:
## file
## LR(1) items:
inputFragment -> file . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production inputFragment -> file

State 481:
## Known stack suffix:
## decl
## LR(1) items:
inputFragment -> decl . decls EOF [ # ]
## Transitions:
-- On TOTAL shift to state 1
-- On SUB_EFFECT shift to state 2
-- On SEMICOLON_SEMICOLON shift to state 462
-- On PRIVATE shift to state 357
-- On PRAGMA_SET_OPTIONS shift to state 358
-- On PRAGMA_RESET_OPTIONS shift to state 360
-- On OPEN shift to state 363
-- On OPAQUE shift to state 365
-- On LOGIC shift to state 366
-- On LET shift to state 367
-- On KIND shift to state 371
-- On EXCEPTION shift to state 377
-- On DEFAULT shift to state 382
-- On ASSUME shift to state 383
-- On tycon shift to state 384
-- On qualifiers shift to state 385
-- On qualifier shift to state 455
-- On pragma shift to state 458
-- On kind_abbrev shift to state 464
-- On decls shift to state 482
-- On decl2 shift to state 468
-- On decl shift to state 469
-- On assumeTag shift to state 471
## Reductions:
-- On EOF
--   reduce production decls ->
-- On VAL TYPE NEW_EFFECT EFFECT
--   reduce production qualifiers ->

State 482:
## Known stack suffix:
## decl decls
## LR(1) items:
inputFragment -> decl decls . EOF [ # ]
## Transitions:
-- On EOF shift to state 483
## Reductions:

State 483:
## Known stack suffix:
## decl decls EOF
## LR(1) items:
inputFragment -> decl decls EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production inputFragment -> decl decls EOF

