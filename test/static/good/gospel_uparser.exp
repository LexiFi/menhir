Grammar has 102 nonterminal symbols, among which 5 start symbols.
Grammar has 79 terminal symbols.
Grammar has 257 productions.
nullable(val_spec_header) = false
nullable(val_spec_body) = true
nullable(val_spec) = false
nullable(uqualid) = false
nullable(uident) = false
nullable(type_spec_model) = false
nullable(type_spec) = false
nullable(typ) = false
nullable(ty_tuple) = false
nullable(ty_arg) = false
nullable(triggers) = true
nullable(term_sub_) = false
nullable(term_rec_field(term)) = false
nullable(term_dot_) = false
nullable(term_dot) = false
nullable(term_block_) = false
nullable(term_arg_) = false
nullable(term_arg) = false
nullable(term_) = false
nullable(term) = false
nullable(separated_nonempty_list(COMMA,typ)) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,ret_value)) = false
nullable(separated_nonempty_list(COMMA,quant_vars)) = false
nullable(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = false
nullable(separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))) = false
nullable(separated_nonempty_list(BAR,raises)) = false
nullable(separated_nonempty_list(BAR,comma_list1(term))) = false
nullable(semicolon_list1(term_rec_field(term))) = false
nullable(semicolon_list1(pattern_rec_field(pattern))) = false
nullable(ret_value) = false
nullable(ret_name) = false
nullable(raises) = false
nullable(quote_lident) = false
nullable(quant_vars) = false
nullable(quant) = false
nullable(qualid) = false
nullable(prefix_op) = false
nullable(pattern_rec_field(pattern)) = false
nullable(pattern_) = false
nullable(pattern) = false
nullable(pat_uni_) = false
nullable(pat_conj_) = false
nullable(pat_arg_shared_) = false
nullable(pat_arg_) = false
nullable(pat_arg) = false
nullable(params) = false
nullable(param) = false
nullable(option(preceded(EQUAL,term))) = true
nullable(option(cast)) = true
nullable(option(UNDERSCORE)) = true
nullable(op_symbol) = false
nullable(nonempty_type_spec) = false
nullable(nonempty_list(pat_arg)) = false
nullable(nonempty_list(located(term_arg))) = false
nullable(nonempty_list(lident)) = false
nullable(nonempty_list(binder_var)) = false
nullable(nonempty_func_spec) = false
nullable(mk_term(term_dot_)) = false
nullable(mk_term(term_block_)) = false
nullable(mk_term(term_arg_)) = false
nullable(mk_term(term_)) = false
nullable(mk_pat(pattern_)) = false
nullable(mk_pat(pat_uni_)) = false
nullable(mk_pat(pat_conj_)) = false
nullable(mk_pat(pat_arg_)) = false
nullable(match_cases(term)) = false
nullable(lqualid_rich) = false
nullable(lqualid) = false
nullable(loption(separated_nonempty_list(COMMA,term))) = true
nullable(loption(params)) = true
nullable(located(term_arg)) = false
nullable(list(fun_arg)) = true
nullable(list(attr)) = true
nullable(lident_rich) = false
nullable(lident_op_id) = false
nullable(lident_op) = false
nullable(lident) = false
nullable(ident_rich) = false
nullable(func_spec) = false
nullable(func_name) = false
nullable(func) = false
nullable(fun_arg) = false
nullable(field_pattern(pattern)) = false
nullable(field_list1(term)) = false
nullable(constant) = false
nullable(comma_list2(term)) = false
nullable(comma_list2(mk_pat(pat_uni_))) = false
nullable(comma_list1(term)) = false
nullable(comma_list1(quant_vars)) = false
nullable(comma_list1(mk_pat(pat_uni_))) = false
nullable(comma_list(ret_value)) = false
nullable(cast) = false
nullable(boption(REC)) = true
nullable(boption(MUTABLE)) = true
nullable(binder_var) = false
nullable(bar_list1(separated_pair(pattern,ARROW,term))) = false
nullable(bar_list1(raises)) = false
nullable(axiom) = false
nullable(attrs(lident_op_id)) = false
nullable(attrs(lident)) = false
nullable(attr) = false
first(val_spec_header) = LIDENT LEFTSQ LEFTPAR
first(val_spec_body) = REQUIRES RAISES PURE MODIFIES EQUIVALENT ENSURES DIVERGES CONSUMES CHECKS
first(val_spec) = LIDENT LEFTSQ LEFTPAR
first(uqualid) = UIDENT
first(uident) = UIDENT
first(type_spec_model) = MUTABLE MODEL
first(type_spec) = MUTABLE MODEL INVARIANT EPHEMERAL EOF
first(typ) = UIDENT QUOTE_LIDENT QUESTION LIDENT LEFTPAR
first(ty_tuple) = UIDENT QUOTE_LIDENT LIDENT LEFTPAR
first(ty_arg) = UIDENT QUOTE_LIDENT LIDENT LEFTPAR
first(triggers) = LEFTSQ
first(term_sub_) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(term_rec_field(term)) = UIDENT LIDENT
first(term_dot_) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(term_dot) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(term_block_) = LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC
first(term_arg_) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(term_arg) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(term_) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(term) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(separated_nonempty_list(COMMA,typ)) = UIDENT QUOTE_LIDENT QUESTION LIDENT LEFTPAR
first(separated_nonempty_list(COMMA,term)) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(separated_nonempty_list(COMMA,ret_value)) = LIDENT LEFTSQ
first(separated_nonempty_list(COMMA,quant_vars)) = LIDENT
first(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(separated_nonempty_list(BAR,raises)) = UIDENT
first(separated_nonempty_list(BAR,comma_list1(term))) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(semicolon_list1(term_rec_field(term))) = UIDENT LIDENT
first(semicolon_list1(pattern_rec_field(pattern))) = UIDENT LIDENT
first(ret_value) = LIDENT LEFTSQ
first(ret_name) = LIDENT LEFTSQ LEFTPAR
first(raises) = UIDENT
first(quote_lident) = QUOTE_LIDENT
first(quant_vars) = LIDENT
first(quant) = FORALL EXISTS
first(qualid) = UIDENT LIDENT LEFTPAR
first(prefix_op) = STAR OP4 OP3 OP2 OP1
first(pattern_rec_field(pattern)) = UIDENT LIDENT
first(pattern_) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pattern) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pat_uni_) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pat_conj_) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pat_arg_shared_) = UNDERSCORE UIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pat_arg_) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(pat_arg) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(params) = LEFTPAR
first(param) = LEFTPAR
first(option(preceded(EQUAL,term))) = EQUAL
first(option(cast)) = COLON
first(option(UNDERSCORE)) = UNDERSCORE
first(op_symbol) = STAR OP4 OP3 OP2 OP1
first(nonempty_type_spec) = MUTABLE MODEL INVARIANT EPHEMERAL
first(nonempty_list(pat_arg)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(nonempty_list(located(term_arg))) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(nonempty_list(lident)) = LIDENT
first(nonempty_list(binder_var)) = LIDENT
first(nonempty_func_spec) = VARIANT REQUIRES ENSURES COERCION
first(mk_term(term_dot_)) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(mk_term(term_block_)) = LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC
first(mk_term(term_arg_)) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(mk_term(term_)) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(mk_pat(pattern_)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(mk_pat(pat_uni_)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(mk_pat(pat_conj_)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(mk_pat(pat_arg_)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(match_cases(term)) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC BAR
first(lqualid_rich) = UIDENT LIDENT LEFTPAR
first(lqualid) = UIDENT LIDENT
first(loption(separated_nonempty_list(COMMA,term))) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(loption(params)) = LEFTPAR
first(located(term_arg)) = UIDENT TRUE STRING OPPREF LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER FLOAT FALSE CHAR
first(list(fun_arg)) = TILDE QUESTION LIDENT LEFTSQ LEFTPAR
first(list(attr)) = ATTRIBUTE
first(lident_rich) = LIDENT LEFTPAR
first(lident_op_id) = LEFTPAR
first(lident_op) = STAR OPPREF OP4 OP3 OP2 OP1 LEFTSQ EQUAL DOT
first(lident) = LIDENT
first(ident_rich) = UIDENT LIDENT LEFTPAR
first(func_spec) = VARIANT REQUIRES EOF ENSURES COERCION
first(func_name) = LIDENT LEFTPAR
first(func) = PREDICATE FUNCTION
first(fun_arg) = TILDE QUESTION LIDENT LEFTSQ LEFTPAR
first(field_pattern(pattern)) = UIDENT LIDENT
first(field_list1(term)) = UIDENT LIDENT
first(constant) = STRING INTEGER FLOAT CHAR
first(comma_list2(term)) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(comma_list2(mk_pat(pat_uni_))) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(comma_list1(term)) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
first(comma_list1(quant_vars)) = LIDENT
first(comma_list1(mk_pat(pat_uni_))) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC
first(comma_list(ret_value)) = LIDENT LEFTSQ
first(cast) = COLON
first(boption(REC)) = REC
first(boption(MUTABLE)) = MUTABLE
first(binder_var) = LIDENT
first(bar_list1(separated_pair(pattern,ARROW,term))) = UNDERSCORE UIDENT LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC BAR
first(bar_list1(raises)) = UIDENT BAR
first(axiom) = AXIOM
first(attrs(lident_op_id)) = LEFTPAR
first(attrs(lident)) = LIDENT
first(attr) = ATTRIBUTE
minimal(val_spec_header) = (* 1 *) LIDENT
minimal(val_spec_body) = (* 0 *)
minimal(val_spec) = (* 2 *) LIDENT EOF
minimal(uqualid) = (* 1 *) UIDENT
minimal(uident) = (* 1 *) UIDENT
minimal(type_spec_model) = (* 4 *) MODEL LIDENT COLON LIDENT
minimal(type_spec) = (* 1 *) EOF
minimal(typ) = (* 1 *) LIDENT
minimal(ty_tuple) = (* 1 *) LIDENT
minimal(ty_arg) = (* 1 *) LIDENT
minimal(triggers) = (* 0 *)
minimal(term_sub_) = (* 1 *) LEFTSQRIGHTSQ
minimal(term_rec_field(term)) = (* 1 *) LIDENT
minimal(term_dot_) = (* 1 *) LIDENT
minimal(term_dot) = (* 1 *) LIDENT
minimal(term_block_) = (* 1 *) LEFTSQRIGHTSQ
minimal(term_arg_) = (* 1 *) UIDENT
minimal(term_arg) = (* 1 *) UIDENT
minimal(term_) = (* 1 *) UIDENT
minimal(term) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,typ)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,ret_value)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,quant_vars)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(separated_nonempty_list(BAR,raises)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(BAR,comma_list1(term))) = (* 1 *) UIDENT
minimal(semicolon_list1(term_rec_field(term))) = (* 1 *) LIDENT
minimal(semicolon_list1(pattern_rec_field(pattern))) = (* 1 *) LIDENT
minimal(ret_value) = (* 1 *) LIDENT
minimal(ret_name) = (* 2 *) LIDENT EQUAL
minimal(raises) = (* 1 *) UIDENT
minimal(quote_lident) = (* 1 *) QUOTE_LIDENT
minimal(quant_vars) = (* 1 *) LIDENT
minimal(quant) = (* 1 *) FORALL
minimal(qualid) = (* 1 *) UIDENT
minimal(prefix_op) = (* 1 *) OP1
minimal(pattern_rec_field(pattern)) = (* 1 *) LIDENT
minimal(pattern_) = (* 1 *) UNDERSCORE
minimal(pattern) = (* 1 *) UNDERSCORE
minimal(pat_uni_) = (* 1 *) UNDERSCORE
minimal(pat_conj_) = (* 1 *) UNDERSCORE
minimal(pat_arg_shared_) = (* 1 *) UNDERSCORE
minimal(pat_arg_) = (* 1 *) UNDERSCORE
minimal(pat_arg) = (* 1 *) UNDERSCORE
minimal(params) = (* 5 *) LEFTPAR LIDENT COLON LIDENT RIGHTPAR
minimal(param) = (* 5 *) LEFTPAR LIDENT COLON LIDENT RIGHTPAR
minimal(option(preceded(EQUAL,term))) = (* 0 *)
minimal(option(cast)) = (* 0 *)
minimal(option(UNDERSCORE)) = (* 0 *)
minimal(op_symbol) = (* 1 *) OP1
minimal(nonempty_type_spec) = (* 2 *) EPHEMERAL EOF
minimal(nonempty_list(pat_arg)) = (* 1 *) UNDERSCORE
minimal(nonempty_list(located(term_arg))) = (* 1 *) UIDENT
minimal(nonempty_list(lident)) = (* 1 *) LIDENT
minimal(nonempty_list(binder_var)) = (* 1 *) LIDENT
minimal(nonempty_func_spec) = (* 2 *) COERCION EOF
minimal(mk_term(term_dot_)) = (* 1 *) LIDENT
minimal(mk_term(term_block_)) = (* 1 *) LEFTSQRIGHTSQ
minimal(mk_term(term_arg_)) = (* 1 *) UIDENT
minimal(mk_term(term_)) = (* 1 *) UIDENT
minimal(mk_pat(pattern_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_uni_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_conj_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_arg_)) = (* 1 *) UNDERSCORE
minimal(match_cases(term)) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(lqualid_rich) = (* 1 *) LIDENT
minimal(lqualid) = (* 1 *) LIDENT
minimal(loption(separated_nonempty_list(COMMA,term))) = (* 0 *)
minimal(loption(params)) = (* 0 *)
minimal(located(term_arg)) = (* 1 *) UIDENT
minimal(list(fun_arg)) = (* 0 *)
minimal(list(attr)) = (* 0 *)
minimal(lident_rich) = (* 1 *) LIDENT
minimal(lident_op_id) = (* 3 *) LEFTPAR OP1 RIGHTPAR
minimal(lident_op) = (* 1 *) OP1
minimal(lident) = (* 1 *) LIDENT
minimal(ident_rich) = (* 1 *) UIDENT
minimal(func_spec) = (* 1 *) EOF
minimal(func_name) = (* 1 *) LIDENT
minimal(func) = (* 5 *) FUNCTION LIDENT COLON LIDENT EOF
minimal(fun_arg) = (* 1 *) LIDENT
minimal(field_pattern(pattern)) = (* 1 *) LIDENT
minimal(field_list1(term)) = (* 1 *) LIDENT
minimal(constant) = (* 1 *) INTEGER
minimal(comma_list2(term)) = (* 3 *) UIDENT COMMA UIDENT
minimal(comma_list2(mk_pat(pat_uni_))) = (* 3 *) UNDERSCORE COMMA UNDERSCORE
minimal(comma_list1(term)) = (* 1 *) UIDENT
minimal(comma_list1(quant_vars)) = (* 1 *) LIDENT
minimal(comma_list1(mk_pat(pat_uni_))) = (* 1 *) UNDERSCORE
minimal(comma_list(ret_value)) = (* 1 *) LIDENT
minimal(cast) = (* 2 *) COLON LIDENT
minimal(boption(REC)) = (* 0 *)
minimal(boption(MUTABLE)) = (* 0 *)
minimal(binder_var) = (* 1 *) LIDENT
minimal(bar_list1(separated_pair(pattern,ARROW,term))) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(bar_list1(raises)) = (* 1 *) UIDENT
minimal(axiom) = (* 5 *) AXIOM LIDENT COLON UIDENT EOF
minimal(attrs(lident_op_id)) = (* 3 *) LEFTPAR OP1 RIGHTPAR
minimal(attrs(lident)) = (* 1 *) LIDENT
minimal(attr) = (* 1 *) ATTRIBUTE
follow(val_spec_header) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(val_spec_body) = EOF
follow(val_spec) = #
follow(uqualid) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC REQUIRES RAISES PURE MODIFIES LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC EQUIVALENT EQUAL EOF ENSURES DOT DIVERGES CONSUMES COMMA COLONCOLON COLON CHECKS BAR AS ARROW
follow(uident) = WITH VARIANT UNDERSCORE UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT AS ARROW AND AMPAMP
follow(type_spec_model) = MUTABLE MODEL INVARIANT EPHEMERAL EOF
follow(type_spec) = EOF #
follow(typ) = RIGHTSQ RIGHTPAR MUTABLE MODEL INVARIANT EQUAL EPHEMERAL EOF COMMA ARROW
follow(ty_tuple) = RIGHTSQ RIGHTPAR MUTABLE MODEL INVARIANT EQUAL EPHEMERAL EOF COMMA ARROW
follow(ty_arg) = WITH VARIANT UIDENT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQ LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT AS ARROW AND AMPAMP
follow(triggers) = DOT
follow(term_sub_) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(term_rec_field(term)) = SEMICOLON RIGHTBRC
follow(term_dot_) = DOT
follow(term_dot) = DOT
follow(term_block_) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(term_arg_) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(term_arg) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(term_) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(term) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(separated_nonempty_list(COMMA,typ)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,term)) = WITH RIGHTSQ RIGHTPAR REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS BAR
follow(separated_nonempty_list(COMMA,ret_value)) = RIGHTPAR EQUAL
follow(separated_nonempty_list(COMMA,quant_vars)) = LEFTSQ DOT
follow(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(separated_nonempty_list(BAR,raises)) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(separated_nonempty_list(BAR,comma_list1(term))) = RIGHTSQ
follow(semicolon_list1(term_rec_field(term))) = RIGHTBRC
follow(semicolon_list1(pattern_rec_field(pattern))) = RIGHTBRC
follow(ret_value) = RIGHTPAR EQUAL COMMA
follow(ret_name) = LIDENT LEFTPAR
follow(raises) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS BAR
follow(quote_lident) = WITH VARIANT UIDENT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQ LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT AS ARROW AND AMPAMP
follow(quant_vars) = LEFTSQ DOT COMMA ARROW
follow(quant) = LIDENT
follow(qualid) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(prefix_op) = UIDENT TRUE STRING STAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
follow(pattern_rec_field(pattern)) = SEMICOLON RIGHTBRC
follow(pattern_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(pattern) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(pat_uni_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(pat_conj_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(pat_arg_shared_) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC EQUAL COMMA COLONCOLON COLON BAR AS ARROW
follow(pat_arg_) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC EQUAL COMMA COLONCOLON COLON BAR AS ARROW
follow(pat_arg) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC EQUAL COMMA COLONCOLON COLON BAR AS ARROW
follow(params) = EQUAL EOF COLON
follow(param) = LEFTPAR EQUAL EOF COLON
follow(option(preceded(EQUAL,term))) = EOF
follow(option(cast)) = LEFTSQ DOT COMMA ARROW
follow(option(UNDERSCORE)) = RIGHTPAR
follow(op_symbol) = UNDERSCORE UIDENT TRUE STRING STAR RIGHTPAR OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS CHAR ATTRIBUTE
follow(nonempty_type_spec) = EOF
follow(nonempty_list(pat_arg)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(nonempty_list(located(term_arg))) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(nonempty_list(lident)) = COLON
follow(nonempty_list(binder_var)) = LEFTSQ DOT COMMA COLON ARROW
follow(nonempty_func_spec) = EOF
follow(mk_term(term_dot_)) = DOT
follow(mk_term(term_block_)) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(mk_term(term_arg_)) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(mk_term(term_)) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(mk_pat(pattern_)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(mk_pat(pat_uni_)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(mk_pat(pat_conj_)) = BAR
follow(mk_pat(pat_arg_)) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRC EQUAL COMMA COLONCOLON COLON BAR AS ARROW
follow(match_cases(term)) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(lqualid_rich) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(lqualid) = WITH VARIANT UIDENT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQ LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT AS ARROW AND AMPAMP
follow(loption(separated_nonempty_list(COMMA,term))) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(loption(params)) = COLON
follow(located(term_arg)) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(list(fun_arg)) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(list(attr)) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRC EQUAL DOT COMMA COLONCOLON COLON BAR AS ARROW
follow(lident_rich) = WITH VARIANT UIDENT TRUE TILDE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES QUESTION PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(lident_op_id) = WITH VARIANT UIDENT TRUE TILDE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES QUESTION PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ATTRIBUTE ARROW AND AMPAMP
follow(lident_op) = RIGHTPAR
follow(lident) = WITH VARIANT UNDERSCORE UIDENT TRUE TILDE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES QUESTION PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ATTRIBUTE AS ARROW AND AMPAMP
follow(ident_rich) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(func_spec) = EOF #
follow(func_name) = LEFTPAR COLON
follow(func) = #
follow(fun_arg) = TILDE REQUIRES RAISES QUESTION PURE MODIFIES LIDENT LEFTSQ LEFTPAR EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(field_pattern(pattern)) = RIGHTBRC
follow(field_list1(term)) = RIGHTBRC
follow(constant) = WITH VARIANT UIDENT TRUE THEN STRING STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OPPREF OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC LARROW INVARIANT INTEGER IN FLOAT FALSE EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS CHAR BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(comma_list2(term)) = WITH RIGHTPAR
follow(comma_list2(mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(comma_list1(term)) = WITH RIGHTSQ RIGHTPAR BAR
follow(comma_list1(quant_vars)) = LEFTSQ DOT
follow(comma_list1(mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(comma_list(ret_value)) = RIGHTPAR EQUAL
follow(cast) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LEFTSQ LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT AS ARROW AND AMPAMP
follow(boption(REC)) = LIDENT LEFTPAR
follow(boption(MUTABLE)) = MODEL
follow(binder_var) = LIDENT LEFTSQ DOT COMMA COLON ARROW
follow(bar_list1(separated_pair(pattern,ARROW,term))) = WITH VARIANT THEN STAR SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REQUIRES RAISES PURE OR OP4 OP3 OP2 OP1 MUTABLE MODIFIES MODEL LTGT LRARROW LARROW INVARIANT IN EQUIVALENT EQUAL EPHEMERAL EOF ENSURES ELSE DOTDOT DIVERGES CONSUMES COMMA COLONRIGHTBRC COLONCOLON COLON COERCION CHECKS BARBAR BAR BACKQUOTE_LIDENT ARROW AND AMPAMP
follow(bar_list1(raises)) = REQUIRES RAISES PURE MODIFIES EQUIVALENT EOF ENSURES DIVERGES CONSUMES CHECKS
follow(axiom) = #
follow(attrs(lident_op_id)) = EQUAL
follow(attrs(lident)) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC LIDENT LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRC EQUAL DOT COMMA COLONCOLON COLON BAR AS ARROW
follow(attr) = UNDERSCORE UIDENT TRUE STRING STAR SEMICOLON RIGHTPAR RIGHTBRC OPPREF OP4 OP3 OP2 OP1 OLD NOT MATCH LIDENT LET LEFTSQRIGHTSQ LEFTSQ LEFTPAR LEFTBRCRIGHTBRC LEFTBRCCOLON LEFTBRC INTEGER IF FUN FORALL FLOAT FALSE EXISTS EQUAL DOT COMMA COLONCOLON COLON CHAR BAR ATTRIBUTE AS ARROW
Built an LR(0) automaton with 490 states.
The grammar is not SLR(1) -- 40 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 500 states.
408 shift/reduce conflicts were silently solved.
191 out of 500 states have a default reduction.
231 out of 500 states are represented.
83 out of 188 symbols keep track of their start position.
86 out of 188 symbols keep track of their end position.
The action table is 40000 entries; 4627 non-zero; 3945 compressed.
The action table occupies roughly 7984 bytes.
The goto table is 53500 entries; 2076 non-zero; 4167 compressed.
The goto table occupies roughly 8424 bytes.
The error table occupies roughly 5032 bytes.
The default_reduction table occupies roughly 1032 bytes.
The lhs table occupies roughly 296 bytes.
The trace table occupies roughly 8 bytes.
