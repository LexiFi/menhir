State 0:
constr' -> . constr [ # ]
-- On OBSERVED shift to state 1
-- On NOT shift to state 56
-- On LPAR shift to state 73
-- On FORALL shift to state 76
-- On FINAL shift to state 78
-- On EXISTS shift to state 80
-- On constr shift to state 82
-- On # reduce production constr ->
** End-of-stream conflict on OBSERVED NOT LPAR FORALL FINAL EXISTS
**   There is a tension between
**   (1) reducing production constr ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 1:
constr -> OBSERVED . obs [ # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On obsone shift to state 26
-- On obs shift to state 55
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 52
-- On TOKAND reduce production obsone ->
-- On # reduce production obsone ->
** End-of-stream conflict on TOKAND SYMB_REG PROC NUM NAME LBRK
**   There is a tension between
**   (1) reducing production obsone ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 2:
location_reg -> SYMB_REG . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production location_reg -> SYMB_REG
-- On SYMB_REG reduce production location_reg -> SYMB_REG
-- On STAR reduce production location_reg -> SYMB_REG
-- On SEMI reduce production location_reg -> SYMB_REG
-- On RPAR reduce production location_reg -> SYMB_REG
-- On RBRK reduce production location_reg -> SYMB_REG
-- On PROC reduce production location_reg -> SYMB_REG
-- On OR reduce production location_reg -> SYMB_REG
-- On OBSERVED reduce production location_reg -> SYMB_REG
-- On NUM reduce production location_reg -> SYMB_REG
-- On NOTEQUAL reduce production location_reg -> SYMB_REG
-- On NOT reduce production location_reg -> SYMB_REG
-- On NAME reduce production location_reg -> SYMB_REG
-- On LPAR reduce production location_reg -> SYMB_REG
-- On LBRK reduce production location_reg -> SYMB_REG
-- On IMPLIES reduce production location_reg -> SYMB_REG
-- On FORALL reduce production location_reg -> SYMB_REG
-- On FINAL reduce production location_reg -> SYMB_REG
-- On EXISTS reduce production location_reg -> SYMB_REG
-- On EQUALEQUAL reduce production location_reg -> SYMB_REG
-- On EQUAL reduce production location_reg -> SYMB_REG
-- On EOF reduce production location_reg -> SYMB_REG
-- On AND reduce production location_reg -> SYMB_REG
-- On # reduce production location_reg -> SYMB_REG
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production location_reg -> SYMB_REG
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 3:
location_reg -> PROC . COLON reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
location_reg -> PROC . COLON PTX_REG_DEC PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On COLON shift to state 4

State 4:
location_reg -> PROC COLON . reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
location_reg -> PROC COLON . PTX_REG_DEC PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On PTX_REG_DEC shift to state 5
-- On NAME shift to state 7
-- On DOLLARNAME shift to state 8
-- On reg shift to state 10

State 5:
location_reg -> PROC COLON PTX_REG_DEC . PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On PTX_REG_TYPE shift to state 6

State 6:
location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE . reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On NAME shift to state 7
-- On DOLLARNAME shift to state 8
-- On reg shift to state 9

State 7:
reg -> NAME . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production reg -> NAME
-- On SYMB_REG reduce production reg -> NAME
-- On STAR reduce production reg -> NAME
-- On SEMI reduce production reg -> NAME
-- On RPAR reduce production reg -> NAME
-- On RBRK reduce production reg -> NAME
-- On PROC reduce production reg -> NAME
-- On OR reduce production reg -> NAME
-- On OBSERVED reduce production reg -> NAME
-- On NUM reduce production reg -> NAME
-- On NOTEQUAL reduce production reg -> NAME
-- On NOT reduce production reg -> NAME
-- On NAME reduce production reg -> NAME
-- On LPAR reduce production reg -> NAME
-- On LBRK reduce production reg -> NAME
-- On IMPLIES reduce production reg -> NAME
-- On FORALL reduce production reg -> NAME
-- On FINAL reduce production reg -> NAME
-- On EXISTS reduce production reg -> NAME
-- On EQUALEQUAL reduce production reg -> NAME
-- On EQUAL reduce production reg -> NAME
-- On EOF reduce production reg -> NAME
-- On AND reduce production reg -> NAME
-- On # reduce production reg -> NAME
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production reg -> NAME
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 8:
reg -> DOLLARNAME . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production reg -> DOLLARNAME
-- On SYMB_REG reduce production reg -> DOLLARNAME
-- On STAR reduce production reg -> DOLLARNAME
-- On SEMI reduce production reg -> DOLLARNAME
-- On RPAR reduce production reg -> DOLLARNAME
-- On RBRK reduce production reg -> DOLLARNAME
-- On PROC reduce production reg -> DOLLARNAME
-- On OR reduce production reg -> DOLLARNAME
-- On OBSERVED reduce production reg -> DOLLARNAME
-- On NUM reduce production reg -> DOLLARNAME
-- On NOTEQUAL reduce production reg -> DOLLARNAME
-- On NOT reduce production reg -> DOLLARNAME
-- On NAME reduce production reg -> DOLLARNAME
-- On LPAR reduce production reg -> DOLLARNAME
-- On LBRK reduce production reg -> DOLLARNAME
-- On IMPLIES reduce production reg -> DOLLARNAME
-- On FORALL reduce production reg -> DOLLARNAME
-- On FINAL reduce production reg -> DOLLARNAME
-- On EXISTS reduce production reg -> DOLLARNAME
-- On EQUALEQUAL reduce production reg -> DOLLARNAME
-- On EQUAL reduce production reg -> DOLLARNAME
-- On EOF reduce production reg -> DOLLARNAME
-- On AND reduce production reg -> DOLLARNAME
-- On # reduce production reg -> DOLLARNAME
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production reg -> DOLLARNAME
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 9:
location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On SYMB_REG reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On STAR reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On SEMI reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On RPAR reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On RBRK reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On PROC reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On OR reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On OBSERVED reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NUM reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NOTEQUAL reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NOT reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NAME reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On LPAR reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On LBRK reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On IMPLIES reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On FORALL reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On FINAL reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EXISTS reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EQUALEQUAL reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EQUAL reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EOF reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On AND reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On # reduce production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production location_reg -> PROC COLON PTX_REG_DEC PTX_REG_TYPE reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 10:
location_reg -> PROC COLON reg . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production location_reg -> PROC COLON reg
-- On SYMB_REG reduce production location_reg -> PROC COLON reg
-- On STAR reduce production location_reg -> PROC COLON reg
-- On SEMI reduce production location_reg -> PROC COLON reg
-- On RPAR reduce production location_reg -> PROC COLON reg
-- On RBRK reduce production location_reg -> PROC COLON reg
-- On PROC reduce production location_reg -> PROC COLON reg
-- On OR reduce production location_reg -> PROC COLON reg
-- On OBSERVED reduce production location_reg -> PROC COLON reg
-- On NUM reduce production location_reg -> PROC COLON reg
-- On NOTEQUAL reduce production location_reg -> PROC COLON reg
-- On NOT reduce production location_reg -> PROC COLON reg
-- On NAME reduce production location_reg -> PROC COLON reg
-- On LPAR reduce production location_reg -> PROC COLON reg
-- On LBRK reduce production location_reg -> PROC COLON reg
-- On IMPLIES reduce production location_reg -> PROC COLON reg
-- On FORALL reduce production location_reg -> PROC COLON reg
-- On FINAL reduce production location_reg -> PROC COLON reg
-- On EXISTS reduce production location_reg -> PROC COLON reg
-- On EQUALEQUAL reduce production location_reg -> PROC COLON reg
-- On EQUAL reduce production location_reg -> PROC COLON reg
-- On EOF reduce production location_reg -> PROC COLON reg
-- On AND reduce production location_reg -> PROC COLON reg
-- On # reduce production location_reg -> PROC COLON reg
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production location_reg -> PROC COLON reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 11:
location_reg -> NUM . COLON reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
location_reg -> NUM . COLON PTX_REG_DEC PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
maybev -> NUM . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On COLON shift to state 12
-- On WITH reduce production maybev -> NUM
-- On SYMB_REG reduce production maybev -> NUM
-- On STAR reduce production maybev -> NUM
-- On SEMI reduce production maybev -> NUM
-- On RPAR reduce production maybev -> NUM
-- On RBRK reduce production maybev -> NUM
-- On PROC reduce production maybev -> NUM
-- On OR reduce production maybev -> NUM
-- On OBSERVED reduce production maybev -> NUM
-- On NUM reduce production maybev -> NUM
-- On NOTEQUAL reduce production maybev -> NUM
-- On NOT reduce production maybev -> NUM
-- On NAME reduce production maybev -> NUM
-- On LPAR reduce production maybev -> NUM
-- On LBRK reduce production maybev -> NUM
-- On IMPLIES reduce production maybev -> NUM
-- On FORALL reduce production maybev -> NUM
-- On FINAL reduce production maybev -> NUM
-- On EXISTS reduce production maybev -> NUM
-- On EQUALEQUAL reduce production maybev -> NUM
-- On EQUAL reduce production maybev -> NUM
-- On EOF reduce production maybev -> NUM
-- On AND reduce production maybev -> NUM
-- On # reduce production maybev -> NUM
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF COLON AND
**   There is a tension between
**   (1) reducing production maybev -> NUM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 12:
location_reg -> NUM COLON . reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
location_reg -> NUM COLON . PTX_REG_DEC PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On PTX_REG_DEC shift to state 13
-- On NAME shift to state 7
-- On DOLLARNAME shift to state 8
-- On reg shift to state 16

State 13:
location_reg -> NUM COLON PTX_REG_DEC . PTX_REG_TYPE reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On PTX_REG_TYPE shift to state 14

State 14:
location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE . reg [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On NAME shift to state 7
-- On DOLLARNAME shift to state 8
-- On reg shift to state 15

State 15:
location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On SYMB_REG reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On STAR reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On SEMI reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On RPAR reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On RBRK reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On PROC reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On OR reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On OBSERVED reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NUM reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NOTEQUAL reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NOT reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On NAME reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On LPAR reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On LBRK reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On IMPLIES reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On FORALL reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On FINAL reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EXISTS reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EQUALEQUAL reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EQUAL reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On EOF reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On AND reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
-- On # reduce production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production location_reg -> NUM COLON PTX_REG_DEC PTX_REG_TYPE reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 16:
location_reg -> NUM COLON reg . [ WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND # ]
-- On WITH reduce production location_reg -> NUM COLON reg
-- On SYMB_REG reduce production location_reg -> NUM COLON reg
-- On STAR reduce production location_reg -> NUM COLON reg
-- On SEMI reduce production location_reg -> NUM COLON reg
-- On RPAR reduce production location_reg -> NUM COLON reg
-- On RBRK reduce production location_reg -> NUM COLON reg
-- On PROC reduce production location_reg -> NUM COLON reg
-- On OR reduce production location_reg -> NUM COLON reg
-- On OBSERVED reduce production location_reg -> NUM COLON reg
-- On NUM reduce production location_reg -> NUM COLON reg
-- On NOTEQUAL reduce production location_reg -> NUM COLON reg
-- On NOT reduce production location_reg -> NUM COLON reg
-- On NAME reduce production location_reg -> NUM COLON reg
-- On LPAR reduce production location_reg -> NUM COLON reg
-- On LBRK reduce production location_reg -> NUM COLON reg
-- On IMPLIES reduce production location_reg -> NUM COLON reg
-- On FORALL reduce production location_reg -> NUM COLON reg
-- On FINAL reduce production location_reg -> NUM COLON reg
-- On EXISTS reduce production location_reg -> NUM COLON reg
-- On EQUALEQUAL reduce production location_reg -> NUM COLON reg
-- On EQUAL reduce production location_reg -> NUM COLON reg
-- On EOF reduce production location_reg -> NUM COLON reg
-- On AND reduce production location_reg -> NUM COLON reg
-- On # reduce production location_reg -> NUM COLON reg
** End-of-stream conflict on WITH SYMB_REG STAR SEMI RPAR RBRK PROC OR OBSERVED NUM NOTEQUAL NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUALEQUAL EQUAL EOF AND
**   There is a tension between
**   (1) reducing production location_reg -> NUM COLON reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 17:
loc_deref -> NAME . LBRK NUM RBRK [ SEMI RBRK NOTEQUAL EQUALEQUAL EQUAL ]
maybev -> NAME . [ STAR SEMI RBRK NOTEQUAL NAME EQUALEQUAL EQUAL ]
-- On LBRK shift to state 18
-- On STAR reduce production maybev -> NAME
-- On SEMI reduce production maybev -> NAME
-- On RBRK reduce production maybev -> NAME
-- On NOTEQUAL reduce production maybev -> NAME
-- On NAME reduce production maybev -> NAME
-- On EQUALEQUAL reduce production maybev -> NAME
-- On EQUAL reduce production maybev -> NAME

State 18:
loc_deref -> NAME LBRK . NUM RBRK [ SEMI RBRK NOTEQUAL EQUALEQUAL EQUAL ]
-- On NUM shift to state 19

State 19:
loc_deref -> NAME LBRK NUM . RBRK [ SEMI RBRK NOTEQUAL EQUALEQUAL EQUAL ]
-- On RBRK shift to state 20

State 20:
loc_deref -> NAME LBRK NUM RBRK . [ SEMI RBRK NOTEQUAL EQUALEQUAL EQUAL ]
-- On SEMI reduce production loc_deref -> NAME LBRK NUM RBRK
-- On RBRK reduce production loc_deref -> NAME LBRK NUM RBRK
-- On NOTEQUAL reduce production loc_deref -> NAME LBRK NUM RBRK
-- On EQUALEQUAL reduce production loc_deref -> NAME LBRK NUM RBRK
-- On EQUAL reduce production loc_deref -> NAME LBRK NUM RBRK

State 21:
location -> LBRK . maybev RBRK [ SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF # ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 24

State 22:
maybev -> NUM . [ WITH SEMI RPAR RBRK OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production maybev -> NUM
-- On SEMI reduce production maybev -> NUM
-- On RPAR reduce production maybev -> NUM
-- On RBRK reduce production maybev -> NUM
-- On OR reduce production maybev -> NUM
-- On OBSERVED reduce production maybev -> NUM
-- On NOT reduce production maybev -> NUM
-- On LPAR reduce production maybev -> NUM
-- On IMPLIES reduce production maybev -> NUM
-- On FORALL reduce production maybev -> NUM
-- On FINAL reduce production maybev -> NUM
-- On EXISTS reduce production maybev -> NUM
-- On EOF reduce production maybev -> NUM
-- On AND reduce production maybev -> NUM
-- On # reduce production maybev -> NUM
** End-of-stream conflict on WITH SEMI RPAR RBRK OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production maybev -> NUM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 23:
maybev -> NAME . [ WITH SYMB_REG SEMI RPAR RBRK PROC OR OBSERVED NUM NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUAL EOF AND # ]
-- On WITH reduce production maybev -> NAME
-- On SYMB_REG reduce production maybev -> NAME
-- On SEMI reduce production maybev -> NAME
-- On RPAR reduce production maybev -> NAME
-- On RBRK reduce production maybev -> NAME
-- On PROC reduce production maybev -> NAME
-- On OR reduce production maybev -> NAME
-- On OBSERVED reduce production maybev -> NAME
-- On NUM reduce production maybev -> NAME
-- On NOT reduce production maybev -> NAME
-- On NAME reduce production maybev -> NAME
-- On LPAR reduce production maybev -> NAME
-- On LBRK reduce production maybev -> NAME
-- On IMPLIES reduce production maybev -> NAME
-- On FORALL reduce production maybev -> NAME
-- On FINAL reduce production maybev -> NAME
-- On EXISTS reduce production maybev -> NAME
-- On EQUAL reduce production maybev -> NAME
-- On EOF reduce production maybev -> NAME
-- On AND reduce production maybev -> NAME
-- On # reduce production maybev -> NAME
** End-of-stream conflict on WITH SYMB_REG SEMI RPAR RBRK PROC OR OBSERVED NUM NOT NAME LPAR LBRK IMPLIES FORALL FINAL EXISTS EQUAL EOF AND
**   There is a tension between
**   (1) reducing production maybev -> NAME
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 24:
location -> LBRK maybev . RBRK [ SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF # ]
-- On RBRK shift to state 25

State 25:
location -> LBRK maybev RBRK . [ SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF # ]
-- On SYMB_REG reduce production location -> LBRK maybev RBRK
-- On STAR reduce production location -> LBRK maybev RBRK
-- On SEMI reduce production location -> LBRK maybev RBRK
-- On RBRK reduce production location -> LBRK maybev RBRK
-- On PROC reduce production location -> LBRK maybev RBRK
-- On NUM reduce production location -> LBRK maybev RBRK
-- On NOTEQUAL reduce production location -> LBRK maybev RBRK
-- On NAME reduce production location -> LBRK maybev RBRK
-- On LBRK reduce production location -> LBRK maybev RBRK
-- On EQUALEQUAL reduce production location -> LBRK maybev RBRK
-- On EQUAL reduce production location -> LBRK maybev RBRK
-- On EOF reduce production location -> LBRK maybev RBRK
-- On # reduce production location -> LBRK maybev RBRK
** End-of-stream conflict on SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF
**   There is a tension between
**   (1) reducing production location -> LBRK maybev RBRK
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 26:
obs -> obsone . [ # ]
obs -> obsone . TOKAND obs [ # ]
-- On TOKAND shift to state 27
-- On # reduce production obs -> obsone
** End-of-stream conflict on TOKAND
**   There is a tension between
**   (1) reducing production obs -> obsone
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 27:
obs -> obsone TOKAND . obs [ # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On obsone shift to state 26
-- On obs shift to state 28
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 52
-- On TOKAND reduce production obsone ->
-- On # reduce production obsone ->
** End-of-stream conflict on TOKAND SYMB_REG PROC NUM NAME LBRK
**   There is a tension between
**   (1) reducing production obsone ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 28:
obs -> obsone TOKAND obs . [ # ]
-- On # reduce production obs -> obsone TOKAND obs

State 29:
location -> maybev . [ SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF # ]
-- On SYMB_REG reduce production location -> maybev
-- On STAR reduce production location -> maybev
-- On SEMI reduce production location -> maybev
-- On RBRK reduce production location -> maybev
-- On PROC reduce production location -> maybev
-- On NUM reduce production location -> maybev
-- On NOTEQUAL reduce production location -> maybev
-- On NAME reduce production location -> maybev
-- On LBRK reduce production location -> maybev
-- On EQUALEQUAL reduce production location -> maybev
-- On EQUAL reduce production location -> maybev
-- On EOF reduce production location -> maybev
-- On # reduce production location -> maybev
** End-of-stream conflict on SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF
**   There is a tension between
**   (1) reducing production location -> maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 30:
location -> location_reg . [ SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF # ]
-- On SYMB_REG reduce production location -> location_reg
-- On STAR reduce production location -> location_reg
-- On SEMI reduce production location -> location_reg
-- On RBRK reduce production location -> location_reg
-- On PROC reduce production location -> location_reg
-- On NUM reduce production location -> location_reg
-- On NOTEQUAL reduce production location -> location_reg
-- On NAME reduce production location -> location_reg
-- On LBRK reduce production location -> location_reg
-- On EQUALEQUAL reduce production location -> location_reg
-- On EQUAL reduce production location -> location_reg
-- On EOF reduce production location -> location_reg
-- On # reduce production location -> location_reg
** End-of-stream conflict on SYMB_REG STAR SEMI RBRK PROC NUM NOTEQUAL NAME LBRK EQUALEQUAL EQUAL EOF
**   There is a tension between
**   (1) reducing production location -> location_reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 31:
atom_prop -> location . EQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location . EQUALEQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location . NOTEQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location . EQUAL location_deref [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location . EQUALEQUAL location_deref [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NOTEQUAL shift to state 32
-- On EQUALEQUAL shift to state 34
-- On EQUAL shift to state 42

State 32:
atom_prop -> location NOTEQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 33

State 33:
atom_prop -> location NOTEQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> location NOTEQUAL maybev
-- On SEMI reduce production atom_prop -> location NOTEQUAL maybev
-- On RPAR reduce production atom_prop -> location NOTEQUAL maybev
-- On OR reduce production atom_prop -> location NOTEQUAL maybev
-- On OBSERVED reduce production atom_prop -> location NOTEQUAL maybev
-- On NOT reduce production atom_prop -> location NOTEQUAL maybev
-- On LPAR reduce production atom_prop -> location NOTEQUAL maybev
-- On IMPLIES reduce production atom_prop -> location NOTEQUAL maybev
-- On FORALL reduce production atom_prop -> location NOTEQUAL maybev
-- On FINAL reduce production atom_prop -> location NOTEQUAL maybev
-- On EXISTS reduce production atom_prop -> location NOTEQUAL maybev
-- On EOF reduce production atom_prop -> location NOTEQUAL maybev
-- On AND reduce production atom_prop -> location NOTEQUAL maybev
-- On # reduce production atom_prop -> location NOTEQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> location NOTEQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 34:
atom_prop -> location EQUALEQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location EQUALEQUAL . location_deref [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On SYMB_REG shift to state 2
-- On STAR shift to state 35
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On maybev shift to state 39
-- On location_reg shift to state 40
-- On location_deref shift to state 41

State 35:
location_deref -> STAR . location_reg [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
location_deref -> STAR . NAME [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 36
-- On NAME shift to state 37
-- On location_reg shift to state 38

State 36:
location_reg -> NUM . COLON reg [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
location_reg -> NUM . COLON PTX_REG_DEC PTX_REG_TYPE reg [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On COLON shift to state 12

State 37:
location_deref -> STAR NAME . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production location_deref -> STAR NAME
-- On SEMI reduce production location_deref -> STAR NAME
-- On RPAR reduce production location_deref -> STAR NAME
-- On OR reduce production location_deref -> STAR NAME
-- On OBSERVED reduce production location_deref -> STAR NAME
-- On NOT reduce production location_deref -> STAR NAME
-- On LPAR reduce production location_deref -> STAR NAME
-- On IMPLIES reduce production location_deref -> STAR NAME
-- On FORALL reduce production location_deref -> STAR NAME
-- On FINAL reduce production location_deref -> STAR NAME
-- On EXISTS reduce production location_deref -> STAR NAME
-- On EOF reduce production location_deref -> STAR NAME
-- On AND reduce production location_deref -> STAR NAME
-- On # reduce production location_deref -> STAR NAME
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production location_deref -> STAR NAME
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 38:
location_deref -> STAR location_reg . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production location_deref -> STAR location_reg
-- On SEMI reduce production location_deref -> STAR location_reg
-- On RPAR reduce production location_deref -> STAR location_reg
-- On OR reduce production location_deref -> STAR location_reg
-- On OBSERVED reduce production location_deref -> STAR location_reg
-- On NOT reduce production location_deref -> STAR location_reg
-- On LPAR reduce production location_deref -> STAR location_reg
-- On IMPLIES reduce production location_deref -> STAR location_reg
-- On FORALL reduce production location_deref -> STAR location_reg
-- On FINAL reduce production location_deref -> STAR location_reg
-- On EXISTS reduce production location_deref -> STAR location_reg
-- On EOF reduce production location_deref -> STAR location_reg
-- On AND reduce production location_deref -> STAR location_reg
-- On # reduce production location_deref -> STAR location_reg
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production location_deref -> STAR location_reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 39:
atom_prop -> location EQUALEQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> location EQUALEQUAL maybev
-- On SEMI reduce production atom_prop -> location EQUALEQUAL maybev
-- On RPAR reduce production atom_prop -> location EQUALEQUAL maybev
-- On OR reduce production atom_prop -> location EQUALEQUAL maybev
-- On OBSERVED reduce production atom_prop -> location EQUALEQUAL maybev
-- On NOT reduce production atom_prop -> location EQUALEQUAL maybev
-- On LPAR reduce production atom_prop -> location EQUALEQUAL maybev
-- On IMPLIES reduce production atom_prop -> location EQUALEQUAL maybev
-- On FORALL reduce production atom_prop -> location EQUALEQUAL maybev
-- On FINAL reduce production atom_prop -> location EQUALEQUAL maybev
-- On EXISTS reduce production atom_prop -> location EQUALEQUAL maybev
-- On EOF reduce production atom_prop -> location EQUALEQUAL maybev
-- On AND reduce production atom_prop -> location EQUALEQUAL maybev
-- On # reduce production atom_prop -> location EQUALEQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> location EQUALEQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 40:
location_deref -> location_reg . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production location_deref -> location_reg
-- On SEMI reduce production location_deref -> location_reg
-- On RPAR reduce production location_deref -> location_reg
-- On OR reduce production location_deref -> location_reg
-- On OBSERVED reduce production location_deref -> location_reg
-- On NOT reduce production location_deref -> location_reg
-- On LPAR reduce production location_deref -> location_reg
-- On IMPLIES reduce production location_deref -> location_reg
-- On FORALL reduce production location_deref -> location_reg
-- On FINAL reduce production location_deref -> location_reg
-- On EXISTS reduce production location_deref -> location_reg
-- On EOF reduce production location_deref -> location_reg
-- On AND reduce production location_deref -> location_reg
-- On # reduce production location_deref -> location_reg
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production location_deref -> location_reg
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 41:
atom_prop -> location EQUALEQUAL location_deref . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> location EQUALEQUAL location_deref
-- On SEMI reduce production atom_prop -> location EQUALEQUAL location_deref
-- On RPAR reduce production atom_prop -> location EQUALEQUAL location_deref
-- On OR reduce production atom_prop -> location EQUALEQUAL location_deref
-- On OBSERVED reduce production atom_prop -> location EQUALEQUAL location_deref
-- On NOT reduce production atom_prop -> location EQUALEQUAL location_deref
-- On LPAR reduce production atom_prop -> location EQUALEQUAL location_deref
-- On IMPLIES reduce production atom_prop -> location EQUALEQUAL location_deref
-- On FORALL reduce production atom_prop -> location EQUALEQUAL location_deref
-- On FINAL reduce production atom_prop -> location EQUALEQUAL location_deref
-- On EXISTS reduce production atom_prop -> location EQUALEQUAL location_deref
-- On EOF reduce production atom_prop -> location EQUALEQUAL location_deref
-- On AND reduce production atom_prop -> location EQUALEQUAL location_deref
-- On # reduce production atom_prop -> location EQUALEQUAL location_deref
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> location EQUALEQUAL location_deref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 42:
atom_prop -> location EQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> location EQUAL . location_deref [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On SYMB_REG shift to state 2
-- On STAR shift to state 35
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On maybev shift to state 43
-- On location_reg shift to state 40
-- On location_deref shift to state 44

State 43:
atom_prop -> location EQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> location EQUAL maybev
-- On SEMI reduce production atom_prop -> location EQUAL maybev
-- On RPAR reduce production atom_prop -> location EQUAL maybev
-- On OR reduce production atom_prop -> location EQUAL maybev
-- On OBSERVED reduce production atom_prop -> location EQUAL maybev
-- On NOT reduce production atom_prop -> location EQUAL maybev
-- On LPAR reduce production atom_prop -> location EQUAL maybev
-- On IMPLIES reduce production atom_prop -> location EQUAL maybev
-- On FORALL reduce production atom_prop -> location EQUAL maybev
-- On FINAL reduce production atom_prop -> location EQUAL maybev
-- On EXISTS reduce production atom_prop -> location EQUAL maybev
-- On EOF reduce production atom_prop -> location EQUAL maybev
-- On AND reduce production atom_prop -> location EQUAL maybev
-- On # reduce production atom_prop -> location EQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> location EQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 44:
atom_prop -> location EQUAL location_deref . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> location EQUAL location_deref
-- On SEMI reduce production atom_prop -> location EQUAL location_deref
-- On RPAR reduce production atom_prop -> location EQUAL location_deref
-- On OR reduce production atom_prop -> location EQUAL location_deref
-- On OBSERVED reduce production atom_prop -> location EQUAL location_deref
-- On NOT reduce production atom_prop -> location EQUAL location_deref
-- On LPAR reduce production atom_prop -> location EQUAL location_deref
-- On IMPLIES reduce production atom_prop -> location EQUAL location_deref
-- On FORALL reduce production atom_prop -> location EQUAL location_deref
-- On FINAL reduce production atom_prop -> location EQUAL location_deref
-- On EXISTS reduce production atom_prop -> location EQUAL location_deref
-- On EOF reduce production atom_prop -> location EQUAL location_deref
-- On AND reduce production atom_prop -> location EQUAL location_deref
-- On # reduce production atom_prop -> location EQUAL location_deref
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> location EQUAL location_deref
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 45:
atom_prop -> loc_deref . EQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> loc_deref . EQUALEQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
atom_prop -> loc_deref . NOTEQUAL maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NOTEQUAL shift to state 46
-- On EQUALEQUAL shift to state 48
-- On EQUAL shift to state 50

State 46:
atom_prop -> loc_deref NOTEQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 47

State 47:
atom_prop -> loc_deref NOTEQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On SEMI reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On RPAR reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On OR reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On OBSERVED reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On NOT reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On LPAR reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On IMPLIES reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On FORALL reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On FINAL reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On EXISTS reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On EOF reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On AND reduce production atom_prop -> loc_deref NOTEQUAL maybev
-- On # reduce production atom_prop -> loc_deref NOTEQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> loc_deref NOTEQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 48:
atom_prop -> loc_deref EQUALEQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 49

State 49:
atom_prop -> loc_deref EQUALEQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On SEMI reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On RPAR reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On OR reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On OBSERVED reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On NOT reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On LPAR reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On IMPLIES reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On FORALL reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On FINAL reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On EXISTS reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On EOF reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On AND reduce production atom_prop -> loc_deref EQUALEQUAL maybev
-- On # reduce production atom_prop -> loc_deref EQUALEQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> loc_deref EQUALEQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 50:
atom_prop -> loc_deref EQUAL . maybev [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 51

State 51:
atom_prop -> loc_deref EQUAL maybev . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production atom_prop -> loc_deref EQUAL maybev
-- On SEMI reduce production atom_prop -> loc_deref EQUAL maybev
-- On RPAR reduce production atom_prop -> loc_deref EQUAL maybev
-- On OR reduce production atom_prop -> loc_deref EQUAL maybev
-- On OBSERVED reduce production atom_prop -> loc_deref EQUAL maybev
-- On NOT reduce production atom_prop -> loc_deref EQUAL maybev
-- On LPAR reduce production atom_prop -> loc_deref EQUAL maybev
-- On IMPLIES reduce production atom_prop -> loc_deref EQUAL maybev
-- On FORALL reduce production atom_prop -> loc_deref EQUAL maybev
-- On FINAL reduce production atom_prop -> loc_deref EQUAL maybev
-- On EXISTS reduce production atom_prop -> loc_deref EQUAL maybev
-- On EOF reduce production atom_prop -> loc_deref EQUAL maybev
-- On AND reduce production atom_prop -> loc_deref EQUAL maybev
-- On # reduce production atom_prop -> loc_deref EQUAL maybev
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production atom_prop -> loc_deref EQUAL maybev
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 52:
obsone -> atom_prop . SEMI obsone [ WITH TOKAND SEMI EOF # ]
-- On SEMI shift to state 53

State 53:
obsone -> atom_prop SEMI . obsone [ WITH TOKAND SEMI EOF # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On obsone shift to state 54
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 52
-- On WITH reduce production obsone ->
-- On TOKAND reduce production obsone ->
-- On SEMI reduce production obsone ->
-- On EOF reduce production obsone ->
-- On # reduce production obsone ->
** End-of-stream conflict on WITH TOKAND SYMB_REG SEMI PROC NUM NAME LBRK EOF
**   There is a tension between
**   (1) reducing production obsone ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 54:
obsone -> atom_prop SEMI obsone . [ WITH TOKAND SEMI EOF # ]
-- On WITH reduce production obsone -> atom_prop SEMI obsone
-- On TOKAND reduce production obsone -> atom_prop SEMI obsone
-- On SEMI reduce production obsone -> atom_prop SEMI obsone
-- On EOF reduce production obsone -> atom_prop SEMI obsone
-- On # reduce production obsone -> atom_prop SEMI obsone
** End-of-stream conflict on WITH TOKAND SEMI EOF
**   There is a tension between
**   (1) reducing production obsone -> atom_prop SEMI obsone
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 55:
constr -> OBSERVED obs . [ # ]
-- On # reduce production constr -> OBSERVED obs

State 56:
constr -> NOT . EXISTS prop [ # ]
-- On EXISTS shift to state 57

State 57:
constr -> NOT EXISTS . prop [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 72
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 58:
prop -> TRUE . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production prop -> TRUE
-- On SEMI reduce production prop -> TRUE
-- On RPAR reduce production prop -> TRUE
-- On OR reduce production prop -> TRUE
-- On OBSERVED reduce production prop -> TRUE
-- On NOT reduce production prop -> TRUE
-- On LPAR reduce production prop -> TRUE
-- On IMPLIES reduce production prop -> TRUE
-- On FORALL reduce production prop -> TRUE
-- On FINAL reduce production prop -> TRUE
-- On EXISTS reduce production prop -> TRUE
-- On EOF reduce production prop -> TRUE
-- On AND reduce production prop -> TRUE
-- On # reduce production prop -> TRUE
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> TRUE
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 59:
prop -> NOT . prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 71
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 60:
prop -> LPAR . prop RPAR [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 62
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 61:
prop -> FALSE . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production prop -> FALSE
-- On SEMI reduce production prop -> FALSE
-- On RPAR reduce production prop -> FALSE
-- On OR reduce production prop -> FALSE
-- On OBSERVED reduce production prop -> FALSE
-- On NOT reduce production prop -> FALSE
-- On LPAR reduce production prop -> FALSE
-- On IMPLIES reduce production prop -> FALSE
-- On FORALL reduce production prop -> FALSE
-- On FINAL reduce production prop -> FALSE
-- On EXISTS reduce production prop -> FALSE
-- On EOF reduce production prop -> FALSE
-- On AND reduce production prop -> FALSE
-- On # reduce production prop -> FALSE
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> FALSE
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 62:
prop -> prop . AND prop [ RPAR OR IMPLIES AND ]
prop -> prop . OR prop [ RPAR OR IMPLIES AND ]
prop -> prop . IMPLIES prop [ RPAR OR IMPLIES AND ]
prop -> LPAR prop . RPAR [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On RPAR shift to state 63
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69

State 63:
prop -> LPAR prop RPAR . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production prop -> LPAR prop RPAR
-- On SEMI reduce production prop -> LPAR prop RPAR
-- On RPAR reduce production prop -> LPAR prop RPAR
-- On OR reduce production prop -> LPAR prop RPAR
-- On OBSERVED reduce production prop -> LPAR prop RPAR
-- On NOT reduce production prop -> LPAR prop RPAR
-- On LPAR reduce production prop -> LPAR prop RPAR
-- On IMPLIES reduce production prop -> LPAR prop RPAR
-- On FORALL reduce production prop -> LPAR prop RPAR
-- On FINAL reduce production prop -> LPAR prop RPAR
-- On EXISTS reduce production prop -> LPAR prop RPAR
-- On EOF reduce production prop -> LPAR prop RPAR
-- On AND reduce production prop -> LPAR prop RPAR
-- On # reduce production prop -> LPAR prop RPAR
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> LPAR prop RPAR
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 64:
prop -> prop OR . prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 65
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 65:
prop -> prop . AND prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . OR prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop OR prop . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . IMPLIES prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production prop -> prop OR prop
-- On SEMI reduce production prop -> prop OR prop
-- On RPAR reduce production prop -> prop OR prop
-- On OR reduce production prop -> prop OR prop
-- On OBSERVED reduce production prop -> prop OR prop
-- On NOT reduce production prop -> prop OR prop
-- On LPAR reduce production prop -> prop OR prop
-- On FORALL reduce production prop -> prop OR prop
-- On FINAL reduce production prop -> prop OR prop
-- On EXISTS reduce production prop -> prop OR prop
-- On EOF reduce production prop -> prop OR prop
-- On # reduce production prop -> prop OR prop
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> prop OR prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 66:
prop -> prop IMPLIES . prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 67
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 67:
prop -> prop . AND prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . OR prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . IMPLIES prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop IMPLIES prop . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On IMPLIES shift to state 66
-- On WITH reduce production prop -> prop IMPLIES prop
-- On SEMI reduce production prop -> prop IMPLIES prop
-- On RPAR reduce production prop -> prop IMPLIES prop
-- On OR reduce production prop -> prop IMPLIES prop
-- On OBSERVED reduce production prop -> prop IMPLIES prop
-- On NOT reduce production prop -> prop IMPLIES prop
-- On LPAR reduce production prop -> prop IMPLIES prop
-- On FORALL reduce production prop -> prop IMPLIES prop
-- On FINAL reduce production prop -> prop IMPLIES prop
-- On EXISTS reduce production prop -> prop IMPLIES prop
-- On EOF reduce production prop -> prop IMPLIES prop
-- On AND reduce production prop -> prop IMPLIES prop
-- On # reduce production prop -> prop IMPLIES prop
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> prop IMPLIES prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 68:
prop -> atom_prop . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production prop -> atom_prop
-- On SEMI reduce production prop -> atom_prop
-- On RPAR reduce production prop -> atom_prop
-- On OR reduce production prop -> atom_prop
-- On OBSERVED reduce production prop -> atom_prop
-- On NOT reduce production prop -> atom_prop
-- On LPAR reduce production prop -> atom_prop
-- On IMPLIES reduce production prop -> atom_prop
-- On FORALL reduce production prop -> atom_prop
-- On FINAL reduce production prop -> atom_prop
-- On EXISTS reduce production prop -> atom_prop
-- On EOF reduce production prop -> atom_prop
-- On AND reduce production prop -> atom_prop
-- On # reduce production prop -> atom_prop
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> atom_prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 69:
prop -> prop AND . prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 70
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 70:
prop -> prop . AND prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop AND prop . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . OR prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . IMPLIES prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On IMPLIES shift to state 66
-- On WITH reduce production prop -> prop AND prop
-- On SEMI reduce production prop -> prop AND prop
-- On RPAR reduce production prop -> prop AND prop
-- On OR reduce production prop -> prop AND prop
-- On OBSERVED reduce production prop -> prop AND prop
-- On NOT reduce production prop -> prop AND prop
-- On LPAR reduce production prop -> prop AND prop
-- On FORALL reduce production prop -> prop AND prop
-- On FINAL reduce production prop -> prop AND prop
-- On EXISTS reduce production prop -> prop AND prop
-- On EOF reduce production prop -> prop AND prop
-- On AND reduce production prop -> prop AND prop
-- On # reduce production prop -> prop AND prop
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> prop AND prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 71:
prop -> NOT prop . [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . AND prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . OR prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
prop -> prop . IMPLIES prop [ WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND # ]
-- On WITH reduce production prop -> NOT prop
-- On SEMI reduce production prop -> NOT prop
-- On RPAR reduce production prop -> NOT prop
-- On OR reduce production prop -> NOT prop
-- On OBSERVED reduce production prop -> NOT prop
-- On NOT reduce production prop -> NOT prop
-- On LPAR reduce production prop -> NOT prop
-- On IMPLIES reduce production prop -> NOT prop
-- On FORALL reduce production prop -> NOT prop
-- On FINAL reduce production prop -> NOT prop
-- On EXISTS reduce production prop -> NOT prop
-- On EOF reduce production prop -> NOT prop
-- On AND reduce production prop -> NOT prop
-- On # reduce production prop -> NOT prop
** End-of-stream conflict on WITH SEMI RPAR OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND
**   There is a tension between
**   (1) reducing production prop -> NOT prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 72:
constr -> NOT EXISTS prop . [ # ]
prop -> prop . AND prop [ OR IMPLIES AND # ]
prop -> prop . OR prop [ OR IMPLIES AND # ]
prop -> prop . IMPLIES prop [ OR IMPLIES AND # ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On # reduce production constr -> NOT EXISTS prop
** End-of-stream conflict on OR IMPLIES AND
**   There is a tension between
**   (1) reducing production constr -> NOT EXISTS prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 73:
constr -> LPAR . prop RPAR [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 74
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 74:
constr -> LPAR prop . RPAR [ # ]
prop -> prop . AND prop [ RPAR OR IMPLIES AND ]
prop -> prop . OR prop [ RPAR OR IMPLIES AND ]
prop -> prop . IMPLIES prop [ RPAR OR IMPLIES AND ]
-- On RPAR shift to state 75
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69

State 75:
constr -> LPAR prop RPAR . [ # ]
-- On # reduce production constr -> LPAR prop RPAR

State 76:
constr -> FORALL . prop [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 77
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 77:
constr -> FORALL prop . [ # ]
prop -> prop . AND prop [ OR IMPLIES AND # ]
prop -> prop . OR prop [ OR IMPLIES AND # ]
prop -> prop . IMPLIES prop [ OR IMPLIES AND # ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On # reduce production constr -> FORALL prop
** End-of-stream conflict on OR IMPLIES AND
**   There is a tension between
**   (1) reducing production constr -> FORALL prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 78:
constr -> FINAL . prop [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 79
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 79:
constr -> FINAL prop . [ # ]
prop -> prop . AND prop [ OR IMPLIES AND # ]
prop -> prop . OR prop [ OR IMPLIES AND # ]
prop -> prop . IMPLIES prop [ OR IMPLIES AND # ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On # reduce production constr -> FINAL prop
** End-of-stream conflict on OR IMPLIES AND
**   There is a tension between
**   (1) reducing production constr -> FINAL prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 80:
constr -> EXISTS . prop [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 81
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 81:
constr -> EXISTS prop . [ # ]
prop -> prop . AND prop [ OR IMPLIES AND # ]
prop -> prop . OR prop [ OR IMPLIES AND # ]
prop -> prop . IMPLIES prop [ OR IMPLIES AND # ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On # reduce production constr -> EXISTS prop
** End-of-stream conflict on OR IMPLIES AND
**   There is a tension between
**   (1) reducing production constr -> EXISTS prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 82:
constr' -> constr . [ # ]
-- On # accept constr

State 83:
constraints' -> . constraints [ # ]
-- On LOCATIONS shift to state 84
-- On locations shift to state 97
-- On constraints shift to state 135
-- On WITH reduce production locations ->
-- On SEMI reduce production locations ->
-- On OBSERVED reduce production locations ->
-- On NOT reduce production locations ->
-- On LPAR reduce production locations ->
-- On FORALL reduce production locations ->
-- On FINAL reduce production locations ->
-- On FILTER reduce production locations ->
-- On EXISTS reduce production locations ->
-- On EOF reduce production locations ->

State 84:
locations -> LOCATIONS . LBRK loc_semi_list RBRK [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL FILTER EXISTS EOF # ]
-- On LBRK shift to state 85

State 85:
locations -> LOCATIONS LBRK . loc_semi_list RBRK [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL FILTER EXISTS EOF # ]
-- On SYMB_REG shift to state 2
-- On SEMI shift to state 86
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 87
-- On loc_typ shift to state 91
-- On loc_semi_list shift to state 95
-- On loc_deref shift to state 94
-- On RBRK reduce production loc_semi_list ->

State 86:
loc_semi_list -> SEMI . [ RBRK ]
-- On RBRK reduce production loc_semi_list -> SEMI

State 87:
loc_typ -> location . [ SEMI RBRK ]
loc_typ -> location . STAR [ SEMI RBRK ]
loc_typ -> location . NAME [ SEMI RBRK ]
loc_typ -> location . NAME STAR [ SEMI RBRK ]
-- On STAR shift to state 88
-- On NAME shift to state 89
-- On SEMI reduce production loc_typ -> location
-- On RBRK reduce production loc_typ -> location

State 88:
loc_typ -> location STAR . [ SEMI RBRK ]
-- On SEMI reduce production loc_typ -> location STAR
-- On RBRK reduce production loc_typ -> location STAR

State 89:
loc_typ -> location NAME . [ SEMI RBRK ]
loc_typ -> location NAME . STAR [ SEMI RBRK ]
-- On STAR shift to state 90
-- On SEMI reduce production loc_typ -> location NAME
-- On RBRK reduce production loc_typ -> location NAME

State 90:
loc_typ -> location NAME STAR . [ SEMI RBRK ]
-- On SEMI reduce production loc_typ -> location NAME STAR
-- On RBRK reduce production loc_typ -> location NAME STAR

State 91:
loc_semi_list -> loc_typ . [ RBRK ]
loc_semi_list -> loc_typ . SEMI loc_semi_list [ RBRK ]
-- On SEMI shift to state 92
-- On RBRK reduce production loc_semi_list -> loc_typ

State 92:
loc_semi_list -> loc_typ SEMI . loc_semi_list [ RBRK ]
-- On SYMB_REG shift to state 2
-- On SEMI shift to state 86
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 87
-- On loc_typ shift to state 91
-- On loc_semi_list shift to state 93
-- On loc_deref shift to state 94
-- On RBRK reduce production loc_semi_list ->

State 93:
loc_semi_list -> loc_typ SEMI loc_semi_list . [ RBRK ]
-- On RBRK reduce production loc_semi_list -> loc_typ SEMI loc_semi_list

State 94:
loc_typ -> loc_deref . [ SEMI RBRK ]
-- On SEMI reduce production loc_typ -> loc_deref
-- On RBRK reduce production loc_typ -> loc_deref

State 95:
locations -> LOCATIONS LBRK loc_semi_list . RBRK [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL FILTER EXISTS EOF # ]
-- On RBRK shift to state 96

State 96:
locations -> LOCATIONS LBRK loc_semi_list RBRK . [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL FILTER EXISTS EOF # ]
-- On WITH reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On SEMI reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On OBSERVED reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On NOT reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On LPAR reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On FORALL reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On FINAL reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On FILTER reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On EXISTS reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On EOF reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
-- On # reduce production locations -> LOCATIONS LBRK loc_semi_list RBRK
** End-of-stream conflict on WITH SEMI OBSERVED NOT LPAR FORALL FINAL FILTER EXISTS EOF
**   There is a tension between
**   (1) reducing production locations -> LOCATIONS LBRK loc_semi_list RBRK
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 97:
constraints -> locations . filter old_constraints [ # ]
-- On FILTER shift to state 98
-- On filter shift to state 100
-- On WITH reduce production filter ->
-- On SEMI reduce production filter ->
-- On OBSERVED reduce production filter ->
-- On NOT reduce production filter ->
-- On LPAR reduce production filter ->
-- On FORALL reduce production filter ->
-- On FINAL reduce production filter ->
-- On EXISTS reduce production filter ->
-- On EOF reduce production filter ->

State 98:
filter -> FILTER . prop [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL EXISTS EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 99
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 99:
filter -> FILTER prop . [ WITH SEMI OBSERVED NOT LPAR FORALL FINAL EXISTS EOF ]
prop -> prop . AND prop [ WITH SEMI OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND ]
prop -> prop . OR prop [ WITH SEMI OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND ]
prop -> prop . IMPLIES prop [ WITH SEMI OR OBSERVED NOT LPAR IMPLIES FORALL FINAL EXISTS EOF AND ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production filter -> FILTER prop
-- On SEMI reduce production filter -> FILTER prop
-- On OBSERVED reduce production filter -> FILTER prop
-- On NOT reduce production filter -> FILTER prop
-- On LPAR reduce production filter -> FILTER prop
-- On FORALL reduce production filter -> FILTER prop
-- On FINAL reduce production filter -> FILTER prop
-- On EXISTS reduce production filter -> FILTER prop
-- On EOF reduce production filter -> FILTER prop

State 100:
constraints -> locations filter . old_constraints [ # ]
-- On OBSERVED shift to state 101
-- On NOT shift to state 106
-- On LPAR shift to state 109
-- On FORALL shift to state 112
-- On FINAL shift to state 114
-- On EXISTS shift to state 116
-- On old_constraints shift to state 118
-- On final shift to state 119
-- On constr shift to state 133
-- On WITH reduce production constr ->
-- On SEMI reduce production constr ->
-- On EOF reduce production constr ->

State 101:
constr -> OBSERVED . obs [ WITH SEMI EOF ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On obsone shift to state 102
-- On obs shift to state 105
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 52
-- On WITH reduce production obsone ->
-- On TOKAND reduce production obsone ->
-- On SEMI reduce production obsone ->
-- On EOF reduce production obsone ->

State 102:
obs -> obsone . [ WITH SEMI EOF ]
obs -> obsone . TOKAND obs [ WITH SEMI EOF ]
-- On TOKAND shift to state 103
-- On WITH reduce production obs -> obsone
-- On SEMI reduce production obs -> obsone
-- On EOF reduce production obs -> obsone

State 103:
obs -> obsone TOKAND . obs [ WITH SEMI EOF ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 17
-- On LBRK shift to state 21
-- On obsone shift to state 102
-- On obs shift to state 104
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 52
-- On WITH reduce production obsone ->
-- On TOKAND reduce production obsone ->
-- On SEMI reduce production obsone ->
-- On EOF reduce production obsone ->

State 104:
obs -> obsone TOKAND obs . [ WITH SEMI EOF ]
-- On WITH reduce production obs -> obsone TOKAND obs
-- On SEMI reduce production obs -> obsone TOKAND obs
-- On EOF reduce production obs -> obsone TOKAND obs

State 105:
constr -> OBSERVED obs . [ WITH SEMI EOF ]
-- On WITH reduce production constr -> OBSERVED obs
-- On SEMI reduce production constr -> OBSERVED obs
-- On EOF reduce production constr -> OBSERVED obs

State 106:
constr -> NOT . EXISTS prop [ WITH SEMI EOF ]
-- On EXISTS shift to state 107

State 107:
constr -> NOT EXISTS . prop [ WITH SEMI EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 108
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 108:
constr -> NOT EXISTS prop . [ WITH SEMI EOF ]
prop -> prop . AND prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . OR prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . IMPLIES prop [ WITH SEMI OR IMPLIES EOF AND ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production constr -> NOT EXISTS prop
-- On SEMI reduce production constr -> NOT EXISTS prop
-- On EOF reduce production constr -> NOT EXISTS prop

State 109:
constr -> LPAR . prop RPAR [ WITH SEMI EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 110
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 110:
constr -> LPAR prop . RPAR [ WITH SEMI EOF ]
prop -> prop . AND prop [ RPAR OR IMPLIES AND ]
prop -> prop . OR prop [ RPAR OR IMPLIES AND ]
prop -> prop . IMPLIES prop [ RPAR OR IMPLIES AND ]
-- On RPAR shift to state 111
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69

State 111:
constr -> LPAR prop RPAR . [ WITH SEMI EOF ]
-- On WITH reduce production constr -> LPAR prop RPAR
-- On SEMI reduce production constr -> LPAR prop RPAR
-- On EOF reduce production constr -> LPAR prop RPAR

State 112:
constr -> FORALL . prop [ WITH SEMI EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 113
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 113:
constr -> FORALL prop . [ WITH SEMI EOF ]
prop -> prop . AND prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . OR prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . IMPLIES prop [ WITH SEMI OR IMPLIES EOF AND ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production constr -> FORALL prop
-- On SEMI reduce production constr -> FORALL prop
-- On EOF reduce production constr -> FORALL prop

State 114:
constr -> FINAL . prop [ WITH SEMI EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 115
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 115:
constr -> FINAL prop . [ WITH SEMI EOF ]
prop -> prop . AND prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . OR prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . IMPLIES prop [ WITH SEMI OR IMPLIES EOF AND ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production constr -> FINAL prop
-- On SEMI reduce production constr -> FINAL prop
-- On EOF reduce production constr -> FINAL prop

State 116:
constr -> EXISTS . prop [ WITH SEMI EOF ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 117
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 117:
constr -> EXISTS prop . [ WITH SEMI EOF ]
prop -> prop . AND prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . OR prop [ WITH SEMI OR IMPLIES EOF AND ]
prop -> prop . IMPLIES prop [ WITH SEMI OR IMPLIES EOF AND ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On WITH reduce production constr -> EXISTS prop
-- On SEMI reduce production constr -> EXISTS prop
-- On EOF reduce production constr -> EXISTS prop

State 118:
constraints -> locations filter old_constraints . [ # ]
-- On # reduce production constraints -> locations filter old_constraints

State 119:
old_constraints -> final . EOF [ # ]
old_constraints -> final . WITH kinds EOF [ # ]
-- On WITH shift to state 120
-- On EOF shift to state 132

State 120:
old_constraints -> final WITH . kinds EOF [ # ]
-- On NAME shift to state 121
-- On kinds shift to state 127
-- On kind shift to state 129

State 121:
kind -> NAME . COLON FORALL [ SEMI EOF ]
kind -> NAME . COLON EXISTS [ SEMI EOF ]
kind -> NAME . COLON NOT EXISTS [ SEMI EOF ]
-- On COLON shift to state 122

State 122:
kind -> NAME COLON . FORALL [ SEMI EOF ]
kind -> NAME COLON . EXISTS [ SEMI EOF ]
kind -> NAME COLON . NOT EXISTS [ SEMI EOF ]
-- On NOT shift to state 123
-- On FORALL shift to state 125
-- On EXISTS shift to state 126

State 123:
kind -> NAME COLON NOT . EXISTS [ SEMI EOF ]
-- On EXISTS shift to state 124

State 124:
kind -> NAME COLON NOT EXISTS . [ SEMI EOF ]
-- On SEMI reduce production kind -> NAME COLON NOT EXISTS
-- On EOF reduce production kind -> NAME COLON NOT EXISTS

State 125:
kind -> NAME COLON FORALL . [ SEMI EOF ]
-- On SEMI reduce production kind -> NAME COLON FORALL
-- On EOF reduce production kind -> NAME COLON FORALL

State 126:
kind -> NAME COLON EXISTS . [ SEMI EOF ]
-- On SEMI reduce production kind -> NAME COLON EXISTS
-- On EOF reduce production kind -> NAME COLON EXISTS

State 127:
old_constraints -> final WITH kinds . EOF [ # ]
-- On EOF shift to state 128

State 128:
old_constraints -> final WITH kinds EOF . [ # ]
-- On # reduce production old_constraints -> final WITH kinds EOF

State 129:
kinds -> kind . [ EOF ]
kinds -> kind . SEMI [ EOF ]
kinds -> kind . SEMI kinds [ EOF ]
-- On SEMI shift to state 130
-- On EOF reduce production kinds -> kind

State 130:
kinds -> kind SEMI . [ EOF ]
kinds -> kind SEMI . kinds [ EOF ]
-- On NAME shift to state 121
-- On kinds shift to state 131
-- On kind shift to state 129
-- On EOF reduce production kinds -> kind SEMI

State 131:
kinds -> kind SEMI kinds . [ EOF ]
-- On EOF reduce production kinds -> kind SEMI kinds

State 132:
old_constraints -> final EOF . [ # ]
-- On # reduce production old_constraints -> final EOF

State 133:
final -> constr . [ WITH EOF ]
final -> constr . SEMI [ WITH EOF ]
-- On SEMI shift to state 134
-- On WITH reduce production final -> constr
-- On EOF reduce production final -> constr

State 134:
final -> constr SEMI . [ WITH EOF ]
-- On WITH reduce production final -> constr SEMI
-- On EOF reduce production final -> constr SEMI

State 135:
constraints' -> constraints . [ # ]
-- On # accept constraints

State 136:
filter' -> . filter [ # ]
-- On FILTER shift to state 137
-- On filter shift to state 139
-- On # reduce production filter ->
** End-of-stream conflict on FILTER
**   There is a tension between
**   (1) reducing production filter ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 137:
filter -> FILTER . prop [ # ]
-- On TRUE shift to state 58
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NOT shift to state 59
-- On NAME shift to state 17
-- On LPAR shift to state 60
-- On LBRK shift to state 21
-- On FALSE shift to state 61
-- On prop shift to state 138
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 31
-- On loc_deref shift to state 45
-- On atom_prop shift to state 68

State 138:
filter -> FILTER prop . [ # ]
prop -> prop . AND prop [ OR IMPLIES AND # ]
prop -> prop . OR prop [ OR IMPLIES AND # ]
prop -> prop . IMPLIES prop [ OR IMPLIES AND # ]
-- On OR shift to state 64
-- On IMPLIES shift to state 66
-- On AND shift to state 69
-- On # reduce production filter -> FILTER prop
** End-of-stream conflict on OR IMPLIES AND
**   There is a tension between
**   (1) reducing production filter -> FILTER prop
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 139:
filter' -> filter . [ # ]
-- On # accept filter

State 140:
init' -> . init [ # ]
-- On SYMB_REG shift to state 2
-- On STAR shift to state 141
-- On SEMI shift to state 147
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 148
-- On LBRK shift to state 21
-- On ATOMIC shift to state 165
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 168
-- On init_semi_list shift to state 171
-- On init shift to state 173
-- On atom_init shift to state 174
-- On atom shift to state 177
-- On EOF reduce production init_semi_list ->

State 141:
atom_init -> STAR . location [ SEMI EOF ]
atom_init -> STAR . location EQUAL amperopt maybev [ SEMI EOF ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 142

State 142:
atom_init -> STAR location . [ SEMI EOF ]
atom_init -> STAR location . EQUAL amperopt maybev [ SEMI EOF ]
-- On EQUAL shift to state 143
-- On SEMI reduce production atom_init -> STAR location
-- On EOF reduce production atom_init -> STAR location

State 143:
atom_init -> STAR location EQUAL . amperopt maybev [ SEMI EOF ]
-- On AMPER shift to state 144
-- On amperopt shift to state 145
-- On NUM reduce production amperopt ->
-- On NAME reduce production amperopt ->

State 144:
amperopt -> AMPER . [ NUM NAME ]
-- On NUM reduce production amperopt -> AMPER
-- On NAME reduce production amperopt -> AMPER

State 145:
atom_init -> STAR location EQUAL amperopt . maybev [ SEMI EOF ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 146

State 146:
atom_init -> STAR location EQUAL amperopt maybev . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> STAR location EQUAL amperopt maybev
-- On EOF reduce production atom_init -> STAR location EQUAL amperopt maybev

State 147:
init_semi_list -> SEMI . [ EOF ]
-- On EOF reduce production init_semi_list -> SEMI

State 148:
atom_init -> NAME . location [ SEMI EOF ]
atom_init -> NAME . location EQUAL maybev [ SEMI EOF ]
atom_init -> NAME . location EQUAL ATOMICINIT LPAR maybev RPAR [ SEMI EOF ]
atom_init -> NAME . STAR location [ SEMI EOF ]
atom_init -> NAME . STAR location EQUAL amperopt maybev [ SEMI EOF ]
atom_init -> NAME . NAME LBRK NUM RBRK [ SEMI EOF ]
maybev -> NAME . [ SEMI EQUAL EOF ]
-- On SYMB_REG shift to state 2
-- On STAR shift to state 149
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 154
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 158
-- On SEMI reduce production maybev -> NAME
-- On EQUAL reduce production maybev -> NAME
-- On EOF reduce production maybev -> NAME

State 149:
atom_init -> NAME STAR . location [ SEMI EOF ]
atom_init -> NAME STAR . location EQUAL amperopt maybev [ SEMI EOF ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 150

State 150:
atom_init -> NAME STAR location . [ SEMI EOF ]
atom_init -> NAME STAR location . EQUAL amperopt maybev [ SEMI EOF ]
-- On EQUAL shift to state 151
-- On SEMI reduce production atom_init -> NAME STAR location
-- On EOF reduce production atom_init -> NAME STAR location

State 151:
atom_init -> NAME STAR location EQUAL . amperopt maybev [ SEMI EOF ]
-- On AMPER shift to state 144
-- On amperopt shift to state 152
-- On NUM reduce production amperopt ->
-- On NAME reduce production amperopt ->

State 152:
atom_init -> NAME STAR location EQUAL amperopt . maybev [ SEMI EOF ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 153

State 153:
atom_init -> NAME STAR location EQUAL amperopt maybev . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> NAME STAR location EQUAL amperopt maybev
-- On EOF reduce production atom_init -> NAME STAR location EQUAL amperopt maybev

State 154:
atom_init -> NAME NAME . LBRK NUM RBRK [ SEMI EOF ]
maybev -> NAME . [ SEMI EQUAL EOF ]
-- On LBRK shift to state 155
-- On SEMI reduce production maybev -> NAME
-- On EQUAL reduce production maybev -> NAME
-- On EOF reduce production maybev -> NAME

State 155:
atom_init -> NAME NAME LBRK . NUM RBRK [ SEMI EOF ]
-- On NUM shift to state 156

State 156:
atom_init -> NAME NAME LBRK NUM . RBRK [ SEMI EOF ]
-- On RBRK shift to state 157

State 157:
atom_init -> NAME NAME LBRK NUM RBRK . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> NAME NAME LBRK NUM RBRK
-- On EOF reduce production atom_init -> NAME NAME LBRK NUM RBRK

State 158:
atom_init -> NAME location . [ SEMI EOF ]
atom_init -> NAME location . EQUAL maybev [ SEMI EOF ]
atom_init -> NAME location . EQUAL ATOMICINIT LPAR maybev RPAR [ SEMI EOF ]
-- On EQUAL shift to state 159
-- On SEMI reduce production atom_init -> NAME location
-- On EOF reduce production atom_init -> NAME location

State 159:
atom_init -> NAME location EQUAL . maybev [ SEMI EOF ]
atom_init -> NAME location EQUAL . ATOMICINIT LPAR maybev RPAR [ SEMI EOF ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On ATOMICINIT shift to state 160
-- On maybev shift to state 164

State 160:
atom_init -> NAME location EQUAL ATOMICINIT . LPAR maybev RPAR [ SEMI EOF ]
-- On LPAR shift to state 161

State 161:
atom_init -> NAME location EQUAL ATOMICINIT LPAR . maybev RPAR [ SEMI EOF ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 162

State 162:
atom_init -> NAME location EQUAL ATOMICINIT LPAR maybev . RPAR [ SEMI EOF ]
-- On RPAR shift to state 163

State 163:
atom_init -> NAME location EQUAL ATOMICINIT LPAR maybev RPAR . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> NAME location EQUAL ATOMICINIT LPAR maybev RPAR
-- On EOF reduce production atom_init -> NAME location EQUAL ATOMICINIT LPAR maybev RPAR

State 164:
atom_init -> NAME location EQUAL maybev . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> NAME location EQUAL maybev
-- On EOF reduce production atom_init -> NAME location EQUAL maybev

State 165:
atom_init -> ATOMIC . NAME location [ SEMI EOF ]
-- On NAME shift to state 166

State 166:
atom_init -> ATOMIC NAME . location [ SEMI EOF ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 167

State 167:
atom_init -> ATOMIC NAME location . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> ATOMIC NAME location
-- On EOF reduce production atom_init -> ATOMIC NAME location

State 168:
atom -> location . [ SEMI EOF ]
atom -> location . EQUAL maybev [ SEMI EOF ]
-- On EQUAL shift to state 169
-- On SEMI reduce production atom -> location
-- On EOF reduce production atom -> location

State 169:
atom -> location EQUAL . maybev [ SEMI EOF ]
-- On NUM shift to state 22
-- On NAME shift to state 23
-- On maybev shift to state 170

State 170:
atom -> location EQUAL maybev . [ SEMI EOF ]
-- On SEMI reduce production atom -> location EQUAL maybev
-- On EOF reduce production atom -> location EQUAL maybev

State 171:
init -> init_semi_list . EOF [ # ]
-- On EOF shift to state 172

State 172:
init -> init_semi_list EOF . [ # ]
-- On # reduce production init -> init_semi_list EOF

State 173:
init' -> init . [ # ]
-- On # accept init

State 174:
init_semi_list -> atom_init . [ EOF ]
init_semi_list -> atom_init . SEMI init_semi_list [ EOF ]
-- On SEMI shift to state 175
-- On EOF reduce production init_semi_list -> atom_init

State 175:
init_semi_list -> atom_init SEMI . init_semi_list [ EOF ]
-- On SYMB_REG shift to state 2
-- On STAR shift to state 141
-- On SEMI shift to state 147
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 148
-- On LBRK shift to state 21
-- On ATOMIC shift to state 165
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 168
-- On init_semi_list shift to state 176
-- On atom_init shift to state 174
-- On atom shift to state 177
-- On EOF reduce production init_semi_list ->

State 176:
init_semi_list -> atom_init SEMI init_semi_list . [ EOF ]
-- On EOF reduce production init_semi_list -> atom_init SEMI init_semi_list

State 177:
atom_init -> atom . [ SEMI EOF ]
-- On SEMI reduce production atom_init -> atom
-- On EOF reduce production atom_init -> atom

State 178:
loc_constr' -> . loc_constr [ # ]
-- On LOCATIONS shift to state 84
-- On locations shift to state 179
-- On loc_constr shift to state 181
-- On OBSERVED reduce production locations ->
-- On NOT reduce production locations ->
-- On LPAR reduce production locations ->
-- On FORALL reduce production locations ->
-- On FINAL reduce production locations ->
-- On EXISTS reduce production locations ->
-- On # reduce production locations ->
** End-of-stream conflict on OBSERVED NOT LPAR LOCATIONS FORALL FINAL EXISTS
**   There is a tension between
**   (1) reducing production locations ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 179:
loc_constr -> locations . constr [ # ]
-- On OBSERVED shift to state 1
-- On NOT shift to state 56
-- On LPAR shift to state 73
-- On FORALL shift to state 76
-- On FINAL shift to state 78
-- On EXISTS shift to state 80
-- On constr shift to state 180
-- On # reduce production constr ->
** End-of-stream conflict on OBSERVED NOT LPAR FORALL FINAL EXISTS
**   There is a tension between
**   (1) reducing production constr ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 180:
loc_constr -> locations constr . [ # ]
-- On # reduce production loc_constr -> locations constr

State 181:
loc_constr' -> loc_constr . [ # ]
-- On # accept loc_constr

State 182:
location' -> . location [ # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On location_reg shift to state 30
-- On location shift to state 183

State 183:
location' -> location . [ # ]
-- On # accept location

State 184:
locs' -> . locs [ # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On locs shift to state 185
-- On location_reg shift to state 30
-- On location shift to state 186
-- On # reduce production locs ->
** End-of-stream conflict on SYMB_REG PROC NUM NAME LBRK
**   There is a tension between
**   (1) reducing production locs ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 185:
locs' -> locs . [ # ]
-- On # accept locs

State 186:
locs -> location . locs [ # ]
-- On SYMB_REG shift to state 2
-- On PROC shift to state 3
-- On NUM shift to state 11
-- On NAME shift to state 23
-- On LBRK shift to state 21
-- On maybev shift to state 29
-- On locs shift to state 187
-- On location_reg shift to state 30
-- On location shift to state 186
-- On # reduce production locs ->
** End-of-stream conflict on SYMB_REG PROC NUM NAME LBRK
**   There is a tension between
**   (1) reducing production locs ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 187:
locs -> location locs . [ # ]
-- On # reduce production locs -> location locs

State 188:
skip_loc_constr' -> . skip_loc_constr [ # ]
-- On LOCATIONS shift to state 84
-- On skip_loc_constr shift to state 189
-- On locations shift to state 190
-- On OBSERVED reduce production locations ->
-- On NOT reduce production locations ->
-- On LPAR reduce production locations ->
-- On FORALL reduce production locations ->
-- On FINAL reduce production locations ->
-- On EXISTS reduce production locations ->
-- On # reduce production locations ->
** End-of-stream conflict on OBSERVED NOT LPAR LOCATIONS FORALL FINAL EXISTS
**   There is a tension between
**   (1) reducing production locations ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 189:
skip_loc_constr' -> skip_loc_constr . [ # ]
-- On # accept skip_loc_constr

State 190:
skip_loc_constr -> locations . constr [ # ]
-- On OBSERVED shift to state 1
-- On NOT shift to state 56
-- On LPAR shift to state 73
-- On FORALL shift to state 76
-- On FINAL shift to state 78
-- On EXISTS shift to state 80
-- On constr shift to state 191
-- On # reduce production constr ->
** End-of-stream conflict on OBSERVED NOT LPAR FORALL FINAL EXISTS
**   There is a tension between
**   (1) reducing production constr ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 191:
skip_loc_constr -> locations constr . [ # ]
-- On # reduce production skip_loc_constr -> locations constr

