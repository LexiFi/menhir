State 0:
prog' -> . prog [ # ]
-- On INT shift to state 1
-- On prog shift to state 2
-- On exp shift to state 3

State 1:
exp -> INT . [ TIMES PLUS EOF ]
-- On TIMES reduce production exp -> INT 
-- On PLUS reduce production exp -> INT 
-- On EOF reduce production exp -> INT 

State 2:
prog' -> prog . [ # ]
-- On # accept prog

State 3:
exp -> exp . PLUS exp [ TIMES PLUS EOF ]
exp -> exp . TIMES exp [ TIMES PLUS EOF ]
prog -> exp . EOF [ # ]
-- On TIMES shift to state 4
-- On PLUS shift to state 6
-- On EOF shift to state 8

State 4:
exp -> exp TIMES . exp [ TIMES PLUS EOF ]
-- On INT shift to state 1
-- On exp shift to state 5

State 5:
exp -> exp . PLUS exp [ TIMES PLUS EOF ]
exp -> exp . TIMES exp [ TIMES PLUS EOF ]
exp -> exp TIMES exp . [ TIMES PLUS EOF ]
-- On TIMES reduce production exp -> exp TIMES exp 
-- On PLUS reduce production exp -> exp TIMES exp 
-- On EOF reduce production exp -> exp TIMES exp 

State 6:
exp -> exp PLUS . exp [ TIMES PLUS EOF ]
-- On INT shift to state 1
-- On exp shift to state 7

State 7:
exp -> exp . PLUS exp [ TIMES PLUS EOF ]
exp -> exp PLUS exp . [ TIMES PLUS EOF ]
exp -> exp . TIMES exp [ TIMES PLUS EOF ]
-- On TIMES shift to state 4
-- On PLUS reduce production exp -> exp PLUS exp 
-- On EOF reduce production exp -> exp PLUS exp 

State 8:
prog -> exp EOF . [ # ]
-- On # reduce production prog -> exp EOF 

