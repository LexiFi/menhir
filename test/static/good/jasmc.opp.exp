File "jasmc.mly", line 153, characters 7-10:
Warning: the token EOF is unused.
%{
  open Javalib_pack
  open Javalib

  type switchcase =
    | CaseIntWord of int * string
    | CaseIntInt of int * int

  type switchdefault =
    | DefaultWord of string
    | DefaultInt of int

  type pcode =
    | DCatchIII of JBasics.class_name * int * int * int

  let unescape s =
    Scanf.unescaped (String.sub s 1 ((String.length s)- 2))

  let cbasic = function
      | "boolean" -> "Z"
      | "byte"    -> "B"
      | "char"    -> "C"
      | "short"   -> "S"
      | "int"     -> "I"
      | "long"    -> "J"
      | "float"   -> "F"
      | "double"  -> "D"
      | "void"    -> "V"
      | _ -> assert false

  let cf_access a =
    if List.mem `Public a then `Public else
    if List.mem `Protected a then `Protected else
    if List.mem `Private a then `Private else
    `Default

  let replace_dot s =
    let s = String.copy s in
    for i = 0 to String.length s - 1 do
      if s.[i] = '/' then s.[i] <- '.'
    done;
    s

  let split_method name =
    let pos = String.index name '(' in
    (String.sub name 0 pos, String.sub name pos ((String.length name) - pos))

  let split_obj name =
    let name = replace_dot name in
    let pos = String.rindex name '.' in
    (String.sub name 0 pos, String.sub name (pos+1) ((String.length name) - (pos+1)))

  let sourcefile = ref None
  let cn = ref (JBasics.make_cn "_")
  let limit_stack = ref 0
  let limit_locals = ref 0
  let pos = ref 0
  let lines = ref []
  let excs = ref []
  let throws = ref []
  let label2pos = Hashtbl.create 16
  let pos2label = Hashtbl.create 16

  let init_method () =
    limit_stack := 255;
    limit_locals := 255;
    pos := 0;
    lines := [];
    excs := [];
    throws := [];
    Hashtbl.clear label2pos;
    Hashtbl.clear pos2label

  let label2int l =
    if (Hashtbl.mem label2pos l) then Hashtbl.find label2pos l else
    let pos = -(1 + (Hashtbl.length pos2label)) in
    Hashtbl.add pos2label pos l;
    pos

  let addlabel l i =
    Hashtbl.add label2pos l i

  let add n c =
    let p = !pos in
    pos := !pos + n;
    (p, c)

  let mkcode codes =

    let realloc p l =
      if l >= 0 then l - p else
      let label = Hashtbl.find pos2label l in
      (Hashtbl.find label2pos label) - p

    in
    let code = Array.create !pos JCode.OpInvalid in
    List.iter (function
      | (p, JCode.OpInvalid) -> ()
      | (p, JCode.OpJsr(l)) -> code.(p) <- JCode.OpJsr(realloc p l)
      | (p, JCode.OpIf(a,l)) -> code.(p) <- JCode.OpIf(a,realloc p l)
      | (p, JCode.OpIfCmp(a,l)) -> code.(p) <- JCode.OpIfCmp(a,realloc p l)
      | (p, JCode.OpGoto(l)) -> code.(p) <- JCode.OpGoto(realloc p l)
      | (p, JCode.OpLookupSwitch(d,cases)) ->
        let cases = List.map(fun(a,b)-> (a ,realloc p b)) cases in
        code.(p) <- JCode.OpLookupSwitch(realloc p d ,cases)
      | (p, JCode.OpTableSwitch (def, low, high, defs)) ->
        let defs = Array.map (realloc p) defs in
        code.(p) <- JCode.OpTableSwitch(realloc p def,low, high, defs)
      | (p, c) -> code.(p) <- c
    ) codes;
    let lines = if !lines = [] then None else Some (List.rev !lines) in
    let excs = List.map (fun exc ->
        {
          exc with
          JCode.e_start = realloc 0 exc.JCode.e_start;
          e_end = realloc 0 exc.e_end;
          e_handler = realloc 0 exc.e_handler
        }
    ) (List.rev !excs) in
    let throws = List.rev !throws in
    (code,lines, excs, throws)
%}
%start jas_file
%token ABSTRACT
%token ANNOTATION
%token BRIDGE
%token CLASS
%token COLON
%token DANNOTATION
%token DATTRIBUTE
%token DBYTECODE
%token DCATCH
%token DCLASS
%token DDEBUG
%token DDEPRECATED
%token DEFAULT
%token DENCLOSING
%token DEND
%token DFIELD
%token DIMPLEMENTS
%token DINNER
%token DINTERFACE
%token DLIMIT
%token DLINE
%token DMETHOD
%token DSET
%token DSIGNATURE
%token DSOURCE
%token DSTACK
%token DSUPER
%token DTHROWS
%token DVAR
%token ENUM
%token EOF
%token EQ
%token FIELD
%token FINAL
%token FROM
%token INNER
%token INTERFACE
%token INVISIBLE
%token INVISIBLEPARAM
%token IS
%token <string * string> Insn
%token <int> Int
%token LOCALS
%token LOOKUPSWITCH
%token METHOD
%token NATIVE
%token <string> Num
%token OFFSET
%token OUTER
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token <string> Relative
%token SEP
%token SIGNATURE
%token STACK
%token STATIC
%token STRICT
%token SYNCHRONIZED
%token SYNTHETIC
%token <string> Str
%token TABLESWITCH
%token TO
%token TRANSIENT
%token USE
%token USING
%token VARARGS
%token VISIBLE
%token VISIBLEPARAM
%token VOLATILE
%token <string> Word
%type <Javalib_pack.JCode.jcode Javalib_pack.Javalib.interface_or_class> jas_file
%%

jas_file:
  _1 = sep _2 = jasmin_header _3 = inners _4 = fields _5 = methods
    {    ( _2 _3 _4 _5 )}

sep:
  _1 = SEP
    {        ( () )}
| 
    {    ( () )}

jasmin_header:
  _1 = bytecode_spec _2 = source_spec _3 = class_spec _4 = super_spec _5 = implements _6 = signature_spec _7 = enclosing_spec _8 = deprecated_spec _9 = annotations _10 = generic_attributes _11 = debug_extension
    {    (

      let (class_or_interface, access, name) = _3 in

      match class_or_interface with
      | "class" ->
        (fun inners fields methods ->
          let fields = List.fold_left (fun fields (fs,f) ->
            JBasics.FieldMap.add fs f fields
          ) JBasics.FieldMap.empty fields in
          let methods = List.fold_left (fun methods (ms,m) ->
            JBasics.MethodMap.add ms m methods
          ) JBasics.MethodMap.empty methods in

          JClass {
            c_name = name;
            c_version = _1;
            c_access = if List.mem `Public access then `Public else `Default;
            c_final = List.mem `Final access;
            c_abstract = List.mem `Abstract access;
            c_super_class = _4;
            c_generic_signature = _6;
            c_fields = fields;
            c_interfaces = _5;
            c_consts = [||];
            c_sourcefile = _2;
            c_deprecated = _8;
            c_enclosing_method = _7;
            c_source_debug_extention = _11;
            c_inner_classes = inners;
            c_synthetic = List.mem `Synthetic access;
            c_enum = List.mem `Enum access;
            c_annotations = _9;
            c_other_flags = [];
            c_other_attributes = _10;
            c_methods = methods;
          })
      | "interface" ->
        (fun inners fields methods ->
          let fields = List.fold_left (fun fields (fs,f) ->
            let f = {
                if_signature = f.cf_signature ;
                if_class_signature = f.cf_class_signature;
                if_generic_signature = f.cf_generic_signature;
                if_synthetic = f.cf_synthetic;
                if_value = f.cf_value;
                if_annotations = f.cf_annotations;
                if_other_flags = f.cf_other_flags;
                if_attributes = f.cf_attributes;
              }
            in
            JBasics.FieldMap.add fs f fields
          ) JBasics.FieldMap.empty fields in
          let methods = List.fold_left (fun methods -> function
            (ms, ConcreteMethod {
              cm_signature = signature;
              cm_class_method_signature = class_method_signature;
              cm_access = access;
              cm_generic_signature = generic_signature;
              cm_bridge = bridge;
              cm_varargs = varargs;
              cm_synthetic = synthetic;
              cm_other_flags = other_flags;
              cm_exceptions = exceptions;
              cm_attributes = attributes;
              cm_annotations = annotations;
            }) ->
            let m = {
              am_signature = signature;
              am_class_method_signature = class_method_signature;
              am_access =
                begin match access with
                | `Default -> `Default
                | `Protected -> `Protected
                | `Public -> `Public
                | `Private -> assert false
                end
              ;
              am_generic_signature = generic_signature;
              am_bridge = bridge;
              am_varargs = varargs;
              am_synthetic = synthetic;
              am_other_flags = other_flags;
              am_exceptions = exceptions;
              am_attributes = attributes;
              am_annotations = annotations;
              am_annotation_default = None;
            } in
            JBasics.MethodMap.add ms m methods
          ) JBasics.MethodMap.empty methods in
          JInterface {
            i_name = name;
            i_version = _1;
            i_access = if List.mem `Public access then `Public else `Default;
            i_interfaces = _5;
            i_generic_signature = _6;
            i_consts = [||];
            i_sourcefile = _2;
            i_deprecated = _8;
            i_source_debug_extention = _11;
            i_inner_classes = inners;
            i_initializer = None;
            i_annotation = false;
            i_annotations = _9;
            i_other_attributes = _10;
            i_other_flags = [];
            i_fields = fields;
            i_methods = methods;
          }
        )
    )}

signature_spec:
  _1 = DSIGNATURE _2 = signature_expr _3 = SEP
    {                                  ( Some _2 )}
| 
    {                ( None )}

signature_expr:
  _1 = Str
    {        ( JParseSignature.parse_ClassSignature _1 )}

deprecated_spec:
  _1 = DDEPRECATED _2 = deprecated_expr _3 = SEP
    {                                    ( true )}
| 
    {                  ( false )}

deprecated_expr:
  
    {    ( () )}

bytecode_spec:
  _1 = DBYTECODE _2 = Num _3 = SEP
    {    (
      let (major, minor) =
        begin try
          let pos = String.index _2 '.' in
          let len = String.length _2 in
          (String.sub _2 0 pos, String.sub _2 (pos+1) (len-pos-1))
        with e -> (_2,"0")
        end
      in
      { JBasics.major = int_of_string major; minor = int_of_string minor }
    )}
| 
    {    (
      { JBasics.major = 45; minor = 3 }
    )}

source_spec:
  _1 = DSOURCE _2 = Str _3 = SEP
    {                    ( Some _2 )}
| _1 = DSOURCE _2 = Word _3 = SEP
    {                     ( Some _2 )}
| 
    {                  ( !sourcefile )}

class_spec:
  _1 = DCLASS _2 = access _3 = classname _4 = SEP
    {    (
      cn := _3;
      ("class",_2,_3)
    )}
| _1 = DINTERFACE _2 = access _3 = classname _4 = SEP
    {    (
      cn := _3;
      ("interface",_2,_3)
    )}

classname:
  _1 = Word
    {         ( JBasics.make_cn (replace_dot _1) )}

access:
  _1 = access_list
    {                ( _1 )}

access_list:
  _1 = access_items
    {                   ( _1 )}
| 
    {      ( [`Default] )}

access_items:
  _1 = access_item _2 = access_items
    {                                 ( _1::_2 )}
| _1 = access_item
    {                    ( [_1] )}

access_item:
  _1 = PUBLIC
    {                 ( `Public )}
| _1 = PRIVATE
    {                  ( `Private )}
| _1 = PROTECTED
    {                    ( `Protected )}
| _1 = STATIC
    {                 ( `Static )}
| _1 = FINAL
    {                ( `Final )}
| _1 = SYNCHRONIZED
    {                       ( `Synchronized )}
| _1 = VOLATILE
    {                   ( `Volatile )}
| _1 = TRANSIENT
    {                    ( `Transient )}
| _1 = NATIVE
    {                 ( `Native )}
| _1 = INTERFACE
    {                    ( `Interface )}
| _1 = ABSTRACT
    {                   ( `Abstract )}
| _1 = ANNOTATION
    {                     ( `Annotation )}
| _1 = ENUM
    {               ( `Enum )}
| _1 = BRIDGE
    {                 ( `Bridge )}
| _1 = VARARGS
    {                  ( `Varargs )}
| _1 = STRICT
    {                 ( `Strict )}
| _1 = SYNTHETIC
    {                    ( `Synthetic )}

super_spec:
  _1 = DSUPER _2 = classname _3 = SEP
    {                         ( Some (_2) )}

implements:
  _1 = implements_list
    {                    ( _1 )}
| 
    {                ( [] )}

implements_list:
  _1 = implements_spec _2 = implements_list
    {                                      ( _1::_2 )}
| _1 = implements_spec
    {                      ( [_1] )}

implements_spec:
  _1 = DIMPLEMENTS _2 = classname _3 = SEP
    {                                  ( _2 )}

annotations:
  _1 = ann_cls_list
    {                 ( [] )}
| 
    {                ( [] )}

ann_cls_list:
  _1 = ann_cls_list _2 = ann_cls_spec
    {      ( _2::_1 )}
| _1 = ann_cls_spec
    {      ( [_1] )}

ann_cls_spec:
  _1 = ann_cls_expr _2 = ann_arglist _3 = endannotationsep
    {        ( "" )}

ann_cls_expr:
  _1 = DANNOTATION _2 = ann_clf_expr
    {          ( () )}

endannotationsep:
  _1 = endannotation _2 = SEP
    {                      ( () )}

endannotation:
  _1 = DEND _2 = ANNOTATION
    {                    ( () )}

ann_clf_expr:
  _1 = VISIBLE _2 = classname _3 = SEP
    {    ( () )}
| _1 = INVISIBLE _2 = classname _3 = SEP
    {    ( () )}

ann_met_expr:
  _1 = VISIBLE _2 = classname _3 = SEP
    {    ( () )}
| _1 = INVISIBLE _2 = classname _3 = SEP
    {    ( () )}
| _1 = VISIBLEPARAM _2 = Int _3 = classname _4 = SEP
    {    ( () )}
| _1 = INVISIBLEPARAM _2 = Int _3 = classname _4 = SEP
    {    ( () )}

ann_arglist:
  _1 = ann_arg_list
    {                 ( [] )}
| 
    {                ( [] )}

ann_arg_list:
  _1 = ann_arg_list _2 = ann_arg_spec
    {      ( _2::_1 )}
| _1 = ann_arg_spec
    {      ( [_1] )}

ann_arg_spec:
  _1 = ann_arg_expr _2 = EQ _3 = ann_value_list
    {        ( (_1,_3) )}

ann_arg_expr:
  _1 = Word _2 = Word
    {          ( "" )}
| _1 = Word _2 = Word _3 = Word
    {          ( "" )}

ann_def_spec:
  _1 = DEFAULT _2 = SEP
    {    ( () )}

ann_value_list:
  _1 = ann_value_items _2 = SEP
    {    ( _1 )}
| _1 = ann_ann_list
    {    ( _1 )}

ann_value_items:
  _1 = ann_value_items _2 = ann_value
    {    ( _2::_1 )}
| _1 = ann_value
    {    ( [_1] )}

ann_value:
  _1 = any_item
    {      ( "" )}

ann_ann_list:
  _1 = ann_ann_list _2 = ann_ann_value
    {                               ( _2::_1 )}
| _1 = ann_ann_value
    {                  ( [_1] )}

ann_ann_value:
  _1 = DANNOTATION _2 = ann_nest _3 = ann_arglist _4 = endannotationsep
    {      ( "" )}

ann_nest:
  _1 = SEP
    {            ( () )}

ann_def_val:
  _1 = ann_def_expr _2 = EQ _3 = ann_value_list
    {    ( () )}

ann_def_expr:
  _1 = Word
    {      ( () )}
| _1 = Word _2 = Word
    {      ( () )}

debug_extension:
  _1 = debug_list
    {               ( Some (String.concat " " (List.rev _1)) )}
| 
    {                ( None )}

debug_list:
  _1 = debug_list _2 = debug_spec
    {      ( _2::_1 )}
| _1 = debug_spec
    {      ( [_1] )}

debug_spec:
  _1 = DDEBUG _2 = Str _3 = SEP
    {                       ( _2 )}

enclosing_spec:
  _1 = DENCLOSING _2 = METHOD _3 = Word _4 = SEP
    {    (
      let (name, md) = split_method _3 in
      let (vts, ovt) = JParseSignature.parse_method_descriptor md in
      let ms = JBasics.make_ms name vts ovt in
      Some (!cn,Some (ms))
    )}
| 
    {                  ( None )}

generic_attributes:
  _1 = generic_list
    {                 ( _1 )}
| 
    {                ( [] )}

generic_list:
  _1 = generic_list _2 = generic_spec
    {                                ( _2::_1 )}
| _1 = generic_spec
    {                   ( [_1] )}

generic_spec:
  _1 = DATTRIBUTE _2 = generic_expr _3 = SEP
    {                                    ( _2 )}

generic_expr:
  _1 = Word _2 = Str
    {             ( (_1,_2) )}

fields:
  _1 = field_list
    {               ( _1 )}
| 
    {    ( [] )}

field_list:
  _1 = field_spec _2 = field_list
    {                            ( _1::_2 )}
| _1 = field_spec
    {                 ( [_1] )}

field_spec:
  _1 = DFIELD _2 = access _3 = Word _4 = Word _5 = SIGNATURE _6 = Str _7 = optional_default _8 = SEP
    {        (
          let fs = JBasics.make_fs _3 (JParseSignature.parse_field_descriptor _4) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = cf_access _2;
            cf_static = List.mem `Static _2;
            cf_synthetic = List.mem `Synthetic _2;
            cf_enum = List.mem `Enum _2;
            cf_kind = if List.mem `Final _2 then Final else NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
        )}
| _1 = DFIELD _2 = access _3 = Word _4 = Word _5 = optional_default _6 = SEP
    {        (
          let fs = JBasics.make_fs _3 (JParseSignature.parse_field_descriptor _4) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = cf_access _2;
            cf_static = List.mem `Static _2;
            cf_synthetic = List.mem `Synthetic _2;
            cf_enum = List.mem `Enum _2;
            cf_kind = if List.mem `Final _2 then Final else NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
        )}
| _1 = DFIELD _2 = field_start _3 = field_exts _4 = endfield
    {        (
          let fs = JBasics.make_fs "" (JParseSignature.parse_field_descriptor _2) in
          let f = {
            cf_signature = fs;
            cf_class_signature = JBasics.make_cfs !cn fs;
            cf_generic_signature = None;
            cf_access = `Default;
            cf_static = false;
            cf_synthetic = false;
            cf_enum = false;
            cf_kind = NotFinal;
            cf_value = None;
            cf_transient = false;
            cf_annotations = [];
            cf_other_flags = [];
            cf_attributes = {
              synthetic = false; deprecated = false; other = []
            }
          } in
          (fs,f)
        )}

optional_default:
  _1 = EQ _2 = item
    {                  ( Some _2 )}
| 
    {                      ( None )}

field_start:
  _1 = access _2 = Word _3 = Word _4 = optional_default _5 = SEP
    {          ( "" )}

endfield:
  _1 = DEND _2 = FIELD _3 = SEP
    {          ( () )}

field_exts:
  _1 = field_ext_list
    {                         ( _1 )}
| 
    {                      ( [] )}

field_ext_list:
  _1 = field_ext_list _2 = field_ext_expr
    {                                          ( _2::_1 )}
| _1 = field_ext_expr
    {                           ( [_1] )}

field_ext_expr:
  _1 = DSIGNATURE _2 = signature_expr _3 = SEP
    {              ( "" )}
| _1 = DATTRIBUTE _2 = generic_expr _3 = SEP
    {              ( "" )}
| _1 = DDEPRECATED _2 = deprecated_expr _3 = SEP
    {              ( "" )}
| _1 = DANNOTATION _2 = ann_clf_expr _3 = ann_arglist _4 = endannotationsep
    {              ( "" )}

item:
  _1 = Int
    {    ( () )}
| _1 = Num
    {    ( () )}
| _1 = Str
    {    ( () )}

any_item:
  _1 = Word
    {    ( () )}
| _1 = item
    {    ( () )}

inners:
  _1 = inner_list
    {               ( List.rev _1 )}
| 
    {                ( [] )}

inner_list:
  _1 = inner_list _2 = inner_spec
    {                            ( _2::_1 )}
| _1 = inner_spec
    {                 ( [_1] )}

inner_spec:
  _1 = DINNER _2 = CLASS _3 = access _4 = inner_name _5 = inner_inner _6 = inner_outer _7 = SEP
    {        (
          {
            ic_class_name = _5;
            ic_outer_class_name = _6;
            ic_source_name = _4;
            ic_access = cf_access _3;
            ic_static = List.mem `Static _3;
            ic_final = List.mem `Final _3;
            ic_synthetic = List.mem `Synthetic _3;
            ic_annotation = List.mem `Annotation _3;
            ic_enum = List.mem `Enum _3;
            ic_other_flags = []; (* TODO *)
            ic_type = `ConcreteClass (* TODO `Abstract *)
          }
        )}
| _1 = DINNER _2 = INTERFACE _3 = access _4 = inner_name _5 = inner_inner _6 = inner_outer _7 = SEP
    {        (
          {
            ic_class_name = _5;
            ic_outer_class_name = _6;
            ic_source_name = _4;
            ic_access = cf_access _3;
            ic_static = List.mem `Static _3;
            ic_final = List.mem `Final _3;
            ic_synthetic = List.mem `Synthetic _3;
            ic_annotation = List.mem `Annotation _3;
            ic_enum = List.mem `Enum _3;
            ic_other_flags = []; (* TODO *)
            ic_type = `Interface
          }
        )}

inner_name:
  _1 = Word
    {               ( Some _1 )}
| 
    {                      ( None )}

inner_inner:
  _1 = INNER _2 = classname
    {                          ( Some _2 )}
| 
    {                      ( None )}

inner_outer:
  _1 = OUTER _2 = classname
    {                          ( Some _2 )}
| 
    {                      ( None )}

methods:
  _1 = method_list
    {                ( _1 )}
| 
    {                ( [] )}

method_list:
  _1 = method_spec
    {                  ( [_1] )}
| _1 = method_list _2 = method_spec
    {                              ( _2::_1 )}

method_spec:
  _1 = defmethod _2 = statements _3 = endmethod
    {        (
          let(access,ms) = _1 in
          let code,lines,excs,throws = mkcode (List.rev _2) in
          let jmethod = {
            JCode.c_max_stack = !limit_stack;
            c_max_locals = !limit_locals;
            c_code = code;
            c_exc_tbl = excs;
            c_line_number_table = lines;
            c_local_variable_table = None; (* TODO *)
            c_local_variable_type_table = None; (* TODO *)
            c_stack_map_midp = None; (* TODO *)
            c_stack_map_java6 = None; (* TODO *)
            c_attributes = []; (* TODO *)
          }
          in
          let m = ConcreteMethod {
            cm_signature = ms;
            cm_class_method_signature = JBasics.make_cms !cn ms;
            cm_static = List.mem `Static access;
            cm_final = List.mem `Final access;
            cm_synchronized = List.mem `Synchronized access;
            cm_strict = List.mem `Strict access;
            cm_access = cf_access access;
            cm_generic_signature = None; (* TODO *)
            cm_bridge = List.mem `Bridge access;
            cm_varargs = List.mem `Varargs access;
            cm_synthetic = List.mem `Synthetic access;
            cm_other_flags = []; (* TODO *)
            cm_exceptions = throws; (* TODO *)
            cm_attributes = { synthetic = false; deprecated = false; other = [] };  (* TODO *)
            cm_annotations = { ma_global = []; ma_parameters = [] }; (* TODO *)
            cm_implementation = Java (lazy jmethod)
          } in (ms,m)
        )}
| _1 = defmethod _2 = endmethod
    {        (
          let(access,ms) = _1 in
          let code =[||] in
          let jmethod = {
            JCode.c_max_stack = 0;
            c_max_locals = 0;
            c_code = code;
            c_exc_tbl = [];
            c_line_number_table = None;
            c_local_variable_table = None;
            c_local_variable_type_table = None;
            c_stack_map_midp = None;
            c_stack_map_java6 = None;
            c_attributes = []
          }
          in
          let m = ConcreteMethod {
            cm_signature = ms;
            cm_class_method_signature = JBasics.make_cms !cn ms;
            cm_static = List.mem `Static access;
            cm_final = List.mem `Final access;
            cm_synchronized = List.mem `Synchronized access;
            cm_strict = List.mem `Strict access;
            cm_access = cf_access access;
            cm_generic_signature = None;
            cm_bridge = List.mem `Bridge access;
            cm_varargs = List.mem `Varargs access;
            cm_synthetic = List.mem `Synthetic access;
            cm_other_flags = [];
            cm_exceptions = [];
            cm_attributes = { synthetic = false; deprecated = false; other = [] };
            cm_annotations = { ma_global = []; ma_parameters = [] };
            cm_implementation = Java (lazy jmethod)
          } in (ms,m)
        )}

defmethod:
  _1 = DMETHOD _2 = access _3 = Word _4 = SEP
    {          (
            init_method();
            let (name, md) = split_method _3 in
            let (vts, ovt) = JParseSignature.parse_method_descriptor md in
            let ms = JBasics.make_ms name vts ovt
            in (_2, ms)
          )}

endmethod:
  _1 = DEND _2 = METHOD _3 = SEP
    {                          ( () )}

statements:
  _1 = statements _2 = statement
    {                               ( _2::_1 )}
| _1 = statement
    {                    ( [_1] )}

statement:
  _1 = stmnt _2 = SEP
    {                      ( _1 )}

stmnt:
  _1 = instruction
    {                          ( _1 )}
| _1 = directive
    {                        ( _1 )}
| _1 = error
    {                    ( add 0 JCode.OpInvalid )}
| _1 = label
    {                    ( _1 )}
| 
    {                          ( add 0 JCode.OpInvalid )}

label:
  _1 = Word _2 = COLON
    {                           (
                addlabel _1 !pos;
                add 0 JCode.OpInvalid
               )}
| _1 = Int _2 = COLON _3 = instruction
    {                                      (
                let (pos, _) = _3 in
                addlabel (string_of_int _1) pos;
                _3
              )}

directive:
  _1 = DVAR _2 = var_expr
    {                (
                  failwith "TODO: .var"
                )}
| _1 = DLIMIT _2 = limit_expr
    {                                  ( add 0 JCode.OpInvalid )}
| _1 = DLINE _2 = line_expr
    {                                ( add 0 JCode.OpInvalid )}
| _1 = DTHROWS _2 = throws_expr
    {                                    ( add 0 JCode.OpInvalid )}
| _1 = DCATCH _2 = catch_expr
    {                                  ( add 0 JCode.OpInvalid )}
| _1 = DSET _2 = set_expr
    {                (
                  failwith "TODO: .set"
                )}
| _1 = DSIGNATURE _2 = signature_expr
    {                (
                  failwith "TODO: .signature"
                )}
| _1 = DATTRIBUTE _2 = generic_expr
    {                (
                  failwith "TODO: .attribute"
                )}
| _1 = DDEPRECATED _2 = deprecated_expr
    {                (
                  failwith "TODO: .deprected"
                )}
| _1 = DANNOTATION _2 = ann_met_expr _3 = ann_arglist _4 = endannotation
    {                (
                  failwith "TODO: .annotation"
                )}
| _1 = DANNOTATION _2 = ann_def_spec _3 = ann_def_val _4 = endannotation
    {                (
                  failwith "TODO: .annotation"
                )}
| _1 = DSTACK _2 = stackmap
    {                (
                  failwith "TODO: .stack"
                )}

var_expr:
  _1 = Int _2 = IS _3 = Word _4 = Word _5 = optional_signature _6 = FROM _7 = Word _8 = TO _9 = Word
    {                  ( ()  (* TODO *))}
| _1 = Int _2 = IS _3 = Word _4 = Word _5 = optional_signature
    {                  ( ()  (* TODO *))}
| _1 = Int _2 = IS _3 = Word _4 = Word _5 = optional_signature _6 = FROM _7 = Int _8 = TO _9 = Int
    {                  ( ()  (* TODO *))}

optional_signature:
  _1 = SIGNATURE _2 = Str
    {                                  ( Some _2 )}
| 
    {                                ( None )}

limit_expr:
  _1 = LOCALS _2 = Int
    {                             ( limit_locals := _2 )}
| _1 = STACK _2 = Int
    {                            ( limit_stack := _2 )}
| _1 = Word _2 = Int
    {                           ( () )}

line_expr:
  _1 = Int
    {                      ( lines := (!pos, _1) :: !lines )}

throws_expr:
  _1 = classname
    {                            ( throws := _1 :: !throws )}

catch_expr:
  _1 = classname _2 = FROM _3 = Word _4 = TO _5 = Word _6 = USING _7 = Word
    {                  (
                    excs := {
                      JCode.e_start = label2int _3;
                      e_end = label2int _5;
                      e_handler = label2int _7;
                      e_catch_type = Some _1
                    } :: !excs
                  )}
| _1 = classname _2 = FROM _3 = Int _4 = TO _5 = Int _6 = USING _7 = Int
    {                  (
                    excs := {
                      JCode.e_start = _3;
                      e_end = _5;
                      e_handler = _7;
                      e_catch_type = Some _1
                    } :: !excs
                  )}

set_expr:
  _1 = Word _2 = any_item
    {                                ( () )}

stackmap:
  _1 = defstack _2 = stack_map_frame_desc _3 = endstack
    {                  ( () )}
| _1 = USE _2 = defstack_same _3 = stack_map_frame_desc _4 = endstack
    {                  ( () )}

defstack_same:
  _1 = defstack_same_expr _2 = LOCALS _3 = SEP
    {                    ( () )}

defstack_same_expr:
  _1 = Int
    {                    ( () )}
| 
    {                    ( () )}

defstack:
  _1 = SEP
    {                        ( () )}

stack_map_frame_desc:
  _1 = stack_offset_def _2 = stack_items
    {                    ( () )}

stack_offset_def:
  _1 = OFFSET _2 = Int _3 = SEP
    {                    ( () )}
| _1 = OFFSET _2 = Word _3 = SEP
    {                    ( () )}
| 
    {                    ( () )}

stack_items:
  _1 = stack_items _2 = stack_item
    {                                           ( _2::_1 )}
| 
    {                                  ( [] )}

stack_item:
  _1 = stack_item_expr _2 = SEP
    {                                        ( _1 )}

stack_item_expr:
  _1 = LOCALS _2 = Word
    {                    ( "" )}
| _1 = LOCALS _2 = Word _3 = Word
    {                    ( "" )}
| _1 = LOCALS _2 = Word _3 = Int
    {                    ( "" )}
| _1 = STACK _2 = Word
    {                    ( "" )}
| _1 = STACK _2 = Word _3 = Word
    {                    ( "" )}
| _1 = STACK _2 = Word _3 = Int
    {                    ( "" )}

endstack:
  _1 = DEND _2 = STACK
    {                               ( () )}

instruction:
  _1 = simple_instruction
    {                                   ( _1 )}
| _1 = complex_instruction
    {                                    ( _1 )}

simple_instruction:
  _1 = Insn
    {                       (
                  match (fst _1) with
                  (* A *)
                  | "aaload" -> add 1 (JCode.OpArrayLoad `Object)
                  | "aastore" -> add 1 (JCode.OpArrayStore `Object)
                  | "aconst_null" -> add 1 (JCode.OpConst(`ANull))
                  | "aload_0" -> add 1 (JCode.OpLoad (`Object, 0))
                  | "aload_1" -> add 1 (JCode.OpLoad (`Object, 1))
                  | "aload_2" -> add 1 (JCode.OpLoad (`Object, 2))
                  | "aload_3" -> add 1 (JCode.OpLoad (`Object, 3))
                  | "areturn" -> add 1 (JCode.OpReturn `Object)
                  | "arraylength" -> add 1 (JCode.OpArrayLength)
                  | "astore_0" -> add 1 (JCode.OpStore (`Object, 0))
                  | "astore_1" -> add 1 (JCode.OpStore (`Object, 1))
                  | "astore_2" -> add 1 (JCode.OpStore (`Object, 2))
                  | "astore_3" -> add 1 (JCode.OpStore (`Object, 3))
                  | "athrow" -> add 1 (JCode.OpThrow)
                  (* B *)
                  | "baload" ->add 1 (JCode.OpArrayLoad `ByteBool)
                  | "bastore" -> add 1 (JCode.OpArrayStore `ByteBool)
                  | "breakpoint" -> add 1 (JCode.OpBreakpoint)
                  (* C *)
                  | "caload" ->add 1 (JCode.OpArrayLoad `Char)
                  | "castore" -> add 1 (JCode.OpArrayStore `Char)
                  (* D *)
                  | "d2f" -> add 1 (JCode.OpD2F)
                  | "d2i" -> add 1 (JCode.OpD2I)
                  | "d2l" -> add 1 (JCode.OpD2L)
                  | "dadd" -> add 1 (JCode.OpAdd `Double)
                  | "daload" ->add 1 (JCode.OpArrayLoad `Double)
                  | "dastore" -> add 1 (JCode.OpArrayStore `Double)
                  | "dcmpg" -> add 1 (JCode.OpCmp `DG)
                  | "dcmpl" -> add 1 (JCode.OpCmp `DL)
                  | "dconst_0" -> add 1 (JCode.OpConst(`Double (0.)))
                  | "dconst_1" -> add 1 (JCode.OpConst(`Double (1.)))
                  | "ddiv" -> add 1 (JCode.OpDiv `Double)
                  | "dload_0" -> add 1 (JCode.OpLoad (`Double, 0))
                  | "dload_1" -> add 1 (JCode.OpLoad (`Double, 1))
                  | "dload_2" -> add 1 (JCode.OpLoad (`Double, 2))
                  | "dload_3" -> add 1 (JCode.OpLoad (`Double, 3))
                  | "dmul" -> add 1 (JCode.OpMult `Double)
                  | "dneg" -> add 1 (JCode.OpNeg `Double)
                  | "drem" -> add 1 (JCode.OpRem `Double)
                  | "dreturn" -> add 1 (JCode.OpReturn `Double)
                  | "dstore_0" -> add 1 (JCode.OpStore (`Double, 0))
                  | "dstore_1" -> add 1 (JCode.OpStore (`Double, 1))
                  | "dstore_2" -> add 1 (JCode.OpStore (`Double, 2))
                  | "dstore_3" -> add 1 (JCode.OpStore (`Double, 3))
                  | "dsub" -> add 1 (JCode.OpSub `Double)
                  | "dup" -> add 1 (JCode.OpDup)
                  | "dup2" -> add 1 (JCode.OpDup2)
                  | "dup2_x1" -> add 1 (JCode.OpDup2X1)
                  | "dup2_x2" -> add 1 (JCode.OpDup2X2)
                  | "dup_x1" -> add 1 (JCode.OpDupX1)
                  | "dup_x2" -> add 1 (JCode.OpDupX2)
                  (* F *)
                  | "f2i" -> add 1 (JCode.OpF2I)
                  | "f2l" -> add 1 (JCode.OpF2L)
                  | "f2d" -> add 1 (JCode.OpF2D)
                  | "fadd" -> add 1 (JCode.OpAdd `Float)
                  | "faload" ->add 1 (JCode.OpArrayLoad `Float)
                  | "fastore" -> add 1 (JCode.OpArrayStore `Float)
                  | "fcmpg" -> add 1 (JCode.OpCmp `FG)
                  | "fcmpl" -> add 1 (JCode.OpCmp `FL)
                  | "fconst_0" -> add 1(JCode.OpConst(`Float (0.)))
                  | "fconst_1" -> add 1(JCode.OpConst(`Float (1.)))
                  | "fconst_2" -> add 1(JCode.OpConst(`Float (2.)))
                  | "fdiv" -> add 1 (JCode.OpDiv `Float)
                  | "fload_0" -> add 1 (JCode.OpLoad (`Float, 0))
                  | "fload_1" -> add 1 (JCode.OpLoad (`Float, 1))
                  | "fload_2" -> add 1 (JCode.OpLoad (`Float, 2))
                  | "fload_3" -> add 1 (JCode.OpLoad (`Float, 3))
                  | "fmul" -> add 1 (JCode.OpMult `Float)
                  | "fneg" -> add 1 (JCode.OpNeg `Float)
                  | "frem" -> add 1 (JCode.OpRem `Float)
                  | "freturn" -> add 1 (JCode.OpReturn `Float)
                  | "fstore_0" -> add 1 (JCode.OpStore (`Float, 0))
                  | "fstore_1" -> add 1 (JCode.OpStore (`Float, 1))
                  | "fstore_2" -> add 1 (JCode.OpStore (`Float, 2))
                  | "fstore_3" -> add 1 (JCode.OpStore (`Float, 3))
                  | "fsub" -> add 1 (JCode.OpSub `Float)
                  (* I *)
                  | "i2f" -> add 1 (JCode.OpI2F)
                  | "i2d" -> add 1 (JCode.OpI2D)
                  | "i2l" -> add 1 (JCode.OpI2L)
                  | "iadd" -> add 1 (JCode.OpAdd `Int2Bool)
                  | "iaload" -> add 1 (JCode.OpArrayLoad `Int)
                  | "iand" -> add 1 (JCode.OpIAnd)
                  | "iastore" -> add 1 (JCode.OpArrayStore `Int)
                  | "iconst_0" -> add 1 (JCode.OpConst(`Int (0l)))
                  | "iconst_1" -> add 1 (JCode.OpConst(`Int (1l)))
                  | "iconst_2" -> add 1 (JCode.OpConst(`Int (2l)))
                  | "iconst_3" -> add 1 (JCode.OpConst(`Int (3l)))
                  | "iconst_4" -> add 1 (JCode.OpConst(`Int (4l)))
                  | "iconst_5" -> add 1 (JCode.OpConst(`Int (5l)))
                  | "iconst_m1" -> add 1 (JCode.OpConst(`Int (-1l)))
                  | "idiv" -> add 1 (JCode.OpDiv `Int2Bool)
                  | "iload_0" -> add 1 (JCode.OpLoad (`Int2Bool, 0))
                  | "iload_1" -> add 1 (JCode.OpLoad (`Int2Bool, 1))
                  | "iload_2" -> add 1 (JCode.OpLoad (`Int2Bool, 2))
                  | "iload_3" -> add 1 (JCode.OpLoad (`Int2Bool, 3))
                  | "imul" -> add 1 (JCode.OpMult `Int2Bool)
                  | "ineg" -> add 1 (JCode.OpNeg `Int2Bool)
                  | "int2byte" -> add 1 (JCode.OpI2B)
                  | "int2char" -> add 1 (JCode.OpI2C)
                  | "int2short" -> add 1 (JCode.OpI2S)
                  (*
                  | "invokedynamic", "method" -> add 1 ()
                  *)
                  | "ior" -> add 1 (JCode.OpIOr)
                  | "irem" -> add 1 (JCode.OpRem `Int2Bool)
                  | "ireturn" -> add 1 (JCode.OpReturn `Int2Bool)
                  | "ishl" -> add 1 (JCode.OpIShl)
                  | "ishr" -> add 1 (JCode.OpIShr)
                  | "istore_0" -> add 1 (JCode.OpStore (`Int2Bool, 0))
                  | "istore_1" -> add 1 (JCode.OpStore (`Int2Bool, 1))
                  | "istore_2" -> add 1 (JCode.OpStore (`Int2Bool, 2))
                  | "istore_3" -> add 1 (JCode.OpStore (`Int2Bool, 3))
                  | "isub" -> add 1 (JCode.OpSub `Int2Bool)
                  | "iushr" -> add 1 (JCode.OpIUShr)
                  | "ixor" -> add 1 (JCode.OpIXor)
                  (* L *)
                  | "l2f" -> add 1 (JCode.OpL2F)
                  | "l2d" -> add 1 (JCode.OpL2D)
                  | "l2i" -> add 1 (JCode.OpL2I)
                  | "ladd" -> add 1 (JCode.OpAdd `Long)
                  | "laload" ->add 1 (JCode.OpArrayLoad `Long)
                  | "land" -> add 1 (JCode.OpLAnd)
                  | "lastore" -> add 1 (JCode.OpArrayStore `Long)
                  | "lcmp" -> add 1 (JCode.OpCmp `L)
                  | "lconst_0" -> add 1 (JCode.OpConst(`Long (Int64.of_int 0)))
                  | "lconst_1" -> add 1 (JCode.OpConst(`Long (Int64.of_int 1)))
                  | "ldiv" -> add 1 (JCode.OpDiv `Long)
                  | "lload_0" -> add 1 (JCode.OpLoad (`Long, 0))
                  | "lload_1" -> add 1 (JCode.OpLoad (`Long, 1))
                  | "lload_2" -> add 1 (JCode.OpLoad (`Long, 2))
                  | "lload_3" -> add 1 (JCode.OpLoad (`Long, 3))
                  | "lmul" -> add 1 (JCode.OpMult `Long)
                  | "lneg" -> add 1 (JCode.OpNeg `Long)
                  | "lor" -> add 1 (JCode.OpLOr)
                  | "lrem" -> add 1 (JCode.OpRem `Long)
                  | "lreturn" -> add 1 (JCode.OpReturn `Long)
                  | "lshl" -> add 1 (JCode.OpLShl)
                  | "lshr" -> add 1 (JCode.OpLShr)
                  | "lstore_0" -> add 1 (JCode.OpStore (`Long, 0))
                  | "lstore_1" -> add 1 (JCode.OpStore (`Long, 1))
                  | "lstore_2" -> add 1 (JCode.OpStore (`Long, 2))
                  | "lstore_3" -> add 1 (JCode.OpStore (`Long, 3))
                  | "lsub" -> add 1 (JCode.OpSub `Long)
                  | "lushr" -> add 1 (JCode.OpLUShr)
                  | "lxor" -> add 1 (JCode.OpLXor)
                  (* M *)
                  | "monitorenter" -> add 1 (JCode.OpMonitorEnter)
                  | "monitorexit" -> add 1 (JCode.OpMonitorExit)
                  (* N *)
                  | "nop" -> add 1 (JCode.OpNop)
                  (* P *)
                  | "pop" -> add 1 (JCode.OpPop)
                  | "pop2" -> add 1 (JCode.OpPop2)
                  (* R *)
                  | "return" -> add 1 (JCode.OpReturn `Void)
                  (* S *)
                  | "saload" -> add 1 (JCode.OpArrayLoad `Short)
                  | "sastore" -> add 1 (JCode.OpArrayStore `Short)
                  | "swap" -> add 1 (JCode.OpSwap)
                  | a -> Printf.printf "Inst(%S, %S)\n" a (snd _1); assert false
                )}
| _1 = Insn _2 = Int _3 = Int
    {                               (
                  match(fst _1,snd _1, _2,_3)with
                  | "iinc", "ii", i1, i2 -> add 6 (JCode.OpIInc (i1, i2))
                  | "iinc", "Ii", i1, i2 -> add 6 (JCode.OpIInc (i1, i2))
                  | a,b,i1,i2 ->
                    Printf.printf "InstIntInt(%S, %S, %d, %d)\n" a b i1 i2;
                    assert false
                )}
| _1 = Insn _2 = Int
    {                           (
                  match(fst _1,snd _1, _2)with
                  (* A *)
                  | "aload", _, 0 -> add 1 (JCode.OpLoad (`Object, 0))
                  | "aload", _, 1 -> add 1 (JCode.OpLoad (`Object, 1))
                  | "aload", _, 2 -> add 1 (JCode.OpLoad (`Object, 2))
                  | "aload", _, 3 -> add 1 (JCode.OpLoad (`Object, 3))
                  | "aload", "i", n -> add 2 (JCode.OpLoad(`Object, n))
                  | "aload", "I", n -> add 3 (JCode.OpLoad(`Object, n))
                  | "astore", _, 0 -> add 1 (JCode.OpStore (`Object, 0))
                  | "astore", _, 1 -> add 1 (JCode.OpStore (`Object, 1))
                  | "astore", _, 2 -> add 1 (JCode.OpStore (`Object, 2))
                  | "astore", _, 3 -> add 1 (JCode.OpStore (`Object, 3))
                  | "astore", "i", n -> add 2 (JCode.OpStore(`Object, n))
                  | "astore", "I", n -> add 3 (JCode.OpStore(`Object, n))
                  (* B *)
                  | "bipush", "i", n -> add 2 (JCode.OpConst(`Byte n))
                  (* D *)
                  | "dload", _, 0 -> add 1 (JCode.OpLoad (`Double, 0))
                  | "dload", _, 1 -> add 1 (JCode.OpLoad (`Double, 1))
                  | "dload", _, 2 -> add 1 (JCode.OpLoad (`Double, 2))
                  | "dload", _, 3 -> add 1 (JCode.OpLoad (`Double, 3))
                  | "dload", "i", i -> add 2 (JCode.OpLoad (`Double, i))
                  | "dload", "I", n -> add 3 (JCode.OpLoad (`Double, n))
                  | "dstore", _, 0 -> add 1 (JCode.OpStore (`Double, 0))
                  | "dstore", _, 1 -> add 1 (JCode.OpStore (`Double, 1))
                  | "dstore", _, 2 -> add 1 (JCode.OpStore (`Double, 2))
                  | "dstore", _, 3 -> add 1 (JCode.OpStore (`Double, 3))
                  | "dstore", "i", i -> add 2 (JCode.OpStore (`Double, i))
                  | "dstore", "I", n -> add 3 (JCode.OpStore (`Double, n))
                  (* F *)
                  | "fload", _, 0 -> add 1 (JCode.OpLoad (`Float, 0))
                  | "fload", _, 1 -> add 1 (JCode.OpLoad (`Float, 1))
                  | "fload", _, 2 -> add 1 (JCode.OpLoad (`Float, 2))
                  | "fload", _, 3 -> add 1 (JCode.OpLoad (`Float, 3))
                  | "fload", "i", i -> add 2 (JCode.OpLoad (`Float, i))
                  | "fload", "I", n -> add 3 (JCode.OpLoad (`Float, n))
                  | "fstore", _, 0 -> add 1 (JCode.OpStore (`Float, 0))
                  | "fstore", _, 1 -> add 1 (JCode.OpStore (`Float, 1))
                  | "fstore", _, 2 -> add 1 (JCode.OpStore (`Float, 2))
                  | "fstore", _, 3 -> add 1 (JCode.OpStore (`Float, 3))
                  | "fstore", "i", i -> add 2 (JCode.OpStore (`Float, i))
                  | "fstore", "I", n -> add 3 (JCode.OpStore (`Float, n))
                  (* G *)
                  | "goto", "label", n -> add 3 (JCode.OpGoto n)
                  | "goto_w", "label", n -> add 3 (JCode.OpGoto n)
                  (* I *)
                  | "if_acmpeq", "label", n -> add 3 (JCode.OpIfCmp (`AEq, n))
                  | "if_acmpne", "label", n -> add 3 (JCode.OpIfCmp (`ANe, n))
                  | "if_icmpeq", "label", n -> add 3 (JCode.OpIfCmp (`IEq, n))
                  | "if_icmpge", "label", n -> add 3 (JCode.OpIfCmp (`IGe, n))
                  | "if_icmpgt", "label", n -> add 3 (JCode.OpIfCmp (`IGt, n))
                  | "if_icmple", "label", n -> add 3 (JCode.OpIfCmp (`ILe, n))
                  | "if_icmplt", "label", n -> add 3 (JCode.OpIfCmp (`ILt, n))
                  | "if_icmpne", "label", n -> add 3 (JCode.OpIfCmp (`INe, n))
                  | "ifeq", "label", n -> add 3 (JCode.OpIf (`Eq, n))
                  | "ifge", "label", n -> add 3 (JCode.OpIf (`Ge, n))
                  | "ifgt", "label", n -> add 3 (JCode.OpIf (`Gt, n))
                  | "ifle", "label", n -> add 3 (JCode.OpIf (`Le, n))
                  | "iflt", "label", n -> add 3 (JCode.OpIf (`Lt, n))
                  | "ifne", "label", n -> add 3 (JCode.OpIf (`Ne, n))
                  | "ifnonnull", "label", n -> add 3 (JCode.OpIf (`NonNull, n))
                  | "ifnull", "label", n -> add 3 (JCode.OpIf (`Null, n))
                  | "iload", _, 0 -> add 1 (JCode.OpLoad (`Int2Bool, 0))
                  | "iload", _, 1 -> add 1 (JCode.OpLoad (`Int2Bool, 1))
                  | "iload", _, 2 -> add 1 (JCode.OpLoad (`Int2Bool, 2))
                  | "iload", _, 3 -> add 1 (JCode.OpLoad (`Int2Bool, 3))
                  | "iload", "i", n -> add 2 (JCode.OpLoad (`Int2Bool, n))
                  | "iload", "I", n -> add 3 (JCode.OpLoad (`Int2Bool, n))
                  | "istore", _, 0 -> add 1 (JCode.OpStore (`Int2Bool, 0))
                  | "istore", _, 1 -> add 1 (JCode.OpStore (`Int2Bool, 1))
                  | "istore", _, 2 -> add 1 (JCode.OpStore (`Int2Bool, 2))
                  | "istore", _, 3 -> add 1 (JCode.OpStore (`Int2Bool, 3))
                  | "istore", "i", i -> add 2 (JCode.OpStore (`Int2Bool, i))
                  | "istore", "I", i -> add 3 (JCode.OpStore (`Int2Bool, i))
                  (* I *)
                  | "ldc", "constant", n -> add 2 (JCode.OpConst(`Int (Int32.of_int n)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpConst(`Long (Int64.of_int d)))
                  | "lload", _, 0 -> add 1 (JCode.OpLoad (`Long, 0))
                  | "lload", _, 1 -> add 1 (JCode.OpLoad (`Long, 1))
                  | "lload", _, 2 -> add 1 (JCode.OpLoad (`Long, 2))
                  | "lload", _, 3 -> add 1 (JCode.OpLoad (`Long, 3))
                  | "lload", "i", i -> add 2 (JCode.OpLoad (`Long, i))
                  | "lload", "I", n -> add 3 (JCode.OpLoad (`Long, n))
                  | "lstore", _, 0 -> add 1 (JCode.OpStore (`Long, 0))
                  | "lstore", _, 1 -> add 1 (JCode.OpStore (`Long, 1))
                  | "lstore", _, 2 -> add 1 (JCode.OpStore (`Long, 2))
                  | "lstore", _, 3 -> add 1 (JCode.OpStore (`Long, 3))
                  | "lstore", "i", l -> add 2 (JCode.OpStore (`Long, l))
                  | "lstore", "I", l -> add 3 (JCode.OpStore (`Long, l))
                  (* R *)
                  | "ret", "i", n -> add 2 (JCode.OpRet n)
                  | "ret", "I", n -> add 3 (JCode.OpRet n)
                  (* S *)
                  | "sipush", "i", n -> add 3 (JCode.OpConst(`Short n))
                  | a,b,i1 ->
                    Printf.printf "InstInt(%S, %S, %d)\n" a b i1;
                    assert false
                )}
| _1 = Insn _2 = Num
    {                           (
                  match(fst _1,snd _1, _2)with
                  (* I *)
                  | "ldc", "constant", s -> add 2 (JCode.OpConst(`Float (float_of_string s)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpConst(`Double (float_of_string d)))
                  | a,b,s ->
                    Printf.printf "InstNum(%S, %S, %S)\n" a b s;
                    assert false
                )}
| _1 = Insn _2 = Word
    {                            (
                  match(fst _1,snd _1, _2)with
                  (* A *)
                  | "anewarray", "class", o -> add 3 (JCode.OpNewArray (JBasics.TObject (JParseSignature.parse_objectType o)))
                  (* C *)
                  | "checkcast", "class", w ->
                    add 3 (JCode.OpCheckCast (JParseSignature.parse_objectType w))
                  (* G *)
                  | "goto", "label", l -> add 3 (JCode.OpGoto(label2int l))
                  | "goto_w", "label", l -> add 3 (JCode.OpGoto(label2int l))
                  (* I *)
                  | "if_acmpeq", "label", l -> add 3 (JCode.OpIfCmp (`AEq, label2int l))
                  | "if_acmpne", "label", l -> add 3 (JCode.OpIfCmp (`ANe, label2int l))
                  | "if_icmpeq", "label", l -> add 3 (JCode.OpIfCmp (`IEq, label2int l))
                  | "if_icmpge", "label", l -> add 3 (JCode.OpIfCmp (`IGe, label2int l))
                  | "if_icmpgt", "label", l -> add 3 (JCode.OpIfCmp (`IGt, label2int l))
                  | "if_icmple", "label", l -> add 3 (JCode.OpIfCmp (`ILe, label2int l))
                  | "if_icmplt", "label", l -> add 3 (JCode.OpIfCmp (`ILt, label2int l))
                  | "if_icmpne", "label", l -> add 3 (JCode.OpIfCmp (`INe, label2int l))
                  | "ifeq", "label", l -> add 3 (JCode.OpIf (`Eq, label2int l))
                  | "ifge", "label", l -> add 3 (JCode.OpIf (`Ge, label2int l))
                  | "ifgt", "label", l -> add 3 (JCode.OpIf (`Gt, label2int l))
                  | "ifle", "label", l -> add 3 (JCode.OpIf (`Le, label2int l))
                  | "iflt", "label", l -> add 3 (JCode.OpIf (`Lt, label2int l))
                  | "ifne", "label", l -> add 3 (JCode.OpIf (`Ne, label2int l))
                  | "instanceof", "class", o -> add 3 (JCode.OpInstanceOf (JParseSignature.parse_objectType o))
                  | "invokenonvirtual", "method", m ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let (args,r) = JParseSignature.parse_method_descriptor f in
                    add 3(JCode.OpInvoke (`Special (JBasics.make_cn name), JBasics.make_ms o args r))
                  | "invokestatic", "method", m ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let (args,r) = JParseSignature.parse_method_descriptor f in
                    add 3(JCode.OpInvoke (`Static (JBasics.make_cn name), JBasics.make_ms o args r))
                  | "invokevirtual", "method", m ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let (args,r) = JParseSignature.parse_method_descriptor f in
                    add 3(JCode.OpInvoke (`Virtual ((JBasics.TClass (JBasics.make_cn name))), JBasics.make_ms o args r))
                  (* J *)
                  | "jsr","label",label -> add 3 (JCode.OpJsr((label2int label)))
                  | "jsr_w","label",label -> add 3 (JCode.OpJsr((label2int label)))
                  | "ldc", "constant", d -> add 2 (JCode.OpConst(`Float (float_of_string d)))
                  | "ldc2_w", "bigconstant", d -> add 3 (JCode.OpConst(`Double (float_of_string d)))
                  (* N *)
                  | "new", "class", o -> add 3 (JCode.OpNew (JBasics.make_cn (replace_dot o)))
                  | "newarray", "atype", t ->
                    let a = JParseSignature.parse_field_descriptor (cbasic t) in
                    add 2 (JCode.OpNewArray a)
                  | a,b,s ->
                    Printf.printf "InstWord(%S, %S, %S)\n" a b s;
                    assert false
                )}
| _1 = Insn _2 = Word _3 = Int
    {                                (
                  match(fst _1,snd _1, _2,_3)with
                  (* I *)
                  | "invokeinterface", "interface", m, i ->
                    let (obj,f) = split_method m in
                    let (name,o) = split_obj obj in
                    let (args,r) = JParseSignature.parse_method_descriptor f in
                    add 5(JCode.OpInvoke (`Interface (JBasics.make_cn name), JBasics.make_ms o args r))
                  (* M *)
                  | "multianewarray", "marray", t, i ->
                    add 4 (JCode.OpAMultiNewArray ((JParseSignature.parse_objectType t), i))
                  | a,b,s,i ->
                    Printf.printf "InstWordInt(%S, %S, %S, %d)\n" a b s i;
                    assert false
                )}
| _1 = Insn _2 = Word _3 = Word
    {                                 (
                  match(fst _1, _2,_3)with
                  | "getfield", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let fd = JParseSignature.parse_field_descriptor fd in
                    add 3 (JCode.OpGetField (JBasics.make_cn c, JBasics.make_fs f fd))
                  | "getstatic", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let fd = JParseSignature.parse_field_descriptor fd in
                    add 3 (JCode.OpGetStatic (JBasics.make_cn c, JBasics.make_fs f fd))
                  | "putfield", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let fd = JParseSignature.parse_field_descriptor fd in
                    add 3 (JCode.OpPutField (JBasics.make_cn c, JBasics.make_fs f fd))
                  | "putstatic", cf, fd ->
                    let (c,f) = split_obj(cf) in
                    let fd = JParseSignature.parse_field_descriptor fd in
                    add 3 (JCode.OpPutStatic (JBasics.make_cn c, JBasics.make_fs f fd))
                  | a, b, s2 ->
                    Printf.printf "InstWordWord(%S, %S, %S, %S)\n" a b (snd _1) s2;
                    assert false
                )}
| _1 = Insn _2 = Str
    {                           (
                  match(fst _1,snd _1, unescape _2)with
                  | "ldc", "constant", s -> add 2 (JCode.OpConst(`String (JBasics.make_jstr s)))
                  | a,b,s ->
                    Printf.printf "InstStr(%S, %S, %S)\n" a b s;
                    assert false
                )}
| _1 = Insn _2 = Relative
    {                                (
                  match(fst _1, snd _1,_2)with
                  | a,b,s ->
                    Printf.printf "InstRelative(%S, %S, %S)\n" a b s;
                    assert false
                )}

complex_instruction:
  _1 = LOOKUPSWITCH _2 = lookup
    {                                      ( _2 )}
| _1 = TABLESWITCH _2 = table
    {                                    ( _2 )}

lookup:
  _1 = lookup_args _2 = lookup_list _3 = lookup_default
    {                    (
                      let a =
                        match _3 with
                        | DefaultInt i -> i
                        | DefaultWord l -> label2int l
                      in
                      let ls = List.map(function
                        | CaseIntInt(i, j)-> (Int32.of_int i, j)
                        | CaseIntWord(i, j) -> (Int32.of_int i, (label2int j))
                      ) _2 in
                      let padding_size = (4 - (!pos + 1) mod 4) mod 4 in
                      let n = 9 + padding_size + 8 * (List.length _2) in
                      add n (JCode.OpLookupSwitch (a, ls))

                    )}

lookup_args:
  _1 = SEP
    {                          ( () )}

lookup_list:
  _1 = lookup_entry _2 = lookup_list
    {                                               ( _1 :: _2 )}
| _1 = lookup_entry
    {                                   ( [_1] )}

lookup_entry:
  _1 = Int _2 = COLON _3 = Word _4 = SEP
    {                                           ( CaseIntWord(_1,_3) )}
| _1 = Int _2 = COLON _3 = Int _4 = SEP
    {                                          ( CaseIntInt(_1,_3) )}

lookup_default:
  _1 = DEFAULT _2 = COLON _3 = Word
    {                                         ( DefaultWord _3 )}
| _1 = DEFAULT _2 = COLON _3 = Int
    {                                        ( DefaultInt _3 )}

table:
  _1 = table_args _2 = table_list _3 = table_default
    {                    (
                      (* T *)
                      let (low,high,defs,def) = (fst _1,snd _1,_2,_3) in
                      let default2int = function
                        | DefaultInt i -> i
                        | DefaultWord l -> label2int l
                      in
                      let defs = List.map default2int defs in
                      let defs = Array.of_list defs in
                      let padding_size = (4 - ((!pos + 1) mod 4)) mod 4 in
                      let n = 13 + padding_size + 4 * (Array.length defs) in
                      let high = if high = -1 then Array.length defs - 1 + low else high in
                      add n (JCode.OpTableSwitch ((default2int def), Int32.of_int low, Int32.of_int high, defs))
                    )}

table_args:
  _1 = Int _2 = SEP
    {                              ( (_1,-1) )}
| _1 = Int _2 = Int _3 = SEP
    {                                  ( (_1, _2) )}

table_list:
  _1 = table_entry _2 = table_list
    {                                             ( _1::_2 )}
| _1 = table_entry
    {                                  ( [_1] )}

table_entry:
  _1 = Word _2 = SEP
    {                                 ( DefaultWord(_1) )}
| _1 = Int _2 = SEP
    {                                ( DefaultInt(_1) )}

table_default:
  _1 = DEFAULT _2 = COLON _3 = Word
    {                                         ( DefaultWord(_3) )}
| _1 = DEFAULT _2 = COLON _3 = Int
    {                                        ( DefaultInt(_3) )}

%%
