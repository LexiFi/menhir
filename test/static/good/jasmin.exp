Grammar has 88 nonterminal symbols, among which 1 start symbols.
Grammar has 71 terminal symbols.
Grammar has 213 productions.
nullable(writable) = false
nullable(var) = false
nullable(utype) = false
nullable(top_annotation) = false
nullable(top) = false
nullable(swsize) = false
nullable(svsize) = false
nullable(struct_annot) = true
nullable(storage) = false
nullable(stor_type) = false
nullable(simple_attribute) = false
nullable(separated_nonempty_list(option(COMMA),var)) = false
nullable(separated_nonempty_list(empty,var)) = false
nullable(separated_nonempty_list(COMMA,var)) = false
nullable(separated_nonempty_list(COMMA,range)) = false
nullable(separated_nonempty_list(COMMA,plvalue)) = false
nullable(separated_nonempty_list(COMMA,pexpr)) = false
nullable(separated_nonempty_list(COMMA,annotation)) = false
nullable(separated_nonempty_list(COMMA,annot_stor_type)) = false
nullable(separated_nonempty_list(COMMA,annot_pvardecl)) = false
nullable(range) = false
nullable(ptype_r) = false
nullable(ptype) = false
nullable(ptr) = true
nullable(prim) = false
nullable(prequire1) = false
nullable(prequire) = false
nullable(pparam) = false
nullable(pointer) = false
nullable(plvalues) = false
nullable(plvalue_r) = false
nullable(plvalue) = false
nullable(pinstr_r) = false
nullable(pinstr) = false
nullable(pglobal) = false
nullable(pgexpr) = false
nullable(pfundef) = false
nullable(pfunbody) = false
nullable(pexpr_r) = false
nullable(pexpr) = false
nullable(pexec) = false
nullable(peqop) = false
nullable(pblock_r) = false
nullable(pblock) = false
nullable(option(writable)) = true
nullable(option(utype)) = true
nullable(option(prefix(RARROW,tuple(annot_stor_type)))) = true
nullable(option(prefix(IF,pexpr))) = true
nullable(option(pointer)) = true
nullable(option(pblock)) = true
nullable(option(parens(utype))) = true
nullable(option(mem_ofs)) = true
nullable(option(loc(castop1))) = true
nullable(option(from)) = true
nullable(option(call_conv)) = true
nullable(option(attribute)) = true
nullable(option(arr_access_len)) = true
nullable(option(__anonymous_1)) = true
nullable(option(DOT)) = true
nullable(option(COMMA)) = true
nullable(nonempty_list(prequire1)) = false
nullable(module_) = false
nullable(loption(separated_nonempty_list(COMMA,var))) = true
nullable(loption(separated_nonempty_list(COMMA,range))) = true
nullable(loption(separated_nonempty_list(COMMA,pexpr))) = true
nullable(loption(separated_nonempty_list(COMMA,annotation))) = true
nullable(loption(separated_nonempty_list(COMMA,annot_stor_type))) = true
nullable(loption(separated_nonempty_list(COMMA,annot_pvardecl))) = true
nullable(list(top_annotation)) = true
nullable(list(pinstr)) = true
nullable(list(loc(top))) = true
nullable(keyword) = false
nullable(int) = false
nullable(implicites) = false
nullable(from) = false
nullable(castop1) = false
nullable(castop) = true
nullable(cast) = false
nullable(call_conv) = false
nullable(attribute) = false
nullable(arr_access_len) = false
nullable(arr_access_i) = false
nullable(arr_access) = false
nullable(annotations) = true
nullable(annotationlabel) = false
nullable(annotation) = false
nullable(annot_stor_type) = false
nullable(annot_pvardecl) = false
first(writable) = MUTABLE CONSTANT
first(var) = NID
first(utype) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128
first(top_annotation) = SHARP
first(top) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC
first(swsize) = SWSIZE
first(svsize) = SVSIZE
first(struct_annot) = STRING STACK REG NID INLINE EXPORT
first(storage) = STACK REG INLINE GLOBAL
first(stor_type) = STACK REG INLINE GLOBAL
first(simple_attribute) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 STRING STACK REG NID MINUS INT INLINE EXPORT
first(separated_nonempty_list(option(COMMA),var)) = NID
first(separated_nonempty_list(empty,var)) = NID
first(separated_nonempty_list(COMMA,var)) = NID
first(separated_nonempty_list(COMMA,range)) = INT
first(separated_nonempty_list(COMMA,plvalue)) = UNDERSCORE NID LPAREN LBRACKET
first(separated_nonempty_list(COMMA,pexpr)) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
first(separated_nonempty_list(COMMA,annotation)) = STRING STACK REG NID INLINE EXPORT
first(separated_nonempty_list(COMMA,annot_stor_type)) = STACK SHARP REG INLINE GLOBAL
first(separated_nonempty_list(COMMA,annot_pvardecl)) = STACK SHARP REG INLINE GLOBAL
first(range) = INT
first(ptype_r) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
first(ptype) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
first(ptr) = POINTER MUTABLE CONSTANT
first(prim) = SHARP
first(prequire1) = STRING
first(prequire) = REQUIRE FROM
first(pparam) = PARAM
first(pointer) = POINTER MUTABLE CONSTANT
first(plvalues) = UNDERSCORE QUESTIONMARK NID LPAREN LBRACKET
first(plvalue_r) = UNDERSCORE NID LPAREN LBRACKET
first(plvalue) = UNDERSCORE NID LPAREN LBRACKET
first(pinstr_r) = WHILE UNDERSCORE STACK REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ARRAYINIT
first(pinstr) = WHILE UNDERSCORE STACK SHARP REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ARRAYINIT
first(pglobal) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
first(pgexpr) = TRUE SHARP NID MINUS LPAREN LBRACKET LBRACE INT FALSE BANG
first(pfundef) = SHARP INLINE FN EXPORT
first(pfunbody) = LBRACE
first(pexpr_r) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
first(pexpr) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
first(pexec) = EXEC
first(peqop) = STAR PLUS PIPE MINUS LTLT HAT GTGT EQ AMP
first(pblock_r) = LBRACE
first(pblock) = LBRACE
first(option(writable)) = MUTABLE CONSTANT
first(option(utype)) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128
first(option(prefix(RARROW,tuple(annot_stor_type)))) = RARROW
first(option(prefix(IF,pexpr))) = IF
first(option(pointer)) = POINTER MUTABLE CONSTANT
first(option(pblock)) = LBRACE
first(option(parens(utype))) = LPAREN
first(option(mem_ofs)) = PLUS MINUS
first(option(loc(castop1))) = SWSIZE SVSIZE
first(option(from)) = FROM
first(option(call_conv)) = INLINE EXPORT
first(option(attribute)) = EQ
first(option(arr_access_len)) = COLON
first(option(__anonymous_1)) = RETURN
first(option(DOT)) = DOT
first(option(COMMA)) = COMMA
first(nonempty_list(prequire1)) = STRING
first(module_) = error T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
first(loption(separated_nonempty_list(COMMA,var))) = NID
first(loption(separated_nonempty_list(COMMA,range))) = INT
first(loption(separated_nonempty_list(COMMA,pexpr))) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
first(loption(separated_nonempty_list(COMMA,annotation))) = STRING STACK REG NID INLINE EXPORT
first(loption(separated_nonempty_list(COMMA,annot_stor_type))) = STACK SHARP REG INLINE GLOBAL
first(loption(separated_nonempty_list(COMMA,annot_pvardecl))) = STACK SHARP REG INLINE GLOBAL
first(list(top_annotation)) = SHARP
first(list(pinstr)) = WHILE UNDERSCORE STACK SHARP REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ARRAYINIT
first(list(loc(top))) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC
first(keyword) = STACK REG INLINE EXPORT
first(int) = MINUS INT
first(implicites) = QUESTIONMARK
first(from) = FROM
first(castop1) = SWSIZE SVSIZE
first(castop) = SWSIZE SVSIZE
first(cast) = T_INT SWSIZE
first(call_conv) = INLINE EXPORT
first(attribute) = EQ
first(arr_access_len) = COLON
first(arr_access_i) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
first(arr_access) = LBRACKET DOT
first(annotations) = SHARP
first(annotationlabel) = STRING STACK REG NID INLINE EXPORT
first(annotation) = STRING STACK REG NID INLINE EXPORT
first(annot_stor_type) = STACK SHARP REG INLINE GLOBAL
first(annot_pvardecl) = STACK SHARP REG INLINE GLOBAL
minimal(writable) = (* 1 *) CONSTANT
minimal(var) = (* 1 *) NID
minimal(utype) = (* 1 *) T_U8
minimal(top_annotation) = (* 2 *) SHARP NID
minimal(top) = (* 2 *) REQUIRE STRING
minimal(swsize) = (* 1 *) SWSIZE
minimal(svsize) = (* 1 *) SVSIZE
minimal(struct_annot) = (* 0 *)
minimal(storage) = (* 1 *) REG
minimal(stor_type) = (* 2 *) REG T_BOOL
minimal(simple_attribute) = (* 1 *) INT
minimal(separated_nonempty_list(option(COMMA),var)) = (* 1 *) NID
minimal(separated_nonempty_list(empty,var)) = (* 1 *) NID
minimal(separated_nonempty_list(COMMA,var)) = (* 1 *) NID
minimal(separated_nonempty_list(COMMA,range)) = (* 3 *) INT COLON INT
minimal(separated_nonempty_list(COMMA,plvalue)) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(COMMA,pexpr)) = (* 1 *) NID
minimal(separated_nonempty_list(COMMA,annotation)) = (* 1 *) NID
minimal(separated_nonempty_list(COMMA,annot_stor_type)) = (* 2 *) REG T_BOOL
minimal(separated_nonempty_list(COMMA,annot_pvardecl)) = (* 3 *) REG T_BOOL NID
minimal(range) = (* 3 *) INT COLON INT
minimal(ptype_r) = (* 1 *) T_BOOL
minimal(ptype) = (* 1 *) T_BOOL
minimal(ptr) = (* 0 *)
minimal(prim) = (* 2 *) SHARP NID
minimal(prequire1) = (* 1 *) STRING
minimal(prequire) = (* 2 *) REQUIRE STRING
minimal(pparam) = (* 6 *) PARAM T_BOOL NID EQ NID SEMICOLON
minimal(pointer) = (* 1 *) POINTER
minimal(plvalues) = (* 1 *) UNDERSCORE
minimal(plvalue_r) = (* 1 *) UNDERSCORE
minimal(plvalue) = (* 1 *) UNDERSCORE
minimal(pinstr_r) = (* 4 *) UNDERSCORE EQ NID SEMICOLON
minimal(pinstr) = (* 4 *) UNDERSCORE EQ NID SEMICOLON
minimal(pglobal) = (* 5 *) T_BOOL NID EQ NID SEMICOLON
minimal(pgexpr) = (* 1 *) NID
minimal(pfundef) = (* 6 *) FN NID LPAREN RPAREN LBRACE RBRACE
minimal(pfunbody) = (* 2 *) LBRACE RBRACE
minimal(pexpr_r) = (* 1 *) NID
minimal(pexpr) = (* 1 *) NID
minimal(pexec) = (* 4 *) EXEC NID LPAREN RPAREN
minimal(peqop) = (* 1 *) EQ
minimal(pblock_r) = (* 2 *) LBRACE RBRACE
minimal(pblock) = (* 2 *) LBRACE RBRACE
minimal(option(writable)) = (* 0 *)
minimal(option(utype)) = (* 0 *)
minimal(option(prefix(RARROW,tuple(annot_stor_type)))) = (* 0 *)
minimal(option(prefix(IF,pexpr))) = (* 0 *)
minimal(option(pointer)) = (* 0 *)
minimal(option(pblock)) = (* 0 *)
minimal(option(parens(utype))) = (* 0 *)
minimal(option(mem_ofs)) = (* 0 *)
minimal(option(loc(castop1))) = (* 0 *)
minimal(option(from)) = (* 0 *)
minimal(option(call_conv)) = (* 0 *)
minimal(option(attribute)) = (* 0 *)
minimal(option(arr_access_len)) = (* 0 *)
minimal(option(__anonymous_1)) = (* 0 *)
minimal(option(DOT)) = (* 0 *)
minimal(option(COMMA)) = (* 0 *)
minimal(nonempty_list(prequire1)) = (* 1 *) STRING
minimal(module_) = (* 1 *) EOF
minimal(loption(separated_nonempty_list(COMMA,var))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,range))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,pexpr))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,annotation))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,annot_stor_type))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,annot_pvardecl))) = (* 0 *)
minimal(list(top_annotation)) = (* 0 *)
minimal(list(pinstr)) = (* 0 *)
minimal(list(loc(top))) = (* 0 *)
minimal(keyword) = (* 1 *) INLINE
minimal(int) = (* 1 *) INT
minimal(implicites) = (* 3 *) QUESTIONMARK LBRACE RBRACE
minimal(from) = (* 2 *) FROM NID
minimal(castop1) = (* 1 *) SWSIZE
minimal(castop) = (* 0 *)
minimal(cast) = (* 1 *) T_INT
minimal(call_conv) = (* 1 *) EXPORT
minimal(attribute) = (* 2 *) EQ INT
minimal(arr_access_len) = (* 2 *) COLON NID
minimal(arr_access_i) = (* 1 *) NID
minimal(arr_access) = (* 3 *) LBRACKET NID RBRACKET
minimal(annotations) = (* 0 *)
minimal(annotationlabel) = (* 1 *) NID
minimal(annotation) = (* 1 *) NID
minimal(annot_stor_type) = (* 2 *) REG T_BOOL
minimal(annot_pvardecl) = (* 3 *) REG T_BOOL NID
maximal(writable) = 1
maximal(var) = 1
maximal(utype) = 1
maximal(top_annotation) = infinity
maximal(top) = infinity
maximal(swsize) = 1
maximal(svsize) = 1
maximal(struct_annot) = infinity
maximal(storage) = 3
maximal(stor_type) = infinity
maximal(simple_attribute) = 2
maximal(separated_nonempty_list(option(COMMA),var)) = infinity
maximal(separated_nonempty_list(empty,var)) = infinity
maximal(separated_nonempty_list(COMMA,var)) = infinity
maximal(separated_nonempty_list(COMMA,range)) = infinity
maximal(separated_nonempty_list(COMMA,plvalue)) = infinity
maximal(separated_nonempty_list(COMMA,pexpr)) = infinity
maximal(separated_nonempty_list(COMMA,annotation)) = infinity
maximal(separated_nonempty_list(COMMA,annot_stor_type)) = infinity
maximal(separated_nonempty_list(COMMA,annot_pvardecl)) = infinity
maximal(range) = 3
maximal(ptype_r) = infinity
maximal(ptype) = infinity
maximal(ptr) = 2
maximal(prim) = 2
maximal(prequire1) = 1
maximal(prequire) = infinity
maximal(pparam) = infinity
maximal(pointer) = 2
maximal(plvalues) = infinity
maximal(plvalue_r) = infinity
maximal(plvalue) = infinity
maximal(pinstr_r) = infinity
maximal(pinstr) = infinity
maximal(pglobal) = infinity
maximal(pgexpr) = infinity
maximal(pfundef) = infinity
maximal(pfunbody) = infinity
maximal(pexpr_r) = infinity
maximal(pexpr) = infinity
maximal(pexec) = infinity
maximal(peqop) = 3
maximal(pblock_r) = infinity
maximal(pblock) = infinity
maximal(option(writable)) = 1
maximal(option(utype)) = 1
maximal(option(prefix(RARROW,tuple(annot_stor_type)))) = infinity
maximal(option(prefix(IF,pexpr))) = infinity
maximal(option(pointer)) = 2
maximal(option(pblock)) = infinity
maximal(option(parens(utype))) = 3
maximal(option(mem_ofs)) = infinity
maximal(option(loc(castop1))) = 1
maximal(option(from)) = 2
maximal(option(call_conv)) = 1
maximal(option(attribute)) = infinity
maximal(option(arr_access_len)) = infinity
maximal(option(__anonymous_1)) = infinity
maximal(option(DOT)) = 1
maximal(option(COMMA)) = 1
maximal(nonempty_list(prequire1)) = infinity
maximal(module_) = infinity
maximal(loption(separated_nonempty_list(COMMA,var))) = infinity
maximal(loption(separated_nonempty_list(COMMA,range))) = infinity
maximal(loption(separated_nonempty_list(COMMA,pexpr))) = infinity
maximal(loption(separated_nonempty_list(COMMA,annotation))) = infinity
maximal(loption(separated_nonempty_list(COMMA,annot_stor_type))) = infinity
maximal(loption(separated_nonempty_list(COMMA,annot_pvardecl))) = infinity
maximal(list(top_annotation)) = infinity
maximal(list(pinstr)) = infinity
maximal(list(loc(top))) = infinity
maximal(keyword) = 1
maximal(int) = 2
maximal(implicites) = infinity
maximal(from) = 2
maximal(castop1) = 1
maximal(castop) = 1
maximal(cast) = 1
maximal(call_conv) = 1
maximal(attribute) = infinity
maximal(arr_access_len) = infinity
maximal(arr_access_i) = infinity
maximal(arr_access) = infinity
maximal(annotations) = infinity
maximal(annotationlabel) = 1
maximal(annotation) = infinity
maximal(annot_stor_type) = infinity
maximal(annot_pvardecl) = infinity
follow(writable) = POINTER
follow(var) = TO STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTIONMARK PLUS PIPEPIPE PIPE PERCENT NID MINUS LTLT LT LPAREN LE LBRACKET LBRACE IF HAT GTGT GT GE EQEQ EQ DOWNTO DOT COMMA COLON BANGEQ AMPAMP AMP
follow(utype) = WHILE UNDERSCORE TRUE STACK SHARP RPAREN REG RBRACKET RBRACE QUESTIONMARK NID MINUS LPAREN LBRACKET LBRACE INT INLINE IF GLOBAL FOR FN FALSE EXPORT COMMA BANG ARRAYINIT
follow(top_annotation) = WHILE UNDERSCORE STACK SHARP REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT ARRAYINIT
follow(top) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(swsize) = TRUE SHARP RPAREN NID MINUS LPAREN LBRACKET INT FALSE EQ BANG
follow(svsize) = TRUE SHARP RPAREN NID MINUS LPAREN LBRACKET INT FALSE EQ BANG
follow(struct_annot) = RBRACKET RBRACE
follow(storage) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
follow(stor_type) = RPAREN NID LBRACE COMMA
follow(simple_attribute) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT COMMA ARRAYINIT
follow(separated_nonempty_list(option(COMMA),var)) = SEMICOLON
follow(separated_nonempty_list(empty,var)) = RPAREN COMMA
follow(separated_nonempty_list(COMMA,var)) = SEMICOLON RPAREN
follow(separated_nonempty_list(COMMA,range)) = RPAREN
follow(separated_nonempty_list(COMMA,plvalue)) = STAR RPAREN PLUS PIPE MINUS LTLT HAT GTGT EQ AMP
follow(separated_nonempty_list(COMMA,pexpr)) = RPAREN RBRACKET RBRACE
follow(separated_nonempty_list(COMMA,annotation)) = RBRACKET RBRACE
follow(separated_nonempty_list(COMMA,annot_stor_type)) = RPAREN LBRACE
follow(separated_nonempty_list(COMMA,annot_pvardecl)) = RPAREN
follow(range) = RPAREN COMMA
follow(ptype_r) = RPAREN NID LBRACE COMMA
follow(ptype) = RPAREN NID LBRACE COMMA
follow(ptr) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
follow(prim) = LPAREN
follow(prequire1) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL STRING SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(prequire) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(pparam) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(pointer) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
follow(plvalues) = STAR PLUS PIPE MINUS LTLT HAT GTGT EQ AMP
follow(plvalue_r) = STAR RPAREN PLUS PIPE MINUS LTLT HAT GTGT EQ COMMA AMP
follow(plvalue) = STAR RPAREN PLUS PIPE MINUS LTLT HAT GTGT EQ COMMA AMP
follow(pinstr_r) = WHILE UNDERSCORE STACK SHARP RETURN REG RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ARRAYINIT
follow(pinstr) = WHILE UNDERSCORE STACK SHARP RETURN REG RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ARRAYINIT
follow(pglobal) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(pgexpr) = SEMICOLON
follow(pfundef) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(pfunbody) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(pexpr_r) = TO STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTIONMARK PLUS PIPEPIPE PIPE PERCENT MINUS LTLT LT LE LBRACE IF HAT GTGT GT GE EQEQ DOWNTO COMMA COLON BANGEQ AMPAMP AMP
follow(pexpr) = TO STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTIONMARK PLUS PIPEPIPE PIPE PERCENT MINUS LTLT LT LE LBRACE IF HAT GTGT GT GE EQEQ DOWNTO COMMA COLON BANGEQ AMPAMP AMP
follow(pexec) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(peqop) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
follow(pblock_r) = WHILE UNDERSCORE STACK SHARP RETURN REG RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ELSE ARRAYINIT
follow(pblock) = WHILE UNDERSCORE STACK SHARP RETURN REG RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR ELSE ARRAYINIT
follow(option(writable)) = POINTER
follow(option(utype)) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE BANG
follow(option(prefix(RARROW,tuple(annot_stor_type)))) = LBRACE
follow(option(prefix(IF,pexpr))) = SEMICOLON
follow(option(pointer)) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL
follow(option(pblock)) = LPAREN
follow(option(parens(utype))) = LBRACKET
follow(option(mem_ofs)) = RBRACKET
follow(option(loc(castop1))) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE EQ BANG
follow(option(from)) = REQUIRE
follow(option(call_conv)) = FN
follow(option(attribute)) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT COMMA ARRAYINIT
follow(option(arr_access_len)) = RBRACKET
follow(option(__anonymous_1)) = RBRACE
follow(option(DOT)) = LBRACKET
follow(option(COMMA)) = NID
follow(nonempty_list(prequire1)) = T_U8 T_U64 T_U32 T_U256 T_U16 T_U128 T_INT T_BOOL SHARP REQUIRE PARAM INLINE FROM FN EXPORT EXEC EOF
follow(module_) = #
follow(loption(separated_nonempty_list(COMMA,var))) = SEMICOLON RPAREN
follow(loption(separated_nonempty_list(COMMA,range))) = RPAREN
follow(loption(separated_nonempty_list(COMMA,pexpr))) = RPAREN
follow(loption(separated_nonempty_list(COMMA,annotation))) = RBRACKET RBRACE
follow(loption(separated_nonempty_list(COMMA,annot_stor_type))) = RPAREN LBRACE
follow(loption(separated_nonempty_list(COMMA,annot_pvardecl))) = RPAREN
follow(list(top_annotation)) = WHILE UNDERSCORE STACK REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT ARRAYINIT
follow(list(pinstr)) = RETURN RBRACE
follow(list(loc(top))) = EOF
follow(keyword) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT EQ COMMA ARRAYINIT
follow(int) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT COMMA ARRAYINIT
follow(implicites) = STAR PLUS PIPE MINUS LTLT HAT GTGT EQ COMMA AMP
follow(from) = REQUIRE
follow(castop1) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE EQ BANG
follow(castop) = TRUE SHARP NID MINUS LPAREN LBRACKET INT FALSE EQ BANG
follow(cast) = RPAREN
follow(call_conv) = FN
follow(attribute) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT COMMA ARRAYINIT
follow(arr_access_len) = RBRACKET
follow(arr_access_i) = RBRACKET
follow(arr_access) = TO STAR SLASH SEMICOLON RPAREN RBRACKET RBRACE QUESTIONMARK PLUS PIPEPIPE PIPE PERCENT MINUS LTLT LT LE LBRACE IF HAT GTGT GT GE EQEQ EQ DOWNTO COMMA COLON BANGEQ AMPAMP AMP
follow(annotations) = WHILE UNDERSCORE STACK REG QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT ARRAYINIT
follow(annotationlabel) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT EQ COMMA ARRAYINIT
follow(annotation) = WHILE UNDERSCORE STACK SHARP REG RBRACKET RBRACE QUESTIONMARK NID LPAREN LBRACKET INLINE IF GLOBAL FOR FN EXPORT COMMA ARRAYINIT
follow(annot_stor_type) = RPAREN LBRACE COMMA
follow(annot_pvardecl) = RPAREN COMMA
Built an LR(0) automaton with 387 states.
The grammar is not SLR(1) -- 23 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 387 states.
418 shift/reduce conflicts were silently solved.
151 out of 387 states have a default reduction.
The action table is 27864 entries; 2026 non-zero; 2181 compressed.
The action table occupies roughly 4456 bytes.
The goto table is 34443 entries; 582 non-zero; 1050 compressed.
The goto table occupies roughly 2192 bytes.
The error table occupies roughly 3520 bytes.
The default_reduction table occupies roughly 424 bytes.
The lhs table occupies roughly 248 bytes.
The trace table occupies roughly 8 bytes.
