File "jml.mly", line 69, characters 16-24:
Warning: the token ASSIGNOP is unused.
File "jml.mly", line 87, characters 10-14:
Warning: the token ELSE is unused.
File "jml.mly", line 70, characters 7-9:
Warning: the token EQ is unused.
File "jml.mly", line 61, characters 16-25:
Warning: the token LEFTBRACE is unused.
File "jml.mly", line 82, characters 29-39:
Warning: the token MINUSMINUS is unused.
File "jml.mly", line 82, characters 20-28:
Warning: the token PLUSPLUS is unused.
File "jml.mly", line 61, characters 26-36:
Warning: the token RIGHTBRACE is unused.
File "jml.mly", line 86, characters 10-14:
Warning: the token THEN is unused.
Grammar has 83 nonterminal symbols, among which 1 start symbols.
Grammar has 99 terminal symbols.
Grammar has 219 productions.
nullable(when_clauses) = true
nullable(when_clause) = false
nullable(variable_declarators) = false
nullable(variable_declarator_id) = false
nullable(variable_declaration) = false
nullable(type_expr_no_name) = false
nullable(type_expr) = false
nullable(spec_var_decls) = true
nullable(spec_header) = true
nullable(spec_case_seq) = false
nullable(spec_case) = false
nullable(simple_spec_body) = false
nullable(signals_clauses) = true
nullable(signals_clause) = false
nullable(set_ref_sep) = false
nullable(set_ref_list) = true
nullable(set_ref) = false
nullable(requires_clauses) = true
nullable(requires_clause) = false
nullable(privacy) = true
nullable(primary_no_new_array) = false
nullable(primary_expr_or_name) = false
nullable(primary_expr) = false
nullable(parenthesized_name) = false
nullable(opt_expr_semicolon) = false
nullable(normal_spec_case_seq) = true
nullable(normal_spec_case) = true
nullable(normal_spec_body) = true
nullable(normal_simple_spec_body) = true
nullable(non_extending_specification) = false
nullable(name) = false
nullable(modifiers) = true
nullable(modifier) = false
nullable(method_specification) = false
nullable(measured_clauses) = true
nullable(measured_clause) = false
nullable(loop_annotation) = false
nullable(local_spec_var_decls) = false
nullable(local_spec_var_decl) = false
nullable(let_var_decls) = true
nullable(jml_specification_eof) = false
nullable(jml_specification) = true
nullable(jml_declarations) = true
nullable(jml_declaration) = false
nullable(implicit_dims) = true
nullable(ident) = false
nullable(generic_spec_case_seq) = false
nullable(generic_spec_case) = false
nullable(generic_spec_body) = false
nullable(generic_conjoinable_spec) = false
nullable(forall_var_decls) = true
nullable(forall_var_decl) = false
nullable(field_access) = false
nullable(extending_specification) = false
nullable(expr_semicolon) = false
nullable(expr_no_name) = false
nullable(expr_comma_list) = false
nullable(expr) = false
nullable(exceptional_spec_case_seq) = true
nullable(exceptional_spec_case) = true
nullable(exceptional_spec_body) = true
nullable(exceptional_simple_spec_body) = true
nullable(ensures_clauses) = true
nullable(ensures_clause) = false
nullable(diverges_clauses) = true
nullable(diverges_clause) = false
nullable(decreases_clause) = true
nullable(conjoinable_spec_seq) = false
nullable(conjoinable_spec) = false
nullable(behavior_spec) = false
nullable(behavior_conjoinable_spec) = false
nullable(base_type) = false
nullable(assignable_objects) = false
nullable(assignable_entry) = false
nullable(assignable_clauses) = true
nullable(assignable_clause) = false
nullable(assignable_any_object) = false
nullable(array_type_expr) = false
nullable(array_dims) = false
nullable(array_creation_expression) = false
nullable(array_access) = false
nullable(argument_list) = true
nullable(additive_specification) = false
first(when_clauses) = WHEN
first(when_clause) = WHEN
first(variable_declarators) = ID
first(variable_declarator_id) = ID
first(variable_declaration) = SHORT LONG INT ID FLOAT DOUBLE CHAR BYTE BOOLEAN
first(type_expr_no_name) = SHORT LONG INT ID FLOAT DOUBLE CHAR BYTE BOOLEAN
first(type_expr) = SHORT LONG INT ID FLOAT DOUBLE CHAR BYTE BOOLEAN
first(spec_var_decls) = OLD FORALL
first(spec_header) = WHEN REQUIRES MEASURED_BY
first(spec_case_seq) = WHEN SIGNALS REQUIRES PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MEASURED_BY LEFTBRACEBAR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
first(spec_case) = WHEN SIGNALS REQUIRES PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MEASURED_BY LEFTBRACEBAR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
first(simple_spec_body) = SIGNALS ENSURES DIVERGES ASSIGNABLE
first(signals_clauses) = SIGNALS
first(signals_clause) = SIGNALS
first(set_ref_sep) = LEFTBRACKET
first(set_ref_list) = LEFTBRACKET DOT
first(set_ref) = LEFTBRACKET DOT
first(requires_clauses) = REQUIRES
first(requires_clause) = REQUIRES
first(privacy) = PUBLIC PROTECTED PRIVATE
first(primary_no_new_array) = TRUE THIS SUPER STRING REAL NULL NEW LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI
first(primary_expr_or_name) = TRUE THIS SUPER STRING REAL NULL NEW LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI
first(primary_expr) = TRUE THIS SUPER STRING REAL NULL NEW LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI
first(parenthesized_name) = LEFTPAR
first(opt_expr_semicolon) = TRUE TILDA THIS SUPER STRING SEMICOLON REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(normal_spec_case_seq) = WHEN REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL ENSURES DIVERGES ASSIGNABLE ALSO
first(normal_spec_case) = WHEN REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL ENSURES DIVERGES ASSIGNABLE
first(normal_spec_body) = LEFTBRACEBAR ENSURES DIVERGES ASSIGNABLE
first(normal_simple_spec_body) = ENSURES DIVERGES ASSIGNABLE
first(non_extending_specification) = WHEN SIGNALS REQUIRES PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MEASURED_BY LEFTBRACEBAR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
first(name) = ID
first(modifiers) = STATIC PUBLIC PROTECTED PRIVATE MODEL FINAL
first(modifier) = STATIC PUBLIC PROTECTED PRIVATE MODEL FINAL
first(method_specification) = WHEN SIGNALS REQUIRES PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MEASURED_BY LEFTBRACEBAR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE AND ALSO
first(measured_clauses) = MEASURED_BY
first(measured_clause) = MEASURED_BY
first(loop_annotation) = LOOP_INVARIANT
first(local_spec_var_decls) = MODEL GHOST
first(local_spec_var_decl) = MODEL GHOST
first(let_var_decls) = OLD
first(jml_specification_eof) = WHEN STATIC SPEC_PUBLIC SIGNALS SHORT REQUIRES REPRESENTS PURE PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MODEL MEASURED_BY LOOP_INVARIANT LONG LEFTBRACEBAR INVARIANT INT ID FORALL FLOAT FINAL EXCEPTIONAL_BEHAVIOR EOF ENSURES DOUBLE DIVERGES CHAR BYTE BOOLEAN BEHAVIOR ASSIGNABLE ASSERT AND ALSO
first(jml_specification) = WHEN STATIC SPEC_PUBLIC SIGNALS SHORT REQUIRES REPRESENTS PURE PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MODEL MEASURED_BY LOOP_INVARIANT LONG LEFTBRACEBAR INVARIANT INT ID FORALL FLOAT FINAL EXCEPTIONAL_BEHAVIOR ENSURES DOUBLE DIVERGES CHAR BYTE BOOLEAN BEHAVIOR ASSIGNABLE ASSERT AND ALSO
first(jml_declarations) = STATIC SHORT REPRESENTS PUBLIC PROTECTED PRIVATE MODEL LONG INVARIANT INT ID FLOAT FINAL DOUBLE CHAR BYTE BOOLEAN
first(jml_declaration) = STATIC SHORT REPRESENTS PUBLIC PROTECTED PRIVATE MODEL LONG INVARIANT INT ID FLOAT FINAL DOUBLE CHAR BYTE BOOLEAN
first(implicit_dims) = LEFTBRACKET
first(ident) = ID
first(generic_spec_case_seq) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL ENSURES DIVERGES ASSIGNABLE
first(generic_spec_case) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL ENSURES DIVERGES ASSIGNABLE
first(generic_spec_body) = SIGNALS LEFTBRACEBAR ENSURES DIVERGES ASSIGNABLE
first(generic_conjoinable_spec) = SIGNALS OLD FORALL ENSURES DIVERGES ASSIGNABLE
first(forall_var_decls) = FORALL
first(forall_var_decl) = FORALL
first(field_access) = TRUE THIS SUPER STRING REAL NULL NEW LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI
first(extending_specification) = AND ALSO
first(expr_semicolon) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(expr_no_name) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(expr_comma_list) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(expr) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(exceptional_spec_case_seq) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL DIVERGES ASSIGNABLE ALSO
first(exceptional_spec_case) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL DIVERGES ASSIGNABLE
first(exceptional_spec_body) = SIGNALS LEFTBRACEBAR DIVERGES ASSIGNABLE
first(exceptional_simple_spec_body) = SIGNALS DIVERGES ASSIGNABLE
first(ensures_clauses) = ENSURES
first(ensures_clause) = ENSURES
first(diverges_clauses) = DIVERGES
first(diverges_clause) = DIVERGES
first(decreases_clause) = DECREASES
first(conjoinable_spec_seq) = SIGNALS PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
first(conjoinable_spec) = SIGNALS PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
first(behavior_spec) = PUBLIC PROTECTED PRIVATE NORMAL_BEHAVIOR EXCEPTIONAL_BEHAVIOR BEHAVIOR
first(behavior_conjoinable_spec) = PUBLIC PROTECTED PRIVATE NORMAL_BEHAVIOR EXCEPTIONAL_BEHAVIOR BEHAVIOR
first(base_type) = SHORT LONG INT FLOAT DOUBLE CHAR BYTE BOOLEAN
first(assignable_objects) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSNOTHING BSFRESH BSFPI BSFIELDSOF BSEVERYTHING BANG
first(assignable_entry) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSNOTHING BSFRESH BSFPI BSFIELDSOF BSEVERYTHING BANG
first(assignable_clauses) = ASSIGNABLE
first(assignable_clause) = ASSIGNABLE
first(assignable_any_object) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSNOTHING BSFRESH BSFPI BSFIELDSOF BSEVERYTHING BANG
first(array_type_expr) = SHORT LONG INT ID FLOAT DOUBLE CHAR BYTE BOOLEAN
first(array_dims) = LEFTBRACKET
first(array_creation_expression) = NEW
first(array_access) = TRUE THIS SUPER STRING REAL NULL NEW LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI
first(argument_list) = TRUE TILDA THIS SUPER STRING REAL PLUS NULL NEW MINUS LEFTPAR INTEGER ID FALSE CHARACTER BSTYPEOF BSTYPE BSRESULT BSOLD BSFRESH BSFPI BANG
first(additive_specification) = WHEN SIGNALS REQUIRES PUBLIC PROTECTED PRIVATE OLD NORMAL_BEHAVIOR MEASURED_BY LEFTBRACEBAR FORALL EXCEPTIONAL_BEHAVIOR ENSURES DIVERGES BEHAVIOR ASSIGNABLE
minimal(when_clauses) = (* 0 *)
minimal(when_clause) = (* 3 *) WHEN ID SEMICOLON
minimal(variable_declarators) = (* 1 *) ID
minimal(variable_declarator_id) = (* 1 *) ID
minimal(variable_declaration) = (* 2 *) ID ID
minimal(type_expr_no_name) = (* 1 *) SHORT
minimal(type_expr) = (* 1 *) ID
minimal(spec_var_decls) = (* 0 *)
minimal(spec_header) = (* 0 *)
minimal(spec_case_seq) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(spec_case) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(simple_spec_body) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(signals_clauses) = (* 0 *)
minimal(signals_clause) = (* 5 *) SIGNALS LEFTPAR ID RIGHTPAR SEMICOLON
minimal(set_ref_sep) = (* 3 *) LEFTBRACKET STAR RIGHTBRACKET
minimal(set_ref_list) = (* 0 *)
minimal(set_ref) = (* 2 *) DOT ID
minimal(requires_clauses) = (* 0 *)
minimal(requires_clause) = (* 3 *) REQUIRES ID SEMICOLON
minimal(privacy) = (* 0 *)
minimal(primary_no_new_array) = (* 1 *) INTEGER
minimal(primary_expr_or_name) = (* 1 *) INTEGER
minimal(primary_expr) = (* 1 *) INTEGER
minimal(parenthesized_name) = (* 3 *) LEFTPAR ID RIGHTPAR
minimal(opt_expr_semicolon) = (* 1 *) SEMICOLON
minimal(normal_spec_case_seq) = (* 0 *)
minimal(normal_spec_case) = (* 0 *)
minimal(normal_spec_body) = (* 0 *)
minimal(normal_simple_spec_body) = (* 0 *)
minimal(non_extending_specification) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(name) = (* 1 *) ID
minimal(modifiers) = (* 0 *)
minimal(modifier) = (* 1 *) MODEL
minimal(method_specification) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(measured_clauses) = (* 0 *)
minimal(measured_clause) = (* 3 *) MEASURED_BY ID SEMICOLON
minimal(loop_annotation) = (* 3 *) LOOP_INVARIANT ID SEMICOLON
minimal(local_spec_var_decls) = (* 4 *) MODEL ID ID SEMICOLON
minimal(local_spec_var_decl) = (* 4 *) MODEL ID ID SEMICOLON
minimal(let_var_decls) = (* 0 *)
minimal(jml_specification_eof) = (* 1 *) EOF
minimal(jml_specification) = (* 0 *)
minimal(jml_declarations) = (* 0 *)
minimal(jml_declaration) = (* 3 *) INVARIANT ID SEMICOLON
minimal(implicit_dims) = (* 0 *)
minimal(ident) = (* 1 *) ID
minimal(generic_spec_case_seq) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(generic_spec_case) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(generic_spec_body) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(generic_conjoinable_spec) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(forall_var_decls) = (* 0 *)
minimal(forall_var_decl) = (* 4 *) FORALL ID ID SEMICOLON
minimal(field_access) = (* 3 *) SUPER DOT ID
minimal(extending_specification) = (* 2 *) ALSO EXCEPTIONAL_BEHAVIOR
minimal(expr_semicolon) = (* 2 *) ID SEMICOLON
minimal(expr_no_name) = (* 1 *) INTEGER
minimal(expr_comma_list) = (* 1 *) ID
minimal(expr) = (* 1 *) ID
minimal(exceptional_spec_case_seq) = (* 0 *)
minimal(exceptional_spec_case) = (* 0 *)
minimal(exceptional_spec_body) = (* 0 *)
minimal(exceptional_simple_spec_body) = (* 0 *)
minimal(ensures_clauses) = (* 0 *)
minimal(ensures_clause) = (* 3 *) ENSURES ID SEMICOLON
minimal(diverges_clauses) = (* 0 *)
minimal(diverges_clause) = (* 3 *) DIVERGES ID SEMICOLON
minimal(decreases_clause) = (* 0 *)
minimal(conjoinable_spec_seq) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(conjoinable_spec) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(behavior_spec) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(behavior_conjoinable_spec) = (* 1 *) EXCEPTIONAL_BEHAVIOR
minimal(base_type) = (* 1 *) SHORT
minimal(assignable_objects) = (* 1 *) BSEVERYTHING
minimal(assignable_entry) = (* 1 *) BSEVERYTHING
minimal(assignable_clauses) = (* 0 *)
minimal(assignable_clause) = (* 3 *) ASSIGNABLE BSEVERYTHING SEMICOLON
minimal(assignable_any_object) = (* 1 *) BSEVERYTHING
minimal(array_type_expr) = (* 3 *) SHORT LEFTBRACKET RIGHTBRACKET
minimal(array_dims) = (* 3 *) LEFTBRACKET ID RIGHTBRACKET
minimal(array_creation_expression) = (* 5 *) NEW SHORT LEFTBRACKET ID RIGHTBRACKET
minimal(array_access) = (* 4 *) INTEGER LEFTBRACKET ID RIGHTBRACKET
minimal(argument_list) = (* 0 *)
minimal(additive_specification) = (* 1 *) EXCEPTIONAL_BEHAVIOR
follow(when_clauses) = SIGNALS MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(when_clause) = WHEN SIGNALS MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(variable_declarators) = SEMICOLON
follow(variable_declarator_id) = SEMICOLON LEFTBRACKET COMMA
follow(variable_declaration) = SEMICOLON
follow(type_expr_no_name) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF ID EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(type_expr) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF ID EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(spec_var_decls) = WHEN SIGNALS REQUIRES MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(spec_header) = SIGNALS LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(spec_case_seq) = EOF
follow(spec_case) = EOF ALSO
follow(simple_spec_body) = EOF BARRIGHTBRACE AND ALSO
follow(signals_clauses) = EOF DIVERGES BARRIGHTBRACE AND ALSO
follow(signals_clause) = SIGNALS EOF DIVERGES BARRIGHTBRACE AND ALSO
follow(set_ref_sep) = SEMICOLON LEFTBRACKET IF DOT COMMA
follow(set_ref_list) = SEMICOLON IF COMMA
follow(set_ref) = SEMICOLON LEFTBRACKET IF DOT COMMA
follow(requires_clauses) = WHEN SIGNALS MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(requires_clause) = WHEN SIGNALS REQUIRES MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(privacy) = NORMAL_BEHAVIOR INVARIANT EXCEPTIONAL_BEHAVIOR BEHAVIOR
follow(primary_no_new_array) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(primary_expr_or_name) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(primary_expr) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(parenthesized_name) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(opt_expr_semicolon) = SIGNALS EOF DIVERGES BARRIGHTBRACE AND ALSO
follow(normal_spec_case_seq) = BARRIGHTBRACE
follow(normal_spec_case) = EOF BARRIGHTBRACE ALSO
follow(normal_spec_body) = EOF BARRIGHTBRACE ALSO
follow(normal_simple_spec_body) = EOF BARRIGHTBRACE AND ALSO
follow(non_extending_specification) = EOF
follow(name) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTPAR LEFTBRACKET INSTANCEOF IF ID EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(modifiers) = SHORT LONG INT ID FLOAT DOUBLE CHAR BYTE BOOLEAN
follow(modifier) = STATIC SHORT PUBLIC PROTECTED PRIVATE MODEL LONG INT ID FLOAT FINAL DOUBLE CHAR BYTE BOOLEAN
follow(method_specification) = EOF
follow(measured_clauses) = SIGNALS LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(measured_clause) = SIGNALS MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE ALSO
follow(loop_annotation) = EOF
follow(local_spec_var_decls) = WHEN SIGNALS REQUIRES MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(local_spec_var_decl) = WHEN SIGNALS REQUIRES MODEL MEASURED_BY LEFTBRACEBAR GHOST EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(let_var_decls) = WHEN SIGNALS REQUIRES MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(jml_specification_eof) = #
follow(jml_specification) = EOF
follow(jml_declarations) = EOF
follow(jml_declaration) = STATIC SHORT REPRESENTS PUBLIC PROTECTED PRIVATE MODEL LONG INVARIANT INT ID FLOAT FINAL EOF DOUBLE CHAR BYTE BOOLEAN
follow(implicit_dims) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(ident) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTPAR LEFTBRACKET LEFTARROW INSTANCEOF IF ID EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(generic_spec_case_seq) = BARRIGHTBRACE
follow(generic_spec_case) = EOF BARRIGHTBRACE ALSO
follow(generic_spec_body) = EOF BARRIGHTBRACE ALSO
follow(generic_conjoinable_spec) = EOF AND
follow(forall_var_decls) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(forall_var_decl) = WHEN SIGNALS REQUIRES OLD MEASURED_BY LEFTBRACEBAR FORALL EOF ENSURES DIVERGES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(field_access) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(extending_specification) = EOF
follow(expr_semicolon) = WHEN STATIC SIGNALS SHORT REQUIRES REPRESENTS PUBLIC PROTECTED PRIVATE MODEL MEASURED_BY LONG LEFTBRACEBAR INVARIANT INT ID FLOAT FINAL EOF ENSURES DOUBLE DIVERGES DECREASES CHAR BYTE BOOLEAN BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(expr_no_name) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(expr_comma_list) = RIGHTPAR
follow(expr) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(exceptional_spec_case_seq) = BARRIGHTBRACE
follow(exceptional_spec_case) = EOF BARRIGHTBRACE ALSO
follow(exceptional_spec_body) = EOF BARRIGHTBRACE ALSO
follow(exceptional_simple_spec_body) = EOF BARRIGHTBRACE AND ALSO
follow(ensures_clauses) = SIGNALS EOF DIVERGES BARRIGHTBRACE AND ALSO
follow(ensures_clause) = SIGNALS EOF ENSURES DIVERGES BARRIGHTBRACE AND ALSO
follow(diverges_clauses) = EOF BARRIGHTBRACE AND ALSO
follow(diverges_clause) = EOF DIVERGES BARRIGHTBRACE AND ALSO
follow(decreases_clause) = EOF
follow(conjoinable_spec_seq) = EOF
follow(conjoinable_spec) = EOF AND
follow(behavior_spec) = EOF ALSO
follow(behavior_conjoinable_spec) = EOF AND
follow(base_type) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF ID EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(assignable_objects) = SEMICOLON
follow(assignable_entry) = SEMICOLON COMMA
follow(assignable_clauses) = SIGNALS EOF ENSURES DIVERGES DECREASES BARRIGHTBRACE AND ALSO
follow(assignable_clause) = SIGNALS EOF ENSURES DIVERGES DECREASES BARRIGHTBRACE ASSIGNABLE AND ALSO
follow(assignable_any_object) = SEMICOLON IF COMMA
follow(array_type_expr) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF ID EQOP EQEQGT DOTDOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(array_dims) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(array_creation_expression) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(array_access) = VERTICALBARVERTICALBAR VERTICALBAR STAR SLASH SHIFT SEMICOLON RIGHTPAR RIGHTBRACKET QUESTIONMARK PLUS PERCENT MINUS LTEQEQGT LTEQEQ LTEQBANGEQGT LEFTBRACKET INSTANCEOF IF EQOP EQEQGT DOTDOT DOT COMP COMMA COLON CARET AMPERSANDAMPERSAND AMPERSAND
follow(argument_list) = RIGHTPAR
follow(additive_specification) = EOF
Built an LR(0) automaton with 427 states.
The grammar is not SLR(1) -- 29 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 427 states.
437 shift/reduce conflicts were silently solved.
File "jml.mly", line 89, characters 0-6:
Warning: the precedence level assigned to ASSIGNOP is never useful.
File "jml.mly", line 87, characters 0-9:
Warning: the precedence level assigned to ELSE is never useful.
File "jml.mly", line 89, characters 0-6:
Warning: the precedence level assigned to EQ is never useful.
File "jml.mly", line 105, characters 0-6:
Warning: the precedence level assigned to MINUSMINUS is never useful.
File "jml.mly", line 105, characters 0-6:
Warning: the precedence level assigned to PLUSPLUS is never useful.
File "jml.mly", line 86, characters 0-9:
Warning: the precedence level assigned to THEN is never useful.
File "jml.mly", line 908, characters 62-66:
Warning: this %prec declaration is never useful.
File "jml.mly", line 913, characters 51-55:
Warning: this %prec declaration is never useful.
168 out of 427 states have a default reduction.
159 out of 427 states are represented.
0 out of 185 symbols keep track of their start position.
0 out of 185 symbols keep track of their end position.
120 out of 220 productions exploit shiftreduce optimization.
0 out of 427 states can peek at an error.
1162 functions before inlining, 185 functions after inlining.
