
** Conflict (shift/reduce) in state 1475.
** Token involved: LPAREN
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1475, looking ahead at LPAREN, reducing production
** module_expr -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr
** is permitted because of the following sub-derivation:

module_expr LPAREN module_expr RPAREN // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr . 

** In state 1475, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr 
                                                            module_expr . LPAREN module_expr RPAREN 

** Conflict (shift/reduce) in state 1429.
** Token involved: LPAREN
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL LPAREN FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    LPAREN module_expr COLON module_type RPAREN 
                           (?)

** In state 1429, looking ahead at LPAREN, reducing production
** module_expr -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr
** is permitted because of the following sub-derivation:

module_expr LPAREN module_expr RPAREN // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr . 

** In state 1429, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr 
                                                            module_expr . LPAREN module_expr RPAREN 

** Conflict (shift/reduce) in state 1334.
** Tokens involved: LET DEF
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT DEF join_pattern EQUAL process0 BAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           structure_tail 
                           (?)

** In state 1334, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       process0 BAR process // lookahead token is inherited
                                    . 

** In state 1334, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       process0 BAR process 
                                    . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 1332.
** Tokens involved: LET DEF
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT DEF join_pattern EQUAL BEGIN seq_expr END SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           structure_tail 
                           (?)

** In state 1332, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       BEGIN seq_expr END SEMI process // lookahead token is inherited
                                               . 

** In state 1332, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       BEGIN seq_expr END SEMI process 
                                               . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 1327.
** Tokens involved: LET DEF
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT DEF join_pattern EQUAL DEF def_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           structure_tail 
                           (?)

** In state 1327, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       DEF def_bindings IN process // lookahead token is inherited
                                           . 

** In state 1327, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       DEF def_bindings IN process 
                                           . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 1304.
** Tokens involved: LET DEF
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT DEF join_pattern EQUAL LET rec_flag let_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           structure_tail 
                           (?)

** In state 1304, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       LET rec_flag let_bindings IN process // lookahead token is inherited
                                                    . 

** In state 1304, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       LET rec_flag let_bindings IN process 
                                                    . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 1295.
** Tokens involved: LET DEF
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT DEF join_pattern EQUAL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           structure_tail 
                           (?)

** In state 1295, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       . 

** In state 1295, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 1283.
** Token involved: error
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT LET rec_flag let_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1283, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

STRUCT structure END 
       seq_expr structure_tail 
       expr 
       LET rec_flag let_bindings . error 

** In state 1283, looking ahead at error, reducing production
** structure_item -> LET rec_flag let_bindings
** is permitted because of the following sub-derivation:

STRUCT structure error // lookahead token appears
       structure_tail // lookahead token is inherited
       structure_item structure_tail // lookahead token is inherited because structure_tail can vanish
       LET rec_flag let_bindings . 

** Conflict (shift/reduce) in state 1149.
** Token involved: WITH
** This state is reached from interface after reading:

signature INCLUDE LPAREN FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

interface 
signature EOF 
signature signature_item 
          INCLUDE module_type 
                  LPAREN module_type RPAREN 
                         (?)

** In state 1149, looking ahead at WITH, reducing production
** module_type -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
** is permitted because of the following sub-derivation:

module_type WITH with_constraints // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type . 

** In state 1149, looking ahead at WITH, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type 
                                                            module_type . WITH with_constraints 

** Conflict (shift/reduce) in state 1139.
** Token involved: WITH
** This state is reached from interface after reading:

signature INCLUDE FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

interface 
signature EOF 
signature signature_item 
          INCLUDE module_type 
                  (?)

** In state 1139, looking ahead at WITH, reducing production
** module_type -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
** is permitted because of the following sub-derivation:

module_type WITH with_constraints // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type . 

** In state 1139, looking ahead at WITH, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type 
                                                            module_type . WITH with_constraints 

** Conflict (shift/reduce) in state 1005.
** Token involved: SHARP
** This state is reached from use_file after reading:

EXCEPTION UIDENT OF simple_core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 1005, looking ahead at SHARP, reducing production
** core_type_list -> simple_core_type
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
EXCEPTION UIDENT constructor_arguments // lookahead token is inherited
                 OF core_type_list // lookahead token is inherited
                    simple_core_type . 

** In state 1005, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
EXCEPTION UIDENT constructor_arguments 
                 OF core_type_list 
                    simple_core_type 
                    simple_core_type . SHARP class_longident 

** Conflict (shift/reduce) in state 875.
** Tokens involved: WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token WHILE.
** This state is reached from implementation after reading:

LOC LET rec_flag let_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    (?)

** In state 875, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

location_item location_tail 
LET rec_flag let_bindings location_tail 
                          location_item location_tail 
                          seq_expr location_tail 
                          expr 
                          . WHILE seq_expr DO seq_expr DONE 

** In state 875, looking ahead at WHILE, reducing production
** location_tail ->
** is permitted because of the following sub-derivation:

location_item location_tail // lookahead token appears because location_tail can begin with WHILE
LET rec_flag let_bindings location_tail // lookahead token is inherited
                          . 

** Conflict (shift/reduce) in state 862.
** Tokens involved: WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token WHILE.
** This state is reached from implementation after reading:

LOC seq_expr location_item

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    (?)

** In state 862, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

location_item location_tail 
seq_expr location_tail 
         location_item location_tail 
                       location_item location_tail 
                       seq_expr location_tail 
                       expr 
                       . WHILE seq_expr DO seq_expr DONE 

** In state 862, looking ahead at WHILE, reducing production
** location_tail ->
** is permitted because of the following sub-derivation:

location_item location_tail // lookahead token appears because location_tail can begin with WHILE
seq_expr location_tail // lookahead token is inherited
         location_item location_tail // lookahead token is inherited
                       . 

** Conflict (shift/reduce) in state 860.
** Tokens involved: WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token WHILE.
** This state is reached from implementation after reading:

LOC seq_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    (?)

** In state 860, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

location_item location_tail 
seq_expr location_tail 
         location_item location_tail 
         seq_expr location_tail 
         expr 
         . WHILE seq_expr DO seq_expr DONE 

** In state 860, looking ahead at WHILE, reducing production
** location_tail ->
** is permitted because of the following sub-derivation:

location_item location_tail // lookahead token appears because location_tail can begin with WHILE
seq_expr location_tail // lookahead token is inherited
         . 

** Conflict (shift/reduce) in state 859.
** Tokens involved: WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token WHILE.
** This state is reached from implementation after reading:

LOC DEF def_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    (?)

** In state 859, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

location_item location_tail 
DEF def_bindings location_tail 
                 location_item location_tail 
                 seq_expr location_tail 
                 expr 
                 . WHILE seq_expr DO seq_expr DONE 

** In state 859, looking ahead at WHILE, reducing production
** location_tail ->
** is permitted because of the following sub-derivation:

location_item location_tail // lookahead token appears because location_tail can begin with WHILE
DEF def_bindings location_tail // lookahead token is inherited
                 . 

** Conflict (shift/reduce) in state 815.
** Tokens involved: UIDENT TRUE STRING LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

DEF join_pattern EQUAL LET rec_flag let_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 815, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       LET rec_flag let_bindings IN process // lookahead token is inherited
                                                    . 

** In state 815, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       LET rec_flag let_bindings IN process 
                                                    . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 782.
** Token involved: ELSE
** This state is reached from implementation after reading:

TRY IF seq_expr THEN IF seq_expr THEN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    (?)

** In state 782, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr 
                 IF seq_expr THEN expr . ELSE expr 

** In state 782, looking ahead at ELSE, reducing production
** expr -> IF seq_expr THEN expr
** is permitted because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr // lookahead token appears
                 IF seq_expr THEN expr . 

** Conflict (shift/reduce) in state 736.
** Token involved: ELSE
** This state is reached from implementation after reading:

IF seq_expr THEN IF seq_expr THEN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
(?)

** In state 736, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr 
                 IF seq_expr THEN expr . ELSE expr 

** In state 736, looking ahead at ELSE, reducing production
** expr -> IF seq_expr THEN expr
** is permitted because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr // lookahead token appears
                 IF seq_expr THEN expr . 

** Conflict (shift/reduce) in state 709.
** Tokens involved: WHILE UIDENT TRY TRUE STRING PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
(?)

** In state 709, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

seq_expr structure_tail 
expr SEMI seq_expr 
          expr 
          . LET rec_flag let_bindings IN seq_expr 

** In state 709, looking ahead at LET, reducing production
** seq_expr -> expr SEMI
** is permitted because of the following sub-derivation:

seq_expr structure_tail // lookahead token appears because structure_tail can begin with LET
expr SEMI . 

** Conflict (shift/reduce) in state 708.
** Tokens involved: SUBTRACTIVE STAR SEMI OR LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COMMA COLONEQUAL COLONCOLON BARBAR AMPERSAND AMPERAMPER
** The following explanations concentrate on token SUBTRACTIVE.
** This state is reached from implementation after reading:

LOC expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    location_item location_tail 
    (?)

** In state 708, looking ahead at SUBTRACTIVE, shifting is permitted
** because of the following sub-derivation:

seq_expr location_tail 
expr 
expr . SUBTRACTIVE expr 

** In state 708, looking ahead at SUBTRACTIVE, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

seq_expr location_tail // lookahead token appears because location_tail can begin with SUBTRACTIVE
expr . 

** Conflict (shift/reduce) in state 706.
** Token involved: SHARP
** This state is reached from use_file after reading:

simple_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 706, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
simple_expr simple_expr_list 
            simple_expr 
            simple_expr . SHARP label 

** In state 706, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
simple_expr simple_expr_list // lookahead token is inherited
            simple_expr . 

** Conflict (shift/reduce) in state 705.
** Token involved: SHARP
** This state is reached from use_file after reading:

simple_expr simple_expr_list simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 705, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
simple_expr simple_expr_list 
            simple_expr_list simple_expr 
                             simple_expr . SHARP label 

** In state 705, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr_list simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
simple_expr simple_expr_list // lookahead token is inherited
            simple_expr_list simple_expr . 

** Conflict (shift/reduce) in state 704.
** Tokens involved: UIDENT TRUE STRING NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token UIDENT.
** This state is reached from implementation after reading:

LOC simple_expr simple_expr_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    location_item location_tail 
    (?)

** In state 704, looking ahead at UIDENT, reducing production
** expr -> simple_expr simple_expr_list
** is permitted because of the following sub-derivation:

seq_expr location_tail // lookahead token appears because location_tail can begin with UIDENT
expr // lookahead token is inherited
simple_expr simple_expr_list . 

** In state 704, looking ahead at UIDENT, shifting is permitted
** because of the following sub-derivation:

seq_expr location_tail 
expr 
simple_expr simple_expr_list 
            simple_expr_list simple_expr 
                             val_longident 
                             mod_longident DOT val_ident 
                             . UIDENT 

** Conflict (shift/reduce) in state 662.
** Tokens involved: UIDENT TRUE STRING PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token UIDENT.
** This state is reached from implementation after reading:

constr_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
(?)

** In state 662, looking ahead at UIDENT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
                 val_longident 
                 mod_longident DOT val_ident 
                 . UIDENT 

** In state 662, looking ahead at UIDENT, reducing production
** simple_expr -> constr_longident
** is permitted because of the following sub-derivation:

simple_expr simple_expr_list // lookahead token appears because simple_expr_list can begin with UIDENT
constr_longident . 

** Conflict (shift/reduce) in state 653.
** Token involved: COMMA
** This state is reached from implementation after reading:

expr_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr_comma_list 
(?)

** In state 653, looking ahead at COMMA, reducing production
** expr -> expr_comma_list
** is permitted because of the following sub-derivation:

expr COMMA expr // lookahead token appears
expr_comma_list . 

** In state 653, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

expr_comma_list . COMMA expr 

** Conflict (shift/reduce) in state 640.
** Tokens involved: UIDENT TRUE STRING SHARP PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token SHARP.
** This state is reached from use_file after reading:

simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 640, looking ahead at SHARP, reducing production
** expr -> simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
simple_expr . 

** In state 640, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
simple_expr 
simple_expr . SHARP label 

** Conflict (shift/reduce) in state 589.
** Tokens involved: UIDENT TRUE STRING LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

DEF join_pattern EQUAL process0 BAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 589, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       process0 BAR process // lookahead token is inherited
                                    . 

** In state 589, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       process0 BAR process 
                                    . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 578.
** Tokens involved: UIDENT TRUE STRING LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

DEF join_pattern EQUAL BEGIN seq_expr END SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 578, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       BEGIN seq_expr END SEMI process // lookahead token is inherited
                                               . 

** In state 578, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       BEGIN seq_expr END SEMI process 
                                               . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 568.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 568, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             simple_expr simple_expr_list 
                                         simple_expr 
                                         simple_expr . SHARP label 

** In state 568, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             simple_expr simple_expr_list // lookahead token is inherited
                                         simple_expr . 

** Conflict (shift/reduce) in state 567.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr simple_expr_list simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 567, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             simple_expr simple_expr_list 
                                         simple_expr_list simple_expr 
                                                          simple_expr . SHARP label 

** In state 567, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr_list simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             simple_expr simple_expr_list // lookahead token is inherited
                                         simple_expr_list simple_expr . 

** Conflict (shift/reduce) in state 566.
** Tokens involved: UIDENT TRUE STRING NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token UIDENT.
** This state is reached from implementation after reading:

LOC LET rec_flag val_ident EQUAL simple_expr simple_expr_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    location_item location_tail 
    (?)

** In state 566, looking ahead at UIDENT, reducing production
** expr -> simple_expr simple_expr_list
** is permitted because of the following sub-derivation:

LET rec_flag let_bindings location_tail // lookahead token appears because location_tail can begin with UIDENT
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             simple_expr simple_expr_list . 

** In state 566, looking ahead at UIDENT, shifting is permitted
** because of the following sub-derivation:

LET rec_flag let_bindings location_tail 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             simple_expr simple_expr_list 
                                         simple_expr_list simple_expr 
                                                          val_longident 
                                                          mod_longident DOT val_ident 
                                                          . UIDENT 

** Conflict (shift/reduce) in state 544.
** Tokens involved: SUBTRACTIVE STAR SEMI OR LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COMMA COLONEQUAL COLONCOLON BARBAR AMPERSAND AMPERAMPER
** The following explanations concentrate on token SUBTRACTIVE.
** This state is reached from implementation after reading:

TRY FUN simple_pattern MINUSGREATER expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    (?)

** In state 544, looking ahead at SUBTRACTIVE, shifting is permitted
** because of the following sub-derivation:

FUN simple_pattern fun_def 
                   match_action 
                   MINUSGREATER seq_expr 
                                expr 
                                expr . SUBTRACTIVE expr 

** In state 544, looking ahead at SUBTRACTIVE, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

expr SUBTRACTIVE expr // lookahead token appears
FUN simple_pattern fun_def // lookahead token is inherited
                   match_action // lookahead token is inherited
                   MINUSGREATER seq_expr // lookahead token is inherited
                                expr . 

** Conflict (shift/reduce) in state 542.
** Tokens involved: WHILE UIDENT TRY TRUE STRING PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           (?)

** In state 542, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

seq_expr structure_tail 
expr SEMI seq_expr 
          expr 
          . LET rec_flag let_bindings IN seq_expr 

** In state 542, looking ahead at LET, reducing production
** seq_expr -> expr SEMI
** is permitted because of the following sub-derivation:

seq_expr structure_tail // lookahead token appears because structure_tail can begin with LET
expr SEMI . 

** Conflict (shift/reduce) in state 541.
** Token involved: RPAREN
** This state is reached from implementation after reading:

simple_expr LESSLESS LPAREN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr LESSLESS list_of_exprs GREATERGREATER 
                     (?)

** In state 541, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN expr . RPAREN 

** In state 541, looking ahead at RPAREN, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

expr 
simple_expr 
LPAREN seq_expr RPAREN // lookahead token appears
       expr . 

** Conflict (shift/reduce) in state 508.
** Tokens involved: UIDENT TRUE STRING PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token UIDENT.
** This state is reached from implementation after reading:

TRY constr_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    (?)

** In state 508, looking ahead at UIDENT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
                 val_longident 
                 mod_longident DOT val_ident 
                 . UIDENT 

** In state 508, looking ahead at UIDENT, reducing production
** simple_expr -> constr_longident
** is permitted because of the following sub-derivation:

simple_expr simple_expr_list // lookahead token appears because simple_expr_list can begin with UIDENT
constr_longident . 

** Conflict (shift/reduce) in state 499.
** Token involved: COMMA
** This state is reached from implementation after reading:

TRY expr_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr_comma_list 
    (?)

** In state 499, looking ahead at COMMA, reducing production
** expr -> expr_comma_list
** is permitted because of the following sub-derivation:

expr COMMA expr // lookahead token appears
expr_comma_list . 

** In state 499, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

expr_comma_list . COMMA expr 

** Conflict (shift/reduce) in state 481.
** Tokens involved: UIDENT TRUE STRING SHARP PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token SHARP.
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 481, looking ahead at SHARP, reducing production
** expr -> simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             simple_expr . 

** In state 481, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             simple_expr 
                             simple_expr . SHARP label 

** Conflict (shift/reduce) in state 471.
** Tokens involved: UIDENT TRUE STRING LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

DEF join_pattern EQUAL DEF def_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 471, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       DEF def_bindings IN process // lookahead token is inherited
                                           . 

** In state 471, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       DEF def_bindings IN process 
                                           . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 468.
** Tokens involved: UIDENT TRUE STRING LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
** The following explanations concentrate on token LET.
** This state is reached from implementation after reading:

DEF join_pattern EQUAL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 468, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
DEF def_bindings // lookahead token is inherited
    def_binding // lookahead token is inherited
    join_pattern EQUAL process // lookahead token is inherited
                       . 

** In state 468, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
                       . LET rec_flag let_bindings IN process 

** Conflict (shift/reduce) in state 453.
** Token involved: COMMA
** This state is reached from implementation after reading:

DEF LIDENT LESSLESS pattern_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
DEF def_bindings 
    def_binding 
    join_pattern EQUAL process 
    LIDENT LESSLESS join_args GREATERGREATER 
                    pattern_comma_list 
                    (?)

** In state 453, looking ahead at COMMA, reducing production
** pattern -> pattern_comma_list
** is permitted because of the following sub-derivation:

pattern COMMA pattern // lookahead token appears
pattern_comma_list . 

** In state 453, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

pattern_comma_list . COMMA pattern 

** Conflict (shift/reduce) in state 401.
** Token involved: EQUAL
** This state is reached from implementation after reading:

LBRACEBAR LET rec_flag val_ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
LBRACEBAR process BARRBRACE 
          LET rec_flag let_bindings IN process 
                       let_binding 
                       (?)

** In state 401, looking ahead at EQUAL, shifting is permitted
** because of the following sub-derivation:

val_ident fun_binding 
          . EQUAL seq_expr 

** In state 401, looking ahead at EQUAL, reducing production
** simple_pattern -> val_ident
** is permitted because of the following sub-derivation:

pattern EQUAL seq_expr // lookahead token appears
simple_pattern // lookahead token is inherited
val_ident . 

** Conflict (shift/reduce) in state 389.
** Token involved: RPAREN
** This state is reached from implementation after reading:

LBRACEBAR LPAREN static_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
LBRACEBAR process BARRBRACE 
          process0 
          static_expr LESSLESSGREATERGREATER 
          (?)

** In state 389, looking ahead at RPAREN, reducing production
** static_comma_list -> static_expr
** is permitted because of the following sub-derivation:

LPAREN static_comma_list RPAREN // lookahead token appears
       static_expr . 

** In state 389, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN static_expr . RPAREN 

** Conflict (shift/reduce) in state 378.
** Token involved: DOT
** This state is reached from implementation after reading:

mod_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
(?)

** In state 378, looking ahead at DOT, reducing production
** constr_longident -> mod_longident
** is permitted because of the following sub-derivation:

simple_expr DOT label_longident LESSMINUS expr // lookahead token appears
constr_longident // lookahead token is inherited
mod_longident . 

** In state 378, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
mod_longident 
mod_longident . DOT UIDENT 

** Conflict (shift/reduce) in state 360.
** Token involved: RPAREN
** This state is reached from implementation after reading:

LBRACEBAR LBRACKETBAR LPAREN static_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
LBRACEBAR process BARRBRACE 
          process0 
          static_expr LESSLESSGREATERGREATER 
          LBRACKETBAR static_semi_list opt_semi BARRBRACKET 
                      static_expr 
                      (?)

** In state 360, looking ahead at RPAREN, reducing production
** static_comma_list -> static_expr
** is permitted because of the following sub-derivation:

LPAREN static_comma_list RPAREN // lookahead token appears
       static_expr . 

** In state 360, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN static_expr . RPAREN 

** Conflict (shift/reduce) in state 339.
** Token involved: DOT
** This state is reached from implementation after reading:

TRY mod_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    (?)

** In state 339, looking ahead at DOT, reducing production
** constr_longident -> mod_longident
** is permitted because of the following sub-derivation:

simple_expr DOT label_longident LESSMINUS expr // lookahead token appears
constr_longident // lookahead token is inherited
mod_longident . 

** In state 339, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
mod_longident 
mod_longident . DOT UIDENT 

** Conflict (shift/reduce) in state 298.
** Token involved: COMMA
** This state is reached from implementation after reading:

LET rec_flag pattern_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET rec_flag let_bindings 
             let_binding 
             pattern EQUAL seq_expr 
             pattern_comma_list 
             (?)

** In state 298, looking ahead at COMMA, reducing production
** pattern -> pattern_comma_list
** is permitted because of the following sub-derivation:

pattern COMMA pattern // lookahead token appears
pattern_comma_list . 

** In state 298, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

pattern_comma_list . COMMA pattern 

** Conflict (shift/reduce) in state 289.
** Token involved: EQUAL
** This state is reached from implementation after reading:

LET rec_flag val_ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET rec_flag let_bindings 
             let_binding 
             (?)

** In state 289, looking ahead at EQUAL, shifting is permitted
** because of the following sub-derivation:

val_ident fun_binding 
          . EQUAL seq_expr 

** In state 289, looking ahead at EQUAL, reducing production
** simple_pattern -> val_ident
** is permitted because of the following sub-derivation:

pattern EQUAL seq_expr // lookahead token appears
simple_pattern // lookahead token is inherited
val_ident . 

** Conflict (shift/reduce) in state 284.
** Tokens involved: WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
** The following explanations concentrate on token WHILE.
** This state is reached from implementation after reading:

LOC seq_expr SEMISEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LOC location END 
    location_tail 
    (?)

** In state 284, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

location_item location_tail 
seq_expr location_tail 
         SEMISEMI location_item 
                  seq_expr location_tail 
                  expr 
                  . WHILE seq_expr DO seq_expr DONE 

** In state 284, looking ahead at WHILE, reducing production
** location_tail -> SEMISEMI
** is permitted because of the following sub-derivation:

location_item location_tail // lookahead token appears because location_tail can begin with WHILE
seq_expr location_tail // lookahead token is inherited
         SEMISEMI . 

** Conflict (shift/reduce) in state 232.
** Token involved: MINUSGREATER
** This state is reached from implementation after reading:

PARSER LPAREN pattern COLON core_type MINUSGREATER core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
PARSER opt_pat opt_bar parser_cases 
       simple_pattern 
       LPAREN pattern COLON core_type RPAREN 
                            (?)

** In state 232, looking ahead at MINUSGREATER, shifting is permitted
** because of the following sub-derivation:

core_type MINUSGREATER core_type 
                       core_type . MINUSGREATER core_type 

** In state 232, looking ahead at MINUSGREATER, reducing production
** core_type -> core_type MINUSGREATER core_type
** is permitted because of the following sub-derivation:

core_type MINUSGREATER core_type // lookahead token appears
core_type MINUSGREATER core_type . 

** Conflict (shift/reduce) in state 168.
** Token involved: MINUSGREATER
** This state is reached from implementation after reading:

LPAREN seq_expr COLONGREATER core_type MINUSGREATER core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
simple_expr 
LPAREN seq_expr type_constraint RPAREN 
                COLONGREATER core_type 
                             (?)

** In state 168, looking ahead at MINUSGREATER, shifting is permitted
** because of the following sub-derivation:

core_type MINUSGREATER core_type 
                       core_type . MINUSGREATER core_type 

** In state 168, looking ahead at MINUSGREATER, reducing production
** core_type -> core_type MINUSGREATER core_type
** is permitted because of the following sub-derivation:

core_type MINUSGREATER core_type // lookahead token appears
core_type MINUSGREATER core_type . 

** Conflict (shift/reduce) in state 149.
** Token involved: SHARP
** This state is reached from use_file after reading:

TYPE type_parameters LIDENT EQUAL simple_core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 149, looking ahead at SHARP, reducing production
** core_type -> simple_core_type
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
TYPE type_declarations // lookahead token is inherited
     type_declaration // lookahead token is inherited
     type_parameters LIDENT type_kind constraints // lookahead token is inherited because constraints can vanish
                            EQUAL core_type // lookahead token is inherited
                                  simple_core_type . 

** In state 149, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
TYPE type_declarations 
     type_declaration 
     type_parameters LIDENT type_kind constraints 
                            EQUAL core_type 
                                  simple_core_type 
                                  simple_core_type . SHARP class_longident 

** Conflict (shift/reduce) in state 71.
** Token involved: COMMA
** This state is reached from implementation after reading:

PARSER LPAREN pattern_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
PARSER opt_pat opt_bar parser_cases 
       simple_pattern 
       LPAREN pattern RPAREN 
              pattern_comma_list 
              (?)

** In state 71, looking ahead at COMMA, reducing production
** pattern -> pattern_comma_list
** is permitted because of the following sub-derivation:

pattern COMMA pattern // lookahead token appears
pattern_comma_list . 

** In state 71, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

pattern_comma_list . COMMA pattern 
