%{
open Location
open Asttypes
open Longident
open Parsetree

let mktyp d =
  { ptyp_desc = d; ptyp_loc = symbol_loc() }
let mkpat d =
  { ppat_desc = d; ppat_loc = symbol_loc() }
let mkexp d =
  { pexp_desc = d; pexp_loc = symbol_loc() }
let mkmty d =
  { pmty_desc = d; pmty_loc = symbol_loc() }
let mksig d =
  { psig_desc = d; psig_loc = symbol_loc() }
let mkmod d =
  { pmod_desc = d; pmod_loc = symbol_loc() }
let mkstr d =
  { pstr_desc = d; pstr_loc = symbol_loc() }
let mkfield d =
  { pfield_desc = d; pfield_loc = symbol_loc() }
let mkproc d = (* Join *)
  { pproc_desc = d; pproc_loc = symbol_loc() }

let mkoperator name pos =
  { pexp_desc = Pexp_ident(Lident name); pexp_loc = rhs_loc pos }

let void () = mkexp (Pexp_construct (Lident "()", None, false))
let void_pat () = mkpat (Ppat_construct (Lident "()", None, false))

let mkassert e =
  let {loc_start = st; loc_end = en} = symbol_loc () in
  let triple = mkexp (Pexp_tuple
                       [mkexp (Pexp_constant (Const_string !input_name));
                        mkexp (Pexp_constant (Const_int st));
                        mkexp (Pexp_constant (Const_int en))]) in
  let ex = Ldot (Lident "Pervasives", "Assert_failure") in
  let bucket = mkexp (Pexp_construct (ex, Some triple, false)) in
  let ra = Ldot (Lident "Pervasives", "raise") in
  let raiser = mkexp (Pexp_apply (mkexp (Pexp_ident ra), [bucket])) in
  let un = mkexp (Pexp_construct (Lident "()", None, false)) in
  match e with
  | {pexp_desc = Pexp_construct (Lident "false", None, false) } -> raiser
  | _ -> if !Clflags.noassert
         then un
         else mkexp (Pexp_ifthenelse (e, un, Some raiser))
;;
let mklazy e =
  let void_pat = mkpat (Ppat_construct (Lident "()", None, false)) in
  let f = mkexp (Pexp_function ([void_pat, e])) in
  let delayed = Ldot (Lident "Lazy", "Delayed") in
  let df = mkexp (Pexp_construct (delayed, Some f, false)) in
  let r = mkexp (Pexp_ident (Ldot (Lident "Pervasives", "ref"))) in
  mkexp (Pexp_apply (r, [df]))
;;

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, [arg1; arg2]))

let mkuminus name arg =
  match arg.pexp_desc with
    Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float("-" ^ f)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [arg]))

let rec mklistexp = function
    [] ->
      mkexp(Pexp_construct(Lident "[]", None, false))
  | e1 :: el ->
      mkexp(Pexp_construct(Lident "::",
                           Some(mkexp(Pexp_tuple[e1; mklistexp el])),
                           false))
let rec mklistpat = function
    [] ->
      mkpat(Ppat_construct(Lident "[]", None, false))
  | p1 :: pl ->
      mkpat(Ppat_construct(Lident "::",
                           Some(mkpat(Ppat_tuple[p1; mklistpat pl])),
                           false))

let mkstrexp e =
  { pstr_desc = Pstr_eval e; pstr_loc = e.pexp_loc }

let array_function str name =
  Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name))

let rec mkrangepat c1 c2 =
  if c1 > c2 then mkrangepat c2 c1 else
  if c1 = c2 then mkpat(Ppat_constant(Const_char c1)) else
  mkpat(Ppat_or(mkpat(Ppat_constant(Const_char c1)),
                mkrangepat (Char.chr(Char.code c1 + 1)) c2))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

let mkloc l =
  let r = mkexp (Pexp_ident (Ldot (Lident "Join", "create_location"))) in
	mkexp (Pexp_apply (r, [mkexp (Pexp_thismodule);l]))

let pproc_add list = function
    { pproc_desc= Pproc_par l } -> l@list
  | { pproc_desc= Pproc_null } -> list
  | p -> p::list

%}
%start implementation
%start interface
%start toplevel_phrase
%start use_file
%token AMPERAMPER
%token AMPERSAND
%token AND
%token AS
%token ASSERT
%token BAR
%token BARBAR
%token BARRBRACE
%token BARRBRACKET
%token BEGIN
%token <char> CHAR
%token CLASS
%token CLOSED
%token COLON
%token COLONCOLON
%token COLONEQUAL
%token COLONGREATER
%token COMMA
%token CONSTRAINT
%token DEF
%token DO
%token DONE
%token DOT
%token DOTDOT
%token DOWNTO
%token ELSE
%token END
%token EOF
%token EQUAL
%token EQUALGREATER
%token EXCEPTION
%token EXTERNAL
%token FALSE
%token <string> FLOAT
%token FOR
%token FUN
%token FUNCTION
%token FUNCTOR
%token GREATER
%token GREATERGREATER
%token GREATERRBRACE
%token GREATERRBRACKET
%token IF
%token IN
%token INCLUDE
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token INHERIT
%token <int> INT
%token LAZY
%token LBRACE
%token LBRACEBAR
%token LBRACEBARBARRBRACE
%token LBRACELESS
%token LBRACKET
%token LBRACKETBAR
%token LBRACKETLESS
%token LESS
%token LESSGREATER
%token LESSLESS
%token LESSLESSGREATERGREATER
%token LESSMINUS
%token LET
%token <string> LIDENT
%token LOC
%token LPAREN
%token MATCH
%token METHOD
%token MINUSGREATER
%token MODULE
%token MUTABLE
%token NEW
%token OF
%token OPEN
%token OR
%token PARSER
%token <string> PREFIXOP
%token PRIVATE
%token PROTECTED
%token QUESTION
%token QUOTE
%token RBRACE
%token RBRACKET
%token REC
%token REPLY
%token RPAREN
%token SEMI
%token SEMISEMI
%token SHARP
%token SIG
%token STAR
%token <string> STRING
%token STRUCT
%token <string> SUBTRACTIVE
%token THEN
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token VAL
%token VIRTUAL
%token WHEN
%token WHILE
%token WITH
%right prec_let
%right prec_type_def
%right SEMI
%right prec_fun prec_match prec_try
%right prec_list
%right prec_if
%right COLONEQUAL LESSMINUS
%left AS
%left BAR
%left COMMA
%right prec_type_arrow
%right BARBAR OR
%right AMPERAMPER AMPERSAND
%left EQUAL GREATER INFIXOP0 LESS LESSGREATER
%right INFIXOP1
%right COLONCOLON
%left INFIXOP2 SUBTRACTIVE
%left INFIXOP3 STAR
%right INFIXOP4
%right prec_unary_minus
%left prec_appl
%right prec_constr_appl
%left SHARP
%left DOT
%right PREFIXOP
%type <Parsetree.structure> implementation
%type <Parsetree.signature> interface
%type <Parsetree.toplevel_phrase> toplevel_phrase
%type <Parsetree.toplevel_phrase list> use_file
%%

implementation:
  _1 = structure _2 = EOF
    {                                         ( _1 )}

interface:
  _1 = signature _2 = EOF
    {                                         ( List.rev _1 )}

toplevel_phrase:
  _1 = top_structure _2 = SEMISEMI
    {                                         ( Ptop_def _1 )}
| _1 = seq_expr _2 = SEMISEMI
    {                                         ( Ptop_def[mkstrexp _1] )}
| _1 = toplevel_directive _2 = SEMISEMI
    {                                         ( _1 )}
| _1 = EOF
    {                                         ( raise End_of_file )}

top_structure:
  _1 = structure_item
    {                                         ( [_1] )}
| _1 = structure_item _2 = top_structure
    {                                         ( _1 :: _2 )}

use_file:
  _1 = use_file_tail
    {                                         ( _1 )}
| _1 = seq_expr _2 = use_file_tail
    {                                         ( Ptop_def[mkstrexp _1] :: _2 )}

use_file_tail:
  _1 = EOF
    {                                                ( [] )}
| _1 = SEMISEMI _2 = EOF
    {                                                ( [] )}
| _1 = SEMISEMI _2 = seq_expr _3 = use_file_tail
    {                                                ( Ptop_def[mkstrexp _2] :: _3 )}
| _1 = SEMISEMI _2 = structure_item _3 = use_file_tail
    {                                                ( Ptop_def[_2] :: _3 )}
| _1 = SEMISEMI _2 = toplevel_directive _3 = use_file_tail
    {                                                ( _2 :: _3 )}
| _1 = structure_item _2 = use_file_tail
    {                                                ( Ptop_def[_1] :: _2 )}
| _1 = toplevel_directive _2 = use_file_tail
    {                                                ( _1 :: _2 )}

module_expr:
  _1 = mod_longident
    {      ( mkmod(Pmod_ident _1) )}
| _1 = STRUCT _2 = structure _3 = END
    {      ( mkmod(Pmod_structure(_2)) )}
| _1 = STRUCT _2 = structure _3 = error
    {      ( unclosed "struct" 1 "end" 3 )}
| _1 = FUNCTOR _2 = LPAREN _3 = UIDENT _4 = COLON _5 = module_type _6 = RPAREN _7 = MINUSGREATER _8 = module_expr %prec prec_fun
    {      ( mkmod(Pmod_functor(_3, _5, _8)) )}
| _1 = module_expr _2 = LPAREN _3 = module_expr _4 = RPAREN
    {      ( mkmod(Pmod_apply(_1, _3)) )}
| _1 = module_expr _2 = LPAREN _3 = module_expr _4 = error
    {      ( unclosed "(" 2 ")" 4 )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = RPAREN
    {      ( mkmod(Pmod_constraint(_2, _4)) )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = error
    {      ( unclosed "(" 1 ")" 5 )}
| _1 = LPAREN _2 = module_expr _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = module_expr _3 = error
    {      ( unclosed "(" 1 ")" 3 )}

structure:
  _1 = structure_tail
    {                                                ( _1 )}
| _1 = seq_expr _2 = structure_tail
    {                                                ( mkstrexp _1 :: _2 )}

structure_tail:
  
    {                                                ( [] )}
| _1 = SEMISEMI
    {                                                ( [] )}
| _1 = SEMISEMI _2 = seq_expr _3 = structure_tail
    {                                                ( mkstrexp _2 :: _3 )}
| _1 = SEMISEMI _2 = structure_item _3 = structure_tail
    {                                                ( _2 :: _3 )}
| _1 = structure_item _2 = structure_tail
    {                                                ( _1 :: _2 )}

structure_item:
  _1 = DEF _2 = def_bindings
    {      ( match _2 with
          [{ppat_desc = Ppat_any}, exp] -> mkstr(Pstr_eval exp)
        | _ -> mkstr(Pstr_def(List.rev _2)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings
    {      ( match _3 with
          [{ppat_desc = Ppat_any}, exp] -> mkstr(Pstr_eval exp)
        | _ -> mkstr(Pstr_value(_2, List.rev _3)) )}
| _1 = EXTERNAL _2 = val_ident _3 = COLON _4 = core_type _5 = EQUAL _6 = primitive_declaration
    {      ( mkstr(Pstr_primitive(_2, {pval_type = _4; pval_prim = _6})) )}
| _1 = TYPE _2 = type_declarations
    {      ( mkstr(Pstr_type(List.rev _2)) )}
| _1 = EXCEPTION _2 = UIDENT _3 = constructor_arguments
    {      ( mkstr(Pstr_exception(_2, _3)) )}
| _1 = MODULE _2 = UIDENT _3 = module_binding
    {      ( mkstr(Pstr_module(_2, _3)) )}
| _1 = MODULE _2 = TYPE _3 = ident _4 = EQUAL _5 = module_type
    {      ( mkstr(Pstr_modtype(_3, _5)) )}
| _1 = OPEN _2 = mod_longident
    {      ( mkstr(Pstr_open _2) )}
| _1 = CLASS _2 = class_list _3 = END
    {      ( mkstr(Pstr_class (List.rev _2)) )}
| _1 = CLASS _2 = class_list _3 = error
    {      ( unclosed "class" 1 "end" 3 )}

module_binding:
  _1 = EQUAL _2 = module_expr
    {      ( _2 )}
| _1 = COLON _2 = module_type _3 = EQUAL _4 = module_expr
    {      ( mkmod(Pmod_constraint(_4, _2)) )}
| _1 = LPAREN _2 = UIDENT _3 = COLON _4 = module_type _5 = RPAREN _6 = module_binding
    {      ( mkmod(Pmod_functor(_2, _4, _6)) )}

module_type:
  _1 = mty_longident
    {      ( mkmty(Pmty_ident _1) )}
| _1 = SIG _2 = signature _3 = END
    {      ( mkmty(Pmty_signature(List.rev _2)) )}
| _1 = SIG _2 = signature _3 = error
    {      ( unclosed "sig" 1 "end" 3 )}
| _1 = FUNCTOR _2 = LPAREN _3 = UIDENT _4 = COLON _5 = module_type _6 = RPAREN _7 = MINUSGREATER _8 = module_type %prec prec_fun
    {      ( mkmty(Pmty_functor(_3, _5, _8)) )}
| _1 = module_type _2 = WITH _3 = with_constraints
    {      ( mkmty(Pmty_with(_1, List.rev _3)) )}
| _1 = LPAREN _2 = module_type _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = module_type _3 = error
    {      ( unclosed "(" 1 ")" 3 )}

signature:
  
    {                                                ( [] )}
| _1 = signature _2 = signature_item
    {                                                ( _2 :: _1 )}
| _1 = signature _2 = signature_item _3 = SEMISEMI
    {                                                ( _2 :: _1 )}

signature_item:
  _1 = VAL _2 = val_ident _3 = COLON _4 = core_type
    {      ( mksig(Psig_value(_2, {pval_type = _4; pval_prim = []})) )}
| _1 = EXTERNAL _2 = val_ident _3 = COLON _4 = core_type _5 = EQUAL _6 = primitive_declaration
    {      ( mksig(Psig_value(_2, {pval_type = _4; pval_prim = _6})) )}
| _1 = TYPE _2 = type_declarations
    {      ( mksig(Psig_type(List.rev _2)) )}
| _1 = EXCEPTION _2 = UIDENT _3 = constructor_arguments
    {      ( mksig(Psig_exception(_2, _3)) )}
| _1 = MODULE _2 = UIDENT _3 = module_declaration
    {      ( mksig(Psig_module(_2, _3)) )}
| _1 = MODULE _2 = TYPE _3 = ident
    {      ( mksig(Psig_modtype(_3, Pmodtype_abstract)) )}
| _1 = MODULE _2 = TYPE _3 = ident _4 = EQUAL _5 = module_type
    {      ( mksig(Psig_modtype(_3, Pmodtype_manifest _5)) )}
| _1 = OPEN _2 = mod_longident
    {      ( mksig(Psig_open _2) )}
| _1 = INCLUDE _2 = module_type
    {      ( mksig(Psig_include _2) )}
| _1 = CLASS _2 = class_type_list _3 = END
    {      ( mksig(Psig_class (List.rev _2)) )}

module_declaration:
  _1 = COLON _2 = module_type
    {      ( _2 )}
| _1 = LPAREN _2 = UIDENT _3 = COLON _4 = module_type _5 = RPAREN _6 = module_declaration
    {      ( mkmty(Pmty_functor(_2, _4, _6)) )}

seq_expr:
  _1 = expr
    {                                  ( _1 )}
| _1 = expr _2 = SEMI
    {                                  ( _1 )}
| _1 = expr _2 = SEMI _3 = seq_expr
    {                                  ( mkexp(Pexp_sequence(_1, _3)) )}

expr:
  _1 = simple_expr
    {      ( _1 )}
| _1 = simple_expr _2 = simple_expr_list %prec prec_appl
    {      ( mkexp(Pexp_apply(_1, List.rev _2)) )}
| _1 = DEF _2 = def_bindings _3 = IN _4 = seq_expr %prec prec_let
    {      ( mkexp(Pexp_def(List.rev _2, _4)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = IN _5 = seq_expr %prec prec_let
    {      ( mkexp(Pexp_let(_2, List.rev _3, _5)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = IN _5 = error %prec prec_let
    {      ( syntax_error() )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = error %prec prec_let
    {      ( unclosed "let" 1 "in" 4 )}
| _1 = LBRACEBAR _2 = process _3 = BARRBRACE
    {      ( mkexp(Pexp_process _2) )}
| _1 = simple_expr _2 = LESSLESS _3 = list_of_exprs _4 = GREATERGREATER
    {      ( mkexp(Pexp_call(_1, List.rev _3 )) )}
| _1 = simple_expr _2 = LESSLESS _3 = list_of_exprs _4 = error
    {      ( unclosed "<<"  2 ">>" 4 )}
| _1 = simple_expr _2 = LESSLESSGREATERGREATER
    {      ( mkexp(Pexp_call(_1, [] )) )}
| _1 = PARSER _2 = opt_pat _3 = opt_bar _4 = parser_cases %prec prec_fun
    {      ( Pstream.cparser (_2, List.rev _4) )}
| _1 = FUNCTION _2 = opt_bar _3 = match_cases %prec prec_fun
    {      ( mkexp(Pexp_function(List.rev _3)) )}
| _1 = FUN _2 = simple_pattern _3 = fun_def %prec prec_fun
    {      ( mkexp(Pexp_function([_2, _3])) )}
| _1 = MATCH _2 = seq_expr _3 = WITH _4 = opt_bar _5 = match_cases %prec prec_match
    {      ( mkexp(Pexp_match(_2, List.rev _5)) )}
| _1 = MATCH _2 = seq_expr _3 = WITH _4 = PARSER _5 = opt_pat _6 = opt_bar _7 = parser_cases %prec prec_match
    {      ( mkexp(Pexp_apply(Pstream.cparser (_5, List.rev _7), [_2])) )}
| _1 = TRY _2 = seq_expr _3 = WITH _4 = opt_bar _5 = match_cases %prec prec_try
    {      ( mkexp(Pexp_try(_2, List.rev _5)) )}
| _1 = TRY _2 = seq_expr _3 = WITH _4 = error %prec prec_try
    {      ( syntax_error() )}
| _1 = TRY _2 = seq_expr _3 = error %prec prec_try
    {      ( unclosed "try" 1 "with" 3 )}
| _1 = expr_comma_list
    {      ( mkexp(Pexp_tuple(List.rev _1)) )}
| _1 = constr_longident _2 = simple_expr %prec prec_constr_appl
    {      ( mkexp(Pexp_construct(_1, Some _2, false)) )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = expr _5 = ELSE _6 = expr %prec prec_if
    {      ( mkexp(Pexp_ifthenelse(_2, _4, Some _6)) )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = expr %prec prec_if
    {      ( mkexp(Pexp_ifthenelse(_2, _4, None)) )}
| _1 = WHILE _2 = seq_expr _3 = DO _4 = seq_expr _5 = DONE
    {      ( mkexp(Pexp_while(_2, _4)) )}
| _1 = WHILE _2 = seq_expr _3 = DO _4 = seq_expr _5 = error
    {      ( unclosed "while" 1 "done" 5 )}
| _1 = FOR _2 = val_ident _3 = EQUAL _4 = seq_expr _5 = direction_flag _6 = seq_expr _7 = DO _8 = seq_expr _9 = DONE
    {      ( mkexp(Pexp_for(_2, _4, _6, _5, _8)) )}
| _1 = FOR _2 = val_ident _3 = EQUAL _4 = seq_expr _5 = direction_flag _6 = seq_expr _7 = DO _8 = seq_expr _9 = error
    {      ( unclosed "for" 1 "done" 9 )}
| _1 = expr _2 = COLONCOLON _3 = expr
    {      ( mkexp(Pexp_construct(Lident "::", Some(mkexp(Pexp_tuple[_1;_3])), false)) )}
| _1 = expr _2 = INFIXOP0 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = LESSGREATER _3 = expr
    {      ( mkinfix _1 "<>" _3 )}
| _1 = expr _2 = INFIXOP1 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP2 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP3 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP4 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = SUBTRACTIVE _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = STAR _3 = expr
    {      ( mkinfix _1 "*" _3 )}
| _1 = expr _2 = EQUAL _3 = expr
    {      ( mkinfix _1 "=" _3 )}
| _1 = expr _2 = LESS _3 = expr
    {      ( mkinfix _1 "<" _3 )}
| _1 = expr _2 = GREATER _3 = expr
    {      ( mkinfix _1 ">" _3 )}
| _1 = expr _2 = OR _3 = expr
    {      ( mkinfix _1 "or" _3 )}
| _1 = expr _2 = BARBAR _3 = expr
    {      ( mkinfix _1 "||" _3 )}
| _1 = expr _2 = AMPERSAND _3 = expr
    {      ( mkinfix _1 "&" _3 )}
| _1 = expr _2 = AMPERAMPER _3 = expr
    {      ( mkinfix _1 "&&" _3 )}
| _1 = expr _2 = COLONEQUAL _3 = expr
    {      ( mkinfix _1 ":=" _3 )}
| _1 = SUBTRACTIVE _2 = expr %prec prec_unary_minus
    {      ( mkuminus _1 _2 )}
| _1 = simple_expr _2 = DOT _3 = label_longident _4 = LESSMINUS _5 = expr
    {      ( mkexp(Pexp_setfield(_1, _3, _5)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN _6 = LESSMINUS _7 = expr
    {      ( mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "Array" "set")),
                         [_1; _4; _7])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET _6 = LESSMINUS _7 = expr
    {      ( mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "String" "set")),
                         [_1; _4; _7])) )}
| _1 = label _2 = LESSMINUS _3 = expr
    {      ( mkexp(Pexp_setinstvar(_1, _3)) )}
| _1 = ASSERT _2 = simple_expr %prec prec_appl
    {      ( mkassert _2 )}
| _1 = LAZY _2 = simple_expr %prec prec_appl
    {      ( mklazy _2 )}

simple_expr:
  _1 = val_longident
    {      ( mkexp(Pexp_ident _1) )}
| _1 = constant
    {      ( mkexp(Pexp_constant _1) )}
| _1 = constr_longident
    {      ( mkexp(Pexp_construct(_1, None, false)) )}
| _1 = LPAREN _2 = seq_expr _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = seq_expr _3 = error
    {      ( unclosed "(" 1 ")" 3 )}
| _1 = BEGIN _2 = seq_expr _3 = END
    {      ( _2 )}
| _1 = BEGIN _2 = seq_expr _3 = error
    {      ( unclosed "begin" 1 "end" 3 )}
| _1 = LPAREN _2 = seq_expr _3 = type_constraint _4 = RPAREN
    {      ( let (t, t') = _3 in mkexp(Pexp_constraint(_2, t, t')) )}
| _1 = simple_expr _2 = DOT _3 = label_longident
    {      ( mkexp(Pexp_field(_1, _3)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN
    {      ( mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "Array" "get")),
                         [_1; _4])) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = error
    {      ( unclosed "(" 3 ")" 5 )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET
    {      ( mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "String" "get")),
                         [_1; _4])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = error
    {      ( unclosed "[" 3 "]" 5 )}
| _1 = LBRACE _2 = lbl_expr_list _3 = opt_semi _4 = RBRACE
    {      ( mkexp(Pexp_record(List.rev _2)) )}
| _1 = LBRACE _2 = lbl_expr_list _3 = opt_semi _4 = error
    {      ( unclosed "{" 1 "}" 4 )}
| _1 = LBRACKETLESS _2 = stream_expr _3 = opt_semi _4 = GREATERRBRACKET
    {      ( Pstream.cstream (List.rev _2) )}
| _1 = LBRACKETLESS _2 = stream_expr _3 = opt_semi _4 = error
    {      ( unclosed "[<" 1 ">]" 4 )}
| _1 = LBRACKETLESS _2 = GREATERRBRACKET
    {      ( Pstream.cstream [] )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = BARRBRACKET
    {      ( mkexp(Pexp_array(List.rev _2)) )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = error
    {       ( unclosed "[|" 1 "|]" 4 )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkexp(Pexp_array []) )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = RBRACKET
    {      ( mklistexp(List.rev _2) )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[" 1 "]" 4 )}
| _1 = PREFIXOP _2 = simple_expr
    {      ( mkexp(Pexp_apply(mkoperator _1 1, [_2])) )}
| _1 = simple_expr _2 = SHARP _3 = label
    {      ( mkexp(Pexp_send(_1, _3)) )}
| _1 = NEW _2 = class_longident
    {      ( mkexp(Pexp_new(_2)) )}
| _1 = LBRACELESS _2 = label_expr_list _3 = opt_semi _4 = GREATERRBRACE
    {      ( mkexp(Pexp_override(List.rev _2)) )}
| _1 = LBRACELESS _2 = label_expr_list _3 = opt_semi _4 = error
    {      ( unclosed "{<" 1 ">}" 4 )}
| _1 = LBRACELESS _2 = GREATERRBRACE
    {      ( mkexp(Pexp_override []) )}
| _1 = LPAREN _2 = SHARP _3 = label _4 = RPAREN
    {      ( mkexp(Pexp_function [mkpat(Ppat_var "x"),
                mkexp(Pexp_send(mkexp(Pexp_ident (Lident"x")), _3))]) )}
| _1 = LOC _2 = location _3 = END
    {      ( Clflags.join:= true; mkloc (mkexp (Pexp_function [void_pat (),(_2)])) )}

list_of_exprs:
  _1 = expr
    {  ( match _1 with
        { pexp_desc = Pexp_tuple t } -> t
      | e -> [e]
  )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {                                         ( [_2] )}

simple_expr_list:
  _1 = simple_expr
    {      ( [_1] )}
| _1 = simple_expr_list _2 = simple_expr
    {      ( _2 :: _1 )}

def_binding:
  _1 = join_pattern _2 = EQUAL _3 = process %prec prec_let
    {      ( (_1,mkexp(Pexp_process(_3))) )}

join_pattern:
  _1 = LIDENT _2 = LESS _3 = join_args _4 = GREATER
    {                                       ( mkpat(Ppat_channel (_1,_3,Async)) )}
| _1 = LIDENT _2 = LESSGREATER
    {                                       ( mkpat(Ppat_channel (_1,[],Async)) )}
| _1 = LIDENT _2 = LESSLESS _3 = join_args _4 = GREATERGREATER
    {           ( mkpat(Ppat_channel (_1,_3,Sync)) )}
| _1 = LIDENT _2 = LESSLESSGREATERGREATER
    {           ( mkpat(Ppat_channel (_1,[],Sync)) )}
| _1 = join_pattern _2 = BAR _3 = join_pattern
    {                                       ( mkpat(Ppat_or(_1,_3)) )}

join_args:
  
    {                    ( [] )}
| _1 = simple_pattern
    {                           ( [_1] )}
| _1 = pattern_comma_list
    {                           ( List.rev _1 )}

location:
  _1 = location_tail
    {                                          ( _1 )}

location_tail:
  
    {                                              ( void () )}
| _1 = SEMISEMI
    {                                              ( void () )}
| _1 = SEMISEMI _2 = location_item
    {                                              ( _2 )}
| _1 = location_item _2 = location_tail
    {                                              ( _1 )}

location_item:
  _1 = DEF _2 = def_bindings _3 = location_tail
    {      ( mkexp(Pexp_def(List.rev _2, _3)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = location_tail
    {      ( mkexp(Pexp_let(_2, List.rev _3, _4)) )}
| _1 = seq_expr _2 = location_tail
    {      ( mkexp(Pexp_sequence(_1,_2)) )}

process:
  
    {                                             ( mkproc(Pproc_null))}
| _1 = process0
    {                                             ( _1 )}
| _1 = process0 _2 = BAR _3 = process
    {     ( mkproc(Pproc_par(pproc_add (pproc_add [] _1) _3)) )}
| _1 = DEF _2 = def_bindings _3 = IN _4 = process %prec prec_let
    {      ( mkproc(Pproc_def(List.rev _2, _4)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = IN _5 = process %prec prec_let
    {      ( mkproc(Pproc_let(_2, List.rev _3, _5)) )}
| _1 = BEGIN _2 = seq_expr _3 = END _4 = SEMI _5 = process
    {      ( mkproc(Pproc_let(Nonrecursive,[mkpat(Ppat_any),_2],_5)) )}
| _1 = BEGIN _2 = seq_expr _3 = error
    {      ( unclosed "BEGIN" 1 "END" 3 )}
| _1 = IF _2 = expr _3 = THEN _4 = process0 %prec prec_if
    {      ( mkproc(Pproc_if(_2,_4,mkproc(Pproc_null))) )}

to_ident:
  _1 = TO _2 = LIDENT
    {                ( Some _2 )}
| 
    {                  ( None )}

process0:
  _1 = REPLY _2 = static_expr _3 = to_ident
    {      ( mkproc(Pproc_reply(_2,_3)))}
| _1 = static_expr _2 = LESSLESSGREATERGREATER
    {      ( mkproc(Pproc_send(_1, [] )) )}
| _1 = static_expr _2 = LESSLESS _3 = static_comma_list _4 = GREATERGREATER
    {      ( mkproc(Pproc_send(_1, List.rev _3 )) )}
| _1 = static_expr _2 = LESSLESS _3 = static_comma_list _4 = error
    {      ( unclosed "<<" 2 ">>" 4 )}
| _1 = IF _2 = expr _3 = THEN _4 = process0 _5 = ELSE _6 = process0 %prec prec_if
    {      ( mkproc(Pproc_if(_2,_4,_6)) )}
| _1 = LBRACEBARBARRBRACE
    {                                  ( mkproc(Pproc_null) )}
| _1 = LBRACEBAR _2 = process _3 = BARRBRACE
    {                                ( _2 )}

static_semi_list:
  _1 = static_expr %prec prec_list
    {                                                          ( [_1] )}
| _1 = static_semi_list _2 = SEMI _3 = static_expr %prec prec_list
    {                                                         ( _3 :: _1 )}

static_expr:
  _1 = val_longident
    {      ( mkexp(Pexp_ident _1) )}
| _1 = constant
    {      ( mkexp(Pexp_constant _1) )}
| _1 = constr_longident
    {      ( mkexp(Pexp_construct(_1, None, false)) )}
| _1 = static_expr _2 = DOT _3 = label_longident
    {      ( mkexp(Pexp_field(_1, _3)) )}
| _1 = LPAREN _2 = static_expr _3 = type_constraint _4 = RPAREN
    {      ( let (t, t') = _3 in mkexp(Pexp_constraint(_2, t, t')) )}
| _1 = LPAREN _2 = static_expr _3 = RPAREN
    {      ( _2 )}
| _1 = LBRACKETBAR _2 = static_semi_list _3 = opt_semi _4 = BARRBRACKET
    {      ( mkexp(Pexp_array(List.rev _2)) )}
| _1 = LBRACKETBAR _2 = static_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[|" 1 "|]" 4 )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkexp(Pexp_array []) )}
| _1 = LBRACKET _2 = static_semi_list _3 = opt_semi _4 = RBRACKET
    {      ( mklistexp(List.rev _2) )}
| _1 = LBRACKET _2 = static_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[" 1 "]" 4 )}
| _1 = LPAREN _2 = static_comma_list _3 = RPAREN
    {      ( mkexp(Pexp_tuple(List.rev _2)) )}

static_comma_list:
  _1 = static_expr
    {                                          ( [_1] )}
| _1 = static_comma_list _2 = COMMA _3 = static_expr
    {                                           ( _3 :: _1 )}

let_bindings:
  _1 = let_binding
    {                                                ( [_1] )}
| _1 = let_bindings _2 = AND _3 = let_binding
    {                                                ( _3 :: _1 )}

let_binding:
  _1 = val_ident _2 = fun_binding
    {      ( ({ppat_desc = Ppat_var _1; ppat_loc = rhs_loc 1}, _2) )}
| _1 = pattern _2 = EQUAL _3 = seq_expr %prec prec_let
    {      ( (_1,_3) )}
| _1 = pattern _2 = COLONEQUAL _3 = seq_expr %prec prec_let
    {      (  let r = mkexp (Pexp_ident (Ldot (Lident "Pervasives", "ref"))) in
	    (_1, mkexp (Pexp_apply (r, [_3]))) )}

def_bindings:
  _1 = def_binding
    {                                                   ( [_1] )}
| _1 = def_bindings _2 = AND _3 = def_binding
    {                                                ( _3 :: _1 )}

fun_binding:
  _1 = EQUAL _2 = seq_expr %prec prec_let
    {      ( _2 )}
| _1 = type_constraint _2 = EQUAL _3 = seq_expr %prec prec_let
    {      ( let (t, t') = _1 in mkexp(Pexp_constraint(_3, t, t')) )}
| _1 = simple_pattern _2 = fun_binding
    {      ( mkexp(Pexp_function[_1,_2]) )}

parser_cases:
  _1 = parser_case
    {                                                ( [_1] )}
| _1 = parser_cases _2 = BAR _3 = parser_case
    {                                                ( _3 :: _1 )}

parser_case:
  _1 = LBRACKETLESS _2 = stream_pattern _3 = opt_semi _4 = GREATERRBRACKET _5 = opt_pat _6 = MINUSGREATER _7 = seq_expr
    {      ( (List.rev _2, _5, _7) )}
| _1 = LBRACKETLESS _2 = stream_pattern _3 = opt_semi _4 = error
    {      ( unclosed "[<" 1 ">]" 4 )}
| _1 = LBRACKETLESS _2 = GREATERRBRACKET _3 = opt_pat _4 = MINUSGREATER _5 = seq_expr
    {      ( ([], _3, _5) )}

stream_pattern:
  _1 = stream_pattern_component _2 = opt_err
    {                                                         ( [(_1, _2)] )}
| _1 = stream_pattern _2 = SEMI _3 = stream_pattern_component _4 = opt_err
    {                                                         ( (_3, _4) :: _1 )}

stream_pattern_component:
  _1 = QUOTE _2 = pattern
    {      ( Pstream.Spat_term (_2, None) )}
| _1 = QUOTE _2 = pattern _3 = WHEN _4 = expr %prec prec_list
    {      ( Pstream.Spat_term (_2, Some _4) )}
| _1 = pattern _2 = EQUAL _3 = expr
    {      ( Pstream.Spat_nterm (_1, _3) )}
| _1 = pattern
    {      ( Pstream.Spat_sterm _1 )}

opt_pat:
  
    {                                                ( None )}
| _1 = simple_pattern
    {                                                ( Some _1 )}

opt_err:
  
    {                                                ( None )}
| _1 = QUESTION _2 = expr %prec prec_list
    {                                                ( Some _2 )}

stream_expr:
  _1 = stream_expr_component
    {                                                ( [_1] )}
| _1 = stream_expr _2 = SEMI _3 = stream_expr_component
    {                                                ( _3 :: _1 )}

stream_expr_component:
  _1 = QUOTE _2 = expr %prec prec_list
    {                                                ( Pstream.Sexp_term _2 )}
| _1 = expr %prec prec_list
    {                                                ( Pstream.Sexp_nterm _1 )}

match_cases:
  _1 = pattern _2 = match_action
    {                                                ( [_1, _2] )}
| _1 = match_cases _2 = BAR _3 = pattern _4 = match_action
    {                                                ( (_3, _4) :: _1 )}

fun_def:
  _1 = match_action
    {                                                ( _1 )}
| _1 = simple_pattern _2 = fun_def
    {                                                ( mkexp(Pexp_function[_1,_2]) )}

match_action:
  _1 = MINUSGREATER _2 = seq_expr
    {                                                ( _2 )}
| _1 = WHEN _2 = seq_expr _3 = MINUSGREATER _4 = seq_expr
    {                                                ( mkexp(Pexp_when(_2, _4)) )}

expr_comma_list:
  _1 = expr_comma_list _2 = COMMA _3 = expr
    {                                                ( _3 :: _1 )}
| _1 = expr _2 = COMMA _3 = expr
    {                                                ( [_3; _1] )}

lbl_expr_list:
  _1 = label_longident _2 = EQUAL _3 = expr %prec prec_list
    {      ( [_1,_3] )}
| _1 = lbl_expr_list _2 = SEMI _3 = label_longident _4 = EQUAL _5 = expr %prec prec_list
    {      ( (_3, _5) :: _1 )}

label_expr_list:
  _1 = label _2 = EQUAL _3 = expr %prec prec_list
    {      ( [_1,_3] )}
| _1 = label_expr_list _2 = SEMI _3 = label _4 = EQUAL _5 = expr %prec prec_list
    {      ( (_3, _5) :: _1 )}

expr_semi_list:
  _1 = expr %prec prec_list
    {                                                ( [_1] )}
| _1 = expr_semi_list _2 = SEMI _3 = expr %prec prec_list
    {                                                ( _3 :: _1 )}

type_constraint:
  _1 = COLON _2 = core_type
    {                                                ( (Some _2, None) )}
| _1 = COLON _2 = core_type _3 = COLONGREATER _4 = core_type
    {                                                ( (Some _2, Some _4) )}
| _1 = COLONGREATER _2 = core_type
    {                                                ( (None, Some _2) )}
| _1 = COLON _2 = error
    {                                                ( syntax_error() )}
| _1 = COLONGREATER _2 = error
    {                                                ( syntax_error() )}

pattern:
  _1 = simple_pattern
    {      ( _1 )}
| _1 = pattern _2 = AS _3 = val_ident
    {      ( mkpat(Ppat_alias(_1, _3)) )}
| _1 = pattern_comma_list
    {      ( mkpat(Ppat_tuple(List.rev _1)) )}
| _1 = constr_longident _2 = pattern %prec prec_constr_appl
    {      ( mkpat(Ppat_construct(_1, Some _2, false)) )}
| _1 = pattern _2 = COLONCOLON _3 = pattern
    {      ( mkpat(Ppat_construct(Lident "::", Some(mkpat(Ppat_tuple[_1;_3])),
                             false)) )}
| _1 = pattern _2 = BAR _3 = pattern
    {      ( mkpat(Ppat_or(_1, _3)) )}

simple_pattern:
  _1 = val_ident
    {      ( mkpat(Ppat_var _1) )}
| _1 = UNDERSCORE
    {      ( mkpat(Ppat_any) )}
| _1 = signed_constant
    {      ( mkpat(Ppat_constant _1) )}
| _1 = CHAR _2 = DOTDOT _3 = CHAR
    {      ( mkrangepat _1 _3 )}
| _1 = constr_longident
    {      ( mkpat(Ppat_construct(_1, None, false)) )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = opt_semi _4 = RBRACE
    {      ( mkpat(Ppat_record(List.rev _2)) )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = opt_semi _4 = error
    {      ( unclosed "{" 1 "}" 4 )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = RBRACKET
    {      ( mklistpat(List.rev _2) )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "{" 1 "}" 4 )}
| _1 = LPAREN _2 = pattern _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = pattern _3 = error
    {      ( unclosed "(" 1 ")" 3 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = RPAREN
    {      ( mkpat(Ppat_constraint(_2, _4)) )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = error
    {      ( unclosed "(" 1 ")" 5 )}

pattern_comma_list:
  _1 = pattern_comma_list _2 = COMMA _3 = pattern
    {                                                ( _3 :: _1 )}
| _1 = pattern _2 = COMMA _3 = pattern
    {                                                ( [_3; _1] )}

pattern_semi_list:
  _1 = pattern
    {                                                ( [_1] )}
| _1 = pattern_semi_list _2 = SEMI _3 = pattern
    {                                                ( _3 :: _1 )}

lbl_pattern_list:
  _1 = label_longident _2 = EQUAL _3 = pattern
    {                                                ( [(_1, _3)] )}
| _1 = lbl_pattern_list _2 = SEMI _3 = label_longident _4 = EQUAL _5 = pattern
    {                                                        ( (_3, _5) :: _1 )}

primitive_declaration:
  _1 = STRING
    {                                                ( [_1] )}
| _1 = STRING _2 = primitive_declaration
    {                                                ( _1 :: _2 )}

class_list:
  _1 = class_list _2 = AND _3 = class_def
    {                                                ( _3 :: _1 )}
| _1 = class_def
    {                                                ( [_1] )}

class_def:
  _1 = virtual_flag _2 = closed_flag _3 = class_type_parameters _4 = LIDENT _5 = simple_pattern_list _6 = self _7 = self_type _8 = EQUAL _9 = constraints _10 = class_fields
    {          ( { pcl_name = _4; pcl_param = _3; pcl_args = List.rev _5;
              pcl_self = _6; pcl_self_ty = _7; pcl_cstr = List.rev _9;
              pcl_field = List.rev _10;
              pcl_kind = _1; pcl_closed = _2;
              pcl_loc = symbol_loc () } )}

class_type_parameters:
  _1 = type_parameters
    {                                                ( _1, symbol_loc () )}

simple_pattern_list:
  _1 = simple_pattern
    {                                                ( [_1] )}
| _1 = simple_pattern_list _2 = simple_pattern
    {                                                ( _2::_1 )}

self:
  _1 = AS _2 = LIDENT
    {                                                ( Some _2 )}
| 
    {                                                ( None )}

class_fields:
  
    {                                                ( [] )}
| _1 = class_fields _2 = INHERIT _3 = ancestor
    {                                                ( Pcf_inher _3 :: _1 )}
| _1 = class_fields _2 = VAL _3 = value
    {                                                ( Pcf_val _3 :: _1 )}
| _1 = class_fields _2 = virtual_method
    {                                                ( Pcf_virt _2 :: _1 )}
| _1 = class_fields _2 = method_def
    {                                                ( Pcf_meth _2 :: _1 )}

ancestor:
  _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN _4 = class_longident _5 = simple_expr_list _6 = self
    {          ( _4, List.rev _2, List.rev _5, _6, symbol_loc () )}
| _1 = LPAREN _2 = core_type _3 = RPAREN _4 = class_longident _5 = simple_expr_list _6 = self
    {          ( _4, [_2], List.rev _5, _6, symbol_loc () )}
| _1 = class_longident _2 = simple_expr_list _3 = self
    {          ( _1, [], List.rev _2, _3, symbol_loc () )}

value:
  _1 = private_flag _2 = mutable_flag _3 = label _4 = EQUAL _5 = seq_expr
    {          ( _3, _1, _2, Some _5, symbol_loc () )}
| _1 = private_flag _2 = mutable_flag _3 = label
    {          ( _3, _1, _2, None, symbol_loc () )}

virtual_method:
  _1 = VIRTUAL _2 = protected_flag _3 = label _4 = COLON _5 = core_type
    {          ( _3, _2, _5, symbol_loc () )}

meth_binding:
  _1 = EQUAL _2 = seq_expr %prec prec_let
    {       ( (_2,0) )}
| _1 = type_constraint _2 = EQUAL _3 = seq_expr %prec prec_let
    {       ( let (t, t') = _1 in (mkexp(Pexp_constraint(_3, t, t')),0) )}
| _1 = simple_pattern _2 = meth_binding
    {       (
       let (s2,nparams) = _2
         in
         (mkexp(Pexp_function[_1,s2]),nparams+1) )}

method_def:
  _1 = METHOD _2 = protected_flag _3 = label _4 = meth_binding
    {          ( let (s4,np)= _4 in
	    _3, np , _2, s4, symbol_loc () )}

class_type_list:
  _1 = class_type_list _2 = AND _3 = class_type
    {                                                ( _3 :: _1 )}
| _1 = class_type
    {                                                ( [_1] )}

class_type:
  _1 = virtual_flag _2 = closed_flag _3 = class_type_parameters _4 = LIDENT _5 = type_list _6 = self_type _7 = EQUAL _8 = constraints _9 = class_type_fields
    {          ( { pcty_name = _4; pcty_param = _3; pcty_args = _5;
              pcty_self = _6; pcty_cstr = List.rev _8;
              pcty_field = List.rev _9;
              pcty_kind = _1; pcty_closed = _2;
              pcty_loc = symbol_loc () } )}

type_list:
  _1 = LPAREN _2 = core_type _3 = RPAREN _4 = type_list
    {                                                ( _2 :: _4 )}
| _1 = LPAREN _2 = core_type _3 = RPAREN
    {                                                ( [_2] )}

self_type:
  _1 = COLON _2 = type_parameter
    {                                                ( Some _2 )}
| 
    {                                                ( None )}

constraints:
  _1 = constraints _2 = CONSTRAINT _3 = constrain
    {                                                ( _3 :: _1 )}
| 
    {                                                ( [] )}

constrain:
  _1 = type_parameter _2 = EQUAL _3 = core_type
    {                                                ( _1, _3, symbol_loc () )}

class_type_fields:
  
    {                                                ( [] )}
| _1 = class_type_fields _2 = INHERIT _3 = ancestor_type
    {                                                ( Pctf_inher _3 :: _1 )}
| _1 = class_type_fields _2 = VAL _3 = value_type
    {                                                ( Pctf_val _3 :: _1 )}
| _1 = class_type_fields _2 = virtual_method
    {                                                ( Pctf_virt _2 :: _1 )}
| _1 = class_type_fields _2 = method_type
    {                                                ( Pctf_meth _2 :: _1 )}

ancestor_type:
  _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN _4 = class_longident
    {          ( _4, List.rev _2, symbol_loc () )}
| _1 = LPAREN _2 = core_type _3 = RPAREN _4 = class_longident
    {          ( _4, [_2], symbol_loc () )}
| _1 = class_longident
    {          ( _1, [], symbol_loc () )}

value_type:
  _1 = private_flag _2 = mutable_flag _3 = label _4 = COLON _5 = core_type
    {          ( _3, _1, _2, Some _5, symbol_loc () )}
| _1 = private_flag _2 = mutable_flag _3 = label
    {          ( _3, _1, _2, None, symbol_loc () )}

method_type:
  _1 = METHOD _2 = protected_flag _3 = label _4 = COLON _5 = core_type
    {          ( _3, _2, _5, symbol_loc () )}
| _1 = METHOD _2 = protected_flag _3 = label
    {          ( _3, _2, mktyp(Ptyp_any), symbol_loc () )}

type_declarations:
  _1 = type_declaration
    {                                                ( [_1] )}
| _1 = type_declarations _2 = AND _3 = type_declaration
    {                                                ( _3 :: _1 )}

type_declaration:
  _1 = type_parameters _2 = LIDENT _3 = type_kind _4 = constraints
    {      ( let (kind, manifest) = _3 in
        (_2, {ptype_params = _1;
              ptype_cstrs = List.rev _4;
              ptype_kind = kind;
              ptype_manifest = manifest;
              ptype_loc = symbol_loc()}) )}

type_kind:
  
    {      ( (Ptype_abstract, None) )}
| _1 = EQUAL _2 = core_type %prec prec_type_def
    {      ( (Ptype_abstract, Some _2) )}
| _1 = EQUAL _2 = constructor_declarations
    {      ( (Ptype_variant(List.rev _2), None) )}
| _1 = EQUAL _2 = BAR _3 = constructor_declarations
    {      ( (Ptype_variant(List.rev _3), None) )}
| _1 = EQUAL _2 = LBRACE _3 = label_declarations _4 = opt_semi _5 = RBRACE
    {      ( (Ptype_record(List.rev _3), None) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = opt_bar _5 = constructor_declarations %prec prec_type_def
    {      ( (Ptype_variant(List.rev _5), Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = LBRACE _5 = label_declarations _6 = opt_semi _7 = RBRACE %prec prec_type_def
    {      ( (Ptype_record(List.rev _5), Some _2) )}

type_parameters:
  
    {                                                ( [] )}
| _1 = type_parameter
    {                                                ( [_1] )}
| _1 = LPAREN _2 = type_parameter_list _3 = RPAREN
    {                                                ( List.rev _2 )}

type_parameter:
  _1 = QUOTE _2 = ident
    {                                                ( _2 )}

type_parameter_list:
  _1 = type_parameter
    {                                                ( [_1] )}
| _1 = type_parameter_list _2 = COMMA _3 = type_parameter
    {                                                ( _3 :: _1 )}

constructor_declarations:
  _1 = constructor_declaration
    {                                                ( [_1] )}
| _1 = constructor_declarations _2 = BAR _3 = constructor_declaration
    {                                                         ( _3 :: _1 )}

constructor_declaration:
  _1 = constr_ident _2 = constructor_arguments
    {                                                ( (_1, _2) )}

constructor_arguments:
  
    {                                                ( [] )}
| _1 = OF _2 = core_type_list
    {                                                ( List.rev _2 )}

label_declarations:
  _1 = label_declaration
    {                                                ( [_1] )}
| _1 = label_declarations _2 = SEMI _3 = label_declaration
    {                                                ( _3 :: _1 )}

label_declaration:
  _1 = mutable_flag _2 = LIDENT _3 = COLON _4 = core_type
    {                                                ( (_2, _1, _4) )}

with_constraints:
  _1 = with_constraint
    {                                                ( [_1] )}
| _1 = with_constraints _2 = AND _3 = with_constraint
    {                                                ( _3 :: _1 )}

with_constraint:
  _1 = TYPE _2 = type_parameters _3 = label_longident _4 = EQUAL _5 = core_type _6 = constraints
    {      ( (_3, Pwith_type {ptype_params = _2;
                         ptype_cstrs = List.rev _6;
                         ptype_kind = Ptype_abstract;
                         ptype_manifest = Some _5;
                         ptype_loc = symbol_loc()}) )}
| _1 = MODULE _2 = mod_longident _3 = EQUAL _4 = mod_ext_longident
    {      ( (_2, Pwith_module _4) )}

core_type:
  _1 = simple_core_type
    {      ( _1 )}
| _1 = LESSLESS _2 = channel_type _3 = GREATERGREATER
    {      ( mktyp(Ptyp_channel(List.rev _2,Pasync)) )}
| _1 = LESSLESS _2 = channel_type _3 = EQUALGREATER _4 = core_type _5 = GREATERGREATER
    {      ( mktyp(Ptyp_channel(List.rev _2,Psync _4)) )}
| _1 = core_type _2 = MINUSGREATER _3 = core_type %prec prec_type_arrow
    {      ( mktyp(Ptyp_arrow(_1, _3)) )}
| _1 = core_type_tuple
    {      ( mktyp(Ptyp_tuple(List.rev _1)) )}
| _1 = core_type _2 = AS _3 = type_parameter
    {      ( mktyp(Ptyp_alias(_1, _3)) )}

channel_tuple:
  _1 = core_type
    {              ( [_1] )}
| _1 = channel_tuple _2 = COMMA _3 = core_type
    {                                 ( _3 :: _1 )}

channel_type:
  
    {       ( [] )}
| _1 = channel_tuple
    {                  ( _1 )}

simple_core_type:
  _1 = QUOTE _2 = ident
    {      ( mktyp(Ptyp_var _2) )}
| _1 = UNDERSCORE
    {      ( mktyp(Ptyp_any) )}
| _1 = type_longident
    {      ( mktyp(Ptyp_constr(_1, [])) )}
| _1 = simple_core_type _2 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_2, [_1])) )}
| _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN _4 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_4, List.rev _2)) )}
| _1 = LPAREN _2 = core_type _3 = RPAREN
    {      ( _2 )}
| _1 = LESS _2 = meth_list _3 = GREATER
    {      ( mktyp(Ptyp_object _2) )}
| _1 = LESS _2 = GREATER
    {      ( mktyp(Ptyp_object []) )}
| _1 = SHARP _2 = class_longident
    {      ( mktyp(Ptyp_class(_2, [])) )}
| _1 = simple_core_type _2 = SHARP _3 = class_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_class(_3, [_1])) )}
| _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN _4 = SHARP _5 = class_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_class(_5, List.rev _2)) )}

core_type_tuple:
  _1 = simple_core_type _2 = STAR _3 = simple_core_type
    {                                                ( [_3; _1] )}
| _1 = core_type_tuple _2 = STAR _3 = simple_core_type
    {                                                ( _3 :: _1 )}

core_type_comma_list:
  _1 = core_type _2 = COMMA _3 = core_type
    {                                                ( [_3; _1] )}
| _1 = core_type_comma_list _2 = COMMA _3 = core_type
    {                                                ( _3 :: _1 )}

core_type_list:
  _1 = simple_core_type
    {                                                ( [_1] )}
| _1 = core_type_list _2 = STAR _3 = simple_core_type
    {                                                ( _3 :: _1 )}

meth_list:
  _1 = field _2 = SEMI _3 = meth_list
    {                                                ( _1 :: _3 )}
| _1 = field _2 = opt_semi
    {                                                ( [_1] )}
| _1 = DOTDOT
    {                                                ( [mkfield Pfield_var] )}

field:
  _1 = label _2 = COLON _3 = core_type
    {                                                ( mkfield(Pfield(_1, _3)) )}

label:
  _1 = LIDENT
    {                                                ( _1 )}

constant:
  _1 = INT
    {                                                ( Const_int _1 )}
| _1 = CHAR
    {                                                ( Const_char _1 )}
| _1 = STRING
    {                                                ( Const_string _1 )}
| _1 = FLOAT
    {                                                ( Const_float _1 )}

signed_constant:
  _1 = constant
    {                                                ( _1 )}
| _1 = SUBTRACTIVE _2 = INT
    {                                                ( Const_int(- _2) )}
| _1 = SUBTRACTIVE _2 = FLOAT
    {                                                ( Const_float("-" ^ _2) )}

ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LIDENT
    {                                                ( _1 )}

val_ident:
  _1 = LIDENT
    {                                                ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN
    {                                                ( _2 )}

operator:
  _1 = PREFIXOP
    {                                                ( _1 )}
| _1 = INFIXOP0
    {                                                ( _1 )}
| _1 = LESSGREATER
    {                                                ( "<>" )}
| _1 = INFIXOP1
    {                                                ( _1 )}
| _1 = INFIXOP2
    {                                                ( _1 )}
| _1 = INFIXOP3
    {                                                ( _1 )}
| _1 = INFIXOP4
    {                                                ( _1 )}
| _1 = SUBTRACTIVE
    {                                                ( _1 )}
| _1 = STAR
    {                                                ( "*" )}
| _1 = EQUAL
    {                                                ( "=" )}
| _1 = LESS
    {                                                ( "<" )}
| _1 = GREATER
    {                                                ( ">" )}
| _1 = OR
    {                                                ( "or" )}
| _1 = BARBAR
    {                                                ( "||" )}
| _1 = AMPERSAND
    {                                                ( "&" )}
| _1 = AMPERAMPER
    {                                                ( "&&" )}
| _1 = COLONEQUAL
    {                                                ( ":=" )}

constr_ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( "()" )}
| _1 = COLONCOLON
    {                                                ( "::" )}
| _1 = FALSE
    {                                                ( "false" )}
| _1 = TRUE
    {                                                ( "true" )}

val_longident:
  _1 = val_ident
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = val_ident
    {                                                ( Ldot(_1, _3) )}

constr_longident:
  _1 = mod_longident
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( Lident "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( Lident "()" )}
| _1 = FALSE
    {                                                ( Lident "false" )}
| _1 = TRUE
    {                                                ( Lident "true" )}

label_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

type_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

mod_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

mod_ext_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}
| _1 = mod_ext_longident _2 = LPAREN _3 = mod_ext_longident _4 = RPAREN
    {                                                      ( Lapply(_1, _3) )}

mty_longident:
  _1 = ident
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = ident
    {                                                ( Ldot(_1, _3) )}

class_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

toplevel_directive:
  _1 = SHARP _2 = ident
    {                                ( Ptop_dir(_2, Pdir_none) )}
| _1 = SHARP _2 = ident _3 = STRING
    {                                ( Ptop_dir(_2, Pdir_string _3) )}
| _1 = SHARP _2 = ident _3 = INT
    {                                ( Ptop_dir(_2, Pdir_int _3) )}
| _1 = SHARP _2 = ident _3 = val_longident
    {                                ( Ptop_dir(_2, Pdir_ident _3) )}

rec_flag:
  
    {                                                ( Nonrecursive )}
| _1 = REC
    {                                                ( Recursive )}

direction_flag:
  _1 = TO
    {                                                ( Upto )}
| _1 = DOWNTO
    {                                                ( Downto )}

private_flag:
  
    {                                                ( Public )}
| _1 = PRIVATE
    {                                                ( Private )}

protected_flag:
  
    {                                                ( Public )}
| _1 = PROTECTED
    {                                                ( Private )}

mutable_flag:
  
    {                                                ( Immutable )}
| _1 = MUTABLE
    {                                                ( Mutable )}

virtual_flag:
  
    {                                                ( Concrete )}
| _1 = VIRTUAL
    {                                                ( Virtual )}

closed_flag:
  
    {                                                ( Open )}
| _1 = CLOSED
    {                                                ( Closed )}

opt_bar:
  
    {                                                ( () )}
| _1 = BAR
    {                                                ( () )}

opt_semi:
  
    {                                                ( () )}
| _1 = SEMI
    {                                                ( () )}

%%


