
** Conflict (shift/reduce) in state 1674.
** Token involved: LPAREN
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1674, looking ahead at LPAREN, reducing production
** module_expr -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr
** is permitted because of the following sub-derivation:

module_expr LPAREN module_expr RPAREN // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr . 

** In state 1674, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr 
                                                            module_expr . LPAREN module_expr RPAREN 

** Conflict (shift/reduce) in state 1650.
** Token involved: error
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT SEMISEMI LET LOC loc_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1650, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

STRUCT structure END 
       structure_tail 
       SEMISEMI seq_expr structure_tail 
                expr 
                expr0 
                LET LOC loc_bindings . error 

** In state 1650, looking ahead at error, reducing production
** structure_tail ->
** is permitted because of the following sub-derivation:

STRUCT structure error // lookahead token appears
       structure_tail // lookahead token is inherited
       SEMISEMI LET LOC loc_bindings structure_tail // lookahead token is inherited
                                     . 

** Conflict (shift/reduce) in state 1624.
** Token involved: LPAREN
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL LPAREN FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    LPAREN module_expr COLON module_type RPAREN 
                           (?)

** In state 1624, looking ahead at LPAREN, reducing production
** module_expr -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr
** is permitted because of the following sub-derivation:

module_expr LPAREN module_expr RPAREN // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr . 

** In state 1624, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr 
                                                            module_expr . LPAREN module_expr RPAREN 

** Conflict (shift/reduce) in state 1609.
** Token involved: error
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT LET rec_flag let_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1609, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

STRUCT structure END 
       seq_expr structure_tail 
       expr 
       expr0 
       LET rec_flag let_bindings . error 

** In state 1609, looking ahead at error, reducing production
** structure_item -> LET rec_flag let_bindings
** is permitted because of the following sub-derivation:

STRUCT structure error // lookahead token appears
       structure_tail // lookahead token is inherited
       structure_item structure_tail // lookahead token is inherited because structure_tail can vanish
       LET rec_flag let_bindings . 

** Conflict (shift/reduce) in state 1607.
** Token involved: error
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT LET JOINDEF def_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1607, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

STRUCT structure END 
       seq_expr structure_tail 
       expr 
       expr0 
       LET JOINDEF def_bindings . error 

** In state 1607, looking ahead at error, reducing production
** structure_item -> LET JOINDEF def_bindings
** is permitted because of the following sub-derivation:

STRUCT structure error // lookahead token appears
       structure_tail // lookahead token is inherited
       structure_item structure_tail // lookahead token is inherited because structure_tail can vanish
       LET JOINDEF def_bindings . 

** Conflict (shift/reduce) in state 1522.
** Token involved: error
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT LET LOC loc_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    (?)

** In state 1522, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

STRUCT structure END 
       seq_expr structure_tail 
       expr 
       expr0 
       LET LOC loc_bindings . error 

** In state 1522, looking ahead at error, reducing production
** structure_tail ->
** is permitted because of the following sub-derivation:

STRUCT structure error // lookahead token appears
       structure_tail // lookahead token is inherited
       LET LOC loc_bindings structure_tail // lookahead token is inherited
                            . 

** Conflict (shift/reduce) in state 1386.
** Token involved: WITH
** This state is reached from interface after reading:

signature INCLUDE LPAREN FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

interface 
signature EOF 
signature signature_item 
          INCLUDE module_type 
                  LPAREN module_type RPAREN 
                         (?)

** In state 1386, looking ahead at WITH, reducing production
** module_type -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
** is permitted because of the following sub-derivation:

module_type WITH with_constraints // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type . 

** In state 1386, looking ahead at WITH, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type 
                                                            module_type . WITH with_constraints 

** Conflict (shift/reduce) in state 1376.
** Token involved: WITH
** This state is reached from interface after reading:

signature INCLUDE FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

interface 
signature EOF 
signature signature_item 
          INCLUDE module_type 
                  (?)

** In state 1376, looking ahead at WITH, reducing production
** module_type -> FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
** is permitted because of the following sub-derivation:

module_type WITH with_constraints // lookahead token appears
FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type . 

** In state 1376, looking ahead at WITH, shifting is permitted
** because of the following sub-derivation:

FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type 
                                                            module_type . WITH with_constraints 

** Conflict (shift/reduce) in state 1219.
** Token involved: SHARP
** This state is reached from use_file after reading:

EXCEPTION UIDENT OF simple_core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 1219, looking ahead at SHARP, reducing production
** core_type_list -> simple_core_type
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
EXCEPTION UIDENT constructor_arguments // lookahead token is inherited
                 OF core_type_list // lookahead token is inherited
                    simple_core_type . 

** In state 1219, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
EXCEPTION UIDENT constructor_arguments 
                 OF core_type_list 
                    simple_core_type 
                    simple_core_type . SHARP class_longident 

** Conflict (shift/reduce) in state 1129.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL SPAWN LBRACE process RBRACE SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 1129, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               SPAWN LBRACE process RBRACE SEMI process // lookahead token is inherited
                                                                . 

** In state 1129, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               SPAWN LBRACE process RBRACE SEMI process 
                                                                . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 1125.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL SPAWN LBRACE process RBRACE SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 1125, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               SPAWN LBRACE process RBRACE SEMI process // lookahead token is inherited
                                                                . 

** In state 1125, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               SPAWN LBRACE process RBRACE SEMI process 
                                                                . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 1036.
** Token involved: DO
** This state is reached from implementation after reading:

LET LOC LIDENT loc_modules JOINDEF join_pattern EQUAL LOC LIDENT loc_modules loc_defs

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
LET LOC loc_bindings structure_tail 
        loc_binding 
        (?)

** In state 1036, looking ahead at DO, shifting is permitted
** because of the following sub-derivation:

LIDENT loc_modules loc_defs loc_init 
                   JOINDEF def_bindings 
                           def_binding 
                           simple_def_binding 
                           def_pattern 
                           join_pattern EQUAL process 
                                              process0 
                                              LOC loc_bindings 
                                                  loc_binding 
                                                  LIDENT loc_modules loc_defs loc_init 
                                                                              . DO process0 

** In state 1036, looking ahead at DO, reducing production
** loc_init ->
** is permitted because of the following sub-derivation:

LIDENT loc_modules loc_defs loc_init // lookahead token appears because loc_init can begin with DO
                   JOINDEF def_bindings // lookahead token is inherited
                           def_binding // lookahead token is inherited
                           simple_def_binding // lookahead token is inherited
                           def_pattern // lookahead token is inherited
                           join_pattern EQUAL process // lookahead token is inherited
                                              process0 // lookahead token is inherited
                                              LOC loc_bindings // lookahead token is inherited
                                                  loc_binding // lookahead token is inherited
                                                  LIDENT loc_modules loc_defs loc_init // lookahead token is inherited
                                                                              . 

** Conflict (shift/reduce) in state 1035.
** Token involved: AND
** This state is reached from implementation after reading:

LET LOC LIDENT loc_modules JOINDEF def_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
LET LOC loc_bindings structure_tail 
        (?)

** In state 1035, looking ahead at AND, shifting is permitted
** because of the following sub-derivation:

loc_binding 
LIDENT loc_modules loc_defs loc_init 
                   JOINDEF def_bindings 
                           def_bindings . AND def_binding 

** In state 1035, looking ahead at AND, reducing production
** loc_defs -> JOINDEF def_bindings
** is permitted because of the following sub-derivation:

loc_binding AND loc_bindings // lookahead token appears
LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                   JOINDEF def_bindings . 

** Conflict (shift/reduce) in state 984.
** Token involved: EQUAL
** This state is reached from implementation after reading:

LET rec_flag val_ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET rec_flag let_bindings 
             let_binding 
             (?)

** In state 984, looking ahead at EQUAL, shifting is permitted
** because of the following sub-derivation:

val_ident fun_binding 
          . EQUAL seq_expr 

** In state 984, looking ahead at EQUAL, reducing production
** simple_pattern -> val_ident
** is permitted because of the following sub-derivation:

pattern EQUAL seq_expr // lookahead token appears
simple_pattern // lookahead token is inherited
val_ident . 

** Conflict (shift/reduce) in state 969.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 969, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               . 

** In state 969, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 966.
** Token involved: OR
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LOC LIDENT loc_modules JOINDEF simple_def_binding

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            (?)

** In state 966, looking ahead at OR, reducing production
** def_binding -> simple_def_binding
** is permitted because of the following sub-derivation:

simple_def_binding OR def_pattern // lookahead token appears
def_pattern // lookahead token is inherited
join_pattern EQUAL process // lookahead token is inherited
                   process0 // lookahead token is inherited
                   LOC loc_bindings // lookahead token is inherited
                       loc_binding // lookahead token is inherited
                       LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                                          JOINDEF def_bindings // lookahead token is inherited
                                                  def_binding // lookahead token is inherited
                                                  simple_def_binding . 

** In state 966, looking ahead at OR, shifting is permitted
** because of the following sub-derivation:

def_pattern 
join_pattern EQUAL process 
                   process0 
                   LOC loc_bindings 
                       loc_binding 
                       LIDENT loc_modules loc_defs loc_init 
                                          JOINDEF def_bindings 
                                                  def_binding 
                                                  simple_def_binding 
                                                  simple_def_binding . OR def_pattern 

** Conflict (shift/reduce) in state 923.
** Token involved: ELSE
** This state is reached from implementation after reading:

TRY IF seq_expr THEN IF seq_expr THEN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr0 
    (?)

** In state 923, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr 
                 expr0 
                 IF seq_expr THEN expr . ELSE expr 

** In state 923, looking ahead at ELSE, reducing production
** expr0 -> IF seq_expr THEN expr
** is permitted because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr // lookahead token appears
                 expr0 // lookahead token is inherited
                 IF seq_expr THEN expr . 

** Conflict (shift/reduce) in state 888.
** Token involved: DO
** This state is reached from implementation after reading:

LET JOINDEF LIDENT LBRACE join_pattern EQUAL LOC LIDENT loc_modules loc_defs

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            (?)

** In state 888, looking ahead at DO, shifting is permitted
** because of the following sub-derivation:

LIDENT LBRACE simple_def_binding loc_init RBRACE 
              def_pattern 
              join_pattern EQUAL process 
                                 process0 
                                 LOC loc_bindings 
                                     loc_binding 
                                     LIDENT loc_modules loc_defs loc_init 
                                                                 . DO process0 

** In state 888, looking ahead at DO, reducing production
** loc_init ->
** is permitted because of the following sub-derivation:

LIDENT LBRACE simple_def_binding loc_init RBRACE // lookahead token appears because loc_init can begin with DO
              def_pattern // lookahead token is inherited
              join_pattern EQUAL process // lookahead token is inherited
                                 process0 // lookahead token is inherited
                                 LOC loc_bindings // lookahead token is inherited
                                     loc_binding // lookahead token is inherited
                                     LIDENT loc_modules loc_defs loc_init // lookahead token is inherited
                                                                 . 

** Conflict (shift/reduce) in state 887.
** Token involved: AND
** This state is reached from implementation after reading:

LBRACE BAR LOC LIDENT loc_modules JOINDEF def_bindings

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           process0 
           LOC loc_bindings 
               (?)

** In state 887, looking ahead at AND, shifting is permitted
** because of the following sub-derivation:

loc_binding 
LIDENT loc_modules loc_defs loc_init 
                   JOINDEF def_bindings 
                           def_bindings . AND def_binding 

** In state 887, looking ahead at AND, reducing production
** loc_defs -> JOINDEF def_bindings
** is permitted because of the following sub-derivation:

loc_binding AND loc_bindings // lookahead token appears
LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                   JOINDEF def_bindings . 

** Conflict (shift/reduce) in state 868.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LET rec_flag let_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 868, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET rec_flag let_bindings IN process // lookahead token is inherited
                                                            . 

** In state 868, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET rec_flag let_bindings IN process 
                                                            . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 864.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LET JOINDEF def_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 864, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET JOINDEF def_bindings IN process // lookahead token is inherited
                                                           . 

** In state 864, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET JOINDEF def_bindings IN process 
                                                           . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 856.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LBRACE BAR process RBRACE SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 856, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LBRACE BAR process RBRACE SEMI process // lookahead token is inherited
                                                              . 

** In state 856, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LBRACE BAR process RBRACE SEMI process 
                                                              . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 849.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LET rec_flag let_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 849, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET rec_flag let_bindings IN process // lookahead token is inherited
                                                            . 

** In state 849, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET rec_flag let_bindings IN process 
                                                            . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 834.
** Token involved: EQUAL
** This state is reached from implementation after reading:

structure_item LET rec_flag val_ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               structure_item structure_tail 
               LET rec_flag let_bindings 
                            let_binding 
                            (?)

** In state 834, looking ahead at EQUAL, shifting is permitted
** because of the following sub-derivation:

val_ident fun_binding 
          . EQUAL seq_expr 

** In state 834, looking ahead at EQUAL, reducing production
** simple_pattern -> val_ident
** is permitted because of the following sub-derivation:

pattern EQUAL seq_expr // lookahead token appears
simple_pattern // lookahead token is inherited
val_ident . 

** Conflict (shift/reduce) in state 828.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LET JOINDEF def_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 828, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET JOINDEF def_bindings IN process // lookahead token is inherited
                                                           . 

** In state 828, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET JOINDEF def_bindings IN process 
                                                           . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 825.
** Token involved: OR
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LOC LIDENT loc_modules JOINDEF simple_def_binding

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               structure_item structure_tail 
               LET JOINDEF def_bindings 
                           def_binding 
                           simple_def_binding 
                           (?)

** In state 825, looking ahead at OR, reducing production
** def_binding -> simple_def_binding
** is permitted because of the following sub-derivation:

simple_def_binding OR def_pattern // lookahead token appears
def_pattern // lookahead token is inherited
join_pattern EQUAL process // lookahead token is inherited
                   process0 // lookahead token is inherited
                   LOC loc_bindings // lookahead token is inherited
                       loc_binding // lookahead token is inherited
                       LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                                          JOINDEF def_bindings // lookahead token is inherited
                                                  def_binding // lookahead token is inherited
                                                  simple_def_binding . 

** In state 825, looking ahead at OR, shifting is permitted
** because of the following sub-derivation:

def_pattern 
join_pattern EQUAL process 
                   process0 
                   LOC loc_bindings 
                       loc_binding 
                       LIDENT loc_modules loc_defs loc_init 
                                          JOINDEF def_bindings 
                                                  def_binding 
                                                  simple_def_binding 
                                                  simple_def_binding . OR def_pattern 

** Conflict (shift/reduce) in state 821.
** Token involved: AND
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LOC loc_binding

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               structure_item structure_tail 
               LET JOINDEF def_bindings 
                           (?)

** In state 821, looking ahead at AND, reducing production
** loc_bindings -> loc_binding
** is permitted because of the following sub-derivation:

def_bindings AND def_binding // lookahead token appears
def_binding // lookahead token is inherited
simple_def_binding // lookahead token is inherited
def_pattern // lookahead token is inherited
join_pattern EQUAL process // lookahead token is inherited
                   process0 // lookahead token is inherited
                   LOC loc_bindings // lookahead token is inherited
                       loc_binding . 

** In state 821, looking ahead at AND, shifting is permitted
** because of the following sub-derivation:

def_binding 
simple_def_binding 
def_pattern 
join_pattern EQUAL process 
                   process0 
                   LOC loc_bindings 
                       loc_binding . AND loc_bindings 

** Conflict (shift/reduce) in state 815.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL proc_expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 815, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               proc_expr SEMI process // lookahead token is inherited
                                              . 

** In state 815, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               proc_expr SEMI process 
                                              . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 812.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL process0 BAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 812, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 BAR process // lookahead token is inherited
                                            . 

** In state 812, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 BAR process 
                                            . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 811.
** Token involved: BAR
** This state is reached from implementation after reading:

SPAWN LBRACE LOC LIDENT loc_modules JOINDEF join_pattern EQUAL process0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             (?)

** In state 811, looking ahead at BAR, reducing production
** process -> process0
** is permitted because of the following sub-derivation:

process0 BAR process // lookahead token appears
LOC loc_bindings // lookahead token is inherited
    loc_binding // lookahead token is inherited
    LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                       JOINDEF def_bindings // lookahead token is inherited
                               def_binding // lookahead token is inherited
                               simple_def_binding // lookahead token is inherited
                               def_pattern // lookahead token is inherited
                               join_pattern EQUAL process // lookahead token is inherited
                                                  process0 . 

** In state 811, looking ahead at BAR, shifting is permitted
** because of the following sub-derivation:

process0 
LOC loc_bindings 
    loc_binding 
    LIDENT loc_modules loc_defs loc_init 
                       JOINDEF def_bindings 
                               def_binding 
                               simple_def_binding 
                               def_pattern 
                               join_pattern EQUAL process 
                                                  process0 . BAR process 

** Conflict (shift/reduce) in state 810.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET JOINDEF join_pattern EQUAL simple_chan_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 810, looking ahead at SHARP, reducing production
** process0 -> simple_chan_expr simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 // lookahead token is inherited
                               simple_chan_expr simple_expr . 

** In state 810, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 
                               simple_chan_expr simple_expr 
                                                simple_expr . SHARP label 

** Conflict (shift/reduce) in state 804.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LBRACE BAR process RBRACE SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 804, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LBRACE BAR process RBRACE SEMI process // lookahead token is inherited
                                                              . 

** In state 804, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LBRACE BAR process RBRACE SEMI process 
                                                              . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 800.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL proc_expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 800, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               proc_expr SEMI process // lookahead token is inherited
                                              . 

** In state 800, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               proc_expr SEMI process 
                                              . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 797.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL process0 BAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 797, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 BAR process // lookahead token is inherited
                                            . 

** In state 797, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 BAR process 
                                            . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 796.
** Token involved: BAR
** This state is reached from implementation after reading:

LBRACE BAR LOC LIDENT loc_modules JOINDEF join_pattern EQUAL process0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           (?)

** In state 796, looking ahead at BAR, reducing production
** process -> process0
** is permitted because of the following sub-derivation:

process0 BAR process // lookahead token appears
LOC loc_bindings // lookahead token is inherited
    loc_binding // lookahead token is inherited
    LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                       JOINDEF def_bindings // lookahead token is inherited
                               def_binding // lookahead token is inherited
                               simple_def_binding // lookahead token is inherited
                               def_pattern // lookahead token is inherited
                               join_pattern EQUAL process // lookahead token is inherited
                                                  process0 . 

** In state 796, looking ahead at BAR, shifting is permitted
** because of the following sub-derivation:

process0 
LOC loc_bindings 
    loc_binding 
    LIDENT loc_modules loc_defs loc_init 
                       JOINDEF def_bindings 
                               def_binding 
                               simple_def_binding 
                               def_pattern 
                               join_pattern EQUAL process 
                                                  process0 . BAR process 

** Conflict (shift/reduce) in state 795.
** Token involved: SHARP
** This state is reached from use_file after reading:

toplevel_directive LET JOINDEF join_pattern EQUAL simple_chan_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
toplevel_directive use_file_tail 
                   (?)

** In state 795, looking ahead at SHARP, reducing production
** process0 -> simple_chan_expr simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 // lookahead token is inherited
                               simple_chan_expr simple_expr . 

** In state 795, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 
                               simple_chan_expr simple_expr 
                                                simple_expr . SHARP label 

** Conflict (shift/reduce) in state 790.
** Token involved: ELSE
** This state is reached from implementation after reading:

LBRACE BAR IF expr THEN LOC LIDENT loc_modules JOINDEF join_pattern EQUAL IF expr THEN process0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           (?)

** In state 790, looking ahead at ELSE, reducing production
** process -> IF expr THEN process0
** is permitted because of the following sub-derivation:

process0 
IF expr THEN process0 ELSE process0 // lookahead token appears
             LOC loc_bindings // lookahead token is inherited
                 loc_binding // lookahead token is inherited
                 LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                                    JOINDEF def_bindings // lookahead token is inherited
                                            def_binding // lookahead token is inherited
                                            simple_def_binding // lookahead token is inherited
                                            def_pattern // lookahead token is inherited
                                            join_pattern EQUAL process // lookahead token is inherited
                                                               IF expr THEN process0 . 

** In state 790, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF expr THEN process0 
             LOC loc_bindings 
                 loc_binding 
                 LIDENT loc_modules loc_defs loc_init 
                                    JOINDEF def_bindings 
                                            def_binding 
                                            simple_def_binding 
                                            def_pattern 
                                            join_pattern EQUAL process 
                                                               process0 
                                                               IF expr THEN process0 . ELSE process0 

** Conflict (shift/reduce) in state 788.
** Token involved: THEN
** This state is reached from implementation after reading:

LBRACE BAR IF expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           (?)

** In state 788, looking ahead at THEN, shifting is permitted
** because of the following sub-derivation:

IF expr . THEN process0 

** In state 788, looking ahead at THEN, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

proc_expr SEMI process 
IF seq_expr THEN proc_expr ELSE proc_expr // lookahead token appears
   expr . 

** Conflict (shift/reduce) in state 785.
** Token involved: error
** This state is reached from implementation after reading:

LBRACE BAR LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           process0 
           (?)

** In state 785, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

LBRACE process error // lookahead token appears
       . 

** In state 785, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

LBRACE . error 

** Conflict (shift/reduce) in state 784.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL LET LOC loc_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 784, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET LOC loc_bindings IN process // lookahead token is inherited
                                                       . 

** In state 784, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET LOC loc_bindings IN process 
                                                       . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 779.
** Token involved: ELSE
** This state is reached from implementation after reading:

SPAWN LBRACE IF expr THEN LOC LIDENT loc_modules JOINDEF join_pattern EQUAL IF expr THEN process0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             (?)

** In state 779, looking ahead at ELSE, reducing production
** process -> IF expr THEN process0
** is permitted because of the following sub-derivation:

process0 
IF expr THEN process0 ELSE process0 // lookahead token appears
             LOC loc_bindings // lookahead token is inherited
                 loc_binding // lookahead token is inherited
                 LIDENT loc_modules loc_defs loc_init // lookahead token is inherited because loc_init can vanish
                                    JOINDEF def_bindings // lookahead token is inherited
                                            def_binding // lookahead token is inherited
                                            simple_def_binding // lookahead token is inherited
                                            def_pattern // lookahead token is inherited
                                            join_pattern EQUAL process // lookahead token is inherited
                                                               IF expr THEN process0 . 

** In state 779, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF expr THEN process0 
             LOC loc_bindings 
                 loc_binding 
                 LIDENT loc_modules loc_defs loc_init 
                                    JOINDEF def_bindings 
                                            def_binding 
                                            simple_def_binding 
                                            def_pattern 
                                            join_pattern EQUAL process 
                                                               process0 
                                                               IF expr THEN process0 . ELSE process0 

** Conflict (shift/reduce) in state 777.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET JOINDEF join_pattern EQUAL IF expr THEN simple_chan_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 777, looking ahead at SHARP, reducing production
** process0 -> simple_chan_expr simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               IF expr THEN process0 // lookahead token is inherited
                                            simple_chan_expr simple_expr . 

** In state 777, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               IF expr THEN process0 
                                            simple_chan_expr simple_expr 
                                                             simple_expr . SHARP label 

** Conflict (shift/reduce) in state 767.
** Token involved: SHARP
** This state is reached from use_file after reading:

toplevel_directive LET JOINDEF join_pattern EQUAL IF expr THEN simple_chan_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
toplevel_directive use_file_tail 
                   (?)

** In state 767, looking ahead at SHARP, reducing production
** process0 -> simple_chan_expr simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               IF expr THEN process0 // lookahead token is inherited
                                            simple_chan_expr simple_expr . 

** In state 767, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               IF expr THEN process0 
                                            simple_chan_expr simple_expr 
                                                             simple_expr . SHARP label 

** Conflict (shift/reduce) in state 753.
** Token involved: THEN
** This state is reached from implementation after reading:

SPAWN LBRACE IF expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             (?)

** In state 753, looking ahead at THEN, shifting is permitted
** because of the following sub-derivation:

IF expr . THEN process0 

** In state 753, looking ahead at THEN, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

proc_expr SEMI process 
IF seq_expr THEN proc_expr ELSE proc_expr // lookahead token appears
   expr . 

** Conflict (shift/reduce) in state 743.
** Token involved: ELSE
** This state is reached from implementation after reading:

SPAWN LBRACE IF seq_expr THEN IF seq_expr THEN proc_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             proc_expr SEMI process 
             (?)

** In state 743, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF seq_expr THEN proc_expr ELSE proc_expr 
                 IF seq_expr THEN proc_expr . ELSE proc_expr 

** In state 743, looking ahead at ELSE, reducing production
** proc_expr -> IF seq_expr THEN proc_expr
** is permitted because of the following sub-derivation:

IF seq_expr THEN proc_expr ELSE proc_expr // lookahead token appears
                 IF seq_expr THEN proc_expr . 

** Conflict (shift/reduce) in state 700.
** Token involved: error
** This state is reached from implementation after reading:

SPAWN LBRACE LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             process0 
             (?)

** In state 700, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

LBRACE process error // lookahead token appears
       . 

** In state 700, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

LBRACE . error 

** Conflict (shift/reduce) in state 699.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LET LOC loc_bindings IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 699, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               LET LOC loc_bindings IN process // lookahead token is inherited
                                                       . 

** In state 699, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               LET LOC loc_bindings IN process 
                                                       . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 694.
** Token involved: error
** This state is reached from implementation after reading:

SPAWN LBRACE IF expr THEN LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
SPAWN LBRACE process RBRACE 
             IF expr THEN process0 
                          (?)

** In state 694, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

LBRACE process error // lookahead token appears
       . 

** In state 694, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

LBRACE . error 

** Conflict (shift/reduce) in state 690.
** Token involved: AND
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL LOC loc_binding

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET JOINDEF def_bindings 
            (?)

** In state 690, looking ahead at AND, reducing production
** loc_bindings -> loc_binding
** is permitted because of the following sub-derivation:

def_bindings AND def_binding // lookahead token appears
def_binding // lookahead token is inherited
simple_def_binding // lookahead token is inherited
def_pattern // lookahead token is inherited
join_pattern EQUAL process // lookahead token is inherited
                   process0 // lookahead token is inherited
                   LOC loc_bindings // lookahead token is inherited
                       loc_binding . 

** In state 690, looking ahead at AND, shifting is permitted
** because of the following sub-derivation:

def_binding 
simple_def_binding 
def_pattern 
join_pattern EQUAL process 
                   process0 
                   LOC loc_bindings 
                       loc_binding . AND loc_bindings 

** Conflict (shift/reduce) in state 674.
** Token involved: LET
** This state is reached from implementation after reading:

LET JOINDEF join_pattern EQUAL REPLY

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
(?)

** In state 674, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 
                               REPLY expr to_ident 
                                     expr0 
                                     . LET JOINDEF def_bindings IN error 

** In state 674, looking ahead at LET, reducing production
** to_ident ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 // lookahead token is inherited
                               REPLY to_ident // lookahead token is inherited
                                     . 

** Conflict (shift/reduce) in state 672.
** Token involved: error
** This state is reached from implementation after reading:

LBRACE BAR IF expr THEN LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
LBRACE BAR process RBRACE 
           IF expr THEN process0 
                        (?)

** In state 672, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

LBRACE process error // lookahead token appears
       . 

** In state 672, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

LBRACE . error 

** Conflict (shift/reduce) in state 635.
** Token involved: ELSE
** This state is reached from implementation after reading:

IF seq_expr THEN IF seq_expr THEN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
(?)

** In state 635, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr 
                 expr0 
                 IF seq_expr THEN expr . ELSE expr 

** In state 635, looking ahead at ELSE, reducing production
** expr0 -> IF seq_expr THEN expr
** is permitted because of the following sub-derivation:

IF seq_expr THEN expr ELSE expr // lookahead token appears
                 expr0 // lookahead token is inherited
                 IF seq_expr THEN expr . 

** Conflict (shift/reduce) in state 612.
** Token involved: LET
** This state is reached from implementation after reading:

expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
(?)

** In state 612, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

seq_expr structure_tail 
expr SEMI seq_expr 
          expr 
          expr0 
          . LET JOINDEF def_bindings IN error 

** In state 612, looking ahead at LET, reducing production
** seq_expr -> expr SEMI
** is permitted because of the following sub-derivation:

seq_expr structure_tail // lookahead token appears because structure_tail can begin with LET
expr SEMI . 

** Conflict (shift/reduce) in state 611.
** Tokens involved: SEMI COMMA
** The following explanations concentrate on token SEMI.
** This state is reached from implementation after reading:

FUN simple_pattern MINUSGREATER expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
(?)

** In state 611, looking ahead at SEMI, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

expr SEMI // lookahead token appears
expr0 // lookahead token is inherited
FUN simple_pattern fun_def // lookahead token is inherited
                   match_action // lookahead token is inherited
                   MINUSGREATER seq_expr // lookahead token is inherited
                                expr . 

** In state 611, looking ahead at SEMI, shifting is permitted
** because of the following sub-derivation:

expr 
expr0 
FUN simple_pattern fun_def 
                   match_action 
                   MINUSGREATER seq_expr 
                                expr . SEMI 

** Conflict (shift/reduce) in state 601.
** Token involved: SHARP
** This state is reached from use_file after reading:

simple_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 601, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
expr0 
simple_expr simple_expr_list 
            simple_expr 
            simple_expr . SHARP label 

** In state 601, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
expr0 // lookahead token is inherited
simple_expr simple_expr_list // lookahead token is inherited
            simple_expr . 

** Conflict (shift/reduce) in state 600.
** Token involved: SHARP
** This state is reached from use_file after reading:

simple_expr simple_expr_list simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 600, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
expr0 
simple_expr simple_expr_list 
            simple_expr_list simple_expr 
                             simple_expr . SHARP label 

** In state 600, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr_list simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
expr0 // lookahead token is inherited
simple_expr simple_expr_list // lookahead token is inherited
            simple_expr_list simple_expr . 

** Conflict (shift/reduce) in state 558.
** Tokens involved: VARTYPE UIDENT TRUE STRING RELOCINFO PREFIXOP NEW LPAREN LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token VARTYPE.
** This state is reached from implementation after reading:

constr_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
(?)

** In state 558, looking ahead at VARTYPE, reducing production
** simple_expr -> constr_longident
** is permitted because of the following sub-derivation:

simple_expr simple_expr_list // lookahead token appears because simple_expr_list can begin with VARTYPE
constr_longident . 

** In state 558, looking ahead at VARTYPE, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
                 . VARTYPE 

** Conflict (shift/reduce) in state 551.
** Tokens involved: SUBTRACTIVE STAR LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COLONEQUAL COLONCOLON BARBAR AMPERSAND AMPERAMPER
** The following explanations concentrate on token SUBTRACTIVE.
** This state is reached from implementation after reading:

label LESSMINUS expr0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
(?)

** In state 551, looking ahead at SUBTRACTIVE, reducing production
** expr -> expr0
** is permitted because of the following sub-derivation:

expr0 SUBTRACTIVE expr0 // lookahead token appears
label LESSMINUS expr // lookahead token is inherited
                expr0 . 

** In state 551, looking ahead at SUBTRACTIVE, shifting is permitted
** because of the following sub-derivation:

label LESSMINUS expr 
                expr0 
                expr0 . SUBTRACTIVE expr0 

** Conflict (shift/reduce) in state 549.
** Token involved: COMMA
** This state is reached from implementation after reading:

expr_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr_comma_list 
(?)

** In state 549, looking ahead at COMMA, reducing production
** expr -> expr_comma_list
** is permitted because of the following sub-derivation:

expr COMMA expr // lookahead token appears
expr_comma_list . 

** In state 549, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

expr_comma_list . COMMA expr 

** Conflict (shift/reduce) in state 541.
** Token involved: SHARP
** This state is reached from use_file after reading:

simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
(?)

** In state 541, looking ahead at SHARP, reducing production
** expr0 -> simple_expr
** is permitted because of the following sub-derivation:

seq_expr use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
expr // lookahead token is inherited
expr0 // lookahead token is inherited
simple_expr . 

** In state 541, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

seq_expr use_file_tail 
expr 
expr0 
simple_expr 
simple_expr . SHARP label 

** Conflict (shift/reduce) in state 523.
** Token involved: DOT
** This state is reached from implementation after reading:

mod_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
(?)

** In state 523, looking ahead at DOT, reducing production
** constr_longident -> mod_longident
** is permitted because of the following sub-derivation:

simple_expr DOT label_longident LESSMINUS expr // lookahead token appears
constr_longident // lookahead token is inherited
mod_longident . 

** In state 523, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
mod_longident 
mod_longident . DOT UIDENT 

** Conflict (shift/reduce) in state 492.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 492, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             expr0 
                             simple_expr simple_expr_list 
                                         simple_expr 
                                         simple_expr . SHARP label 

** In state 492, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             expr0 // lookahead token is inherited
                             simple_expr simple_expr_list // lookahead token is inherited
                                         simple_expr . 

** Conflict (shift/reduce) in state 491.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr simple_expr_list simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 491, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             expr0 
                             simple_expr simple_expr_list 
                                         simple_expr_list simple_expr 
                                                          simple_expr . SHARP label 

** In state 491, looking ahead at SHARP, reducing production
** simple_expr_list -> simple_expr_list simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             expr0 // lookahead token is inherited
                             simple_expr simple_expr_list // lookahead token is inherited
                                         simple_expr_list simple_expr . 

** Conflict (shift/reduce) in state 475.
** Token involved: LET
** This state is reached from implementation after reading:

MODULE UIDENT EQUAL STRUCT expr SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
MODULE UIDENT module_binding 
              EQUAL module_expr 
                    STRUCT structure END 
                           (?)

** In state 475, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

seq_expr structure_tail 
expr SEMI seq_expr 
          expr 
          expr0 
          . LET JOINDEF def_bindings IN error 

** In state 475, looking ahead at LET, reducing production
** seq_expr -> expr SEMI
** is permitted because of the following sub-derivation:

seq_expr structure_tail // lookahead token appears because structure_tail can begin with LET
expr SEMI . 

** Conflict (shift/reduce) in state 474.
** Tokens involved: SEMI COMMA
** The following explanations concentrate on token SEMI.
** This state is reached from implementation after reading:

TRY FUN simple_pattern MINUSGREATER expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    (?)

** In state 474, looking ahead at SEMI, reducing production
** seq_expr -> expr
** is permitted because of the following sub-derivation:

expr SEMI // lookahead token appears
expr0 // lookahead token is inherited
FUN simple_pattern fun_def // lookahead token is inherited
                   match_action // lookahead token is inherited
                   MINUSGREATER seq_expr // lookahead token is inherited
                                expr . 

** In state 474, looking ahead at SEMI, shifting is permitted
** because of the following sub-derivation:

expr 
expr0 
FUN simple_pattern fun_def 
                   match_action 
                   MINUSGREATER seq_expr 
                                expr . SEMI 

** Conflict (shift/reduce) in state 439.
** Tokens involved: VARTYPE UIDENT TRUE STRING RELOCINFO PREFIXOP NEW LPAREN LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
** The following explanations concentrate on token VARTYPE.
** This state is reached from implementation after reading:

TRY constr_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr0 
    (?)

** In state 439, looking ahead at VARTYPE, reducing production
** simple_expr -> constr_longident
** is permitted because of the following sub-derivation:

simple_expr simple_expr_list // lookahead token appears because simple_expr_list can begin with VARTYPE
constr_longident . 

** In state 439, looking ahead at VARTYPE, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
                 . VARTYPE 

** Conflict (shift/reduce) in state 432.
** Tokens involved: SUBTRACTIVE STAR LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COLONEQUAL COLONCOLON BARBAR AMPERSAND AMPERAMPER
** The following explanations concentrate on token SUBTRACTIVE.
** This state is reached from implementation after reading:

TRY label LESSMINUS expr0

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr0 
    (?)

** In state 432, looking ahead at SUBTRACTIVE, reducing production
** expr -> expr0
** is permitted because of the following sub-derivation:

expr0 SUBTRACTIVE expr0 // lookahead token appears
label LESSMINUS expr // lookahead token is inherited
                expr0 . 

** In state 432, looking ahead at SUBTRACTIVE, shifting is permitted
** because of the following sub-derivation:

label LESSMINUS expr 
                expr0 
                expr0 . SUBTRACTIVE expr0 

** Conflict (shift/reduce) in state 430.
** Token involved: COMMA
** This state is reached from implementation after reading:

TRY expr_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr_comma_list 
    (?)

** In state 430, looking ahead at COMMA, reducing production
** expr -> expr_comma_list
** is permitted because of the following sub-derivation:

expr COMMA expr // lookahead token appears
expr_comma_list . 

** In state 430, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

expr_comma_list . COMMA expr 

** Conflict (shift/reduce) in state 425.
** Token involved: DOT
** This state is reached from implementation after reading:

TRY mod_longident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr0 
    (?)

** In state 425, looking ahead at DOT, reducing production
** constr_longident -> mod_longident
** is permitted because of the following sub-derivation:

simple_expr DOT label_longident LESSMINUS expr // lookahead token appears
constr_longident // lookahead token is inherited
mod_longident . 

** In state 425, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

constr_longident simple_expr 
mod_longident 
mod_longident . DOT UIDENT 

** Conflict (shift/reduce) in state 418.
** Token involved: SHARP
** This state is reached from use_file after reading:

LET rec_flag val_ident EQUAL simple_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 418, looking ahead at SHARP, reducing production
** expr0 -> simple_expr
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
LET rec_flag let_bindings // lookahead token is inherited
             let_binding // lookahead token is inherited
             val_ident fun_binding // lookahead token is inherited
                       EQUAL seq_expr // lookahead token is inherited
                             expr // lookahead token is inherited
                             expr0 // lookahead token is inherited
                             simple_expr . 

** In state 418, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
LET rec_flag let_bindings 
             let_binding 
             val_ident fun_binding 
                       EQUAL seq_expr 
                             expr 
                             expr0 
                             simple_expr 
                             simple_expr . SHARP label 

** Conflict (shift/reduce) in state 366.
** Token involved: COMMA
** This state is reached from implementation after reading:

LET rec_flag pattern_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET rec_flag let_bindings 
             let_binding 
             pattern EQUAL seq_expr 
             pattern_comma_list 
             (?)

** In state 366, looking ahead at COMMA, reducing production
** pattern -> pattern_comma_list
** is permitted because of the following sub-derivation:

pattern COMMA pattern // lookahead token appears
pattern_comma_list . 

** In state 366, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

pattern_comma_list . COMMA pattern 

** Conflict (shift/reduce) in state 326.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 326, looking ahead at LET, reducing production
** process ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               . 

** In state 326, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               . LET JOINDEF def_bindings IN process 

** Conflict (shift/reduce) in state 314.
** Tokens involved: RBRACKET COMMA
** The following explanations concentrate on token COMMA.
** This state is reached from implementation after reading:

LET JOINDEF LIDENT LBRACKET LIDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            (?)

** In state 314, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

LIDENT LBRACKET lident_comma_list RBRACKET LBRACE simple_def_binding loc_init RBRACE 
                LIDENT . COMMA lident_comma_list 

** In state 314, looking ahead at COMMA, reducing production
** val_ident -> LIDENT
** is permitted because of the following sub-derivation:

simple_def_binding 
def_pattern 
join_pattern EQUAL process 
LIDENT simple_pattern 
       LBRACKET pattern_semi_list opt_semi RBRACKET 
                pattern 
                pattern_comma_list 
                pattern COMMA pattern // lookahead token appears
                simple_pattern // lookahead token is inherited
                val_ident // lookahead token is inherited
                LIDENT . 

** Conflict (shift/reduce) in state 233.
** Token involved: MINUSGREATER
** This state is reached from implementation after reading:

PARSER LPAREN pattern COLON core_type MINUSGREATER core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
PARSER opt_pat opt_bar parser_cases 
       simple_pattern 
       LPAREN pattern COLON core_type RPAREN 
                            (?)

** In state 233, looking ahead at MINUSGREATER, shifting is permitted
** because of the following sub-derivation:

core_type MINUSGREATER core_type 
                       core_type . MINUSGREATER core_type 

** In state 233, looking ahead at MINUSGREATER, reducing production
** core_type -> core_type MINUSGREATER core_type
** is permitted because of the following sub-derivation:

core_type MINUSGREATER core_type // lookahead token appears
core_type MINUSGREATER core_type . 

** Conflict (shift/reduce) in state 179.
** Token involved: MINUSGREATER
** This state is reached from implementation after reading:

LPAREN seq_expr COLONGREATER core_type MINUSGREATER core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
simple_expr 
LPAREN seq_expr type_constraint RPAREN 
                COLONGREATER core_type 
                             (?)

** In state 179, looking ahead at MINUSGREATER, shifting is permitted
** because of the following sub-derivation:

core_type MINUSGREATER core_type 
                       core_type . MINUSGREATER core_type 

** In state 179, looking ahead at MINUSGREATER, reducing production
** core_type -> core_type MINUSGREATER core_type
** is permitted because of the following sub-derivation:

core_type MINUSGREATER core_type // lookahead token appears
core_type MINUSGREATER core_type . 

** Conflict (shift/reduce) in state 160.
** Token involved: SHARP
** This state is reached from use_file after reading:

TYPE type_parameters LIDENT EQUAL simple_core_type

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

use_file 
use_file_tail 
(?)

** In state 160, looking ahead at SHARP, reducing production
** core_type -> simple_core_type
** is permitted because of the following sub-derivation:

structure_item use_file_tail // lookahead token appears because use_file_tail can begin with SHARP
TYPE type_declarations // lookahead token is inherited
     type_declaration // lookahead token is inherited
     type_parameters LIDENT type_kind constraints // lookahead token is inherited because constraints can vanish
                            EQUAL core_type // lookahead token is inherited
                                  simple_core_type . 

** In state 160, looking ahead at SHARP, shifting is permitted
** because of the following sub-derivation:

structure_item use_file_tail 
TYPE type_declarations 
     type_declaration 
     type_parameters LIDENT type_kind constraints 
                            EQUAL core_type 
                                  simple_core_type 
                                  simple_core_type . SHARP class_longident 

** Conflict (shift/reduce) in state 78.
** Token involved: COMMA
** This state is reached from implementation after reading:

PARSER LPAREN pattern_comma_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
PARSER opt_pat opt_bar parser_cases 
       simple_pattern 
       LPAREN pattern RPAREN 
              pattern_comma_list 
              (?)

** In state 78, looking ahead at COMMA, reducing production
** pattern -> pattern_comma_list
** is permitted because of the following sub-derivation:

pattern COMMA pattern // lookahead token appears
pattern_comma_list . 

** In state 78, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

pattern_comma_list . COMMA pattern 

** Conflict (shift/reduce) in state 36.
** Token involved: LET
** This state is reached from implementation after reading:

structure_item LET JOINDEF join_pattern EQUAL REPLY

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
structure_tail 
structure_item structure_tail 
               (?)

** In state 36, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

structure_item structure_tail 
LET JOINDEF def_bindings 
            def_binding 
            simple_def_binding 
            def_pattern 
            join_pattern EQUAL process 
                               process0 
                               REPLY expr to_ident 
                                     expr0 
                                     . LET JOINDEF def_bindings IN error 

** In state 36, looking ahead at LET, reducing production
** to_ident ->
** is permitted because of the following sub-derivation:

structure_item structure_tail // lookahead token appears because structure_tail can begin with LET
LET JOINDEF def_bindings // lookahead token is inherited
            def_binding // lookahead token is inherited
            simple_def_binding // lookahead token is inherited
            def_pattern // lookahead token is inherited
            join_pattern EQUAL process // lookahead token is inherited
                               process0 // lookahead token is inherited
                               REPLY to_ident // lookahead token is inherited
                                     . 

** Conflict (shift/reduce) in state 30.
** Token involved: error
** This state is reached from implementation after reading:

TRY SPAWN LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
TRY seq_expr WITH opt_bar match_cases 
    expr 
    expr0 
    (?)

** In state 30, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

SPAWN LBRACE . error 

** In state 30, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

SPAWN LBRACE process error // lookahead token appears
             . 

** Conflict (shift/reduce) in state 10.
** Token involved: error
** This state is reached from implementation after reading:

SPAWN LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

implementation 
structure EOF 
seq_expr structure_tail 
expr 
expr0 
(?)

** In state 10, looking ahead at error, shifting is permitted
** because of the following sub-derivation:

SPAWN LBRACE . error 

** In state 10, looking ahead at error, reducing production
** process ->
** is permitted because of the following sub-derivation:

SPAWN LBRACE process error // lookahead token appears
             . 
