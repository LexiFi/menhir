File "jparser.mly", line 136, characters 7-10:
Warning: the token CLS is unused.
File "jparser.mly", line 111, characters 16-26:
Warning: the token CORE_LABEL is unused.
File "jparser.mly", line 157, characters 7-14:
Warning: the token EMPRULE is unused.
File "jparser.mly", line 174, characters 7-14:
Warning: the token GARBAGE is unused.
File "jparser.mly", line 186, characters 7-16:
Warning: the token INVARIANT is unused.
File "jparser.mly", line 214, characters 7-11:
Warning: the token PRED is unused.
File "jparser.mly", line 219, characters 7-15:
Warning: the token PURERULE is unused.
File "jparser.mly", line 221, characters 7-12:
Warning: the token QUOTE is unused.
File "jparser.mly", line 249, characters 7-17:
Warning: the token UNDERSCORE is unused.
File "jparser.mly", line 404, characters 0-13:
Warning: symbol exp_posts_npv is unreachable from any of the start symbol(s).
File "jparser.mly", line 841, characters 0-18:
Warning: symbol lvariable_npv_list is unreachable from any of the start symbol(s).
File "jparser.mly", line 388, characters 0-8:
Warning: symbol spec_npv is unreachable from any of the start symbol(s).
File "jparser.mly", line 390, characters 0-9:
Warning: symbol specs_npv is unreachable from any of the start symbol(s).
%{ (* header *)
exception Give_up

open Jparsetree

open Core
open Jimple_global_types
open Lexing
open Load
open Parsing
open Printing
open Psyntax
open Spec
open Spec_def
open Vars


(* TODO(rgrig): Functions in Vars should be used instead of new*Var. *)
let newPVar x = concretep_str x

let newAnyVar x = AnyVar(0,x)

let newEVar x = EVar(0,x)

let newVar x =
  if x = "_" then freshe()
  else if String.get x 0 = '_' then newEVar (String.sub x 1 ((String.length x) -1))
  else newPVar x


let msig_simp (mods,typ,name,args_list) =
  let args_list = List.map fst args_list in
  (mods,typ,name,args_list)

let bind_spec_vars
    (mods,typ,name,args_list)
    {pre=pre;post=post;excep=excep} =
  (* Make substitution to normalise names *)
  let subst = Psyntax.empty in
  let subst = Psyntax.add (newPVar("this")) (Arg_var(Support_syntax.this_var)) subst in
  (* For each name that is given convert to normalised param name. *)
  let _,subst =
    List.fold_left
      (fun (n,subst) arg_opt ->
	(n+1,
	 match arg_opt with
	   ty,None -> subst
	 | ty,Some str ->
	     Psyntax.add
	       (newPVar(str))
	       (Arg_var(Support_syntax.parameter_var n))
	       subst
	))
	  (0,subst) args_list in
  {pre=subst_pform subst pre;
   post=subst_pform subst post;
   excep=ClassMap.map (subst_pform subst) excep}

let mkDynamic (msig, specs, source_pos) =
  let specs = List.map (bind_spec_vars msig) specs in
  let msig = msig_simp msig in
  Dynamic(msig, specs, source_pos)

let mkStatic (msig, specs, source_pos) =
  let specs = List.map (bind_spec_vars msig) specs in
  let msig = msig_simp msig in
  Static(msig, specs, source_pos)


let location_to_string pos =
  Printf.sprintf "Line %d character %d" pos.pos_lnum  (pos.pos_cnum - pos.pos_bol + 1)

let parse_error s =
  let start_pos = Parsing.symbol_start_pos () in
  let end_pos = Parsing.symbol_end_pos () in
  Printf.printf "Error between %s and %s\n%s\n" (location_to_string start_pos) (location_to_string end_pos) s

let parse_warning s =
  let start_pos = Parsing.symbol_start_pos () in
  let end_pos = Parsing.symbol_end_pos () in
  Printf.printf "Warning %s (between %s and %s)\n" s (location_to_string start_pos) (location_to_string end_pos)

let field_signature2str fs =
  match fs with
  | Field_signature (c,t,n) ->  Pprinter.mkStrOfFieldSignature c t n
  | _ -> assert false


%}
%start file
%start question_file
%start rule_file
%start spec
%start spec_file
%start symb_question_file
%start symb_test_file
%start test_file
%token ABDUCTION
%token ABS
%token ABSRULE
%token ABSTRACT
%token AND
%token ANDALSO
%token ANNOTATION
%token AS
%token ASSIGN
%token <string> AT_IDENTIFIER
%token AXIOMS
%token BANG
%token BIMP
%token BOOLEAN
%token BREAKPOINT
%token BYTE
%token CASE
%token CATCH
%token CHAR
%token CLASS
%token CLS
%token CMP
%token CMPEQ
%token CMPG
%token CMPGE
%token CMPGT
%token CMPL
%token CMPLE
%token CMPLT
%token CMPNE
%token COLON
%token COLON_EQUALS
%token COMMA
%token CONSTRUCTOR
%token <string> CORE_LABEL
%token DASHV
%token DEFAULT
%token DEFINE
%token DIV
%token DOT
%token DOUBLE
%token EMP
%token EMPRULE
%token END
%token ENSURES
%token ENTERMONITOR
%token ENUM
%token EOF
%token EQUALS
%token EQUIV
%token EXITMONITOR
%token EXPORT
%token EXPORTS
%token EXTENDS
%token FALSE
%token FINAL
%token FLOAT
%token <float> FLOAT_CONSTANT
%token FRAME
%token FROM
%token <string> FULL_IDENTIFIER
%token GARBAGE
%token GOTO
%token <string> IDENTIFIER
%token IF
%token IMP
%token IMPLEMENTS
%token IMPLICATION
%token IMPORT
%token INCONSISTENCY
%token INSTANCEOF
%token INT
%token <int> INTEGER_CONSTANT
%token <int> INTEGER_CONSTANT_LONG
%token INTERFACE
%token INTERFACEINVOKE
%token INVARIANT
%token LABEL
%token LEADSTO
%token LENGTHOF
%token LONG
%token LOOKUPSWITCH
%token L_BRACE
%token L_BRACKET
%token L_PAREN
%token MAPSTO
%token MINUS
%token MOD
%token MULT
%token NATIVE
%token NEG
%token NEW
%token NEWARRAY
%token NEWMULTIARRAY
%token NOP
%token NOTIN
%token NOTINCONTEXT
%token NULL
%token NULL_TYPE
%token OLD
%token OR
%token OROR
%token ORTEXT
%token PLUS
%token PRED
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token PUREGUARD
%token PURERULE
%token QUESTIONMARK
%token QUOTE
%token <string> QUOTED_NAME
%token REQUIRES
%token RET
%token RETURN
%token REWRITERULE
%token RULE
%token R_BRACE
%token R_BRACKET
%token R_PAREN
%token SEMICOLON
%token SHL
%token SHORT
%token SHR
%token SOURCE_POS_TAG
%token SOURCE_POS_TAG_CLOSE
%token SPECIALINVOKE
%token SPECIFICATION
%token SPECTEST
%token STATIC
%token STATICINVOKE
%token STRICTFP
%token <string> STRING_CONSTANT
%token SYNCHRONIZED
%token TABLESWITCH
%token THROW
%token THROWS
%token TO
%token TRANSIENT
%token TRUE
%token UNDERSCORE
%token UNKNOWN
%token USHR
%token VDASH
%token VIRTUALINVOKE
%token VOID
%token VOLATILE
%token WAND
%token WHERE
%token WITH
%token WITHOUT
%token XOR
%left IDENTIFIER
%left AT_IDENTIFIER
%left QUOTED_NAME
%left FULL_IDENTIFIER
%left OR
%left OROR
%left MULT
%left AND
%left XOR
%left MOD
%left CMP
%left CMPG
%left CMPL
%left CMPEQ
%left CMPNE
%left CMPGT
%left CMPGE
%left CMPLT
%left CMPLE
%left SHL
%left SHR
%left USHR
%left PLUS
%left MINUS
%left DIV
%left DEFINE
%left EXPORT
%type <Jimple_global_types.jimple_file> file
%type <Psyntax.question list> question_file
%type <Psyntax.rules Load.importoption list> rule_file
%type <Spec.spec> spec
%type <Spec_def.class_spec Load.importoption list> spec_file
%type <Core.symb_question list> symb_question_file
%type <Core.symb_test list> symb_test_file
%type <Psyntax.test list> test_file
%%

file:
  _1 = modifier_list_star _2 = file_type _3 = class_name _4 = extends_clause _5 = implements_clause _6 = file_body
    {       (JFile(_1, _2, _3, _4, _5, _6))}

spec_file:
  _1 = EOF
    {          ( [] )}
| _1 = IMPORT _2 = STRING_CONSTANT _3 = SEMICOLON _4 = spec_file
    {                                                 ( (ImportEntry _2) :: _4 )}
| _1 = classspec _2 = spec_file
    {                         ( (NormalEntry _1) :: _2 )}

classspec:
  _1 = file_type _2 = class_name _3 = extends_clause _4 = implements_clause _5 = L_BRACE _6 = apf_defines _7 = exports_clause _8 = axioms_clause _9 = methods_specs _10 = R_BRACE
    {                                                                                                                                   ( {class_or_interface=_1;classname=_2;extends=_3;implements=_4;apf=_6;exports=_7;axioms=_8;methodspecs=_9} )}

apf_defines:
  _1 = apf_define _2 = apf_defines
    {                            ( _1 :: _2 )}
| 
    {               ( [] )}

eq_as:
  _1 = EQUALS
    {            ( (* Deprecated *))}
| _1 = AS
    {        ()}

apf_define:
  _1 = EXPORT _2 = identifier _3 = L_PAREN _4 = lvariable _5 = paramlist_question_mark _6 = R_PAREN _7 = eq_as _8 = formula _9 = SEMICOLON
    {       ( let a=match _5 with | Some b -> b | None -> [] in (_2,_4,a,_8,true) )}
| _1 = DEFINE _2 = identifier _3 = L_PAREN _4 = lvariable _5 = paramlist_question_mark _6 = R_PAREN _7 = eq_as _8 = formula _9 = SEMICOLON
    {       ( let a=match _5 with | Some b -> b | None -> [] in (_2,_4,a,_8,false) )}

exports_clause:
  _1 = EXPORTS _2 = L_BRACE _3 = named_implication_star _4 = R_BRACE _5 = WHERE _6 = L_BRACE _7 = exportLocal_predicate_def_star _8 = R_BRACE
    {                                                                                                         ( Some (_3,_7) )}
| 
    {              (None)}

axioms_clause:
  _1 = AXIOMS _2 = L_BRACE _3 = named_implication_star _4 = R_BRACE
    {                                                  ( Some _3 )}
| 
    {              (None)}

named_implication_star:
  _1 = named_implication _2 = named_implication_star
    {                                              ( _1 @ _2 )}
| 
    {               ( [] )}

named_implication:
  _1 = identifier _2 = COLON _3 = formula _4 = IMP _5 = formula _6 = SEMICOLON
    {                                                    ( [(_1,_3,_5)] )}
| _1 = identifier _2 = COLON _3 = formula _4 = BIMP _5 = formula _6 = SEMICOLON
    {                                                     ( [(_1^"_forwards",_3,_5); (_1^"_backwards",_5,_3)] )}

exportLocal_predicate_def_star:
  _1 = exportLocal_predicate_def _2 = exportLocal_predicate_def_star
    {                                                              ( _1 :: _2 )}
| 
    {               ( [] )}

exportLocal_predicate_def:
  _1 = identifier _2 = L_PAREN _3 = lvariable_list_ne _4 = R_PAREN _5 = eq_as _6 = formula _7 = SEMICOLON
    {                                                                          ( (_1,_3,_6) )}

methods_specs:
  _1 = method_spec _2 = methods_specs
    {                               ( _1 :: _2 )}
| 
    {               ( [] )}

spec:
  _1 = L_BRACE _2 = formula _3 = R_BRACE _4 = L_BRACE _5 = formula _6 = R_BRACE _7 = exp_posts
    {                                                                (  {pre=_2;post=_5;excep=_7} )}

specs:
  _1 = spec _2 = ANDALSO _3 = specs
    {                         ( _1 :: _3 )}
| _1 = spec
    {           ([_1])}

method_spec:
  _1 = method_signature_short _2 = COLON _3 = specs _4 = SEMICOLON _5 = source_pos_tag_option
    {                                                                         ( mkDynamic(_1, _3, _5) )}
| _1 = method_signature_short _2 = STATIC _3 = COLON _4 = specs _5 = SEMICOLON _6 = source_pos_tag_option
    {                                                                               ( mkStatic(_1, _4, _6) )}
| _1 = method_signature_short _2 = COLON _3 = specs _4 = source_pos_tag_option
    {                                                              ( mkDynamic(_1, _3, _4) )}
| _1 = method_signature_short _2 = STATIC _3 = COLON _4 = specs _5 = source_pos_tag_option
    {                                                                     ( mkStatic(_1, _4, _5) )}

exp_posts:
  _1 = L_BRACE _2 = identifier _3 = COLON _4 = formula _5 = R_BRACE _6 = exp_posts
    {                                                        ( ClassMap.add _2 _4 _6 )}
| 
    {                ( ClassMap.empty )}

modifier:
  _1 = ABSTRACT
    {                   (Abstract)}
| _1 = FINAL
    {                   (Final)}
| _1 = NATIVE
    {                   (Native)}
| _1 = PUBLIC
    {                   (Public)}
| _1 = PROTECTED
    {                   (Protected)}
| _1 = PRIVATE
    {                   (Private)}
| _1 = STATIC
    {                   (Jparsetree.Static)}
| _1 = SYNCHRONIZED
    {                   (Synchronized)}
| _1 = TRANSIENT
    {                   (Transient)}
| _1 = VOLATILE
    {                   (Volatile)}
| _1 = STRICTFP
    {                   (Strictfp)}
| _1 = ENUM
    {                   (Enum)}
| _1 = ANNOTATION
    {                   (Annotation)}

file_type:
  _1 = CLASS
    {            ( ClassFile )}
| _1 = INTERFACE
    {               ( InterfaceFile )}

extends_clause:
  _1 = EXTENDS _2 = class_name_list
    {                             ( _2 )}
| 
    {                 ( [] )}

implements_clause:
  _1 = IMPLEMENTS _2 = class_name_list
    {                                ( _2 )}
| 
    {                 ( [] )}

file_body:
  _1 = L_BRACE _2 = member_list_star _3 = R_BRACE
    {                                      (_2)}

class_name_list:
  _1 = class_name
    {                ( [_1] )}
| _1 = class_name _2 = COMMA _3 = class_name_list
    {                                      (_1::_3)}

modifier_list_star:
  
    {                 ( [] )}
| _1 = modifier _2 = modifier_list_star
    {                                  (_1::_2)}

member_list_star:
  
    {                 ( [] )}
| _1 = member _2 = member_list_star
    {                              (_1::_2)}

member:
  _1 = modifier_list_star _2 = jtype _3 = name _4 = SEMICOLON
    {                                             (Field(_1,_2,_3))}
| _1 = modifier_list_star _2 = jtype _3 = name _4 = L_PAREN _5 = parameter_list_question_mark _6 = R_PAREN _7 = throws_clause _8 = requires_clause _9 = old_clauses _10 = ensures_clause _11 = method_body
    {   (Method(_1,_2,_3,_5,_7,_8,_9,_10,_11))}

jtype:
  _1 = VOID
    {          (Void)}
| _1 = nonvoid_type
    {                  (Non_void(_1))}

parameter_list:
  _1 = parameter
    {               ( [_1] )}
| _1 = parameter _2 = COMMA _3 = parameter_list
    {                                    ( _1::_3 )}

parameter_list_args_opt:
  _1 = parameter_args_opt
    {                        ( [_1] )}
| _1 = parameter_args_opt _2 = COMMA _3 = parameter_list_args_opt
    {                                                      ( _1::_3 )}

parameter:
  _1 = nonvoid_type
    {                  (_1)}

parameter_args_opt:
  _1 = nonvoid_type
    {                  (_1,None)}
| _1 = nonvoid_type _2 = identifier
    {                             (_1,Some _2)}

throws_clause:
  _1 = THROWS _2 = class_name_list
    {                            ( Some _2 )}
| 
    {                 ( None )}

requires_clause:
  _1 = REQUIRES _2 = method_body
    {                          ( _2 )}
| 
    {                 ( None )}

old_clauses:
  _1 = old_clause _2 = old_clauses
    {                            ( _1::_2 )}
| 
    {                 ( [] )}

old_clause:
  _1 = OLD _2 = method_body
    {                     ( _2 )}

ensures_clause:
  _1 = ENSURES _2 = method_body
    {                         ( _2 )}
| 
    {                 ( None )}

base_type_no_name:
  _1 = BOOLEAN
    {             (Boolean)}
| _1 = BYTE
    {          (Byte)}
| _1 = CHAR
    {          (Char)}
| _1 = SHORT
    {           (Short)}
| _1 = INT
    {         (Int)}
| _1 = LONG
    {          (Long)}
| _1 = FLOAT
    {           (Float)}
| _1 = DOUBLE
    {            (Double)}
| _1 = NULL
    {          (Null_type)}

base_type:
  _1 = base_type_no_name
    {                       (_1)}
| _1 = class_name
    {                (Class_name _1)}

integer_constant:
  _1 = INTEGER_CONSTANT
    {                      ( _1 )}

integer_constant_long:
  _1 = INTEGER_CONSTANT_LONG
    {                           ( _1 )}

float_constant:
  _1 = FLOAT_CONSTANT
    {                    ( _1 )}

string_constant:
  _1 = STRING_CONSTANT
    {                     ( _1 )}

quoted_name:
  _1 = QUOTED_NAME
    {                 ( _1 )}

identifier:
  _1 = AS
    {        ( "as" )}
| _1 = IDENTIFIER
    {                ( _1 )}
| _1 = FALSE
    {            ( "False" )}
| _1 = TRUE
    {           ( "True" )}
| _1 = EMP
    {           ( "Emp")}

at_identifier:
  _1 = AT_IDENTIFIER
    {                   ( _1 )}

full_identifier:
  _1 = FULL_IDENTIFIER
    {                     ( _1 )}

nonvoid_type:
  _1 = base_type_no_name _2 = array_brackets_list_star
    {                                                 (Base(_1,_2))}
| _1 = quoted_name _2 = array_brackets_list_star
    {                                          (Quoted(_1,_2))}
| _1 = identifier _2 = array_brackets_list_star
    {                                         (Ident_NVT(_1,_2))}
| _1 = full_identifier _2 = array_brackets_list_star
    {                                              (Full_ident_NVT(_1,_2))}

array_brackets_list_star:
  
    {                 ( [] )}
| _1 = L_BRACKET _2 = R_BRACKET _3 = array_brackets_list_star
    {                                                  ( "[]"::_3 )}

method_body:
  _1 = SEMICOLON
    {               (None)}
| _1 = L_BRACE _2 = declaration_or_statement_list_star _3 = catch_clause_list_star _4 = R_BRACE
    {                                                                                (Some(_2,_3))}

source_pos_tag:
  _1 = SOURCE_POS_TAG _2 = COLON _3 = identifier _4 = COLON _5 = integer_constant _6 = identifier _7 = COLON _8 = integer_constant _9 = identifier _10 = COLON _11 = integer_constant _12 = identifier _13 = COLON _14 = integer_constant _15 = identifier _16 = COLON _17 = full_identifier _18 = SOURCE_POS_TAG_CLOSE
    {   ( {begin_line=_5; begin_column=_11; end_line=_8; end_column=_14} )}

source_pos_tag_option:
  
    {                 ( None )}
| _1 = source_pos_tag
    {                    ( Some(_1) )}

declaration_or_statement:
  _1 = declaration
    {                 ( DOS_dec(_1) )}
| _1 = statement _2 = source_pos_tag_option
    {                                     ( DOS_stm(_1, _2) )}

declaration_or_statement_list_star:
  
    {                 ( [] )}
| _1 = declaration_or_statement _2 = declaration_or_statement_list_star
    {                                                                  (_1::_2)}

declaration:
  _1 = jimple_type _2 = local_name_list _3 = SEMICOLON
    {                                           (Declaration(_1,_2))}

catch_clause_list_star:
  
    {                 ( [] )}
| _1 = catch_clause _2 = catch_clause_list_star
    {                                          (_1::_2)}

jimple_type:
  _1 = UNKNOWN
    {             (None)}
| _1 = nonvoid_type
    {                  (Some(Non_void(_1)))}
| _1 = NULL_TYPE
    {               (None)}

local_name:
  _1 = name
    {          (_1)}

local_name_list:
  _1 = local_name
    {                ( [_1] )}
| _1 = local_name _2 = COMMA _3 = local_name_list
    {                                      ( _1::_3 )}

case_stmt_list_plus:
  _1 = case_stmt
    {               ( [_1] )}
| _1 = case_stmt _2 = case_stmt_list_plus
    {                                   ( _1::_2 )}

statement:
  _1 = label_name _2 = COLON
    {                       (Label_stmt(_1))}
| _1 = BREAKPOINT _2 = SEMICOLON
    {                           (Breakpoint_stmt)}
| _1 = ENTERMONITOR _2 = immediate _3 = SEMICOLON
    {                                      (Entermonitor_stmt(_2))}
| _1 = EXITMONITOR _2 = immediate _3 = SEMICOLON
    {                                      (Exitmonitor_stmt(_2))}
| _1 = TABLESWITCH _2 = L_PAREN _3 = immediate _4 = R_PAREN _5 = L_BRACE _6 = case_stmt_list_plus _7 = R_BRACE _8 = SEMICOLON
    {                                                                                         (Tableswitch_stmt(_3,_6))}
| _1 = LOOKUPSWITCH _2 = L_PAREN _3 = immediate _4 = R_PAREN _5 = L_BRACE _6 = case_stmt_list_plus _7 = R_BRACE _8 = SEMICOLON
    {                                                                                          (Lookupswitch_stmt(_3,_6))}
| _1 = local_name _2 = COLON_EQUALS _3 = at_identifier _4 = SEMICOLON
    {                                                     (Identity_no_type_stmt(_1,_3))}
| _1 = local_name _2 = COLON_EQUALS _3 = at_identifier _4 = jtype _5 = SEMICOLON
    {                                                            (Identity_stmt(_1,_3,_4))}
| _1 = variable _2 = EQUALS _3 = expression _4 = SEMICOLON
    {                                           (Assign_stmt(_1,_3))}
| _1 = IF _2 = bool_expr _3 = goto_stmt
    {                                (If_stmt(_2,_3))}
| _1 = goto_stmt
    {               (Goto_stmt(_1))}
| _1 = NOP _2 = SEMICOLON
    {                       (Nop_stmt)}
| _1 = RET _2 = immediate_question_mark _3 = SEMICOLON
    {                                               (Ret_stmt(_2))}
| _1 = RETURN _2 = immediate_question_mark _3 = SEMICOLON
    {                                               (Return_stmt(_2))}
| _1 = THROW _2 = immediate _3 = SEMICOLON
    {                                   (Throw_stmt(_2))}
| _1 = invoke_expr _2 = SEMICOLON
    {                               (Invoke_stmt(_1))}
| _1 = L_BRACE _2 = lvariable_list _3 = R_BRACE _4 = COLON _5 = spec _6 = SEMICOLON
    {                                                        (Spec_stmt(_2,_5))}

immediate_question_mark:
  _1 = immediate
    {               (Some _1)}
| 
    {                 ( None )}

label_name:
  _1 = identifier
    {               (_1)}

case_stmt:
  _1 = case_label _2 = COLON _3 = goto_stmt
    {                               (Case_stmt(_1,_3))}

minus_question_mark:
  _1 = MINUS
    {           ( Negative )}
| 
    {                  ( Positive )}

case_label:
  _1 = CASE _2 = minus_question_mark _3 = integer_constant
    {                                                (Case_label(_2,_3))}
| _1 = DEFAULT
    {                 (Case_label_default)}

goto_stmt:
  _1 = GOTO _2 = label_name _3 = SEMICOLON
    {                               (_2)}

catch_clause:
  _1 = CATCH _2 = class_name _3 = FROM _4 = label_name _5 = TO _6 = label_name _7 = WITH _8 = label_name _9 = SEMICOLON
    {                                                                              (Catch_clause(_2,_4,_6,_8))}

expression:
  _1 = new_expr
    {                (_1)}
| _1 = L_PAREN _2 = nonvoid_type _3 = R_PAREN _4 = immediate
    {                                            (Cast_exp(_2,_4))}
| _1 = immediate _2 = INSTANCEOF _3 = nonvoid_type
    {                                        (Instanceof_exp(_1,_3))}
| _1 = invoke_expr
    {                     (Invoke_exp _1)}
| _1 = reference
    {               (Reference_exp _1)}
| _1 = binop_expr
    {                (_1)}
| _1 = unop_expr
    {               (_1)}
| _1 = immediate
    {               (Immediate_exp _1)}

new_expr:
  _1 = NEW _2 = base_type
    {                    (New_simple_exp(_2))}
| _1 = NEWARRAY _2 = L_PAREN _3 = nonvoid_type _4 = R_PAREN _5 = fixed_array_descriptor
    {                                                                    (New_array_exp(_3,_5))}
| _1 = NEWMULTIARRAY _2 = L_PAREN _3 = base_type _4 = R_PAREN _5 = array_descriptor_list_plus
    {                                                                          (New_multiarray_exp(_3,_5))}

array_descriptor_list_plus:
  _1 = array_descriptor
    {                      ( [_1] )}
| _1 = array_descriptor _2 = array_descriptor_list_plus
    {                                                 ( _1::_2 )}

array_descriptor:
  _1 = L_BRACKET _2 = immediate_question_mark _3 = R_BRACKET
    {                                              ( _2 )}

variable:
  _1 = reference
    {              (Var_ref(_1))}
| _1 = local_name
    {               (Var_name(_1))}

bool_expr:
  _1 = binop_expr
    {                   (_1)}
| _1 = unop_expr
    {                 (_1)}

arg_list_question_mark:
  _1 = arg_list
    {              ( _1 )}
| 
    {                 ( [] )}

invoke_expr:
  _1 = nonstatic_invoke _2 = local_name _3 = DOT _4 = method_signature _5 = L_PAREN _6 = arg_list_question_mark _7 = R_PAREN
    {       (Invoke_nostatic_exp(_1,_2,_4,_6))}
| _1 = STATICINVOKE _2 = method_signature _3 = L_PAREN _4 = arg_list_question_mark _5 = R_PAREN
    {       (Invoke_static_exp(_2,_4))}

binop_expr:
  _1 = immediate _2 = binop _3 = immediate
    {                              (Binop_exp(_2,_1,_3))}

unop_expr:
  _1 = unop _2 = immediate
    {                    (Unop_exp(_1,_2))}

nonstatic_invoke:
  _1 = SPECIALINVOKE
    {                        (Special_invoke)}
| _1 = VIRTUALINVOKE
    {                        (Virtual_invoke)}
| _1 = INTERFACEINVOKE
    {                        (Interface_invoke)}

parameter_list_question_mark:
  _1 = parameter_list
    {                    ( _1 )}
| 
    {                 ( [] )}

parameter_args_opt_list_question_mark:
  _1 = parameter_list_args_opt
    {                             ( _1 )}
| 
    {                 ( [] )}

method_signature:
  _1 = CMPLT _2 = class_name _3 = COLON _4 = jtype _5 = name _6 = L_PAREN _7 = parameter_list_question_mark _8 = R_PAREN _9 = CMPGT
    {       (Method_signature(_2,_4,_5,_7))}

method_signature_short:
  _1 = modifier_list_star _2 = jtype _3 = name _4 = L_PAREN _5 = parameter_args_opt_list_question_mark _6 = R_PAREN
    {       ( _1,_2,_3,_5 )}

reference:
  _1 = array_ref
    {               (_1)}
| _1 = field_ref
    {               (_1)}

array_ref:
  _1 = identifier _2 = fixed_array_descriptor
    {                                    (Array_ref(_1,_2))}

field_ref:
  _1 = local_name _2 = DOT _3 = field_signature
    {                                       ( Field_local_ref(_1,_3))}
| _1 = field_signature
    {                    (Field_sig_ref(_1))}

field_signature:
  _1 = CMPLT _2 = class_name _3 = COLON _4 = jtype _5 = name _6 = CMPGT
    {                                             (Field_signature(_2,_4,_5))}

fixed_array_descriptor:
  _1 = L_BRACKET _2 = immediate _3 = R_BRACKET
    {                                 (_2)}

arg_list:
  _1 = immediate
    {               ( [_1] )}
| _1 = immediate _2 = COMMA _3 = arg_list
    {                              ( _1::_3 )}

immediate:
  _1 = local_name
    {                   ( Immediate_local_name(_1) )}
| _1 = constant
    {                ( Immediate_constant(_1) )}

constant:
  _1 = minus_question_mark _2 = integer_constant
    {                                          (Int_const(_1,_2))}
| _1 = minus_question_mark _2 = integer_constant_long
    {                                               (Int_const_long(_1,_2))}
| _1 = minus_question_mark _2 = float_constant
    {                                          (Float_const(_1,_2))}
| _1 = string_constant
    {                         (String_const(_1))}
| _1 = CLASS _2 = string_constant
    {                           (Clzz_const(_2))}
| _1 = NULL
    {          (Null_const)}

binop_no_mult:
  _1 = AND
    {         (And)}
| _1 = OR
    {         (Jparsetree.Or)}
| _1 = XOR
    {         (Xor)}
| _1 = MOD
    {         (Mod)}
| _1 = CMP
    {         (Cmp)}
| _1 = CMPG
    {          (Cmpg)}
| _1 = CMPL
    {          (Cmpl)}
| _1 = CMPEQ
    {           (Cmpeq)}
| _1 = CMPNE
    {           (Cmpne)}
| _1 = CMPGT
    {           (Cmpgt)}
| _1 = CMPGE
    {           (Cmpge)}
| _1 = CMPLT
    {           (Cmplt)}
| _1 = CMPLE
    {           (Cmple)}
| _1 = SHL
    {         (Shl)}
| _1 = SHR
    {         (Shr)}
| _1 = USHR
    {          (Ushr)}
| _1 = PLUS
    {          (Plus)}
| _1 = MINUS
    {           (Minus)}
| _1 = DIV
    {         (Div)}

binop_val_no_multor:
  _1 = AND
    {         (And)}
| _1 = XOR
    {         (Xor)}
| _1 = MOD
    {         (Mod)}
| _1 = SHL
    {         (Shl)}
| _1 = SHR
    {         (Shr)}
| _1 = USHR
    {          (Ushr)}
| _1 = PLUS
    {          (Plus)}
| _1 = MINUS
    {           (Minus)}
| _1 = DIV
    {         (Div)}

binop_cmp:
  _1 = CMP
    {         (Cmp)}
| _1 = CMPG
    {          (Cmpg)}
| _1 = CMPL
    {          (Cmpl)}
| _1 = CMPEQ
    {           (Cmpeq)}
| _1 = CMPNE
    {           (Cmpne)}
| _1 = CMPGT
    {           (Cmpgt)}
| _1 = CMPGE
    {           (Cmpge)}
| _1 = CMPLT
    {           (Cmplt)}
| _1 = CMPLE
    {           (Cmple)}

binop:
  _1 = binop_no_mult
    {                    ( _1 )}
| _1 = MULT
    {           ( Mult )}

unop:
  _1 = LENGTHOF
    {                (Lengthof)}
| _1 = NEG
    {         (Neg)}

class_name:
  _1 = quoted_name
    {                     (Quoted_clname _1)}
| _1 = identifier
    {                (Identifier_clname _1)}
| _1 = full_identifier
    {                     (Full_identifier_clname _1)}

name:
  _1 = quoted_name
    {                 (Quoted_name _1)}
| _1 = identifier
    {                (Identifier_name _1)}

lvariable:
  _1 = at_identifier
    {                   ( newPVar(_1) )}
| _1 = identifier
    {                ( newVar(_1) )}
| _1 = QUESTIONMARK _2 = identifier
    {                             ( newAnyVar(_2) )}

lvariable_list_ne:
  _1 = lvariable
    {                   ( [_1] )}
| _1 = lvariable _2 = COMMA _3 = lvariable_list_ne
    {                                         ( _1 :: _3 )}

lvariable_list:
  
    {      ([])}
| _1 = lvariable_list_ne
    {                       ( _1 )}

lvariable_npv:
  _1 = at_identifier
    {                   ( newPVar(_1) )}
| _1 = identifier
    {                ( newVar(_1) )}

lvariable_npv_list_ne:
  _1 = lvariable_npv
    {                       ( [_1] )}
| _1 = lvariable_npv _2 = COMMA _3 = lvariable_npv_list_ne
    {                                                 ( _1 :: _3 )}

fldlist:
  _1 = identifier _2 = EQUALS _3 = jargument
    {                                 ( [(_1,_3)] )}
| 
    {               ( [] )}
| _1 = identifier _2 = EQUALS _3 = jargument _4 = SEMICOLON _5 = fldlist
    {                                                    ( (_1,_3) :: _5 )}

fldlist_npv:
  _1 = identifier _2 = EQUALS _3 = jargument_npv
    {                                     ( [(_1,_3)] )}
| 
    {               ( [] )}
| _1 = identifier _2 = EQUALS _3 = jargument_npv _4 = SEMICOLON _5 = fldlist_npv
    {                                                            ( (_1,_3) :: _5 )}

paramlist_question_mark:
  _1 = COMMA _2 = L_BRACE _3 = paramlist _4 = R_BRACE
    {                                     ( Some _3 )}
| _1 = COMMA _2 = paramlist
    {                     ( Some _2 )}
| 
    {                 ( None )}

paramlist:
  _1 = identifier _2 = EQUALS _3 = lvariable
    {                                 ( [(_1,Arg_var _3)] )}
| 
    {               ( [] )}
| _1 = identifier _2 = EQUALS _3 = lvariable _4 = SEMICOLON _5 = fldlist
    {                                                    ( (_1,Arg_var _3) :: _5 )}

jargument_npv:
  _1 = RETURN
    {            ( Arg_var (newPVar(Spec.name_ret_v1)) )}
| _1 = lvariable_npv
    {                   (Arg_var (_1))}
| _1 = identifier _2 = L_PAREN _3 = jargument_npv_list _4 = R_PAREN
    {                                                   (Arg_op(_1,_3) )}
| _1 = INTEGER_CONSTANT
    {                      (Arg_string(string_of_int _1))}
| _1 = MINUS _2 = INTEGER_CONSTANT
    {                            (Arg_string("-" ^(string_of_int _2)))}
| _1 = STRING_CONSTANT
    {                     (Arg_string(_1))}
| _1 = field_signature
    {                     (Arg_string(field_signature2str _1))}
| _1 = L_BRACE _2 = fldlist_npv _3 = R_BRACE
    {                                 (mkArgRecord _2)}
| _1 = L_PAREN _2 = jargument_npv _3 = binop_val_no_multor _4 = jargument_npv _5 = R_PAREN
    {                                                                     ( Arg_op(Support_syntax.bop_to_prover_arg _3, [_2;_4]) )}

jargument_npv_list_ne:
  _1 = jargument_npv
    {                   (_1::[])}
| _1 = jargument_npv _2 = COMMA _3 = jargument_npv_list_ne
    {                                               ( _1::_3 )}

jargument_npv_list:
  
    {                ([])}
| _1 = jargument_npv_list_ne
    {                           (_1)}

jargument:
  _1 = RETURN
    {            ( Arg_var (newPVar(Spec.name_ret_v1)) )}
| _1 = lvariable
    {               (Arg_var (_1))}
| _1 = identifier _2 = L_PAREN _3 = jargument_list _4 = R_PAREN
    {                                               (Arg_op(_1,_3) )}
| _1 = INTEGER_CONSTANT
    {                      (Arg_string(string_of_int _1))}
| _1 = MINUS _2 = INTEGER_CONSTANT
    {                            (Arg_string("-" ^(string_of_int _2)))}
| _1 = STRING_CONSTANT
    {                     (Arg_string(_1))}
| _1 = field_signature
    {                     (Arg_string(field_signature2str _1))}
| _1 = L_BRACE _2 = fldlist _3 = R_BRACE
    {                             (mkArgRecord _2)}
| _1 = L_PAREN _2 = jargument _3 = binop_val_no_multor _4 = jargument _5 = R_PAREN
    {                                                             ( Arg_op(Support_syntax.bop_to_prover_arg _3, [_2;_4]) )}

jargument_list_ne:
  _1 = jargument
    {               (_1::[])}
| _1 = jargument _2 = COMMA _3 = jargument_list_ne
    {                                       ( _1::_3 )}

jargument_list:
  
    {                ([])}
| _1 = jargument_list_ne
    {                       (_1)}

formula:
  
    {                ( [] )}
| _1 = EMP
    {          ( [] )}
| _1 = FALSE
    {           ( mkFalse)}
| _1 = lvariable _2 = DOT _3 = jargument _4 = MAPSTO _5 = jargument
    {                                               ( [P_SPred("field", [Arg_var _1; _3; _5] )] )}
| _1 = BANG _2 = identifier _3 = L_PAREN _4 = jargument_list _5 = R_PAREN
    {                                                    ( [P_PPred(_2, _4)] )}
| _1 = identifier _2 = L_PAREN _3 = jargument_list _4 = R_PAREN
    {       (if List.length _3 =1 then [P_SPred(_1,_3 @ [mkArgRecord []])] else [P_SPred(_1,_3)] )}
| _1 = full_identifier _2 = L_PAREN _3 = jargument_list _4 = R_PAREN
    {                                                    (if List.length _3 =1 then [P_SPred(_1,_3 @ [mkArgRecord []])] else [P_SPred(_1,_3)] )}
| _1 = formula _2 = MULT _3 = formula
    {                          ( pconjunction _1 _3 )}
| _1 = formula _2 = OR _3 = formula
    {                        ( if Config.parse_debug() then parse_warning "deprecated use of |"  ; pconjunction (purify _1) _3 )}
| _1 = formula _2 = OROR _3 = formula
    {                          ( mkOr (_1,_3) )}
| _1 = lvariable _2 = COLON _3 = identifier
    {                                ( [P_PPred("type", [Arg_var(_1);Arg_string(_3)])] )}
| _1 = jargument _2 = binop_cmp _3 = jargument
    {                                   ( Support_syntax.bop_to_prover_pred _2 _1 _3 )}
| _1 = jargument _2 = EQUALS _3 = jargument
    {                                ( Support_syntax.bop_to_prover_pred (Cmpeq) _1 _3 )}
| _1 = L_PAREN _2 = formula _3 = R_PAREN
    {                             ( _2 )}

formula_npv:
  
    {               ( [] )}
| _1 = EMP
    {          ( [])}
| _1 = FALSE
    {           ( mkFalse)}
| _1 = lvariable_npv _2 = DOT _3 = jargument_npv _4 = MAPSTO _5 = jargument_npv
    {                                                           ( [P_SPred("field", [Arg_var _1; _3; _5] )] )}
| _1 = BANG _2 = identifier _3 = L_PAREN _4 = jargument_npv_list _5 = R_PAREN
    {                                                        ( [P_PPred(_2, _4)] )}
| _1 = identifier _2 = L_PAREN _3 = jargument_npv_list _4 = R_PAREN
    {       (if List.length _3 =1 then [P_SPred(_1,_3 @ [mkArgRecord []])] else [P_SPred(_1,_3)] )}
| _1 = full_identifier _2 = L_PAREN _3 = jargument_npv_list _4 = R_PAREN
    {                                                        (if List.length _3 =1 then [P_SPred(_1,_3 @ [mkArgRecord []])] else [P_SPred(_1,_3)] )}
| _1 = formula_npv _2 = MULT _3 = formula_npv
    {                                  ( pconjunction _1 _3 )}
| _1 = formula_npv _2 = OR _3 = formula_npv
    {                                ( if Config.parse_debug() then parse_warning "deprecated use of |"  ; pconjunction (purify _1) _3 )}
| _1 = formula_npv _2 = OROR _3 = formula_npv
    {                                  ( mkOr (_1,_3) )}
| _1 = lvariable_npv _2 = COLON _3 = identifier
    {                                    ( [P_PPred("type", [Arg_var _1;Arg_string(_3)])] )}
| _1 = jargument_npv _2 = binop_cmp _3 = jargument_npv
    {                                           ( Support_syntax.bop_to_prover_pred _2 _1 _3 )}
| _1 = jargument_npv _2 = EQUALS _3 = jargument_npv
    {                                        ( Support_syntax.bop_to_prover_pred (Cmpeq) _1 _3 )}
| _1 = L_PAREN _2 = formula_npv _3 = R_PAREN
    {                                 ( _2 )}

spatial_at:
  _1 = jargument _2 = DOT _3 = field_signature _4 = MAPSTO _5 = jargument
    {                                                     ( P_SPred("field", [_1; Arg_string(field_signature2str _3); _5] ) )}
| _1 = identifier _2 = L_PAREN _3 = jargument_list _4 = R_PAREN
    {       (if List.length _3 =1 then P_SPred(_1,_3 @ [mkArgRecord []]) else P_SPred(_1,_3) )}
| _1 = full_identifier _2 = L_PAREN _3 = jargument_list _4 = R_PAREN
    {                                                    (if List.length _3 =1 then P_SPred(_1,_3 @ [mkArgRecord []]) else P_SPred(_1,_3) )}

spatial_list_ne:
  _1 = spatial_at _2 = MULT _3 = spatial_list_ne
    {                                      ( _1 :: _3 )}
| _1 = spatial_at
    {                   ( [ _1 ] )}

spatial_list:
  _1 = spatial_list_ne
    {                     ( _1 )}
| 
    {        ( [] )}

sequent:
  _1 = spatial_list _2 = OR _3 = formula _4 = VDASH _5 = formula
    {                                           ( (_1,_3,_5,mkEmpty) )}
| _1 = spatial_list _2 = OR _3 = formula _4 = VDASH _5 = formula _6 = DASHV _7 = formula
    {                                                         ( (_1,_3,_5,_7) )}
| _1 = spatial_list _2 = OROR _3 = formula _4 = VDASH _5 = formula
    {                                             (  if Config.symb_debug() then parse_warning "deprecated use of |" ; (_1,_3,_5,mkEmpty) )}

sequent_list:
  
    {                  ( [] )}
| _1 = TRUE
    {          ( [] )}
| _1 = sequent
    {             ([_1])}
| _1 = sequent _2 = SEMICOLON _3 = sequent_list
    {                                    ( _1::_3 )}

sequent_list_or_list:
  _1 = sequent_list
    {                   ([_1])}
| _1 = sequent_list _2 = ORTEXT _3 = sequent_list_or_list
    {                                               ( _1::_3 )}

identifier_op:
  
    {                 ("")}
| _1 = identifier
    {                 (_1)}

without:
  _1 = WITHOUT _2 = formula
    {                     ( (_2, mkEmpty) )}
| _1 = WITHOUT _2 = formula _3 = VDASH _4 = formula
    {                                   ( (_2,_4) )}
| 
    {                 ( (mkEmpty,mkEmpty) )}

without_simp:
  _1 = WITHOUT _2 = formula
    {                     ( _2 )}
| 
    {                 ( [] )}

varterm:
  _1 = lvariable_list
    {                    ( Var(vs_from_list _1) )}

clause:
  _1 = varterm _2 = NOTINCONTEXT
    {                          ( NotInContext(_1) )}
| _1 = varterm _2 = NOTIN _3 = jargument
    {                             ( NotInTerm(_1,_3) )}
| _1 = formula _2 = PUREGUARD
    {                      ( PureGuard(_1) )}

clause_list:
  _1 = clause
    {             ( [_1] )}
| _1 = clause _2 = SEMICOLON _3 = clause_list
    {                                  (_1 :: _3)}

where:
  _1 = WHERE _2 = clause_list
    {                       ( _2 )}
| 
    {                 ( [] )}

ifclause:
  
    {                            ( [] )}
| _1 = IF _2 = formula
    {                (_2)}

equiv_rule:
  _1 = EQUIV _2 = identifier_op _3 = COLON _4 = formula _5 = WAND _6 = formula _7 = BIMP _8 = formula _9 = without_simp
    {                                                                               ( EquivRule(_2,_4,_6,_8,_9) )}
| _1 = EQUIV _2 = identifier_op _3 = COLON _4 = formula _5 = IMP _6 = formula _7 = BIMP _8 = formula _9 = without_simp
    {                                                                              ( EquivRule(_2,_4,_6,_8,_9) )}
| _1 = EQUIV _2 = identifier_op _3 = COLON _4 = formula _5 = IMP _6 = formula _7 = without_simp
    {                                                                 ( EquivRule(_2,_4,_6,mkEmpty,_7) )}
| _1 = EQUIV _2 = identifier_op _3 = COLON _4 = formula _5 = BIMP _6 = formula _7 = without_simp
    {                                                                  ( EquivRule(_2,mkEmpty,_4,_6,_7) )}

rule:
  _1 = CONSTRUCTOR _2 = identifier
    {                              ( NormalEntry( ConsDecl(_2) ) )}
| _1 = IMPORT _2 = STRING_CONSTANT _3 = SEMICOLON
    {                                        ( ImportEntry(_2) )}
| _1 = RULE _2 = identifier_op _3 = COLON _4 = sequent _5 = without _6 = where _7 = IF _8 = sequent_list_or_list
    {                                                                             ( NormalEntry(SeqRule(_4,_8,_2,_5,_6)) )}
| _1 = REWRITERULE _2 = identifier_op _3 = COLON _4 = identifier _5 = L_PAREN _6 = jargument_list _7 = R_PAREN _8 = EQUALS _9 = jargument _10 = ifclause _11 = without_simp _12 = where
    {  ( NormalEntry(RewriteRule({function_name=_4;
				     arguments=_6;
				     result=_9;
				     guard={without_form=_11;rewrite_where=_12;if_form=_10};
				     rewrite_name=_2;
				     saturate=false})) )}
| _1 = REWRITERULE _2 = identifier_op _3 = MULT _4 = COLON _5 = identifier _6 = L_PAREN _7 = jargument_list _8 = R_PAREN _9 = EQUALS _10 = jargument _11 = ifclause _12 = without_simp _13 = where
    {  ( NormalEntry(RewriteRule({function_name=_5;
				     arguments=_7;
				     result=_10;
				     guard={without_form=_12;
					     rewrite_where=_13;
					     if_form=_11};
				     rewrite_name=_2;
				     saturate=true})) )}
| _1 = ABSRULE _2 = identifier_op _3 = COLON _4 = formula _5 = LEADSTO _6 = formula _7 = where
    {                                                                 ( let seq=(mkEmpty,_4,mkEmpty,mkEmpty) in
							       let wo=(mkEmpty,mkEmpty) in
							       let seq2=(mkEmpty,_6,mkEmpty,mkEmpty) in
							       let seq_list=[[seq2]] in
							       NormalEntry(SeqRule(seq,seq_list,_2,wo,_7)) )}
| _1 = equiv_rule
    {                ( NormalEntry(_1) )}

rule_file:
  _1 = EOF
    {          ( [] )}
| _1 = rule _2 = rule_file
    {                     (_1 :: _2)}

boolean:
  _1 = TRUE
    {          ( true )}
| _1 = FALSE
    {           ( false )}

question:
  _1 = IMPLICATION _2 = COLON _3 = formula_npv _4 = VDASH _5 = formula_npv
    {                                                     (Implication(_3,_5))}
| _1 = INCONSISTENCY _2 = COLON _3 = formula_npv
    {                                     (Inconsistency(_3))}
| _1 = FRAME _2 = COLON _3 = formula_npv _4 = VDASH _5 = formula_npv
    {                                               (Frame(_3,_5))}
| _1 = ABS _2 = COLON _3 = formula_npv
    {                           (Abs(_3))}
| _1 = ABDUCTION _2 = COLON _3 = formula_npv _4 = VDASH _5 = formula_npv
    {                                                   (Abduction(_3,_5))}

test:
  _1 = IMPLICATION _2 = COLON _3 = formula_npv _4 = VDASH _5 = formula_npv _6 = QUESTIONMARK _7 = boolean
    {                                                                          (TImplication(_3,_5,_7))}
| _1 = INCONSISTENCY _2 = COLON _3 = formula_npv _4 = QUESTIONMARK _5 = boolean
    {                                                          (TInconsistency(_3,_5))}
| _1 = FRAME _2 = COLON _3 = formula_npv _4 = VDASH _5 = formula_npv _6 = QUESTIONMARK _7 = formula_npv
    {                                                                        (TFrame(_3,_5,_7))}
| _1 = ABS _2 = COLON _3 = formula_npv _4 = QUESTIONMARK _5 = formula_npv
    {                                                    (TAbs(_3,_5))}

question_file:
  _1 = EOF
    {          ( [] )}
| _1 = question _2 = question_file
    {                             (_1 :: _2)}

test_file:
  _1 = EOF
    {          ( [] )}
| _1 = test _2 = test_file
    {                     (_1 :: _2)}

symb_question_file:
  _1 = EOF
    {          ( [] )}
| _1 = symb_question _2 = symb_question_file
    {                                       (_1 :: _2)}

symb_test_file:
  _1 = EOF
    {          ( [] )}
| _1 = symb_test _2 = symb_test_file
    {                               (_1 :: _2)}

symb_question:
  _1 = SPECIFICATION _2 = identifier _3 = COLON _4 = spec _5 = QUESTIONMARK _6 = core_stmt_list
    {                                                                      (Specification(_2,_4,_6))}

symb_test:
  _1 = SPECTEST _2 = identifier _3 = COLON _4 = spec _5 = QUESTIONMARK _6 = boolean _7 = core_stmt_list
    {                                                                        (SpecTest(_2,_4,_7,_6))}

core_stmt_list:
  _1 = core_stmt _2 = SEMICOLON _3 = core_stmt_list
    {                                          ( _1 :: _3 )}
| 
    {                   ( [] )}

core_stmt:
  _1 = END
    {            ( End )}
| _1 = NOP
    {           ( Nop_stmt_core )}
| _1 = ASSIGN _2 = core_assn_args _3 = spec _4 = L_PAREN _5 = jargument_npv_list _6 = R_PAREN
    {         ( Assignment_core(_2, _3, _5) )}
| _1 = GOTO _2 = label_list
    {                      ( Goto_stmt_core _2 )}
| _1 = LABEL _2 = IDENTIFIER
    {                        ( Label_stmt_core _2 )}

core_assn_args:
  _1 = lvariable_npv_list_ne _2 = COLON_EQUALS
    {                                        ( _1 )}
| _1 = COLON_EQUALS
    {                  ( [] )}
| 
    {                   ( [] )}

label_list:
  _1 = IDENTIFIER
    {                   ( [_1] )}
| _1 = IDENTIFIER _2 = COMMA _3 = label_list
    {                                    ( _1 :: _3 )}

%%
 (* trailer *)

