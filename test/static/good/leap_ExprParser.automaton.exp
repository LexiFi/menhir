State 0:
## Known stack suffix:
##
## LR(1) items:
axiom' -> . axiom [ # ]
## Transitions:
-- On VARS shift to state 1
-- On param shift to state 2
-- On axiom shift to state 567
## Reductions:

State 1:
## Known stack suffix:
## VARS
## LR(1) items:
param -> VARS . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production param -> VARS

State 2:
## Known stack suffix:
## param
## LR(1) items:
axiom -> param . COLON inv_var_declarations AXIOM formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On COLON shift to state 3
## Reductions:

State 3:
## Known stack suffix:
## param COLON
## LR(1) items:
axiom -> param COLON . inv_var_declarations AXIOM formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On IDENT shift to state 4
-- On inv_var_declarations shift to state 6
-- On inv_var_decl_list shift to state 564
-- On inv_var_decl shift to state 565
## Reductions:
-- On AXIOM
--   reduce production inv_var_declarations ->

State 4:
## Known stack suffix:
## IDENT
## LR(1) items:
inv_var_decl -> IDENT . IDENT [ SUPPORT INVARIANT IDENT FORMULA AXIOM ]
## Transitions:
-- On IDENT shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## IDENT IDENT
## LR(1) items:
inv_var_decl -> IDENT IDENT . [ SUPPORT INVARIANT IDENT FORMULA AXIOM ]
## Transitions:
## Reductions:
-- On SUPPORT INVARIANT IDENT FORMULA AXIOM
--   reduce production inv_var_decl -> IDENT IDENT

State 6:
## Known stack suffix:
## param COLON inv_var_declarations
## LR(1) items:
axiom -> param COLON inv_var_declarations . AXIOM formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On AXIOM shift to state 7
## Reductions:

State 7:
## Known stack suffix:
## param COLON inv_var_declarations AXIOM
## LR(1) items:
axiom -> param COLON inv_var_declarations AXIOM . formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On OPEN_BRACKET shift to state 8
-- On formula_tag shift to state 11
## Reductions:
-- On COLON
--   reduce production formula_tag ->

State 8:
## Known stack suffix:
## OPEN_BRACKET
## LR(1) items:
formula_tag -> OPEN_BRACKET . IDENT CLOSE_BRACKET [ COLON ]
## Transitions:
-- On IDENT shift to state 9
## Reductions:

State 9:
## Known stack suffix:
## OPEN_BRACKET IDENT
## LR(1) items:
formula_tag -> OPEN_BRACKET IDENT . CLOSE_BRACKET [ COLON ]
## Transitions:
-- On CLOSE_BRACKET shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## OPEN_BRACKET IDENT CLOSE_BRACKET
## LR(1) items:
formula_tag -> OPEN_BRACKET IDENT CLOSE_BRACKET . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production formula_tag -> OPEN_BRACKET IDENT CLOSE_BRACKET

State 11:
## Known stack suffix:
## param COLON inv_var_declarations AXIOM formula_tag
## LR(1) items:
axiom -> param COLON inv_var_declarations AXIOM formula_tag . COLON formula_decl_list [ # ]
## Transitions:
-- On COLON shift to state 12
## Reductions:

State 12:
## Known stack suffix:
## param COLON inv_var_declarations AXIOM formula_tag COLON
## LR(1) items:
axiom -> param COLON inv_var_declarations AXIOM formula_tag COLON . formula_decl_list [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 411
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula_decl_list shift to state 560
-- On formula_decl shift to state 561
-- On formula shift to state 563
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 13:
## Known stack suffix:
## UPDATE
## LR(1) items:
mem -> UPDATE . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 14
## Reductions:

State 14:
## Known stack suffix:
## UPDATE OPEN_PAREN
## LR(1) items:
mem -> UPDATE OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 367
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 15:
## Known stack suffix:
## UNLOCK
## LR(1) items:
lock -> UNLOCK . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 16
## Reductions:

State 16:
## Known stack suffix:
## UNLOCK OPEN_PAREN
## LR(1) items:
lock -> UNLOCK OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 365
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 17:
## Known stack suffix:
## UNIONTH
## LR(1) items:
setth -> UNIONTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## UNIONTH OPEN_PAREN
## LR(1) items:
setth -> UNIONTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 361
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 19:
## Known stack suffix:
## UNIONINT
## LR(1) items:
setint -> UNIONINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 20
## Reductions:

State 20:
## Known stack suffix:
## UNIONINT OPEN_PAREN
## LR(1) items:
setint -> UNIONINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 357
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 21:
## Known stack suffix:
## UNIONELEM
## LR(1) items:
setelem -> UNIONELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 22
## Reductions:

State 22:
## Known stack suffix:
## UNIONELEM OPEN_PAREN
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 353
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 23:
## Known stack suffix:
## UNION
## LR(1) items:
set -> UNION . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 24
## Reductions:

State 24:
## Known stack suffix:
## UNION OPEN_PAREN
## LR(1) items:
set -> UNION OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 349
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 25:
## Known stack suffix:
## TIDOF
## LR(1) items:
tid -> TIDOF . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 26
## Reductions:

State 26:
## Known stack suffix:
## TIDOF OPEN_PAREN
## LR(1) items:
tid -> TIDOF OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 347
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 27:
## Known stack suffix:
## SINGLETH
## LR(1) items:
setth -> SINGLETH . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 28
## Reductions:

State 28:
## Known stack suffix:
## SINGLETH OPEN_PAREN
## LR(1) items:
setth -> SINGLETH OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 345
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 29:
## Known stack suffix:
## SINGLEINT
## LR(1) items:
setint -> SINGLEINT . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 30
## Reductions:

State 30:
## Known stack suffix:
## SINGLEINT OPEN_PAREN
## LR(1) items:
setint -> SINGLEINT OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 343
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 31:
## Known stack suffix:
## SINGLEELEM
## LR(1) items:
setelem -> SINGLEELEM . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 32
## Reductions:

State 32:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN
## LR(1) items:
setelem -> SINGLEELEM OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 341
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 33:
## Known stack suffix:
## SHARP
## LR(1) items:
tid -> SHARP . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production tid -> SHARP
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production tid -> SHARP
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 34:
## Known stack suffix:
## SETPAIRUNION
## LR(1) items:
setpair -> SETPAIRUNION . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 35
## Reductions:

State 35:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 337
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 36:
## Known stack suffix:
## SETPAIRSINGLE
## LR(1) items:
setpair -> SETPAIRSINGLE . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 37
## Reductions:

State 37:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRSINGLE OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 335
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 38:
## Known stack suffix:
## SETPAIRMIN
## LR(1) items:
pair -> SETPAIRMIN . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN
## LR(1) items:
pair -> SETPAIRMIN OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 333
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 40:
## Known stack suffix:
## SETPAIRMAX
## LR(1) items:
pair -> SETPAIRMAX . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN
## LR(1) items:
pair -> SETPAIRMAX OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 331
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 42:
## Known stack suffix:
## SETPAIRLOWER
## LR(1) items:
setpair -> SETPAIRLOWER . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 43
## Reductions:

State 43:
## Known stack suffix:
## SETPAIRLOWER OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRLOWER OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 327
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 44:
## Known stack suffix:
## SETPAIRINTR
## LR(1) items:
setpair -> SETPAIRINTR . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 323
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 46:
## Known stack suffix:
## SETPAIREMPTY
## LR(1) items:
setpair -> SETPAIREMPTY . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIREMPTY
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIREMPTY
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 47:
## Known stack suffix:
## SETPAIRDIFF
## LR(1) items:
setpair -> SETPAIRDIFF . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 48
## Reductions:

State 48:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 319
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 49:
## Known stack suffix:
## SETLOWER
## LR(1) items:
setint -> SETLOWER . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## SETLOWER OPEN_PAREN
## LR(1) items:
setint -> SETLOWER OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 315
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 51:
## Known stack suffix:
## SETINTMIN
## LR(1) items:
integer -> SETINTMIN . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 52
## Reductions:

State 52:
## Known stack suffix:
## SETINTMIN OPEN_PAREN
## LR(1) items:
integer -> SETINTMIN OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 313
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 53:
## Known stack suffix:
## SETINTMAX
## LR(1) items:
integer -> SETINTMAX . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 54
## Reductions:

State 54:
## Known stack suffix:
## SETINTMAX OPEN_PAREN
## LR(1) items:
integer -> SETINTMAX OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 311
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 55:
## Known stack suffix:
## SETDIFFTH
## LR(1) items:
setth -> SETDIFFTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 56
## Reductions:

State 56:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 307
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 57:
## Known stack suffix:
## SETDIFFINT
## LR(1) items:
setint -> SETDIFFINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 58
## Reductions:

State 58:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 303
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 59:
## Known stack suffix:
## SETDIFFELEM
## LR(1) items:
setelem -> SETDIFFELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 60
## Reductions:

State 60:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 299
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 61:
## Known stack suffix:
## SETDIFF
## LR(1) items:
set -> SETDIFF . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## SETDIFF OPEN_PAREN
## LR(1) items:
set -> SETDIFF OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 295
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 63:
## Known stack suffix:
## SET2ELEM
## LR(1) items:
setelem -> SET2ELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 64
## Reductions:

State 64:
## Known stack suffix:
## SET2ELEM OPEN_PAREN
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 291
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 65:
## Known stack suffix:
## PATH2SET
## LR(1) items:
set -> PATH2SET . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 66
## Reductions:

State 66:
## Known stack suffix:
## PATH2SET OPEN_PAREN
## LR(1) items:
set -> PATH2SET OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 289
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 67:
## Known stack suffix:
## OPEN_SET
## LR(1) items:
set -> OPEN_SET . term CLOSE_SET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 287
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 68:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
pair -> OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
term -> OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 282
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 69:
## Known stack suffix:
## OPEN_BRACKET
## LR(1) items:
path -> OPEN_BRACKET . term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 281
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 70:
## Known stack suffix:
## NUMBER
## LR(1) items:
integer -> NUMBER . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> NUMBER
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> NUMBER
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 71:
## Known stack suffix:
## NULL
## LR(1) items:
addr -> NULL . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> NULL
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> NULL
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 72:
## Known stack suffix:
## MKCELL
## LR(1) items:
cell -> MKCELL . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL . OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 73
## Reductions:

State 73:
## Known stack suffix:
## MKCELL OPEN_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN . term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 258
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 74:
## Known stack suffix:
## MKBUCKET
## LR(1) items:
bucket -> MKBUCKET . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## MKBUCKET OPEN_PAREN
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 250
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 76:
## Known stack suffix:
## MEMORY_READ
## LR(1) items:
cell -> MEMORY_READ . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 77
## Reductions:

State 77:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 246
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 78:
## Known stack suffix:
## MATH_MINUS
## LR(1) items:
integer -> MATH_MINUS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 245
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 79:
## Known stack suffix:
## MARK_T
## LR(1) items:
mark -> MARK_T . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production mark -> MARK_T
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production mark -> MARK_T
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 80:
## Known stack suffix:
## MARK_F
## LR(1) items:
mark -> MARK_F . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production mark -> MARK_F
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production mark -> MARK_F
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 81:
## Known stack suffix:
## LOWEST_ELEM
## LR(1) items:
elem -> LOWEST_ELEM . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production elem -> LOWEST_ELEM
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production elem -> LOWEST_ELEM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 82:
## Known stack suffix:
## LOCKSET
## LR(1) items:
setth -> LOCKSET . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 83
## Reductions:

State 83:
## Known stack suffix:
## LOCKSET OPEN_PAREN
## LR(1) items:
setth -> LOCKSET OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 241
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 84:
## Known stack suffix:
## LOCK
## LR(1) items:
lock -> LOCK . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 85
## Reductions:

State 85:
## Known stack suffix:
## LOCK OPEN_PAREN
## LR(1) items:
lock -> LOCK OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 237
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 86:
## Known stack suffix:
## LASTLOCKED
## LR(1) items:
addr -> LASTLOCKED . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 233
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 88:
## Known stack suffix:
## INTRTH
## LR(1) items:
setth -> INTRTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 89
## Reductions:

State 89:
## Known stack suffix:
## INTRTH OPEN_PAREN
## LR(1) items:
setth -> INTRTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 229
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 90:
## Known stack suffix:
## INTRINT
## LR(1) items:
setint -> INTRINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## INTRINT OPEN_PAREN
## LR(1) items:
setint -> INTRINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 225
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 92:
## Known stack suffix:
## INTRELEM
## LR(1) items:
setelem -> INTRELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 93
## Reductions:

State 93:
## Known stack suffix:
## INTRELEM OPEN_PAREN
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 221
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 94:
## Known stack suffix:
## INTR
## LR(1) items:
set -> INTR . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 95
## Reductions:

State 95:
## Known stack suffix:
## INTR OPEN_PAREN
## LR(1) items:
set -> INTR OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 217
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 96:
## Known stack suffix:
## INTOF
## LR(1) items:
integer -> INTOF . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## INTOF OPEN_PAREN
## LR(1) items:
integer -> INTOF OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 215
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 98:
## Known stack suffix:
## IDENT
## LR(1) items:
ident -> IDENT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
ident -> IDENT . DOUBLECOLON IDENT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
ident -> IDENT . DOUBLECOLON IDENT th_param [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOUBLECOLON shift to state 99
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production ident -> IDENT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOUBLECOLON DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production ident -> IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 99:
## Known stack suffix:
## IDENT DOUBLECOLON
## LR(1) items:
ident -> IDENT DOUBLECOLON . IDENT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
ident -> IDENT DOUBLECOLON . IDENT th_param [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On IDENT shift to state 100
## Reductions:

State 100:
## Known stack suffix:
## IDENT DOUBLECOLON IDENT
## LR(1) items:
ident -> IDENT DOUBLECOLON IDENT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
ident -> IDENT DOUBLECOLON IDENT . th_param [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 101
-- On th_param shift to state 106
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production ident -> IDENT DOUBLECOLON IDENT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production ident -> IDENT DOUBLECOLON IDENT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 101:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
th_param -> OPEN_PAREN . IDENT CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
th_param -> OPEN_PAREN . NUMBER CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On NUMBER shift to state 102
-- On IDENT shift to state 104
## Reductions:

State 102:
## Known stack suffix:
## OPEN_PAREN NUMBER
## LR(1) items:
th_param -> OPEN_PAREN NUMBER . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On CLOSE_PAREN shift to state 103
## Reductions:

State 103:
## Known stack suffix:
## OPEN_PAREN NUMBER CLOSE_PAREN
## LR(1) items:
th_param -> OPEN_PAREN NUMBER CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production th_param -> OPEN_PAREN NUMBER CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production th_param -> OPEN_PAREN NUMBER CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 104:
## Known stack suffix:
## OPEN_PAREN IDENT
## LR(1) items:
th_param -> OPEN_PAREN IDENT . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On CLOSE_PAREN shift to state 105
## Reductions:

State 105:
## Known stack suffix:
## OPEN_PAREN IDENT CLOSE_PAREN
## LR(1) items:
th_param -> OPEN_PAREN IDENT CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production th_param -> OPEN_PAREN IDENT CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production th_param -> OPEN_PAREN IDENT CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 106:
## Known stack suffix:
## IDENT DOUBLECOLON IDENT th_param
## LR(1) items:
ident -> IDENT DOUBLECOLON IDENT th_param . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production ident -> IDENT DOUBLECOLON IDENT th_param
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production ident -> IDENT DOUBLECOLON IDENT th_param
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 107:
## Known stack suffix:
## HIGHEST_ELEM
## LR(1) items:
elem -> HIGHEST_ELEM . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production elem -> HIGHEST_ELEM
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production elem -> HIGHEST_ELEM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 108:
## Known stack suffix:
## GETP
## LR(1) items:
path -> GETP . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 109
## Reductions:

State 109:
## Known stack suffix:
## GETP OPEN_PAREN
## LR(1) items:
path -> GETP OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 206
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 110:
## Known stack suffix:
## FIRSTLOCKED
## LR(1) items:
addr -> FIRSTLOCKED . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> FIRSTLOCKED . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 111
## Reductions:

State 111:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> FIRSTLOCKED OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 199
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 112:
## Known stack suffix:
## ERROR
## LR(1) items:
cell -> ERROR . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> ERROR
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> ERROR
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 113:
## Known stack suffix:
## EPSILON
## LR(1) items:
path -> EPSILON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production path -> EPSILON
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production path -> EPSILON
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 114:
## Known stack suffix:
## EMPTYSETTH
## LR(1) items:
setth -> EMPTYSETTH . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> EMPTYSETTH
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> EMPTYSETTH
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 115:
## Known stack suffix:
## EMPTYSETINT
## LR(1) items:
setint -> EMPTYSETINT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> EMPTYSETINT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> EMPTYSETINT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 116:
## Known stack suffix:
## EMPTYSETELEM
## LR(1) items:
setelem -> EMPTYSETELEM . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> EMPTYSETELEM
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> EMPTYSETELEM
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 117:
## Known stack suffix:
## EMPTYSET
## LR(1) items:
set -> EMPTYSET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> EMPTYSET
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> EMPTYSET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 118:
## Known stack suffix:
## ARR_UPDATE
## LR(1) items:
arrays -> ARR_UPDATE . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 119
## Reductions:

State 119:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN
## LR(1) items:
arrays -> ARR_UPDATE OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 193
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 120:
## Known stack suffix:
## ADDR2SET
## LR(1) items:
set -> ADDR2SET . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> ADDR2SET . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## ADDR2SET OPEN_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> ADDR2SET OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 124
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 122:
## Known stack suffix:
## tidarr
## LR(1) items:
term -> tidarr . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> tidarr
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> tidarr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 123:
## Known stack suffix:
## tid
## LR(1) items:
term -> tid . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> tid
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> tid
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 124:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> ADDR2SET OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> ADDR2SET OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 187
## Reductions:

State 125:
## Known stack suffix:
## term OPEN_BRACKET
## LR(1) items:
arrays -> term OPEN_BRACKET . term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 126
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 126:
## Known stack suffix:
## term OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arrays -> term OPEN_BRACKET term . CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_BRACKET shift to state 186
## Reductions:

State 127:
## Known stack suffix:
## term MATH_PLUS
## LR(1) items:
integer -> term MATH_PLUS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 128
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 128:
## Known stack suffix:
## term MATH_PLUS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term MATH_PLUS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term MATH_PLUS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term MATH_PLUS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 129:
## Known stack suffix:
## term MATH_MULT
## LR(1) items:
integer -> term MATH_MULT . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 130
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 130:
## Known stack suffix:
## term MATH_MULT term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term MATH_MULT term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term MATH_MULT term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term MATH_MULT term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 131:
## Known stack suffix:
## term DOT
## LR(1) items:
addr -> term DOT . NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term DOT . NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term DOT . BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term DOT . BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term DOT . ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term DOT . LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term DOT . LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term DOT . UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term DOT . UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term DOT . DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term DOT . MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term DOT . MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term DOT . BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term DOT . LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term DOT . BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term DOT . TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UNLOCKAT shift to state 132
-- On UNLOCK shift to state 160
-- On TIDS shift to state 161
-- On NEXTAT shift to state 162
-- On NEXT shift to state 166
-- On MAX shift to state 167
-- On MARKED shift to state 168
-- On LOCKID shift to state 169
-- On LOCKAT shift to state 170
-- On LOCK shift to state 176
-- On DATA shift to state 180
-- On BTID shift to state 181
-- On BREGION shift to state 182
-- On BINIT shift to state 183
-- On BEND shift to state 184
-- On ARR shift to state 185
## Reductions:

State 132:
## Known stack suffix:
## term DOT UNLOCKAT
## LR(1) items:
cell -> term DOT UNLOCKAT . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 133
## Reductions:

State 133:
## Known stack suffix:
## term DOT UNLOCKAT OPEN_PAREN
## LR(1) items:
cell -> term DOT UNLOCKAT OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 134
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 134:
## Known stack suffix:
## term DOT UNLOCKAT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term DOT UNLOCKAT OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 159
## Reductions:

State 135:
## Known stack suffix:
## term MATH_MOD
## LR(1) items:
integer -> term MATH_MOD . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 136
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 136:
## Known stack suffix:
## term MATH_MOD term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term MATH_MOD term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term MATH_MOD term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term MATH_MOD term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 137:
## Known stack suffix:
## setth
## LR(1) items:
term -> setth . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> setth
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> setth
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 138:
## Known stack suffix:
## setpair
## LR(1) items:
term -> setpair . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> setpair
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> setpair
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 139:
## Known stack suffix:
## setint
## LR(1) items:
term -> setint . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> setint
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> setint
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 140:
## Known stack suffix:
## setelem
## LR(1) items:
term -> setelem . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> setelem
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> setelem
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 141:
## Known stack suffix:
## set
## LR(1) items:
term -> set . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> set
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> set
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 142:
## Known stack suffix:
## path
## LR(1) items:
term -> path . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> path
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> path
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 143:
## Known stack suffix:
## pair
## LR(1) items:
term -> pair . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> pair
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> pair
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 144:
## Known stack suffix:
## mem
## LR(1) items:
term -> mem . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> mem
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> mem
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 145:
## Known stack suffix:
## mark
## LR(1) items:
term -> mark . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> mark
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> mark
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 146:
## Known stack suffix:
## lock
## LR(1) items:
term -> lock . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> lock
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> lock
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 147:
## Known stack suffix:
## integer
## LR(1) items:
term -> integer . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> integer
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> integer
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 148:
## Known stack suffix:
## ident
## LR(1) items:
term -> ident . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> ident
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> ident
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 149:
## Known stack suffix:
## elem
## LR(1) items:
term -> elem . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> elem
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> elem
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 150:
## Known stack suffix:
## cell
## LR(1) items:
term -> cell . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> cell
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> cell
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 151:
## Known stack suffix:
## bucket
## LR(1) items:
term -> bucket . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> bucket
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> bucket
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 152:
## Known stack suffix:
## arrays
## LR(1) items:
term -> arrays . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> arrays
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> arrays
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 153:
## Known stack suffix:
## addrarr
## LR(1) items:
term -> addrarr . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> addrarr
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> addrarr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 154:
## Known stack suffix:
## addr
## LR(1) items:
term -> addr . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> addr
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> addr
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 155:
## Known stack suffix:
## term MATH_MINUS
## LR(1) items:
integer -> term MATH_MINUS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 156
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 156:
## Known stack suffix:
## term MATH_MINUS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term MATH_MINUS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term MATH_MINUS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term MATH_MINUS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 157:
## Known stack suffix:
## term MATH_DIV
## LR(1) items:
integer -> term MATH_DIV . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 158
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 158:
## Known stack suffix:
## term MATH_DIV term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term MATH_DIV term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term MATH_DIV term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term MATH_DIV term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 159:
## Known stack suffix:
## term DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
cell -> term DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> term DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> term DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 160:
## Known stack suffix:
## term DOT UNLOCK
## LR(1) items:
cell -> term DOT UNLOCK . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> term DOT UNLOCK
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> term DOT UNLOCK
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 161:
## Known stack suffix:
## term DOT TIDS
## LR(1) items:
tidarr -> term DOT TIDS . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production tidarr -> term DOT TIDS
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production tidarr -> term DOT TIDS
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 162:
## Known stack suffix:
## term DOT NEXTAT
## LR(1) items:
addr -> term DOT NEXTAT . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET
## LR(1) items:
addr -> term DOT NEXTAT OPEN_BRACKET . term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 164
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 164:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term DOT NEXTAT OPEN_BRACKET term . CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_BRACKET shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
addr -> term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 166:
## Known stack suffix:
## term DOT NEXT
## LR(1) items:
addr -> term DOT NEXT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> term DOT NEXT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> term DOT NEXT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 167:
## Known stack suffix:
## term DOT MAX
## LR(1) items:
integer -> term DOT MAX . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> term DOT MAX
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> term DOT MAX
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 168:
## Known stack suffix:
## term DOT MARKED
## LR(1) items:
mark -> term DOT MARKED . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production mark -> term DOT MARKED
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production mark -> term DOT MARKED
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 169:
## Known stack suffix:
## term DOT LOCKID
## LR(1) items:
tid -> term DOT LOCKID . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production tid -> term DOT LOCKID
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production tid -> term DOT LOCKID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 170:
## Known stack suffix:
## term DOT LOCKAT
## LR(1) items:
cell -> term DOT LOCKAT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 171
## Reductions:

State 171:
## Known stack suffix:
## term DOT LOCKAT OPEN_PAREN
## LR(1) items:
cell -> term DOT LOCKAT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 172
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 172:
## Known stack suffix:
## term DOT LOCKAT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term DOT LOCKAT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## term DOT LOCKAT OPEN_PAREN term COMMA
## LR(1) items:
cell -> term DOT LOCKAT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 174
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 174:
## Known stack suffix:
## term DOT LOCKAT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term DOT LOCKAT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## term DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> term DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> term DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> term DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 176:
## Known stack suffix:
## term DOT LOCK
## LR(1) items:
cell -> term DOT LOCK . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## term DOT LOCK OPEN_PAREN
## LR(1) items:
cell -> term DOT LOCK OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 178
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 178:
## Known stack suffix:
## term DOT LOCK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term DOT LOCK OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## term DOT LOCK OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
cell -> term DOT LOCK OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> term DOT LOCK OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> term DOT LOCK OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 180:
## Known stack suffix:
## term DOT DATA
## LR(1) items:
elem -> term DOT DATA . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production elem -> term DOT DATA
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production elem -> term DOT DATA
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 181:
## Known stack suffix:
## term DOT BTID
## LR(1) items:
tid -> term DOT BTID . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production tid -> term DOT BTID
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production tid -> term DOT BTID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 182:
## Known stack suffix:
## term DOT BREGION
## LR(1) items:
set -> term DOT BREGION . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> term DOT BREGION
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> term DOT BREGION
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 183:
## Known stack suffix:
## term DOT BINIT
## LR(1) items:
addr -> term DOT BINIT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> term DOT BINIT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> term DOT BINIT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 184:
## Known stack suffix:
## term DOT BEND
## LR(1) items:
addr -> term DOT BEND . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> term DOT BEND
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> term DOT BEND
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 185:
## Known stack suffix:
## term DOT ARR
## LR(1) items:
addrarr -> term DOT ARR . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addrarr -> term DOT ARR
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addrarr -> term DOT ARR
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 186:
## Known stack suffix:
## term OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
arrays -> term OPEN_BRACKET term CLOSE_BRACKET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production arrays -> term OPEN_BRACKET term CLOSE_BRACKET
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production arrays -> term OPEN_BRACKET term CLOSE_BRACKET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 187:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> ADDR2SET OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 188
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 188:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> ADDR2SET OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> ADDR2SET OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 189
-- On CLOSE_PAREN shift to state 192
## Reductions:

State 189:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 190
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 190:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 191
## Reductions:

State 191:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 192:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 193:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> ARR_UPDATE OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 194
## Reductions:

State 194:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA
## LR(1) items:
arrays -> ARR_UPDATE OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 195
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 195:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> ARR_UPDATE OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 196
## Reductions:

State 196:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA
## LR(1) items:
arrays -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 197
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 197:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 198
## Reductions:

State 198:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
arrays -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production arrays -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production arrays -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 199:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> FIRSTLOCKED OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> FIRSTLOCKED OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 200
## Reductions:

State 200:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> FIRSTLOCKED OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 201
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 201:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 202
-- On CLOSE_PAREN shift to state 205
## Reductions:

State 202:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term COMMA
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 203
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 203:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 204
## Reductions:

State 204:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> FIRSTLOCKED OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 205:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 206:
## Known stack suffix:
## GETP OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
path -> GETP OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 207
## Reductions:

State 207:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 208
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 208:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
path -> GETP OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 210
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 210:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
path -> GETP OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> GETP OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 211
-- On CLOSE_PAREN shift to state 214
## Reductions:

State 211:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 212
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 212:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
path -> GETP OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 213
## Reductions:

State 213:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production path -> GETP OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production path -> GETP OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 214:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production path -> GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production path -> GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 215:
## Known stack suffix:
## INTOF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> INTOF OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 216
## Reductions:

State 216:
## Known stack suffix:
## INTOF OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> INTOF OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> INTOF OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> INTOF OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 217:
## Known stack suffix:
## INTR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> INTR OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 218
## Reductions:

State 218:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA
## LR(1) items:
set -> INTR OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 219
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 219:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> INTR OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 220
## Reductions:

State 220:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> INTR OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> INTR OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> INTR OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 221:
## Known stack suffix:
## INTRELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> INTRELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 223
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 223:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> INTRELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 224
## Reductions:

State 224:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 225:
## Known stack suffix:
## INTRINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> INTRINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 226
## Reductions:

State 226:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> INTRINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 227
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 227:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> INTRINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 228
## Reductions:

State 228:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 229:
## Known stack suffix:
## INTRTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> INTRTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 230
## Reductions:

State 230:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> INTRTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 231
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 231:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> INTRTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 232
## Reductions:

State 232:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 233:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> LASTLOCKED OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 235
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 235:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> LASTLOCKED OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production addr -> LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production addr -> LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 237:
## Known stack suffix:
## LOCK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
lock -> LOCK OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 238
## Reductions:

State 238:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA
## LR(1) items:
lock -> LOCK OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 239
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 239:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
lock -> LOCK OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 240
## Reductions:

State 240:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
lock -> LOCK OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production lock -> LOCK OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production lock -> LOCK OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 241:
## Known stack suffix:
## LOCKSET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> LOCKSET OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 242
## Reductions:

State 242:
## Known stack suffix:
## LOCKSET OPEN_PAREN term COMMA
## LR(1) items:
setth -> LOCKSET OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 243
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 243:
## Known stack suffix:
## LOCKSET OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> LOCKSET OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## LOCKSET OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> LOCKSET OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> LOCKSET OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> LOCKSET OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 245:
## Known stack suffix:
## MATH_MINUS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> MATH_MINUS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> MATH_MINUS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> MATH_MINUS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 246:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MEMORY_READ OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 248
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 248:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> MEMORY_READ OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 249
## Reductions:

State 249:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 250:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 251
## Reductions:

State 251:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 252
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 252:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 253
## Reductions:

State 253:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 254
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 254:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 256
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 256:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 258:
## Known stack suffix:
## MKCELL OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MKCELL OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term . COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 259
## Reductions:

State 259:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term COMMA . OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 260
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 274
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 260:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET . term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
path -> OPEN_BRACKET . term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term_list shift to state 261
-- On term shift to state 272
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 261:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list . CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On CLOSE_BRACKET shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET . COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On COMMA shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA . OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 264
## Reductions:

State 264:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET . term_list CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term_list shift to state 265
-- On term shift to state 268
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 265:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list . CLOSE_BRACKET CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On CLOSE_BRACKET shift to state 266
## Reductions:

State 266:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On CLOSE_PAREN shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 268:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
term_list -> term . COMMA term [ CLOSE_BRACKET ]
term_list -> term . COMMA term_list [ CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 269
## Reductions:

State 269:
## Known stack suffix:
## term COMMA
## LR(1) items:
term_list -> term COMMA . term [ CLOSE_BRACKET ]
term_list -> term COMMA . term_list [ CLOSE_BRACKET ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term_list shift to state 270
-- On term shift to state 271
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 270:
## Known stack suffix:
## term COMMA term_list
## LR(1) items:
term_list -> term COMMA term_list . [ CLOSE_BRACKET ]
## Transitions:
## Reductions:
-- On CLOSE_BRACKET
--   reduce production term_list -> term COMMA term_list

State 271:
## Known stack suffix:
## term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
term_list -> term . COMMA term [ CLOSE_BRACKET ]
term_list -> term COMMA term . [ CLOSE_BRACKET ]
term_list -> term . COMMA term_list [ CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 269
## Reductions:
-- On CLOSE_BRACKET
--   reduce production term_list -> term COMMA term

State 272:
## Known stack suffix:
## OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
path -> OPEN_BRACKET term . CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
term_list -> term . COMMA term [ CLOSE_BRACKET ]
term_list -> term . COMMA term_list [ CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 269
-- On CLOSE_BRACKET shift to state 273
## Reductions:

State 273:
## Known stack suffix:
## OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
path -> OPEN_BRACKET term CLOSE_BRACKET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production path -> OPEN_BRACKET term CLOSE_BRACKET
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production path -> OPEN_BRACKET term CLOSE_BRACKET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 274:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MKCELL OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 275
## Reductions:

State 275:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 276
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 276:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 277
-- On CLOSE_PAREN shift to state 280
## Reductions:

State 277:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 278
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 278:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 279
## Reductions:

State 279:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 280:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 281:
## Known stack suffix:
## OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
path -> OPEN_BRACKET term . CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_BRACKET shift to state 273
## Reductions:

State 282:
## Known stack suffix:
## OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
pair -> OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
term -> OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 283
-- On CLOSE_PAREN shift to state 286
## Reductions:

State 283:
## Known stack suffix:
## OPEN_PAREN term COMMA
## LR(1) items:
pair -> OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 284
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 284:
## Known stack suffix:
## OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 285
## Reductions:

State 285:
## Known stack suffix:
## OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
pair -> OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production pair -> OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production pair -> OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 286:
## Known stack suffix:
## OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
term -> OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production term -> OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production term -> OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 287:
## Known stack suffix:
## OPEN_SET term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
set -> OPEN_SET term . CLOSE_SET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_SET shift to state 288
## Reductions:

State 288:
## Known stack suffix:
## OPEN_SET term CLOSE_SET
## LR(1) items:
set -> OPEN_SET term CLOSE_SET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> OPEN_SET term CLOSE_SET
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> OPEN_SET term CLOSE_SET
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 289:
## Known stack suffix:
## PATH2SET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> PATH2SET OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 290
## Reductions:

State 290:
## Known stack suffix:
## PATH2SET OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
set -> PATH2SET OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> PATH2SET OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> PATH2SET OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 291:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> SET2ELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 292
## Reductions:

State 292:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 293
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 293:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SET2ELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 294
## Reductions:

State 294:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 295:
## Known stack suffix:
## SETDIFF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> SETDIFF OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA
## LR(1) items:
set -> SETDIFF OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 297
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 297:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> SETDIFF OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 298
## Reductions:

State 298:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 299:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> SETDIFFELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 300
## Reductions:

State 300:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 301
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 301:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SETDIFFELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 302
## Reductions:

State 302:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 303:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> SETDIFFINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 304
## Reductions:

State 304:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 305
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 305:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> SETDIFFINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 307:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> SETDIFFTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 309
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 309:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> SETDIFFTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 311:
## Known stack suffix:
## SETINTMAX OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> SETINTMAX OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## SETINTMAX OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> SETINTMAX OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> SETINTMAX OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> SETINTMAX OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 313:
## Known stack suffix:
## SETINTMIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> SETINTMIN OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 314
## Reductions:

State 314:
## Known stack suffix:
## SETINTMIN OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> SETINTMIN OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production integer -> SETINTMIN OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production integer -> SETINTMIN OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 315:
## Known stack suffix:
## SETLOWER OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> SETLOWER OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 316
## Reductions:

State 316:
## Known stack suffix:
## SETLOWER OPEN_PAREN term COMMA
## LR(1) items:
setint -> SETLOWER OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 317
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 317:
## Known stack suffix:
## SETLOWER OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> SETLOWER OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 318
## Reductions:

State 318:
## Known stack suffix:
## SETLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> SETLOWER OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> SETLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> SETLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 319:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRDIFF OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 321
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 321:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 322
## Reductions:

State 322:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 323:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRINTR OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 324
## Reductions:

State 324:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 325
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 325:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRINTR OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 327:
## Known stack suffix:
## SETPAIRLOWER OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRLOWER OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## SETPAIRLOWER OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRLOWER OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 329
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 329:
## Known stack suffix:
## SETPAIRLOWER OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRLOWER OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## SETPAIRLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRLOWER OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIRLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIRLOWER OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 331:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> SETPAIRMAX OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
pair -> SETPAIRMAX OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production pair -> SETPAIRMAX OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production pair -> SETPAIRMAX OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 333:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> SETPAIRMIN OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
pair -> SETPAIRMIN OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production pair -> SETPAIRMIN OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production pair -> SETPAIRMIN OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 335:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRSINGLE OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 337:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRUNION OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 339
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 339:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRUNION OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 340
## Reductions:

State 340:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setpair -> SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setpair -> SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 341:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SINGLEELEM OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 342
## Reductions:

State 342:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setelem -> SINGLEELEM OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> SINGLEELEM OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> SINGLEELEM OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 343:
## Known stack suffix:
## SINGLEINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> SINGLEINT OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## SINGLEINT OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setint -> SINGLEINT OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> SINGLEINT OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> SINGLEINT OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 345:
## Known stack suffix:
## SINGLETH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> SINGLETH OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 346
## Reductions:

State 346:
## Known stack suffix:
## SINGLETH OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setth -> SINGLETH OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> SINGLETH OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> SINGLETH OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 347:
## Known stack suffix:
## TIDOF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> TIDOF OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 348
## Reductions:

State 348:
## Known stack suffix:
## TIDOF OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
tid -> TIDOF OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production tid -> TIDOF OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production tid -> TIDOF OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 349:
## Known stack suffix:
## UNION OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> UNION OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA
## LR(1) items:
set -> UNION OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 351
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 351:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> UNION OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> UNION OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production set -> UNION OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production set -> UNION OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 353:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> UNIONELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 355
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 355:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> UNIONELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 356
## Reductions:

State 356:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setelem -> UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setelem -> UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 357:
## Known stack suffix:
## UNIONINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> UNIONINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 358
## Reductions:

State 358:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> UNIONINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 359
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 359:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> UNIONINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 360
## Reductions:

State 360:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setint -> UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setint -> UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 361:
## Known stack suffix:
## UNIONTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> UNIONTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> UNIONTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 363
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 363:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> UNIONTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 364
## Reductions:

State 364:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production setth -> UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production setth -> UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 365:
## Known stack suffix:
## UNLOCK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
lock -> UNLOCK OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 366
## Reductions:

State 366:
## Known stack suffix:
## UNLOCK OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
lock -> UNLOCK OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production lock -> UNLOCK OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production lock -> UNLOCK OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 367:
## Known stack suffix:
## UPDATE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mem -> UPDATE OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 368
## Reductions:

State 368:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 369
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 369:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mem -> UPDATE OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 370
## Reductions:

State 370:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 371
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 371:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mem -> UPDATE OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production mem -> UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL NOT_EQUALS MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LINE LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production mem -> UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 373:
## Known stack suffix:
## SUBSETEQTH
## LR(1) items:
literal -> SUBSETEQTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN
## LR(1) items:
literal -> SUBSETEQTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 375
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 375:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SUBSETEQTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 376
## Reductions:

State 376:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA
## LR(1) items:
literal -> SUBSETEQTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 377
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 377:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SUBSETEQTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 378
## Reductions:

State 378:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 379:
## Known stack suffix:
## SUBSETEQINT
## LR(1) items:
literal -> SUBSETEQINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 380
## Reductions:

State 380:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN
## LR(1) items:
literal -> SUBSETEQINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 381
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 381:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SUBSETEQINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 382
## Reductions:

State 382:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA
## LR(1) items:
literal -> SUBSETEQINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 383
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 383:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SUBSETEQINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 384
## Reductions:

State 384:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 385:
## Known stack suffix:
## SUBSETEQELEM
## LR(1) items:
literal -> SUBSETEQELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN
## LR(1) items:
literal -> SUBSETEQELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 387
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 387:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SUBSETEQELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 388
## Reductions:

State 388:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA
## LR(1) items:
literal -> SUBSETEQELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 389
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 389:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SUBSETEQELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 391:
## Known stack suffix:
## SUBSETEQ
## LR(1) items:
literal -> SUBSETEQ . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 392
## Reductions:

State 392:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN
## LR(1) items:
literal -> SUBSETEQ OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 393
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 393:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SUBSETEQ OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 394
## Reductions:

State 394:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA
## LR(1) items:
literal -> SUBSETEQ OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 395
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 395:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SUBSETEQ OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 396
## Reductions:

State 396:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 397:
## Known stack suffix:
## SKIPLIST
## LR(1) items:
literal -> SKIPLIST . OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 398
## Reductions:

State 398:
## Known stack suffix:
## SKIPLIST OPEN_PAREN
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN . term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 399
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 399:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SKIPLIST OPEN_PAREN term . COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 400
## Reductions:

State 400:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA . term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 401
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 401:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SKIPLIST OPEN_PAREN term COMMA term . COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 402
## Reductions:

State 402:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 403
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 403:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 404
## Reductions:

State 404:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 405
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 405:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 406
## Reductions:

State 406:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 407
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 407:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 409
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 409:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 410
## Reductions:

State 410:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 411:
## Known stack suffix:
## SHARP
## LR(1) items:
formula_decl -> SHARP . IDENT COLON formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> SHARP . [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
## Transitions:
-- On IDENT shift to state 412
## Reductions:
-- On OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT
--   reduce production tid -> SHARP

State 412:
## Known stack suffix:
## SHARP IDENT
## LR(1) items:
formula_decl -> SHARP IDENT . COLON formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On COLON shift to state 413
## Reductions:

State 413:
## Known stack suffix:
## SHARP IDENT COLON
## LR(1) items:
formula_decl -> SHARP IDENT COLON . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 559
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 414:
## Known stack suffix:
## SETPAIRUNIQUETID
## LR(1) items:
literal -> SETPAIRUNIQUETID . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 415
## Reductions:

State 415:
## Known stack suffix:
## SETPAIRUNIQUETID OPEN_PAREN
## LR(1) items:
literal -> SETPAIRUNIQUETID OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 416
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 416:
## Known stack suffix:
## SETPAIRUNIQUETID OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRUNIQUETID OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 417
## Reductions:

State 417:
## Known stack suffix:
## SETPAIRUNIQUETID OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRUNIQUETID OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRUNIQUETID OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRUNIQUETID OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 418:
## Known stack suffix:
## SETPAIRUNIQUEINT
## LR(1) items:
literal -> SETPAIRUNIQUEINT . OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 419
## Reductions:

State 419:
## Known stack suffix:
## SETPAIRUNIQUEINT OPEN_PAREN
## LR(1) items:
literal -> SETPAIRUNIQUEINT OPEN_PAREN . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 420
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 420:
## Known stack suffix:
## SETPAIRUNIQUEINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRUNIQUEINT OPEN_PAREN term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 421
## Reductions:

State 421:
## Known stack suffix:
## SETPAIRUNIQUEINT OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRUNIQUEINT OPEN_PAREN term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRUNIQUEINT OPEN_PAREN term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRUNIQUEINT OPEN_PAREN term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 422:
## Known stack suffix:
## SETPAIRSUBSETEQ
## LR(1) items:
literal -> SETPAIRSUBSETEQ . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 423
## Reductions:

State 423:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN
## LR(1) items:
literal -> SETPAIRSUBSETEQ OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 424
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 424:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SETPAIRSUBSETEQ OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 425
## Reductions:

State 425:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA
## LR(1) items:
literal -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 426
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 426:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 428:
## Known stack suffix:
## SETPAIRINTIDPAIR
## LR(1) items:
literal -> SETPAIRINTIDPAIR . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 429
## Reductions:

State 429:
## Known stack suffix:
## SETPAIRINTIDPAIR OPEN_PAREN
## LR(1) items:
literal -> SETPAIRINTIDPAIR OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 430
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 430:
## Known stack suffix:
## SETPAIRINTIDPAIR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SETPAIRINTIDPAIR OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 431
## Reductions:

State 431:
## Known stack suffix:
## SETPAIRINTIDPAIR OPEN_PAREN term COMMA
## LR(1) items:
literal -> SETPAIRINTIDPAIR OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 432
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 432:
## Known stack suffix:
## SETPAIRINTIDPAIR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRINTIDPAIR OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 433
## Reductions:

State 433:
## Known stack suffix:
## SETPAIRINTIDPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRINTIDPAIR OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRINTIDPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRINTIDPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 434:
## Known stack suffix:
## SETPAIRININTPAIR
## LR(1) items:
literal -> SETPAIRININTPAIR . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 435
## Reductions:

State 435:
## Known stack suffix:
## SETPAIRININTPAIR OPEN_PAREN
## LR(1) items:
literal -> SETPAIRININTPAIR OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 436
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 436:
## Known stack suffix:
## SETPAIRININTPAIR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SETPAIRININTPAIR OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## SETPAIRININTPAIR OPEN_PAREN term COMMA
## LR(1) items:
literal -> SETPAIRININTPAIR OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 438
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 438:
## Known stack suffix:
## SETPAIRININTPAIR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRININTPAIR OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 439
## Reductions:

State 439:
## Known stack suffix:
## SETPAIRININTPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRININTPAIR OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRININTPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRININTPAIR OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 440:
## Known stack suffix:
## SETPAIRIN
## LR(1) items:
literal -> SETPAIRIN . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN
## LR(1) items:
literal -> SETPAIRIN OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 442
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 442:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> SETPAIRIN OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 443
## Reductions:

State 443:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA
## LR(1) items:
literal -> SETPAIRIN OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 444
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 444:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> SETPAIRIN OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 445
## Reductions:

State 445:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 446:
## Known stack suffix:
## REACH
## LR(1) items:
literal -> REACH . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH . OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## REACH OPEN_PAREN
## LR(1) items:
literal -> REACH OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN . term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 448
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 448:
## Known stack suffix:
## REACH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> REACH OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term . COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 449
## Reductions:

State 449:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 450
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 450:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> REACH OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 451
## Reductions:

State 451:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 452
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 452:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 453
## Reductions:

State 453:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 454
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 454:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 455
-- On CLOSE_PAREN shift to state 458
## Reductions:

State 455:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 456
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 456:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 457
## Reductions:

State 457:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 458:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 459:
## Known stack suffix:
## ORDERLIST
## LR(1) items:
literal -> ORDERLIST . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 460
## Reductions:

State 460:
## Known stack suffix:
## ORDERLIST OPEN_PAREN
## LR(1) items:
literal -> ORDERLIST OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 461
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 461:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> ORDERLIST OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 462
## Reductions:

State 462:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA
## LR(1) items:
literal -> ORDERLIST OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 463
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 463:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> ORDERLIST OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 464
## Reductions:

State 464:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA
## LR(1) items:
literal -> ORDERLIST OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 465
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 465:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> ORDERLIST OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 466
## Reductions:

State 466:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 467:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
formula -> OPEN_PAREN . formula CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
pair -> OPEN_PAREN . term COMMA term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
term -> OPEN_PAREN . term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 548
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 549
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 468:
## Known stack suffix:
## LOGICAL_TRUE
## LR(1) items:
formula -> LOGICAL_TRUE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> LOGICAL_TRUE
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> LOGICAL_TRUE
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 469:
## Known stack suffix:
## LOGICAL_NOT
## LR(1) items:
formula -> LOGICAL_NOT . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 545
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 470:
## Known stack suffix:
## LOGICAL_FALSE
## LR(1) items:
formula -> LOGICAL_FALSE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> LOGICAL_FALSE
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> LOGICAL_FALSE
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 471:
## Known stack suffix:
## INTH
## LR(1) items:
literal -> INTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 472
## Reductions:

State 472:
## Known stack suffix:
## INTH OPEN_PAREN
## LR(1) items:
literal -> INTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 473
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 473:
## Known stack suffix:
## INTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> INTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 474
## Reductions:

State 474:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA
## LR(1) items:
literal -> INTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 475
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 475:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> INTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 476
## Reductions:

State 476:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> INTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> INTH OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> INTH OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 477:
## Known stack suffix:
## ININT
## LR(1) items:
literal -> ININT . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 478
## Reductions:

State 478:
## Known stack suffix:
## ININT OPEN_PAREN
## LR(1) items:
literal -> ININT OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 479
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 479:
## Known stack suffix:
## ININT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> ININT OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 480
## Reductions:

State 480:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA
## LR(1) items:
literal -> ININT OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 481
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 481:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> ININT OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> ININT OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> ININT OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> ININT OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 483:
## Known stack suffix:
## INELEM
## LR(1) items:
literal -> INELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 484
## Reductions:

State 484:
## Known stack suffix:
## INELEM OPEN_PAREN
## LR(1) items:
literal -> INELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 485
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 485:
## Known stack suffix:
## INELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> INELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 486
## Reductions:

State 486:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA
## LR(1) items:
literal -> INELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 487
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 487:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> INELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 488
## Reductions:

State 488:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> INELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> INELEM OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> INELEM OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 489:
## Known stack suffix:
## IN
## LR(1) items:
literal -> IN . OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 490
## Reductions:

State 490:
## Known stack suffix:
## IN OPEN_PAREN
## LR(1) items:
literal -> IN OPEN_PAREN . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 491
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 491:
## Known stack suffix:
## IN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> IN OPEN_PAREN term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## IN OPEN_PAREN term COMMA
## LR(1) items:
literal -> IN OPEN_PAREN term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 493
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 493:
## Known stack suffix:
## IN OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> IN OPEN_PAREN term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 494
## Reductions:

State 494:
## Known stack suffix:
## IN OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> IN OPEN_PAREN term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> IN OPEN_PAREN term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> IN OPEN_PAREN term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 495:
## Known stack suffix:
## HASHTBL
## LR(1) items:
literal -> HASHTBL . OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 496
## Reductions:

State 496:
## Known stack suffix:
## HASHTBL OPEN_PAREN
## LR(1) items:
literal -> HASHTBL OPEN_PAREN . term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 497
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 497:
## Known stack suffix:
## HASHTBL OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> HASHTBL OPEN_PAREN term . COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 498
## Reductions:

State 498:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA
## LR(1) items:
literal -> HASHTBL OPEN_PAREN term COMMA . term COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 499
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 499:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> HASHTBL OPEN_PAREN term COMMA term . COMMA term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 500
## Reductions:

State 500:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA
## LR(1) items:
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 501
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 501:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 502
## Reductions:

State 502:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 503
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 503:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 505
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 505:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 506
## Reductions:

State 506:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 507:
## Known stack suffix:
## DOT
## LR(1) items:
literal -> DOT . ident DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> DOT . IDENT DOUBLECOLON IDENT th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On IDENT shift to state 508
-- On ident shift to state 513
## Reductions:

State 508:
## Known stack suffix:
## DOT IDENT
## LR(1) items:
ident -> IDENT . [ DOT ]
ident -> IDENT . DOUBLECOLON IDENT [ DOT ]
ident -> IDENT . DOUBLECOLON IDENT th_param [ DOT ]
literal -> DOT IDENT . DOUBLECOLON IDENT th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOUBLECOLON shift to state 509
## Reductions:
-- On DOT
--   reduce production ident -> IDENT

State 509:
## Known stack suffix:
## DOT IDENT DOUBLECOLON
## LR(1) items:
ident -> IDENT DOUBLECOLON . IDENT [ DOT ]
ident -> IDENT DOUBLECOLON . IDENT th_param [ DOT ]
literal -> DOT IDENT DOUBLECOLON . IDENT th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On IDENT shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## DOT IDENT DOUBLECOLON IDENT
## LR(1) items:
ident -> IDENT DOUBLECOLON IDENT . [ DOT ]
ident -> IDENT DOUBLECOLON IDENT . th_param [ DOT ]
literal -> DOT IDENT DOUBLECOLON IDENT . th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 101
-- On th_param shift to state 511
## Reductions:
-- On DOT
--   reduce production ident -> IDENT DOUBLECOLON IDENT

State 511:
## Known stack suffix:
## DOT IDENT DOUBLECOLON IDENT th_param
## LR(1) items:
ident -> IDENT DOUBLECOLON IDENT th_param . [ DOT ]
literal -> DOT IDENT DOUBLECOLON IDENT th_param . DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## DOT IDENT DOUBLECOLON IDENT th_param DOT
## LR(1) items:
literal -> DOT IDENT DOUBLECOLON IDENT th_param DOT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> DOT IDENT DOUBLECOLON IDENT th_param DOT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> DOT IDENT DOUBLECOLON IDENT th_param DOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 513:
## Known stack suffix:
## DOT ident
## LR(1) items:
literal -> DOT ident . DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 514
## Reductions:

State 514:
## Known stack suffix:
## DOT ident DOT
## LR(1) items:
literal -> DOT ident DOT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> DOT ident DOT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> DOT ident DOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 515:
## Known stack suffix:
## AT
## LR(1) items:
formula -> AT . NUMBER opt_th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> AT . IDENT opt_th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On NUMBER shift to state 516
-- On IDENT shift to state 520
## Reductions:

State 516:
## Known stack suffix:
## AT NUMBER
## LR(1) items:
formula -> AT NUMBER . opt_th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 101
-- On th_param shift to state 517
-- On opt_th_param shift to state 518
## Reductions:
-- On DOT
--   reduce production opt_th_param ->

State 517:
## Known stack suffix:
## th_param
## LR(1) items:
opt_th_param -> th_param . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production opt_th_param -> th_param

State 518:
## Known stack suffix:
## AT NUMBER opt_th_param
## LR(1) items:
formula -> AT NUMBER opt_th_param . DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 519
## Reductions:

State 519:
## Known stack suffix:
## AT NUMBER opt_th_param DOT
## LR(1) items:
formula -> AT NUMBER opt_th_param DOT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> AT NUMBER opt_th_param DOT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> AT NUMBER opt_th_param DOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 520:
## Known stack suffix:
## AT IDENT
## LR(1) items:
formula -> AT IDENT . opt_th_param DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 101
-- On th_param shift to state 517
-- On opt_th_param shift to state 521
## Reductions:
-- On DOT
--   reduce production opt_th_param ->

State 521:
## Known stack suffix:
## AT IDENT opt_th_param
## LR(1) items:
formula -> AT IDENT opt_th_param . DOT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On DOT shift to state 522
## Reductions:

State 522:
## Known stack suffix:
## AT IDENT opt_th_param DOT
## LR(1) items:
formula -> AT IDENT opt_th_param DOT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> AT IDENT opt_th_param DOT
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> AT IDENT opt_th_param DOT
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 523:
## Known stack suffix:
## APPEND
## LR(1) items:
literal -> APPEND . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_PAREN shift to state 524
## Reductions:

State 524:
## Known stack suffix:
## APPEND OPEN_PAREN
## LR(1) items:
literal -> APPEND OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 525
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 525:
## Known stack suffix:
## APPEND OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> APPEND OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 526
## Reductions:

State 526:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA
## LR(1) items:
literal -> APPEND OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 527
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 527:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
literal -> APPEND OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 528
## Reductions:

State 528:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA
## LR(1) items:
literal -> APPEND OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 529
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 529:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
literal -> APPEND OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On CLOSE_PAREN shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
literal -> APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 531:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BINIT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BEND [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addrarr -> term . DOT ARR [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
equals -> term . EQUALS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MULT term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_DIV term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MOD term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . DOT MAX [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
literal -> term . MATH_LESS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term . MATH_GREATER term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term . MATH_LESS_EQ term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term . MATH_GREATER_EQ term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
set -> term . DOT BREGION [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT LOCKID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT BTID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On NOT_EQUALS shift to state 532
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_LESS_EQ shift to state 534
-- On MATH_LESS shift to state 536
-- On MATH_GREATER_EQ shift to state 538
-- On MATH_GREATER shift to state 540
-- On MATH_DIV shift to state 157
-- On EQUALS shift to state 542
-- On DOT shift to state 131
## Reductions:

State 532:
## Known stack suffix:
## term NOT_EQUALS
## LR(1) items:
disequals -> term NOT_EQUALS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 533
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 533:
## Known stack suffix:
## term NOT_EQUALS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
disequals -> term NOT_EQUALS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production disequals -> term NOT_EQUALS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production disequals -> term NOT_EQUALS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 534:
## Known stack suffix:
## term MATH_LESS_EQ
## LR(1) items:
literal -> term MATH_LESS_EQ . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 535
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 535:
## Known stack suffix:
## term MATH_LESS_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term MATH_LESS_EQ term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> term MATH_LESS_EQ term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> term MATH_LESS_EQ term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 536:
## Known stack suffix:
## term MATH_LESS
## LR(1) items:
literal -> term MATH_LESS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 537
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 537:
## Known stack suffix:
## term MATH_LESS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term MATH_LESS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> term MATH_LESS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> term MATH_LESS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 538:
## Known stack suffix:
## term MATH_GREATER_EQ
## LR(1) items:
literal -> term MATH_GREATER_EQ . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 539
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 539:
## Known stack suffix:
## term MATH_GREATER_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term MATH_GREATER_EQ term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> term MATH_GREATER_EQ term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> term MATH_GREATER_EQ term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 540:
## Known stack suffix:
## term MATH_GREATER
## LR(1) items:
literal -> term MATH_GREATER . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 541
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 541:
## Known stack suffix:
## term MATH_GREATER term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
literal -> term MATH_GREATER term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> term MATH_GREATER term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> term MATH_GREATER term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 542:
## Known stack suffix:
## term EQUALS
## LR(1) items:
equals -> term EQUALS . term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 543
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 543:
## Known stack suffix:
## term EQUALS term
## LR(1) items:
addr -> term . DOT NEXT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BINIT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addr -> term . DOT BEND [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
addrarr -> term . DOT ARR [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCK [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
elem -> term . DOT DATA [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
equals -> term EQUALS term . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_PLUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MINUS term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MULT term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_DIV term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . MATH_MOD term [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
integer -> term . DOT MAX [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
mark -> term . DOT MARKED [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
set -> term . DOT BREGION [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT LOCKID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tid -> term . DOT BTID [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
tidarr -> term . DOT TIDS [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production equals -> term EQUALS term
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM SEMICOLON REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production equals -> term EQUALS term
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 544:
## Known stack suffix:
## literal
## LR(1) items:
formula -> literal . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> literal
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> literal
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 545:
## Known stack suffix:
## LOGICAL_NOT formula
## LR(1) items:
formula -> LOGICAL_NOT formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> LOGICAL_NOT formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> LOGICAL_NOT formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 546:
## Known stack suffix:
## equals
## LR(1) items:
literal -> equals . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> equals
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> equals
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 547:
## Known stack suffix:
## disequals
## LR(1) items:
literal -> disequals . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production literal -> disequals
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production literal -> disequals
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 548:
## Known stack suffix:
## OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addrarr -> term . DOT ARR [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
disequals -> term . NOT_EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
elem -> term . DOT DATA [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
equals -> term . EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . DOT MAX [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
literal -> term . MATH_LESS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
literal -> term . MATH_GREATER term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
literal -> term . MATH_LESS_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
literal -> term . MATH_GREATER_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
mark -> term . DOT MARKED [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
pair -> OPEN_PAREN term . COMMA term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
set -> term . DOT BREGION [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
term -> OPEN_PAREN term . CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On NOT_EQUALS shift to state 532
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_LESS_EQ shift to state 534
-- On MATH_LESS shift to state 536
-- On MATH_GREATER_EQ shift to state 538
-- On MATH_GREATER shift to state 540
-- On MATH_DIV shift to state 157
-- On EQUALS shift to state 542
-- On DOT shift to state 131
-- On COMMA shift to state 283
-- On CLOSE_PAREN shift to state 286
## Reductions:

State 549:
## Known stack suffix:
## OPEN_PAREN formula
## LR(1) items:
formula -> OPEN_PAREN formula . CLOSE_PAREN [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
-- On CLOSE_PAREN shift to state 558
## Reductions:

State 550:
## Known stack suffix:
## formula LOGICAL_THEN
## LR(1) items:
formula -> formula LOGICAL_THEN . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 551
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 551:
## Known stack suffix:
## formula LOGICAL_THEN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula LOGICAL_THEN formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> formula LOGICAL_THEN formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> formula LOGICAL_THEN formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 552:
## Known stack suffix:
## formula LOGICAL_OR
## LR(1) items:
formula -> formula LOGICAL_OR . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 553
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 553:
## Known stack suffix:
## formula LOGICAL_OR formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula LOGICAL_OR formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> formula LOGICAL_OR formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> formula LOGICAL_OR formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 554:
## Known stack suffix:
## formula LOGICAL_AND
## LR(1) items:
formula -> formula LOGICAL_AND . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 555
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 555:
## Known stack suffix:
## formula LOGICAL_AND formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula LOGICAL_AND formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> formula LOGICAL_AND formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> formula LOGICAL_AND formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 556:
## Known stack suffix:
## formula EQUALS
## LR(1) items:
formula -> formula EQUALS . formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 557
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 557:
## Known stack suffix:
## formula EQUALS formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula EQUALS formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> formula EQUALS formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> formula EQUALS formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 558:
## Known stack suffix:
## OPEN_PAREN formula CLOSE_PAREN
## LR(1) items:
formula -> OPEN_PAREN formula CLOSE_PAREN . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula -> OPEN_PAREN formula CLOSE_PAREN
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TRANSITION_TID TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GOAL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT CLOSE_SET CLOSE_PAREN AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula -> OPEN_PAREN formula CLOSE_PAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 559:
## Known stack suffix:
## SHARP IDENT COLON formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula_decl -> SHARP IDENT COLON formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula_decl -> SHARP IDENT COLON formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula_decl -> SHARP IDENT COLON formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 560:
## Known stack suffix:
## param COLON inv_var_declarations AXIOM formula_tag COLON formula_decl_list
## LR(1) items:
axiom -> param COLON inv_var_declarations AXIOM formula_tag COLON formula_decl_list . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production axiom -> param COLON inv_var_declarations AXIOM formula_tag COLON formula_decl_list

State 561:
## Known stack suffix:
## formula_decl
## LR(1) items:
formula_decl_list -> formula_decl . [ # ]
formula_decl_list -> formula_decl . formula_decl_list [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 411
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula_decl_list shift to state 562
-- On formula_decl shift to state 561
-- On formula shift to state 563
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:
-- On #
--   reduce production formula_decl_list -> formula_decl
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula_decl_list -> formula_decl
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 562:
## Known stack suffix:
## formula_decl formula_decl_list
## LR(1) items:
formula_decl_list -> formula_decl formula_decl_list . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production formula_decl_list -> formula_decl formula_decl_list

State 563:
## Known stack suffix:
## formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
formula_decl -> formula . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET #
--   reduce production formula_decl -> formula
** End-of-stream conflict on UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET
**   There is a tension between
**   (1) reducing production formula_decl -> formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 564:
## Known stack suffix:
## inv_var_decl_list
## LR(1) items:
inv_var_declarations -> inv_var_decl_list . [ SUPPORT INVARIANT FORMULA AXIOM ]
## Transitions:
## Reductions:
-- On SUPPORT INVARIANT FORMULA AXIOM
--   reduce production inv_var_declarations -> inv_var_decl_list

State 565:
## Known stack suffix:
## inv_var_decl
## LR(1) items:
inv_var_decl_list -> inv_var_decl . [ SUPPORT INVARIANT FORMULA AXIOM ]
inv_var_decl_list -> inv_var_decl . inv_var_decl_list [ SUPPORT INVARIANT FORMULA AXIOM ]
## Transitions:
-- On IDENT shift to state 4
-- On inv_var_decl_list shift to state 566
-- On inv_var_decl shift to state 565
## Reductions:
-- On SUPPORT INVARIANT FORMULA AXIOM
--   reduce production inv_var_decl_list -> inv_var_decl

State 566:
## Known stack suffix:
## inv_var_decl inv_var_decl_list
## LR(1) items:
inv_var_decl_list -> inv_var_decl inv_var_decl_list . [ SUPPORT INVARIANT FORMULA AXIOM ]
## Transitions:
## Reductions:
-- On SUPPORT INVARIANT FORMULA AXIOM
--   reduce production inv_var_decl_list -> inv_var_decl inv_var_decl_list

State 567:
## Known stack suffix:
## axiom
## LR(1) items:
axiom' -> axiom . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept axiom

State 568:
## Known stack suffix:
##
## LR(1) items:
formula' -> . formula [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 569
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 569:
## Known stack suffix:
## formula
## LR(1) items:
formula' -> formula . [ # ]
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
## Reductions:
-- On #
--   accept formula
** End-of-stream conflict on LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS
**   There is a tension between
**   (1) accepting formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 570:
## Known stack suffix:
##
## LR(1) items:
invariant' -> . invariant [ # ]
## Transitions:
-- On VARS shift to state 1
-- On param shift to state 571
-- On invariant shift to state 578
## Reductions:

State 571:
## Known stack suffix:
## param
## LR(1) items:
invariant -> param . COLON inv_var_declarations INVARIANT formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On COLON shift to state 572
## Reductions:

State 572:
## Known stack suffix:
## param COLON
## LR(1) items:
invariant -> param COLON . inv_var_declarations INVARIANT formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On IDENT shift to state 4
-- On inv_var_declarations shift to state 573
-- On inv_var_decl_list shift to state 564
-- On inv_var_decl shift to state 565
## Reductions:
-- On INVARIANT
--   reduce production inv_var_declarations ->

State 573:
## Known stack suffix:
## param COLON inv_var_declarations
## LR(1) items:
invariant -> param COLON inv_var_declarations . INVARIANT formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On INVARIANT shift to state 574
## Reductions:

State 574:
## Known stack suffix:
## param COLON inv_var_declarations INVARIANT
## LR(1) items:
invariant -> param COLON inv_var_declarations INVARIANT . formula_tag COLON formula_decl_list [ # ]
## Transitions:
-- On OPEN_BRACKET shift to state 8
-- On formula_tag shift to state 575
## Reductions:
-- On COLON
--   reduce production formula_tag ->

State 575:
## Known stack suffix:
## param COLON inv_var_declarations INVARIANT formula_tag
## LR(1) items:
invariant -> param COLON inv_var_declarations INVARIANT formula_tag . COLON formula_decl_list [ # ]
## Transitions:
-- On COLON shift to state 576
## Reductions:

State 576:
## Known stack suffix:
## param COLON inv_var_declarations INVARIANT formula_tag COLON
## LR(1) items:
invariant -> param COLON inv_var_declarations INVARIANT formula_tag COLON . formula_decl_list [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 411
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula_decl_list shift to state 577
-- On formula_decl shift to state 561
-- On formula shift to state 563
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 577:
## Known stack suffix:
## param COLON inv_var_declarations INVARIANT formula_tag COLON formula_decl_list
## LR(1) items:
invariant -> param COLON inv_var_declarations INVARIANT formula_tag COLON formula_decl_list . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production invariant -> param COLON inv_var_declarations INVARIANT formula_tag COLON formula_decl_list

State 578:
## Known stack suffix:
## invariant
## LR(1) items:
invariant' -> invariant . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept invariant

State 579:
## Known stack suffix:
##
## LR(1) items:
pvd' -> . pvd [ # ]
## Transitions:
-- On DIAGRAM shift to state 580
-- On pvd shift to state 692
## Reductions:

State 580:
## Known stack suffix:
## DIAGRAM
## LR(1) items:
pvd -> DIAGRAM . OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On OPEN_BRACKET shift to state 581
## Reductions:

State 581:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET . IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On IDENT shift to state 582
## Reductions:

State 582:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT . CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On CLOSE_BRACKET shift to state 583
## Reductions:

State 583:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET . NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On NODES shift to state 584
## Reductions:

State 584:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES . COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On COLON shift to state 585
## Reductions:

State 585:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON . node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On IDENT shift to state 586
-- On node_list shift to state 590
-- On node shift to state 689
## Reductions:

State 586:
## Known stack suffix:
## IDENT
## LR(1) items:
node -> IDENT . [ COMMA BOXES ]
node -> IDENT . OPEN_SET formula CLOSE_SET [ COMMA BOXES ]
## Transitions:
-- On OPEN_SET shift to state 587
## Reductions:
-- On COMMA BOXES
--   reduce production node -> IDENT

State 587:
## Known stack suffix:
## IDENT OPEN_SET
## LR(1) items:
node -> IDENT OPEN_SET . formula CLOSE_SET [ COMMA BOXES ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 588
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 588:
## Known stack suffix:
## IDENT OPEN_SET formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_SET ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_SET ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_SET ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_SET ]
node -> IDENT OPEN_SET formula . CLOSE_SET [ COMMA BOXES ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
-- On CLOSE_SET shift to state 589
## Reductions:

State 589:
## Known stack suffix:
## IDENT OPEN_SET formula CLOSE_SET
## LR(1) items:
node -> IDENT OPEN_SET formula CLOSE_SET . [ COMMA BOXES ]
## Transitions:
## Reductions:
-- On COMMA BOXES
--   reduce production node -> IDENT OPEN_SET formula CLOSE_SET

State 590:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list . BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On BOXES shift to state 591
## Reductions:

State 591:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES . COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On COLON shift to state 592
## Reductions:

State 592:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON . box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On OPEN_SET shift to state 593
-- On box_list shift to state 604
-- On box shift to state 687
## Reductions:
-- On INITIAL
--   reduce production box_list ->

State 593:
## Known stack suffix:
## OPEN_SET
## LR(1) items:
box -> OPEN_SET . IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On IDENT shift to state 594
## Reductions:

State 594:
## Known stack suffix:
## OPEN_SET IDENT
## LR(1) items:
box -> OPEN_SET IDENT . OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On OPEN_BRACKET shift to state 595
## Reductions:

State 595:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET . IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On IDENT shift to state 596
## Reductions:

State 596:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET IDENT
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET IDENT . CLOSE_BRACKET COLON node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On CLOSE_BRACKET shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET . COLON node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On COLON shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON . node_id_list CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On IDENT shift to state 599
-- On node_id_list shift to state 602
## Reductions:

State 599:
## Known stack suffix:
## IDENT
## LR(1) items:
node_id_list -> IDENT . [ EDGES CLOSE_SET ]
node_id_list -> IDENT . COMMA node_id_list [ EDGES CLOSE_SET ]
## Transitions:
-- On COMMA shift to state 600
## Reductions:
-- On EDGES CLOSE_SET
--   reduce production node_id_list -> IDENT

State 600:
## Known stack suffix:
## IDENT COMMA
## LR(1) items:
node_id_list -> IDENT COMMA . node_id_list [ EDGES CLOSE_SET ]
## Transitions:
-- On IDENT shift to state 599
-- On node_id_list shift to state 601
## Reductions:

State 601:
## Known stack suffix:
## IDENT COMMA node_id_list
## LR(1) items:
node_id_list -> IDENT COMMA node_id_list . [ EDGES CLOSE_SET ]
## Transitions:
## Reductions:
-- On EDGES CLOSE_SET
--   reduce production node_id_list -> IDENT COMMA node_id_list

State 602:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list . CLOSE_SET [ OPEN_SET INITIAL ]
## Transitions:
-- On CLOSE_SET shift to state 603
## Reductions:

State 603:
## Known stack suffix:
## OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET
## LR(1) items:
box -> OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET . [ OPEN_SET INITIAL ]
## Transitions:
## Reductions:
-- On OPEN_SET INITIAL
--   reduce production box -> OPEN_SET IDENT OPEN_BRACKET IDENT CLOSE_BRACKET COLON node_id_list CLOSE_SET

State 604:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list . INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On INITIAL shift to state 605
## Reductions:

State 605:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL . COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On COLON shift to state 606
## Reductions:

State 606:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON . node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On IDENT shift to state 599
-- On node_id_list shift to state 607
## Reductions:

State 607:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list . EDGES COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On EDGES shift to state 608
## Reductions:

State 608:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES . COLON edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On COLON shift to state 609
## Reductions:

State 609:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON . edge_list ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On OPEN_BRACKET shift to state 610
-- On IDENT shift to state 629
-- On edge_list shift to state 638
-- On edge shift to state 685
## Reductions:

State 610:
## Known stack suffix:
## OPEN_BRACKET
## LR(1) items:
edge -> OPEN_BRACKET . IDENT EDGE_ARROW IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
edge -> OPEN_BRACKET . IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On IDENT shift to state 611
## Reductions:

State 611:
## Known stack suffix:
## OPEN_BRACKET IDENT
## LR(1) items:
edge -> OPEN_BRACKET IDENT . EDGE_ARROW IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
edge -> OPEN_BRACKET IDENT . EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On EDGE_ARROW_OPEN shift to state 612
-- On EDGE_ARROW shift to state 625
## Reductions:

State 612:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN . trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On NUMBER shift to state 613
-- On trans_list shift to state 617
-- On trans shift to state 622
## Reductions:

State 613:
## Known stack suffix:
## NUMBER
## LR(1) items:
trans -> NUMBER . OPEN_PAREN IDENT CLOSE_PAREN [ EDGE_ARROW_CLOSE COMMA ]
## Transitions:
-- On OPEN_PAREN shift to state 614
## Reductions:

State 614:
## Known stack suffix:
## NUMBER OPEN_PAREN
## LR(1) items:
trans -> NUMBER OPEN_PAREN . IDENT CLOSE_PAREN [ EDGE_ARROW_CLOSE COMMA ]
## Transitions:
-- On IDENT shift to state 615
## Reductions:

State 615:
## Known stack suffix:
## NUMBER OPEN_PAREN IDENT
## LR(1) items:
trans -> NUMBER OPEN_PAREN IDENT . CLOSE_PAREN [ EDGE_ARROW_CLOSE COMMA ]
## Transitions:
-- On CLOSE_PAREN shift to state 616
## Reductions:

State 616:
## Known stack suffix:
## NUMBER OPEN_PAREN IDENT CLOSE_PAREN
## LR(1) items:
trans -> NUMBER OPEN_PAREN IDENT CLOSE_PAREN . [ EDGE_ARROW_CLOSE COMMA ]
## Transitions:
## Reductions:
-- On EDGE_ARROW_CLOSE COMMA
--   reduce production trans -> NUMBER OPEN_PAREN IDENT CLOSE_PAREN

State 617:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list . EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On EDGE_ARROW_CLOSE shift to state 618
## Reductions:

State 618:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE . IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On IDENT shift to state 619
## Reductions:

State 619:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT . CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On CLOSE_BRACKET shift to state 620
## Reductions:

State 620:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET . SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On SEMICOLON shift to state 621
## Reductions:

State 621:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON . [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
## Reductions:
-- On OPEN_BRACKET IDENT ACCEPTANCE
--   reduce production edge -> OPEN_BRACKET IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT CLOSE_BRACKET SEMICOLON

State 622:
## Known stack suffix:
## trans
## LR(1) items:
trans_list -> trans . [ EDGE_ARROW_CLOSE ]
trans_list -> trans . COMMA trans_list [ EDGE_ARROW_CLOSE ]
## Transitions:
-- On COMMA shift to state 623
## Reductions:
-- On EDGE_ARROW_CLOSE
--   reduce production trans_list -> trans

State 623:
## Known stack suffix:
## trans COMMA
## LR(1) items:
trans_list -> trans COMMA . trans_list [ EDGE_ARROW_CLOSE ]
## Transitions:
-- On NUMBER shift to state 613
-- On trans_list shift to state 624
-- On trans shift to state 622
## Reductions:

State 624:
## Known stack suffix:
## trans COMMA trans_list
## LR(1) items:
trans_list -> trans COMMA trans_list . [ EDGE_ARROW_CLOSE ]
## Transitions:
## Reductions:
-- On EDGE_ARROW_CLOSE
--   reduce production trans_list -> trans COMMA trans_list

State 625:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW . IDENT CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On IDENT shift to state 626
## Reductions:

State 626:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW IDENT
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW IDENT . CLOSE_BRACKET SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On CLOSE_BRACKET shift to state 627
## Reductions:

State 627:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW IDENT CLOSE_BRACKET
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW IDENT CLOSE_BRACKET . SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On SEMICOLON shift to state 628
## Reductions:

State 628:
## Known stack suffix:
## OPEN_BRACKET IDENT EDGE_ARROW IDENT CLOSE_BRACKET SEMICOLON
## LR(1) items:
edge -> OPEN_BRACKET IDENT EDGE_ARROW IDENT CLOSE_BRACKET SEMICOLON . [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
## Reductions:
-- On OPEN_BRACKET IDENT ACCEPTANCE
--   reduce production edge -> OPEN_BRACKET IDENT EDGE_ARROW IDENT CLOSE_BRACKET SEMICOLON

State 629:
## Known stack suffix:
## IDENT
## LR(1) items:
edge -> IDENT . EDGE_ARROW IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
edge -> IDENT . EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On EDGE_ARROW_OPEN shift to state 630
-- On EDGE_ARROW shift to state 635
## Reductions:

State 630:
## Known stack suffix:
## IDENT EDGE_ARROW_OPEN
## LR(1) items:
edge -> IDENT EDGE_ARROW_OPEN . trans_list EDGE_ARROW_CLOSE IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On NUMBER shift to state 613
-- On trans_list shift to state 631
-- On trans shift to state 622
## Reductions:

State 631:
## Known stack suffix:
## IDENT EDGE_ARROW_OPEN trans_list
## LR(1) items:
edge -> IDENT EDGE_ARROW_OPEN trans_list . EDGE_ARROW_CLOSE IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On EDGE_ARROW_CLOSE shift to state 632
## Reductions:

State 632:
## Known stack suffix:
## IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE
## LR(1) items:
edge -> IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE . IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On IDENT shift to state 633
## Reductions:

State 633:
## Known stack suffix:
## IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT
## LR(1) items:
edge -> IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT . SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On SEMICOLON shift to state 634
## Reductions:

State 634:
## Known stack suffix:
## IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT SEMICOLON
## LR(1) items:
edge -> IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT SEMICOLON . [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
## Reductions:
-- On OPEN_BRACKET IDENT ACCEPTANCE
--   reduce production edge -> IDENT EDGE_ARROW_OPEN trans_list EDGE_ARROW_CLOSE IDENT SEMICOLON

State 635:
## Known stack suffix:
## IDENT EDGE_ARROW
## LR(1) items:
edge -> IDENT EDGE_ARROW . IDENT SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On IDENT shift to state 636
## Reductions:

State 636:
## Known stack suffix:
## IDENT EDGE_ARROW IDENT
## LR(1) items:
edge -> IDENT EDGE_ARROW IDENT . SEMICOLON [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
-- On SEMICOLON shift to state 637
## Reductions:

State 637:
## Known stack suffix:
## IDENT EDGE_ARROW IDENT SEMICOLON
## LR(1) items:
edge -> IDENT EDGE_ARROW IDENT SEMICOLON . [ OPEN_BRACKET IDENT ACCEPTANCE ]
## Transitions:
## Reductions:
-- On OPEN_BRACKET IDENT ACCEPTANCE
--   reduce production edge -> IDENT EDGE_ARROW IDENT SEMICOLON

State 638:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list . ACCEPTANCE COLON acceptance_list [ # ]
## Transitions:
-- On ACCEPTANCE shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE . COLON acceptance_list [ # ]
## Transitions:
-- On COLON shift to state 640
## Reductions:

State 640:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON . acceptance_list [ # ]
## Transitions:
-- On OPEN_ANGLE shift to state 641
-- On acceptance_list shift to state 682
-- On acceptance shift to state 683
## Reductions:

State 641:
## Known stack suffix:
## OPEN_ANGLE
## LR(1) items:
acceptance -> OPEN_ANGLE . BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On BAD shift to state 642
## Reductions:

State 642:
## Known stack suffix:
## OPEN_ANGLE BAD
## LR(1) items:
acceptance -> OPEN_ANGLE BAD . COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On COLON shift to state 643
## Reductions:

State 643:
## Known stack suffix:
## OPEN_ANGLE BAD COLON
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON . OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_SET shift to state 644
## Reductions:

State 644:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET . accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_PAREN shift to state 645
-- On accept_edge_list shift to state 652
-- On accept_edge shift to state 679
## Reductions:
-- On CLOSE_SET
--   reduce production accept_edge_list ->

State 645:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
accept_edge -> OPEN_PAREN . IDENT COMMA IDENT COMMA IDENT CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On IDENT shift to state 646
## Reductions:

State 646:
## Known stack suffix:
## OPEN_PAREN IDENT
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT . COMMA IDENT COMMA IDENT CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On COMMA shift to state 647
## Reductions:

State 647:
## Known stack suffix:
## OPEN_PAREN IDENT COMMA
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT COMMA . IDENT COMMA IDENT CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On IDENT shift to state 648
## Reductions:

State 648:
## Known stack suffix:
## OPEN_PAREN IDENT COMMA IDENT
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT COMMA IDENT . COMMA IDENT CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On COMMA shift to state 649
## Reductions:

State 649:
## Known stack suffix:
## OPEN_PAREN IDENT COMMA IDENT COMMA
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT COMMA IDENT COMMA . IDENT CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On IDENT shift to state 650
## Reductions:

State 650:
## Known stack suffix:
## OPEN_PAREN IDENT COMMA IDENT COMMA IDENT
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT COMMA IDENT COMMA IDENT . CLOSE_PAREN [ COMMA CLOSE_SET ]
## Transitions:
-- On CLOSE_PAREN shift to state 651
## Reductions:

State 651:
## Known stack suffix:
## OPEN_PAREN IDENT COMMA IDENT COMMA IDENT CLOSE_PAREN
## LR(1) items:
accept_edge -> OPEN_PAREN IDENT COMMA IDENT COMMA IDENT CLOSE_PAREN . [ COMMA CLOSE_SET ]
## Transitions:
## Reductions:
-- On COMMA CLOSE_SET
--   reduce production accept_edge -> OPEN_PAREN IDENT COMMA IDENT COMMA IDENT CLOSE_PAREN

State 652:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list . CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On CLOSE_SET shift to state 653
## Reductions:

State 653:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET . SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On SEMICOLON shift to state 654
## Reductions:

State 654:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON . GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On GOOD shift to state 655
## Reductions:

State 655:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD . COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On COLON shift to state 656
## Reductions:

State 656:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON . OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_SET shift to state 657
## Reductions:

State 657:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET . accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_PAREN shift to state 645
-- On accept_edge_list shift to state 658
-- On accept_edge shift to state 679
## Reductions:
-- On CLOSE_SET
--   reduce production accept_edge_list ->

State 658:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list . CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On CLOSE_SET shift to state 659
## Reductions:

State 659:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET . SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On SEMICOLON shift to state 660
## Reductions:

State 660:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON . OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_BRACKET shift to state 661
## Reductions:

State 661:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET . delta_list CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On OPEN_PAREN shift to state 662
-- On delta_list shift to state 673
-- On delta shift to state 676
## Reductions:

State 662:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
delta -> OPEN_PAREN . term COMMA wf_op CLOSE_PAREN [ SEMICOLON CLOSE_BRACKET ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 663
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 663:
## Known stack suffix:
## OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
delta -> OPEN_PAREN term . COMMA wf_op CLOSE_PAREN [ SEMICOLON CLOSE_BRACKET ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On DOT shift to state 131
-- On COMMA shift to state 664
## Reductions:

State 664:
## Known stack suffix:
## OPEN_PAREN term COMMA
## LR(1) items:
delta -> OPEN_PAREN term COMMA . wf_op CLOSE_PAREN [ SEMICOLON CLOSE_BRACKET ]
## Transitions:
-- On WF_TIDSUBSET shift to state 665
-- On WF_PAIRSUBSET shift to state 666
-- On WF_INTSUBSET shift to state 667
-- On WF_INTLESS shift to state 668
-- On WF_ELEMSUBSET shift to state 669
-- On WF_ADDRSUBSET shift to state 670
-- On wf_op shift to state 671
## Reductions:

State 665:
## Known stack suffix:
## WF_TIDSUBSET
## LR(1) items:
wf_op -> WF_TIDSUBSET . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_TIDSUBSET

State 666:
## Known stack suffix:
## WF_PAIRSUBSET
## LR(1) items:
wf_op -> WF_PAIRSUBSET . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_PAIRSUBSET

State 667:
## Known stack suffix:
## WF_INTSUBSET
## LR(1) items:
wf_op -> WF_INTSUBSET . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_INTSUBSET

State 668:
## Known stack suffix:
## WF_INTLESS
## LR(1) items:
wf_op -> WF_INTLESS . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_INTLESS

State 669:
## Known stack suffix:
## WF_ELEMSUBSET
## LR(1) items:
wf_op -> WF_ELEMSUBSET . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_ELEMSUBSET

State 670:
## Known stack suffix:
## WF_ADDRSUBSET
## LR(1) items:
wf_op -> WF_ADDRSUBSET . [ CLOSE_PAREN ]
## Transitions:
## Reductions:
-- On CLOSE_PAREN
--   reduce production wf_op -> WF_ADDRSUBSET

State 671:
## Known stack suffix:
## OPEN_PAREN term COMMA wf_op
## LR(1) items:
delta -> OPEN_PAREN term COMMA wf_op . CLOSE_PAREN [ SEMICOLON CLOSE_BRACKET ]
## Transitions:
-- On CLOSE_PAREN shift to state 672
## Reductions:

State 672:
## Known stack suffix:
## OPEN_PAREN term COMMA wf_op CLOSE_PAREN
## LR(1) items:
delta -> OPEN_PAREN term COMMA wf_op CLOSE_PAREN . [ SEMICOLON CLOSE_BRACKET ]
## Transitions:
## Reductions:
-- On SEMICOLON CLOSE_BRACKET
--   reduce production delta -> OPEN_PAREN term COMMA wf_op CLOSE_PAREN

State 673:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list . CLOSE_BRACKET CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On CLOSE_BRACKET shift to state 674
## Reductions:

State 674:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET . CLOSE_ANGLE [ OPEN_ANGLE # ]
## Transitions:
-- On CLOSE_ANGLE shift to state 675
## Reductions:

State 675:
## Known stack suffix:
## OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE
## LR(1) items:
acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE . [ OPEN_ANGLE # ]
## Transitions:
## Reductions:
-- On OPEN_ANGLE #
--   reduce production acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE
** End-of-stream conflict on OPEN_ANGLE
**   There is a tension between
**   (1) reducing production acceptance -> OPEN_ANGLE BAD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON GOOD COLON OPEN_SET accept_edge_list CLOSE_SET SEMICOLON OPEN_BRACKET delta_list CLOSE_BRACKET CLOSE_ANGLE
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 676:
## Known stack suffix:
## delta
## LR(1) items:
delta_list -> delta . [ CLOSE_BRACKET ]
delta_list -> delta . SEMICOLON delta_list [ CLOSE_BRACKET ]
## Transitions:
-- On SEMICOLON shift to state 677
## Reductions:
-- On CLOSE_BRACKET
--   reduce production delta_list -> delta

State 677:
## Known stack suffix:
## delta SEMICOLON
## LR(1) items:
delta_list -> delta SEMICOLON . delta_list [ CLOSE_BRACKET ]
## Transitions:
-- On OPEN_PAREN shift to state 662
-- On delta_list shift to state 678
-- On delta shift to state 676
## Reductions:

State 678:
## Known stack suffix:
## delta SEMICOLON delta_list
## LR(1) items:
delta_list -> delta SEMICOLON delta_list . [ CLOSE_BRACKET ]
## Transitions:
## Reductions:
-- On CLOSE_BRACKET
--   reduce production delta_list -> delta SEMICOLON delta_list

State 679:
## Known stack suffix:
## accept_edge
## LR(1) items:
accept_edge_list -> accept_edge . [ CLOSE_SET ]
accept_edge_list -> accept_edge . COMMA accept_edge_list [ CLOSE_SET ]
## Transitions:
-- On COMMA shift to state 680
## Reductions:
-- On CLOSE_SET
--   reduce production accept_edge_list -> accept_edge

State 680:
## Known stack suffix:
## accept_edge COMMA
## LR(1) items:
accept_edge_list -> accept_edge COMMA . accept_edge_list [ CLOSE_SET ]
## Transitions:
-- On OPEN_PAREN shift to state 645
-- On accept_edge_list shift to state 681
-- On accept_edge shift to state 679
## Reductions:
-- On CLOSE_SET
--   reduce production accept_edge_list ->

State 681:
## Known stack suffix:
## accept_edge COMMA accept_edge_list
## LR(1) items:
accept_edge_list -> accept_edge COMMA accept_edge_list . [ CLOSE_SET ]
## Transitions:
## Reductions:
-- On CLOSE_SET
--   reduce production accept_edge_list -> accept_edge COMMA accept_edge_list

State 682:
## Known stack suffix:
## DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list
## LR(1) items:
pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production pvd -> DIAGRAM OPEN_BRACKET IDENT CLOSE_BRACKET NODES COLON node_list BOXES COLON box_list INITIAL COLON node_id_list EDGES COLON edge_list ACCEPTANCE COLON acceptance_list

State 683:
## Known stack suffix:
## acceptance
## LR(1) items:
acceptance_list -> acceptance . [ # ]
acceptance_list -> acceptance . acceptance_list [ # ]
## Transitions:
-- On OPEN_ANGLE shift to state 641
-- On acceptance_list shift to state 684
-- On acceptance shift to state 683
## Reductions:
-- On #
--   reduce production acceptance_list -> acceptance
** End-of-stream conflict on OPEN_ANGLE
**   There is a tension between
**   (1) reducing production acceptance_list -> acceptance
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 684:
## Known stack suffix:
## acceptance acceptance_list
## LR(1) items:
acceptance_list -> acceptance acceptance_list . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production acceptance_list -> acceptance acceptance_list

State 685:
## Known stack suffix:
## edge
## LR(1) items:
edge_list -> edge . [ ACCEPTANCE ]
edge_list -> edge . edge_list [ ACCEPTANCE ]
## Transitions:
-- On OPEN_BRACKET shift to state 610
-- On IDENT shift to state 629
-- On edge_list shift to state 686
-- On edge shift to state 685
## Reductions:
-- On ACCEPTANCE
--   reduce production edge_list -> edge

State 686:
## Known stack suffix:
## edge edge_list
## LR(1) items:
edge_list -> edge edge_list . [ ACCEPTANCE ]
## Transitions:
## Reductions:
-- On ACCEPTANCE
--   reduce production edge_list -> edge edge_list

State 687:
## Known stack suffix:
## box
## LR(1) items:
box_list -> box . box_list [ INITIAL ]
## Transitions:
-- On OPEN_SET shift to state 593
-- On box_list shift to state 688
-- On box shift to state 687
## Reductions:
-- On INITIAL
--   reduce production box_list ->

State 688:
## Known stack suffix:
## box box_list
## LR(1) items:
box_list -> box box_list . [ INITIAL ]
## Transitions:
## Reductions:
-- On INITIAL
--   reduce production box_list -> box box_list

State 689:
## Known stack suffix:
## node
## LR(1) items:
node_list -> node . [ BOXES ]
node_list -> node . COMMA node_list [ BOXES ]
## Transitions:
-- On COMMA shift to state 690
## Reductions:
-- On BOXES
--   reduce production node_list -> node

State 690:
## Known stack suffix:
## node COMMA
## LR(1) items:
node_list -> node COMMA . node_list [ BOXES ]
## Transitions:
-- On IDENT shift to state 586
-- On node_list shift to state 691
-- On node shift to state 689
## Reductions:

State 691:
## Known stack suffix:
## node COMMA node_list
## LR(1) items:
node_list -> node COMMA node_list . [ BOXES ]
## Transitions:
## Reductions:
-- On BOXES
--   reduce production node_list -> node COMMA node_list

State 692:
## Known stack suffix:
## pvd
## LR(1) items:
pvd' -> pvd . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept pvd

State 693:
## Known stack suffix:
##
## LR(1) items:
single_formula' -> . single_formula [ # ]
## Transitions:
-- On VARS shift to state 1
-- On single_formula shift to state 694
-- On param shift to state 695
## Reductions:

State 694:
## Known stack suffix:
## single_formula
## LR(1) items:
single_formula' -> single_formula . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept single_formula

State 695:
## Known stack suffix:
## param
## LR(1) items:
single_formula -> param . COLON inv_var_declarations FORMULA COLON formula [ # ]
## Transitions:
-- On COLON shift to state 696
## Reductions:

State 696:
## Known stack suffix:
## param COLON
## LR(1) items:
single_formula -> param COLON . inv_var_declarations FORMULA COLON formula [ # ]
## Transitions:
-- On IDENT shift to state 4
-- On inv_var_declarations shift to state 697
-- On inv_var_decl_list shift to state 564
-- On inv_var_decl shift to state 565
## Reductions:
-- On FORMULA
--   reduce production inv_var_declarations ->

State 697:
## Known stack suffix:
## param COLON inv_var_declarations
## LR(1) items:
single_formula -> param COLON inv_var_declarations . FORMULA COLON formula [ # ]
## Transitions:
-- On FORMULA shift to state 698
## Reductions:

State 698:
## Known stack suffix:
## param COLON inv_var_declarations FORMULA
## LR(1) items:
single_formula -> param COLON inv_var_declarations FORMULA . COLON formula [ # ]
## Transitions:
-- On COLON shift to state 699
## Reductions:

State 699:
## Known stack suffix:
## param COLON inv_var_declarations FORMULA COLON
## LR(1) items:
single_formula -> param COLON inv_var_declarations FORMULA COLON . formula [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 700
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 700:
## Known stack suffix:
## param COLON inv_var_declarations FORMULA COLON formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS # ]
single_formula -> param COLON inv_var_declarations FORMULA COLON formula . [ # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
## Reductions:
-- On #
--   reduce production single_formula -> param COLON inv_var_declarations FORMULA COLON formula
** End-of-stream conflict on LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS
**   There is a tension between
**   (1) reducing production single_formula -> param COLON inv_var_declarations FORMULA COLON formula
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 701:
## Known stack suffix:
##
## LR(1) items:
vc_info' -> . vc_info [ # ]
## Transitions:
-- On VARS shift to state 1
-- On vc_info shift to state 702
-- On param shift to state 703
## Reductions:

State 702:
## Known stack suffix:
## vc_info
## LR(1) items:
vc_info' -> vc_info . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept vc_info

State 703:
## Known stack suffix:
## param
## LR(1) items:
vc_info -> param . COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 704
## Reductions:

State 704:
## Known stack suffix:
## param COLON
## LR(1) items:
vc_info -> param COLON . inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On IDENT shift to state 4
-- On inv_var_declarations shift to state 705
-- On inv_var_decl_list shift to state 564
-- On inv_var_decl shift to state 565
## Reductions:
-- On SUPPORT
--   reduce production inv_var_declarations ->

State 705:
## Known stack suffix:
## param COLON inv_var_declarations
## LR(1) items:
vc_info -> param COLON inv_var_declarations . SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On SUPPORT shift to state 706
## Reductions:

State 706:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT . COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 707
## Reductions:

State 707:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON . formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula_list shift to state 708
-- On formula shift to state 730
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:
-- On TID_CONSTRAINT
--   reduce production formula_list ->

State 708:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list . TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On TID_CONSTRAINT shift to state 709
## Reductions:

State 709:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT . COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 710
## Reductions:

State 710:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON . tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid_constraint_list shift to state 711
-- On tid_constraint shift to state 724
-- On tid shift to state 123
-- On term shift to state 727
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On equals shift to state 728
-- On elem shift to state 149
-- On disequals shift to state 729
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:
-- On RHO
--   reduce production tid_constraint_list ->

State 711:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list . RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On RHO shift to state 712
## Reductions:

State 712:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO . COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 713
## Reductions:

State 713:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON . formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 714
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 714:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND GOAL EQUALS ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND GOAL EQUALS ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND GOAL EQUALS ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND GOAL EQUALS ]
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula . GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On GOAL shift to state 715
-- On EQUALS shift to state 556
## Reductions:

State 715:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL . COLON formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON . formula TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula shift to state 717
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 717:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ TRANSITION_TID LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ TRANSITION_TID LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ TRANSITION_TID LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ TRANSITION_TID LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula . TRANSITION_TID COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On TRANSITION_TID shift to state 718
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_AND shift to state 554
-- On EQUALS shift to state 556
## Reductions:

State 718:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID . COLON term LINE COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 719
## Reductions:

State 719:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON . term LINE COLON NUMBER [ # ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 720
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On elem shift to state 149
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:

State 720:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
addr -> term . DOT BINIT [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
addr -> term . DOT BEND [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
addrarr -> term . DOT ARR [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
elem -> term . DOT DATA [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . MATH_MULT term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . MATH_DIV term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . MATH_MOD term [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
integer -> term . DOT MAX [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
mark -> term . DOT MARKED [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
set -> term . DOT BREGION [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
tid -> term . DOT LOCKID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
tid -> term . DOT BTID [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LINE DOT ]
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term . LINE COLON NUMBER [ # ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On LINE shift to state 721
-- On DOT shift to state 131
## Reductions:

State 721:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE . COLON NUMBER [ # ]
## Transitions:
-- On COLON shift to state 722
## Reductions:

State 722:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON . NUMBER [ # ]
## Transitions:
-- On NUMBER shift to state 723
## Reductions:

State 723:
## Known stack suffix:
## param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER
## LR(1) items:
vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production vc_info -> param COLON inv_var_declarations SUPPORT COLON formula_list TID_CONSTRAINT COLON tid_constraint_list RHO COLON formula GOAL COLON formula TRANSITION_TID COLON term LINE COLON NUMBER

State 724:
## Known stack suffix:
## tid_constraint
## LR(1) items:
tid_constraint_list -> tid_constraint . SEMICOLON tid_constraint_list [ RHO ]
## Transitions:
-- On SEMICOLON shift to state 725
## Reductions:

State 725:
## Known stack suffix:
## tid_constraint SEMICOLON
## LR(1) items:
tid_constraint_list -> tid_constraint SEMICOLON . tid_constraint_list [ RHO ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On PATH2SET shift to state 65
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 68
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On ARR_UPDATE shift to state 118
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid_constraint_list shift to state 726
-- On tid_constraint shift to state 724
-- On tid shift to state 123
-- On term shift to state 727
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On integer shift to state 147
-- On ident shift to state 148
-- On equals shift to state 728
-- On elem shift to state 149
-- On disequals shift to state 729
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:
-- On RHO
--   reduce production tid_constraint_list ->

State 726:
## Known stack suffix:
## tid_constraint SEMICOLON tid_constraint_list
## LR(1) items:
tid_constraint_list -> tid_constraint SEMICOLON tid_constraint_list . [ RHO ]
## Transitions:
## Reductions:
-- On RHO
--   reduce production tid_constraint_list -> tid_constraint SEMICOLON tid_constraint_list

State 727:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
addr -> term . DOT BINIT [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
addr -> term . DOT BEND [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
addrarr -> term . DOT ARR [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
arrays -> term . OPEN_BRACKET term CLOSE_BRACKET [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
cell -> term . DOT LOCK OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
cell -> term . DOT LOCKAT OPEN_PAREN term COMMA term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCK [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCKAT OPEN_PAREN term CLOSE_PAREN [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ SEMICOLON ]
elem -> term . DOT DATA [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
equals -> term . EQUALS term [ SEMICOLON ]
integer -> term . MATH_PLUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
integer -> term . MATH_MINUS term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
integer -> term . MATH_MULT term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
integer -> term . MATH_DIV term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
integer -> term . MATH_MOD term [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
integer -> term . DOT MAX [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
mark -> term . DOT MARKED [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
set -> term . DOT BREGION [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
tid -> term . DOT LOCKID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
tid -> term . DOT BTID [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
tidarr -> term . DOT TIDS [ OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV EQUALS DOT ]
## Transitions:
-- On OPEN_BRACKET shift to state 125
-- On NOT_EQUALS shift to state 532
-- On MATH_PLUS shift to state 127
-- On MATH_MULT shift to state 129
-- On MATH_MOD shift to state 135
-- On MATH_MINUS shift to state 155
-- On MATH_DIV shift to state 157
-- On EQUALS shift to state 542
-- On DOT shift to state 131
## Reductions:

State 728:
## Known stack suffix:
## equals
## LR(1) items:
tid_constraint -> equals . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production tid_constraint -> equals

State 729:
## Known stack suffix:
## disequals
## LR(1) items:
tid_constraint -> disequals . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production tid_constraint -> disequals

State 730:
## Known stack suffix:
## formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET ]
formula -> formula . LOGICAL_OR formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET ]
formula -> formula . LOGICAL_THEN formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET ]
formula -> formula . EQUALS formula [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TID_CONSTRAINT TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNIQUETID SETPAIRUNIQUEINT SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRLOWER SETPAIRINTR SETPAIRINTIDPAIR SETPAIRININTPAIR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETLOWER SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN OPEN_BRACKET NUMBER NULL MKCELL MKBUCKET MEMORY_READ MATH_MINUS MARK_T MARK_F LOWEST_ELEM LOGICAL_TRUE LOGICAL_THEN LOGICAL_OR LOGICAL_NOT LOGICAL_FALSE LOGICAL_AND LOCKSET LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HASHTBL GETP FIRSTLOCKED ERROR EQUALS EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET DOT AT ARR_UPDATE APPEND ADDR2SET ]
formula_list -> formula . formula_list [ TID_CONSTRAINT ]
## Transitions:
-- On UPDATE shift to state 13
-- On UNLOCK shift to state 15
-- On UNIONTH shift to state 17
-- On UNIONINT shift to state 19
-- On UNIONELEM shift to state 21
-- On UNION shift to state 23
-- On TIDOF shift to state 25
-- On SUBSETEQTH shift to state 373
-- On SUBSETEQINT shift to state 379
-- On SUBSETEQELEM shift to state 385
-- On SUBSETEQ shift to state 391
-- On SKIPLIST shift to state 397
-- On SINGLETH shift to state 27
-- On SINGLEINT shift to state 29
-- On SINGLEELEM shift to state 31
-- On SHARP shift to state 33
-- On SETPAIRUNIQUETID shift to state 414
-- On SETPAIRUNIQUEINT shift to state 418
-- On SETPAIRUNION shift to state 34
-- On SETPAIRSUBSETEQ shift to state 422
-- On SETPAIRSINGLE shift to state 36
-- On SETPAIRMIN shift to state 38
-- On SETPAIRMAX shift to state 40
-- On SETPAIRLOWER shift to state 42
-- On SETPAIRINTR shift to state 44
-- On SETPAIRINTIDPAIR shift to state 428
-- On SETPAIRININTPAIR shift to state 434
-- On SETPAIRIN shift to state 440
-- On SETPAIREMPTY shift to state 46
-- On SETPAIRDIFF shift to state 47
-- On SETLOWER shift to state 49
-- On SETINTMIN shift to state 51
-- On SETINTMAX shift to state 53
-- On SETDIFFTH shift to state 55
-- On SETDIFFINT shift to state 57
-- On SETDIFFELEM shift to state 59
-- On SETDIFF shift to state 61
-- On SET2ELEM shift to state 63
-- On REACH shift to state 446
-- On PATH2SET shift to state 65
-- On ORDERLIST shift to state 459
-- On OPEN_SET shift to state 67
-- On OPEN_PAREN shift to state 467
-- On OPEN_BRACKET shift to state 69
-- On NUMBER shift to state 70
-- On NULL shift to state 71
-- On MKCELL shift to state 72
-- On MKBUCKET shift to state 74
-- On MEMORY_READ shift to state 76
-- On MATH_MINUS shift to state 78
-- On MARK_T shift to state 79
-- On MARK_F shift to state 80
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 468
-- On LOGICAL_THEN shift to state 550
-- On LOGICAL_OR shift to state 552
-- On LOGICAL_NOT shift to state 469
-- On LOGICAL_FALSE shift to state 470
-- On LOGICAL_AND shift to state 554
-- On LOCKSET shift to state 82
-- On LOCK shift to state 84
-- On LASTLOCKED shift to state 86
-- On INTRTH shift to state 88
-- On INTRINT shift to state 90
-- On INTRELEM shift to state 92
-- On INTR shift to state 94
-- On INTOF shift to state 96
-- On INTH shift to state 471
-- On ININT shift to state 477
-- On INELEM shift to state 483
-- On IN shift to state 489
-- On IDENT shift to state 98
-- On HIGHEST_ELEM shift to state 107
-- On HASHTBL shift to state 495
-- On GETP shift to state 108
-- On FIRSTLOCKED shift to state 110
-- On ERROR shift to state 112
-- On EQUALS shift to state 556
-- On EPSILON shift to state 113
-- On EMPTYSETTH shift to state 114
-- On EMPTYSETINT shift to state 115
-- On EMPTYSETELEM shift to state 116
-- On EMPTYSET shift to state 117
-- On DOT shift to state 507
-- On AT shift to state 515
-- On ARR_UPDATE shift to state 118
-- On APPEND shift to state 523
-- On ADDR2SET shift to state 120
-- On tidarr shift to state 122
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 137
-- On setpair shift to state 138
-- On setint shift to state 139
-- On setelem shift to state 140
-- On set shift to state 141
-- On path shift to state 142
-- On pair shift to state 143
-- On mem shift to state 144
-- On mark shift to state 145
-- On lock shift to state 146
-- On literal shift to state 544
-- On integer shift to state 147
-- On ident shift to state 148
-- On formula_list shift to state 731
-- On formula shift to state 730
-- On equals shift to state 546
-- On elem shift to state 149
-- On disequals shift to state 547
-- On cell shift to state 150
-- On bucket shift to state 151
-- On arrays shift to state 152
-- On addrarr shift to state 153
-- On addr shift to state 154
## Reductions:
-- On TID_CONSTRAINT
--   reduce production formula_list ->

State 731:
## Known stack suffix:
## formula formula_list
## LR(1) items:
formula_list -> formula formula_list . [ TID_CONSTRAINT ]
## Transitions:
## Reductions:
-- On TID_CONSTRAINT
--   reduce production formula_list -> formula formula_list

