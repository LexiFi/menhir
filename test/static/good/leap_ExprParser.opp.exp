File "leap_ExprParser.mly", line 515, characters 7-13:
Warning: the token ASSIGN is unused.
File "leap_ExprParser.mly", line 506, characters 40-49:
Warning: the token BARRAYUPD is unused.
File "leap_ExprParser.mly", line 480, characters 7-12:
Warning: the token BEGIN is unused.
File "leap_ExprParser.mly", line 480, characters 13-16:
Warning: the token END is unused.
File "leap_ExprParser.mly", line 530, characters 7-10:
Warning: the token EOF is unused.
File "leap_ExprParser.mly", line 552, characters 10-25:
Warning: the token GHOST_DELIMITER is unused.
File "leap_ExprParser.mly", line 516, characters 55-66:
Warning: the token LOGICAL_IFF is unused.
File "leap_ExprParser.mly", line 504, characters 7-13:
Warning: the token THREAD is unused.
File "leap_ExprParser.mly", line 522, characters 10-20:
Warning: the token UNDERSCORE is unused.
File "leap_ExprParser.mly", line 513, characters 7-19:
Warning: the token VERTICAL_BAR is unused.
%{

(***********************************************************************)
(*                                                                     *)
(*                                 LEAP                                *)
(*                                                                     *)
(*               Alejandro Sanchez, IMDEA Software Institute           *)
(*                                                                     *)
(*                                                                     *)
(*      Copyright 2011 IMDEA Software Institute                        *)
(*                                                                     *)
(*  Licensed under the Apache License, Version 2.0 (the "License");    *)
(*  you may not use this file except in compliance with the License.   *)
(*  You may obtain a copy of the License at                            *)
(*                                                                     *)
(*      http://www.apache.org/licenses/LICENSE-2.0                     *)
(*                                                                     *)
(*  Unless required by applicable law or agreed to in writing,         *)
(*  software distributed under the License is distributed on an        *)
(*  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,       *)
(*  either express or implied.                                         *)
(*  See the License for the specific language governing permissions    *)
(*  and limitations under the License.                                 *)
(*                                                                     *)
(***********************************************************************)

open Printf

open LeapLib
open Global

module E      = Expression
module Symtbl = ExprSymTable

(* ALE: This code should be changed in the future *)

exception WrongType of E.term
exception Sort_mismatch of E.V.id * E.sort * E.sort
exception Boolean_var_expected of E.term
exception Not_sort_name of string
exception Unknown_procedure of string
exception Variable_not_in_procedure of E.V.id * string
exception Unexpected_statement of string
exception Different_argument_length of string * string
exception Wrong_edge_acceptance_argument of string


let invVars = System.empty_var_table ()

let empty_tbl = Hashtbl.create 1

let curr_box_counter = ref 0

let curr_tag : string ref = ref ""


(* Looks for a term sort in the global and temporal var tables. *)
let get_sort (t:E.term) : E.sort =
  let p = E.term_scope t in
  let gVars = System.get_global !Symtbl.sys in
  let (iVars,lVars) = match p with
                        E.V.Scope proc  -> (System.get_input_by_name !Symtbl.sys proc,
                                             System.get_local_by_name !Symtbl.sys proc)
                      | E.V.GlobalScope -> (System.empty_var_table (),
                                             System.empty_var_table ())
  in
    System.get_sort_from_term gVars iVars lVars invVars t


(* Parsing error message function *)
let parser_error (msg:string) =
  let msg = sprintf "Error at line %i:\n%s" (Global.get_linenum ()) msg in
    raise(ParserError msg)



let parser_typing_error (term:E.term)
                        (a_sort:E.sort)
                        (get_expr:unit -> string) =
  let term_str = (E.term_to_str term) in
  let term_sort_str = (E.sort_to_str (get_sort term)) in
  let sort_str = (E.sort_to_str a_sort) in
  let str_expr = (get_expr ()) in
  let str = sprintf "Term \"%s\" is of sort %s, but it was \
                     expected to be of sort %s in expression \"%s\""
                     term_str term_sort_str sort_str str_expr in
  parser_error str



let parser_types_incompatible (t1:E.term)
                              (t2:E.term)
                              (get_expr_str:unit -> string) =
  let t1_str = (E.term_to_str t1) in
  let s1_str = (E.sort_to_str (get_sort t1)) in
  let t2_str = (E.term_to_str t2) in
  let s2_str = (E.sort_to_str (get_sort t2)) in
  let str_expr = (get_expr_str ()) in
  let str = (Printf.sprintf "Unexpectedly \"%s\" is of type \"%s\" and  \
                             \"%s\" is of type \"%s\", when they should \
                             have the same type in expression \"%s\"."
                            t1_str s1_str t2_str s2_str str_expr) in
    parser_error str



let parser_check_compatibility (t1:E.term)
                               (t2:E.term)
                               (get_expr_str:unit -> string) =
  let s1 = get_sort t1 in
  let s2 = get_sort t2 in
    if (s1 != s2) then
      parser_types_incompatible t1 t2 get_expr_str



let parser_check_type checker a_term a_sort get_expr_str =
  try
    checker a_term
  with
    | WrongType(_) -> parser_typing_error a_term a_sort get_expr_str


let decl_inv_var (v:E.V.id) (s:E.sort) (e:E.initVal_t option) : unit =
  System.add_var invVars v s e E.V.Shared E.RealVar



(* Slow way to project: traverse one time per entry. *)
let get_name id = fst id
let get_line id = snd id


let check_sort_var (v:E.V.t) =
  let generic_var = E.VarT (E.build_var (E.V.id v) E.Unknown false E.V.Shared
                                        (E.V.scope v) ~nature:(E.var_nature v)) in
  let knownSort = get_sort generic_var in
    if (knownSort != (E.V.sort v)) then
      begin
        Interface.Err.msg "Mismatch variable type" $
          sprintf "Variable %s is of sort %s, while it is trying to be \
                   assigned to an expression of sort %s"
                    (E.V.id v) (E.sort_to_str knownSort) (E.sort_to_str (E.V.sort v));
        raise(Sort_mismatch((E.V.id v),knownSort,(E.V.sort v)))
      end


let wrong_sort_msg_for (t:E.term) (s:E.sort) =
  Interface.Err.msg "Wrong type" $
  sprintf "A term of sort %s was expected, but term \"%s\" has sort %s."
              (E.sort_to_str s) (E.term_to_str t)
              (E.sort_to_str (get_sort t))


let parser_check_boolean_type (a_term:E.term)
                              (get_expr_str:unit -> string) : E.formula =
  match a_term with
    | E.VarT v -> let var = E.V.set_sort v E.Bool in
                       check_sort_var var;
                       E.boolvar var
    | _           -> parser_typing_error a_term E.Bool get_expr_str


let check_type_int t =
  match t with
      E.IntT i -> i
    | E.VarT v -> let var = E.V.set_sort v E.Int in
                       check_sort_var var;
                       E.VarInt var
    | _           -> raise(WrongType t)


let check_type_pair t =
  match t with
      E.PairT p -> p
    | E.VarT v -> let var = E.V.set_sort v E.Pair in
                       check_sort_var var;
                       E.VarPair var
    | _           -> raise(WrongType t)


let check_type_set t =
  match t with
      E.SetT s -> s
    | E.VarT v -> let var = E.V.set_sort v E.Set in
                       check_sort_var var;
                       E.VarSet var
    | _           -> raise(WrongType t)


let check_type_elem t =
  match t with
      E.ElemT e -> e
    | E.VarT v  -> let var = E.V.set_sort v E.Elem in
                        check_sort_var var;
                        E.VarElem var
    | _            -> raise(WrongType t)


let check_type_tid t =
  match t with
      E.TidT th -> th
    | E.VarT v   -> let var = E.V.set_sort v E.Tid in
                         check_sort_var var;
                         E.VarTh var
    | _             -> raise(WrongType t)


let check_type_addr t =
  match t with
      E.AddrT a -> a
    | E.VarT v  -> let var = E.V.set_sort v E.Addr in
                        check_sort_var var;
                        E.VarAddr var
    | _            -> raise(WrongType t)


let check_type_cell t =
  match t with
      E.CellT c -> c
    | E.VarT v  -> let var = E.V.set_sort v E.Cell in
                        check_sort_var var;
                        E.VarCell var
    | _            -> raise(WrongType t)


let check_type_setth t =
  match t with
      E.SetThT sth -> sth
    | E.VarT v     -> let var = E.V.set_sort v E.SetTh in
                           check_sort_var var;
                           E.VarSetTh var
    | _               -> raise(WrongType t)


let check_type_setint t =
  match t with
      E.SetIntT sth -> sth
    | E.VarT v      -> let var = E.V.set_sort v E.SetInt in
                            check_sort_var var;
                            E.VarSetInt var
    | _                -> raise(WrongType t)


let check_type_setelem t =
  match t with
      E.SetElemT se -> se
    | E.VarT v      -> let var = E.V.set_sort v E.SetElem in
                            check_sort_var var;
                            E.VarSetElem var
    | _                -> raise(WrongType t)


let check_type_setpair t =
  match t with
      E.SetPairT sp -> sp
    | E.VarT v      -> let var = E.V.set_sort v E.SetPair in
                            check_sort_var var;
                            E.VarSetPair var
    | _                -> raise(WrongType t)


let check_type_path t =
  match t with
      E.PathT p -> p
    | E.VarT v  -> let var = E.V.set_sort v E.Path in
                        check_sort_var var;
                        E.VarPath var
    | _            -> raise(WrongType t)


let check_type_mem t =
  match t with
      E.MemT m  -> m
    | E.VarT v  -> let var = E.V.set_sort v E.Mem in
                        check_sort_var var;
                        E.VarMem var
    | _            -> raise(WrongType t)


let check_type_addrarr t =
  match t with
      E.AddrArrayT arr -> arr
    | E.VarT v         -> let var = E.V.set_sort v E.AddrArray in
                               check_sort_var var;
                               E.VarAddrArray var
    | _                   -> raise(WrongType t)


let check_type_tidarr t =
  match t with
      E.TidArrayT arr -> arr
    | E.VarT v        -> let var = E.V.set_sort v E.TidArray in
                              check_sort_var var;
                              E.VarTidArray var
    | _                  -> raise(WrongType t)


let check_type_mark t =
  match t with
      E.MarkT m -> m
    | E.VarT v  -> let var = E.V.set_sort v E.Mark in
                     check_sort_var var;
                     E.VarMark var
    | _         -> raise(WrongType t)


let check_type_bucket t =
  match t with
      E.BucketT b -> b
    | E.VarT v  -> let var = E.V.set_sort v E.Bucket in
                     check_sort_var var;
                     E.VarBucket var
    | _         -> raise(WrongType t)


let check_type_bucketarr t =
  match t with
      E.BucketArrayT arr -> arr
    | E.VarT v  -> let var = E.V.set_sort v E.BucketArray in
                     check_sort_var var;
                     E.VarBucketArray var
    | _         -> raise(WrongType t)


let check_type_lock t =
  match t with
      E.LockT l -> l
    | E.VarT v  -> let var = E.V.set_sort v E.Lock in
                     check_sort_var var;
                     E.VarLock var
    | _         -> raise(WrongType t)


let check_type_lockarr t =
  match t with
      E.LockArrayT arr -> arr
    | E.VarT v  -> let var = E.V.set_sort v E.LockArray in
                     check_sort_var var;
                     E.VarLockArray var
    | _         -> raise(WrongType t)


let check_and_get_sort (id:string) : E.sort =
  match id with
    "tid"       -> E.Tid
  | "elem"      -> E.Elem
  | "addr"      -> E.Addr
  | "cell"      -> E.Cell
  | "mem"       -> E.Mem
  | "path"      -> E.Path
  | "bool"      -> E.Bool
  | "addrSet"   -> E.Set
  | "tidSet"    -> E.SetTh
  | "intSet"    -> E.SetInt
  | "elemSet"   -> E.SetElem
  | "int"       -> E.Int
  | "array"     -> E.Array
  | "addrarr"   -> E.AddrArray
  | "tidarr"    -> E.TidArray
  | "mark"      -> E.Mark
  | "bucket"    -> E.Bucket
  | "bucketarr" -> E.BucketArray
  | "tlock"     -> E.Lock
  | "lockarr"   -> E.LockArray
  | _ -> begin
           Interface.Err.msg "Unrecognized sort" $
             sprintf "A sort was expected, but \"%s\" was found" id;
           raise(Not_sort_name id)
         end


let check_is_procedure (id:string) =
  if not (System.is_proc !Symtbl.sys id) then
    begin
      Interface.Err.msg "Unknown procedure" $
              sprintf "Identifier \"%s\" is used as a procedure identifier, \
                       but no procedure with such name has been parsed." id;
      raise(Unknown_procedure id)
    end


let inject_sort (exp:E.term) : E.term =
  match exp with
    E.VarT v -> let s = get_sort exp in
                   let var = E.V.set_sort v s in
                     begin
                       match s with
                         E.Set         -> E.SetT         (E.VarSet       var)
                       | E.Elem        -> E.ElemT        (E.VarElem      var)
                       | E.Tid         -> E.TidT         (E.VarTh        var)
                       | E.Addr        -> E.AddrT        (E.VarAddr      var)
                       | E.Cell        -> E.CellT        (E.VarCell      var)
                       | E.SetTh       -> E.SetThT       (E.VarSetTh     var)
                       | E.SetInt      -> E.SetIntT      (E.VarSetInt    var)
                       | E.SetElem     -> E.SetElemT     (E.VarSetElem   var)
                       | E.SetPair     -> E.SetPairT     (E.VarSetPair   var)
                       | E.Path        -> E.PathT        (E.VarPath      var)
                       | E.Mem         -> E.MemT         (E.VarMem       var)
                       | E.Bool        -> E.VarT         (var)
                       | E.Int         -> E.IntT         (E.VarInt       var)
                       | E.Pair        -> E.PairT        (E.VarPair      var)
                       | E.Array       -> E.ArrayT       (E.VarArray     var)
                       | E.AddrArray   -> E.AddrArrayT   (E.VarAddrArray var)
                       | E.TidArray    -> E.TidArrayT    (E.VarTidArray  var)
                       | E.BucketArray -> E.BucketArrayT (E.VarBucketArray  var)
                       | E.Mark        -> E.MarkT        (E.VarMark      var)
                       | E.Bucket      -> E.BucketT      (E.VarBucket    var)
                       | E.Lock        -> E.LockT        (E.VarLock      var)
                       | E.LockArray   -> E.LockArrayT   (E.VarLockArray var)
                       | E.Unknown     -> E.VarT         (var)
                     end
  | _           -> exp


let unexpected_statement get_str_expr =
  let str_expr = (get_str_expr()) in
    Interface.Err.msg "Unexpected statement" $
      sprintf "Ghost and atomic statements admit only assignments or \
               conditional statements. However, the following statement \
               was found:\n\n%s\n" str_expr;
    raise(Unexpected_statement str_expr)


let check_var_belongs_to_procedure (v:E.V.id) (p_name:string) =
  let p_info = System.get_proc_by_name !Symtbl.sys p_name in
  let iVars = System.proc_info_get_input p_info in
  let lVars = System.proc_info_get_local p_info in
    if not (System.mem_var iVars v || System.mem_var lVars v) then
      begin
        Interface.Err.msg "Variable not declared in procedure" $
                sprintf "Variable \"%s\" does not belong to procedure %s"
                        v p_name;
        raise(Variable_not_in_procedure(v,p_name))
      end


let check_delta_sort (s:E.sort) : unit =
  match s with
    E.Int    -> ()
  | E.Set    -> ()
  | E.SetTh  -> ()
  | E.SetInt -> ()
  | _        -> Interface.Err.msg "Wrong ranking function sort" $
                  sprintf "By the moment, only expressions of sort %s are \
                           accepted for ranking functions. Instead, an \
                           expression of sort %s was found."
                          (E.sort_to_str E.Int)
                          (E.sort_to_str s)


let define_ident (proc_name:E.V.procedure_name)
                 (id:string)
                 (th:E.V.shared_or_local) : E.term =
      let k = match proc_name with
              | E.V.Scope p ->      check_is_procedure p;
                                    check_var_belongs_to_procedure id p;
                                    let proc_info = System.get_proc_by_name !Symtbl.sys p in
                                    let iVars     = System.proc_info_get_input proc_info in
                                    let lVars     = System.proc_info_get_local proc_info in
                                    if System.mem_var iVars id then
                                      System.find_var_kind iVars id
                                    else
                                      System.find_var_kind lVars id
              | E.V.GlobalScope -> try
                                      let gVars = System.get_global !Symtbl.sys in
                                        System.find_var_kind gVars id
                                    with _ -> E.RealVar in
      inject_sort (E.VarT (E.build_var id E.Unknown false th proc_name ~nature:k))


%}
%start axiom
%start formula
%start invariant
%start pvd
%start single_formula
%start vc_info
%token ACCEPTANCE
%token ADDR2SET
%token APPEND
%token ARR
%token ARR_UPDATE
%token ASSIGN
%token AT
%token AXIOM
%token BAD
%token BARRAYUPD
%token BEGIN
%token BEND
%token BINIT
%token BOXES
%token BREGION
%token BTID
%token CLOSE_ANGLE
%token CLOSE_BRACKET
%token CLOSE_PAREN
%token CLOSE_SET
%token COLON
%token COMMA
%token DATA
%token DIAGRAM
%token DOT
%token DOUBLECOLON
%token EDGES
%token EDGE_ARROW
%token EDGE_ARROW_CLOSE
%token EDGE_ARROW_OPEN
%token EMPTYSET
%token EMPTYSETELEM
%token EMPTYSETINT
%token EMPTYSETTH
%token END
%token EOF
%token EPSILON
%token EQUALS
%token ERROR
%token FIRSTLOCKED
%token FORMULA
%token GETP
%token GOAL
%token GOOD
%token HASHTBL
%token HIGHEST_ELEM
%token <string*int> IDENT
%token IN
%token INELEM
%token ININT
%token INITIAL
%token INTH
%token INTOF
%token INTR
%token INTRELEM
%token INTRINT
%token INTRTH
%token INVARIANT
%token LASTLOCKED
%token LINE
%token LOCK
%token LOCKAT
%token LOCKID
%token LOCKSET
%token LOGICAL_AND
%token LOGICAL_FALSE
%token LOGICAL_IFF
%token LOGICAL_NOT
%token LOGICAL_OR
%token LOGICAL_THEN
%token LOGICAL_TRUE
%token LOWEST_ELEM
%token MARKED
%token MARK_F
%token MARK_T
%token MATH_DIV
%token MATH_GREATER
%token MATH_GREATER_EQ
%token MATH_LESS
%token MATH_LESS_EQ
%token MATH_MINUS
%token MATH_MOD
%token MATH_MULT
%token MATH_PLUS
%token MAX
%token MEMORY_READ
%token MKBUCKET
%token MKCELL
%token NEXT
%token NEXTAT
%token NODES
%token NOT_EQUALS
%token NULL
%token <int> NUMBER
%token OPEN_ANGLE
%token OPEN_BRACKET
%token OPEN_PAREN
%token OPEN_SET
%token ORDERLIST
%token PATH2SET
%token REACH
%token RHO
%token SEMICOLON
%token SET2ELEM
%token SETDIFF
%token SETDIFFELEM
%token SETDIFFINT
%token SETDIFFTH
%token SETINTMAX
%token SETINTMIN
%token SETLOWER
%token SETPAIRDIFF
%token SETPAIREMPTY
%token SETPAIRIN
%token SETPAIRININTPAIR
%token SETPAIRINTIDPAIR
%token SETPAIRINTR
%token SETPAIRLOWER
%token SETPAIRMAX
%token SETPAIRMIN
%token SETPAIRSINGLE
%token SETPAIRSUBSETEQ
%token SETPAIRUNION
%token SETPAIRUNIQUEINT
%token SETPAIRUNIQUETID
%token SHARP
%token SINGLEELEM
%token SINGLEINT
%token SINGLETH
%token SKIPLIST
%token SUBSETEQ
%token SUBSETEQELEM
%token SUBSETEQINT
%token SUBSETEQTH
%token SUPPORT
%token THREAD
%token TIDOF
%token TIDS
%token TID_CONSTRAINT
%token TRANSITION_TID
%token UNDERSCORE
%token UNION
%token UNIONELEM
%token UNIONINT
%token UNIONTH
%token UNLOCK
%token UNLOCKAT
%token UPDATE
%token VARS
%token VERTICAL_BAR
%token WF_ADDRSUBSET
%token WF_ELEMSUBSET
%token WF_INTLESS
%token WF_INTSUBSET
%token WF_PAIRSUBSET
%token WF_TIDSUBSET
%nonassoc EQUALS MATH_GREATER MATH_GREATER_EQ MATH_LESS MATH_LESS_EQ NOT_EQUALS
%nonassoc IDENT
%nonassoc ASSIGN
%right LOGICAL_AND
%right LOGICAL_OR
%right LOGICAL_THEN
%nonassoc LOGICAL_NOT
%left INTR SETDIFF UNION
%left INTRTH SETDIFFTH UNIONTH
%left INTRINT SETDIFFINT UNIONINT
%nonassoc IN SUBSETEQ
%nonassoc INTH SUBSETEQTH
%nonassoc ININT SUBSETEQINT
%nonassoc INELEM SUBSETEQELEM
%nonassoc GHOST_DELIMITER
%nonassoc CLOSE_BRACKET OPEN_BRACKET
%nonassoc CLOSE_PAREN OPEN_PAREN
%nonassoc VERTICAL_BAR
%left MATH_MINUS MATH_PLUS
%left MATH_DIV MATH_MOD MATH_MULT
%right MATH_NEG
%left DOT
%type <(PVD.accept_triple_t)> accept_edge
%type <(PVD.accept_triple_t) list> accept_edge_list
%type <(PVD.accept_triple_t list * PVD.accept_triple_t list * (E.term * PVD.wf_op_t) list)> acceptance
%type <(PVD.accept_triple_t list * PVD.accept_triple_t list * (E.term * PVD.wf_op_t) list) list> acceptance_list
%type <E.addr> addr
%type <E.addrarr> addrarr
%type <E.term> arrays
%type <System.var_table_t * Tag.f_tag option * (Tag.f_tag option * Expression.formula) list> axiom
%type <(PVD.box_id_t * PVD.node_id_t list * E.ThreadSet.elt)> box
%type <(PVD.box_id_t * PVD.node_id_t list * E.ThreadSet.elt) list> box_list
%type <E.bucket> bucket
%type <E.cell> cell
%type <(E.term * PVD.wf_op_t)> delta
%type <(E.term * PVD.wf_op_t) list> delta_list
%type <E.diseq> disequals
%type <(PVD.node_id_t * PVD.node_id_t * (PVD.edge_type_t * PVD.trans_t))> edge
%type <(PVD.node_id_t * PVD.node_id_t * (PVD.edge_type_t * PVD.trans_t)) list> edge_list
%type <E.elem> elem
%type <E.eq> equals
%type <Expression.formula> formula
%type <(Tag.f_tag option * Expression.formula)> formula_decl
%type <(Tag.f_tag option * Expression.formula) list> formula_decl_list
%type <Tag.f_tag option> formula_tag
%type <E.integer> integer
%type <unit> inv_var_decl
%type <unit> inv_var_decl_list
%type <unit> inv_var_declarations
%type <System.var_table_t * Tag.f_tag option * (Tag.f_tag option * Expression.formula) list> invariant
%type <E.literal> literal
%type <E.lock> lock
%type <E.mark> mark
%type <E.mem> mem
%type <(PVD.node_id_t * E.formula)> node
%type <PVD.node_id_t list> node_id_list
%type <(PVD.node_id_t * E.formula) list> node_list
%type <E.V.shared_or_local> opt_th_param
%type <E.pair> pair
%type <E.path> path
%type <PVD.t> pvd
%type <E.set> set
%type <E.setelem> setelem
%type <E.setint> setint
%type <E.setpair> setpair
%type <E.setth> setth
%type <Expression.formula> single_formula
%type <E.term> term
%type <E.term list> term_list
%type <E.V.shared_or_local> th_param
%type <E.tid> tid
%type <E.tidarr> tidarr
%type <(int * E.V.t)> trans
%type <(int * E.V.t) list> trans_list
%type <Tactics.vc_info> vc_info
%type <PVD.wf_op_t> wf_op
%%

pvd:
  _1 = DIAGRAM _2 = OPEN_BRACKET _3 = IDENT _4 = CLOSE_BRACKET _5 = NODES _6 = COLON _7 = node_list _8 = BOXES _9 = COLON _10 = box_list _11 = INITIAL _12 = COLON _13 = node_id_list _14 = EDGES _15 = COLON _16 = edge_list _17 = ACCEPTANCE _18 = COLON _19 = acceptance_list
    {    (
      let name = get_name _3 in
      let nodes = _7 in
      let boxes = _10 in
      let initial = _13 in
      let edges = _16 in
      let acceptance = _19 in
      PVD.new_pvd name nodes boxes initial edges acceptance
    )}

node_list:
  _1 = node
    {    ( [_1] )}
| _1 = node _2 = COMMA _3 = node_list
    {    ( _1 :: _3 )}

node:
  _1 = IDENT
    {    (
      let n = get_name _1 in
      (n, Formula.True)
    )}
| _1 = IDENT _2 = OPEN_SET _3 = formula _4 = CLOSE_SET
    {    ( let n = get_name _1 in
      let phi = _3 in
      (n,phi)
    )}

node_id_list:
  _1 = IDENT
    {    ( [get_name _1] )}
| _1 = IDENT _2 = COMMA _3 = node_id_list
    {    ( (get_name _1) :: _3 )}

box_list:
  
    {    ( [] )}
| _1 = box _2 = box_list
    {    ( _1 :: _2 )}

box:
  _1 = OPEN_SET _2 = IDENT _3 = OPEN_BRACKET _4 = IDENT _5 = CLOSE_BRACKET _6 = COLON _7 = node_id_list _8 = CLOSE_SET
    {    ( let box_id = get_name _2 in
      let param = E.VarTh (E.build_global_var (get_name _4) E.Tid) in
      let nodes = _7 in
      (box_id, nodes, param)
    )}

trans_list:
  _1 = trans
    {    ( [_1] )}
| _1 = trans _2 = COMMA _3 = trans_list
    {    ( _1 :: _3 )}

trans:
  _1 = NUMBER _2 = OPEN_PAREN _3 = IDENT _4 = CLOSE_PAREN
    {    (
      let i = _1 in
      let t = E.build_global_var (get_name _3) E.Tid in
      (i, t)
    )}

edge_list:
  _1 = edge
    {    ( [_1] )}
| _1 = edge _2 = edge_list
    {    ( _1 :: _2 )}

edge:
  _1 = OPEN_BRACKET _2 = IDENT _3 = EDGE_ARROW _4 = IDENT _5 = CLOSE_BRACKET _6 = SEMICOLON
    {    (
      let n1 = get_name _2 in
      let n2 = get_name _4 in
      (n1, n2, (PVD.Pres, PVD.NoLabel))
    )}
| _1 = IDENT _2 = EDGE_ARROW _3 = IDENT _4 = SEMICOLON
    {    (
      let n1 = get_name _1 in
      let n2 = get_name _3 in
      (n1, n2, (PVD.Any, PVD.NoLabel))
    )}
| _1 = OPEN_BRACKET _2 = IDENT _3 = EDGE_ARROW_OPEN _4 = trans_list _5 = EDGE_ARROW_CLOSE _6 = IDENT _7 = CLOSE_BRACKET _8 = SEMICOLON
    {    (
      let n1 = get_name _2 in
      let n2 = get_name _6 in
      let trans = _4 in
      (n1, n2, (PVD.Pres, PVD.Label trans))
    )}
| _1 = IDENT _2 = EDGE_ARROW_OPEN _3 = trans_list _4 = EDGE_ARROW_CLOSE _5 = IDENT _6 = SEMICOLON
    {    (
      let n1 = get_name _1 in
      let n2 = get_name _5 in
      let trans = _3 in
      (n1, n2, (PVD.Any, PVD.Label trans))
    )}

acceptance_list:
  _1 = acceptance
    {    ( [_1] )}
| _1 = acceptance _2 = acceptance_list
    {    ( _1 :: _2 )}

accept_edge_list:
  
    {    ( [] )}
| _1 = accept_edge
    {    ( [_1] )}
| _1 = accept_edge _2 = COMMA _3 = accept_edge_list
    {    ( _1 :: _3 )}

accept_edge:
  _1 = OPEN_PAREN _2 = IDENT _3 = COMMA _4 = IDENT _5 = COMMA _6 = IDENT _7 = CLOSE_PAREN
    {    (
      let n1 = get_name _2 in
      let n2 = get_name _4 in
      let p = match (get_name _6) with
              | "any" -> PVD.Any
              | "pres" -> PVD.Pres
              | _ -> raise(Wrong_edge_acceptance_argument (get_name _6)) in
      (n1,n2,p)
    )}

acceptance:
  _1 = OPEN_ANGLE _2 = BAD _3 = COLON _4 = OPEN_SET _5 = accept_edge_list _6 = CLOSE_SET _7 = SEMICOLON _8 = GOOD _9 = COLON _10 = OPEN_SET _11 = accept_edge_list _12 = CLOSE_SET _13 = SEMICOLON _14 = OPEN_BRACKET _15 = delta_list _16 = CLOSE_BRACKET _17 = CLOSE_ANGLE
    {    (
      let bad = _5 in
      let good = _11 in
      let delta = _15 in
      (bad, good, delta)
    )}

delta_list:
  _1 = delta
    {    ( [_1] )}
| _1 = delta _2 = SEMICOLON _3 = delta_list
    {    ( _1 :: _3)}

delta:
  _1 = OPEN_PAREN _2 = term _3 = COMMA _4 = wf_op _5 = CLOSE_PAREN
    {    ( (_2, _4) )}

wf_op:
  _1 = WF_INTSUBSET
    {    ( PVD.WFIntSubset )}
| _1 = WF_PAIRSUBSET
    {    ( PVD.WFPairSubset )}
| _1 = WF_ADDRSUBSET
    {    ( PVD.WFAddrSubset )}
| _1 = WF_ELEMSUBSET
    {    ( PVD.WFElemSubset )}
| _1 = WF_TIDSUBSET
    {    ( PVD.WFTidSubset )}
| _1 = WF_INTLESS
    {    ( PVD.WFIntLess )}

axiom:
  _1 = param _2 = COLON _3 = inv_var_declarations _4 = AXIOM _5 = formula_tag _6 = COLON _7 = formula_decl_list
    {    ( let declInvVars = System.copy_var_table invVars in
      let tag         = _5 in
      let inv_decl    = _7 in
      let _           = System.clear_table invVars
      in
        (declInvVars, tag, inv_decl)
    )}

invariant:
  _1 = param _2 = COLON _3 = inv_var_declarations _4 = INVARIANT _5 = formula_tag _6 = COLON _7 = formula_decl_list
    {    ( let declInvVars = System.copy_var_table invVars in
      let tag         = _5 in
      let inv_decl    = _7 in
      let _           = System.clear_table invVars
      in
        (declInvVars, tag, inv_decl)
    )}

formula_tag:
  
    {    ( None )}
| _1 = OPEN_BRACKET _2 = IDENT _3 = CLOSE_BRACKET
    {    (
      let tag_name = get_name _2 in
      curr_tag := tag_name;
      Some (Tag.new_tag tag_name "")
    )}

formula_decl_list:
  _1 = formula_decl
    {    ( [_1] )}
| _1 = formula_decl _2 = formula_decl_list
    {    ( _1 :: _2 )}

formula_decl:
  _1 = formula
    {    ( (None, _1) )}
| _1 = SHARP _2 = IDENT _3 = COLON _4 = formula
    {    (
      let tag_name = get_name _2 in
      (Some (Tag.new_tag !curr_tag tag_name), _4)
    )}

param:
  _1 = VARS
    {    ( )}

inv_var_declarations:
  
    {    ( )}
| _1 = inv_var_decl_list
    {    ( )}

inv_var_decl_list:
  _1 = inv_var_decl
    {    ( () )}
| _1 = inv_var_decl _2 = inv_var_decl_list
    {    ( () )}

inv_var_decl:
  _1 = IDENT _2 = IDENT
    {    (
      let s      = check_and_get_sort (get_name _1) in
      let v_name = get_name _2 in
      decl_inv_var v_name s None
    )}

formula:
  _1 = OPEN_PAREN _2 = formula _3 = CLOSE_PAREN
    {      ( _2 )}
| _1 = literal
    {      ( Formula.Literal _1 )}
| _1 = LOGICAL_TRUE
    {      ( Formula.True )}
| _1 = LOGICAL_FALSE
    {      ( Formula.False )}
| _1 = LOGICAL_NOT _2 = formula
    {      ( Formula.Not _2 )}
| _1 = formula _2 = LOGICAL_AND _3 = formula
    {      ( Formula.And (_1, _3) )}
| _1 = formula _2 = LOGICAL_OR _3 = formula
    {      ( Formula.Or (_1, _3) )}
| _1 = formula _2 = LOGICAL_THEN _3 = formula
    {      ( Formula.Implies (_1, _3) )}
| _1 = formula _2 = EQUALS _3 = formula
    {      ( Formula.Iff (_1, _3) )}
| _1 = AT _2 = NUMBER _3 = opt_th_param _4 = DOT
    {      (
        let line_num = _2 in
        let th_p     = _3 in
          E.pc_form line_num th_p false
      )}
| _1 = AT _2 = IDENT _3 = opt_th_param _4 = DOT
    {      (
        let label_name = get_name _2 in
        let th_p       = _3 in
        let labelTbl   = System.get_labels !Symtbl.sys in
        let pc_pos     = System.get_label_pos labelTbl label_name in
        let pc_expr    = match pc_pos with
                           None -> parser_error ("Unknown label: " ^ label_name)
                         | Some (i,e) -> if i = e then
                                           E.pc_form i th_p false
                                         else
                                           E.pcrange_form i e th_p false
        in
          pc_expr
      )}

opt_th_param:
  
    {    ( E.V.Shared )}
| _1 = th_param
    {    ( _1 )}

th_param:
  _1 = OPEN_PAREN _2 = IDENT _3 = CLOSE_PAREN
    {    (
      let th_id = get_name _2 in
        E.V.Local (E.build_global_var th_id E.Tid)
    )}
| _1 = OPEN_PAREN _2 = NUMBER _3 = CLOSE_PAREN
    {    (
      let th_id = _2 in
        E.V.Local (E.build_num_tid_var th_id)
    )}

literal:
  _1 = APPEND _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "append(%s,%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5)
                                                       (E.term_to_str _7) in
      let p1   = parser_check_type check_type_path _3 E.Path get_str_expr in
      let p2   = parser_check_type check_type_path _5 E.Path get_str_expr in
      let pres = parser_check_type check_type_path _7 E.Path get_str_expr in
        Formula.Atom (E.Append (p1,p2,pres))
    )}
| _1 = REACH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "reach(%s,%s,%s,%s)" (E.term_to_str _3)
                                                         (E.term_to_str _5)
                                                         (E.term_to_str _7)
                                                         (E.term_to_str _9) in
      let h      = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a_from = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr _7 E.Addr get_str_expr in
      let p      = parser_check_type check_type_path _9 E.Path get_str_expr in
        Formula.Atom (E.Reach (h,a_from,a_to,p))
    )}
| _1 = REACH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = COMMA _11 = term _12 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "reach(%s,%s,%s,%s,%s)" (E.term_to_str _3)
                                                            (E.term_to_str _5)
                                                            (E.term_to_str _7)
                                                            (E.term_to_str _9)
                                                            (E.term_to_str _11) in
      let h      = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a_from = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr _7 E.Addr get_str_expr in
      let p      = parser_check_type check_type_path _9 E.Path get_str_expr in
      let l      = parser_check_type check_type_int _11 E.Int get_str_expr in
        Formula.Atom (E.ReachAt (h,a_from,a_to,l,p))
    )}
| _1 = ORDERLIST _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "orderlist(%s,%s,%s)" (E.term_to_str _3)
                                                          (E.term_to_str _5)
                                                          (E.term_to_str _7) in
      let h      = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a_from = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr _7 E.Addr get_str_expr in
        Formula.Atom (E.OrderList (h,a_from,a_to))
    )}
| _1 = SKIPLIST _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = COMMA _11 = term _12 = COMMA _13 = term _14 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "skiplist(%s,%s,%s,%s,%s,%s)"
                                        (E.term_to_str _3)
                                        (E.term_to_str _5)
                                        (E.term_to_str _7)
                                        (E.term_to_str _9)
                                        (E.term_to_str _11)
                                        (E.term_to_str _13) in
      let h      = parser_check_type check_type_mem      _3 E.Mem get_str_expr in
      let s      = parser_check_type check_type_set      _5 E.Set get_str_expr in
      let l      = parser_check_type check_type_int      _7 E.Int get_str_expr in
      let a_from = parser_check_type check_type_addr     _9 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr    _11 E.Addr get_str_expr in
      let elems  = parser_check_type check_type_setelem _13 E.SetElem get_str_expr in
        Formula.Atom (E.Skiplist (h,s,l,a_from,a_to,elems))
    )}
| _1 = HASHTBL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = COMMA _11 = term _12 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "hashtbl(%s,%s,%s,%s,%s)"
                                        (E.term_to_str _3)
                                        (E.term_to_str _5)
                                        (E.term_to_str _7)
                                        (E.term_to_str _9)
                                        (E.term_to_str _11) in
      let h  = parser_check_type check_type_mem        _3 E.Mem get_str_expr in
      let s  = parser_check_type check_type_set        _5 E.Set get_str_expr in
      let se = parser_check_type check_type_setelem    _7 E.SetElem get_str_expr in
      let bb = parser_check_type check_type_bucketarr  _9 E.BucketArray get_str_expr in
      let i  = parser_check_type check_type_int       _11 E.Int get_str_expr in
        Formula.Atom (E.Hashtbl (h,s,se,bb,i))
    )}
| _1 = IN _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "in(%s,%s)" (E.term_to_str _3)
                                                (E.term_to_str _5) in
      let a = parser_check_type check_type_addr _3 E.Addr get_str_expr in
      let r = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Formula.Atom (E.In (a,r))
    )}
| _1 = SUBSETEQ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "subseteq(%s,%s)" (E.term_to_str _3)
                                                      (E.term_to_str _5) in
      let s = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let r = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Formula.Atom (E.SubsetEq(s,r))
    )}
| _1 = INTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tin(%s,%s)" (E.term_to_str _3)
                                                 (E.term_to_str _5) in
      let th = parser_check_type check_type_tid  _3 E.Tid get_str_expr in
      let s  = parser_check_type check_type_setth _5 E.SetTh get_str_expr in
        Formula.Atom (E.InTh (th,s))
    )}
| _1 = SUBSETEQTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tsubseteq(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let r = parser_check_type check_type_setth _3 E.SetTh get_str_expr in
      let s = parser_check_type check_type_setth _5 E.SetTh get_str_expr in
        Formula.Atom (E.SubsetEqTh(r,s))
    )}
| _1 = ININT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "iin(%s,%s)" (E.term_to_str _3)
                                                 (E.term_to_str _5) in
      let i = parser_check_type check_type_int _3 E.Int get_str_expr in
      let s = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Formula.Atom (E.InInt (i,s))
    )}
| _1 = SUBSETEQINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "isubseteq(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let r = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Formula.Atom (E.SubsetEqInt(r,s))
    )}
| _1 = INELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "ein(%s,%s)" (E.term_to_str _3)
                                                 (E.term_to_str _5) in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let s = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Formula.Atom (E.InElem (e,s))
    )}
| _1 = SUBSETEQELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "esubseteq(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let r = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Formula.Atom (E.SubsetEqElem(r,s))
    )}
| _1 = SETPAIRIN _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spin(%s,%s)" (E.term_to_str _3)
                                                  (E.term_to_str _5) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Formula.Atom (E.InPair (p,s))
    )}
| _1 = SETPAIRSUBSETEQ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spsubseteq(%s,%s)" (E.term_to_str _3)
                                                        (E.term_to_str _5) in
      let r = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Formula.Atom (E.SubsetEqPair(r,s))
    )}
| _1 = SETPAIRINTIDPAIR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "inintpair(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let t = parser_check_type check_type_tid _3 E.Tid get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Formula.Atom (E.InTidPair(t,s))
    )}
| _1 = SETPAIRININTPAIR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "inintpair(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let i = parser_check_type check_type_int _3 E.Int get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Formula.Atom (E.InIntPair(i,s))
    )}
| _1 = SETPAIRUNIQUETID _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "uniquetid(%s)" (E.term_to_str _3) in
      let s = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        Formula.Atom (E.UniqueTid(s))
    )}
| _1 = SETPAIRUNIQUEINT _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "uniqueint(%s)" (E.term_to_str _3) in
      let s = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        Formula.Atom (E.UniqueInt(s))
    )}
| _1 = term _2 = MATH_LESS _3 = term
    {    (
      let get_str_expr () = sprintf "%s < %s" (E.term_to_str _1)
                                              (E.term_to_str _3) in
      try
        let e1 = parser_check_type check_type_elem _1 E.Elem get_str_expr in
        let e2 = parser_check_type check_type_elem _3 E.Elem get_str_expr in
          Formula.Atom (E.LessElem (e1, e2))
      with
        _ -> let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
             let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
               Formula.Atom (E.Less (i1, i2))
    )}
| _1 = term _2 = MATH_GREATER _3 = term
    {    (
      let get_str_expr () = sprintf "%s > %s" (E.term_to_str _1)
                                              (E.term_to_str _3) in
      try
        let e1 = parser_check_type check_type_elem _1 E.Elem get_str_expr in
        let e2 = parser_check_type check_type_elem _3 E.Elem get_str_expr in
          Formula.Atom (E.GreaterElem (e1, e2))
      with _ -> let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
                let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
                  Formula.Atom (E.Greater (i1, i2))
    )}
| _1 = term _2 = MATH_LESS_EQ _3 = term
    {    (
      let get_str_expr () = sprintf "%s <= %s" (E.term_to_str _1)
                                               (E.term_to_str _3) in
      let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
        Formula.Atom (E.LessEq (i1, i2))
    )}
| _1 = term _2 = MATH_GREATER_EQ _3 = term
    {    (
      let get_str_expr () = sprintf "%s >= %s" (E.term_to_str _1)
                                               (E.term_to_str _3) in
      let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
        Formula.Atom (E.GreaterEq (i1, i2))
    )}
| _1 = equals
    {    ( Formula.Atom (E.Eq(_1)) )}
| _1 = disequals
    {    ( Formula.Atom (E.InEq(_1)) )}
| _1 = DOT _2 = ident _3 = DOT
    {    (
      match _2 with
      | E.VarT v -> Formula.Atom(E.BoolVar v)
      | _           -> raise(Boolean_var_expected _2)
    )}
| _1 = DOT _2 = IDENT _3 = DOUBLECOLON _4 = IDENT _5 = th_param _6 = DOT
    {    (
      let p = get_name _2 in
      let proc_name = E.V.Scope p in
      let id = get_name _4 in
      let th = _5 in

      check_is_procedure p;
      check_var_belongs_to_procedure id p;
      let proc_info = System.get_proc_by_name !Symtbl.sys p in
      let iVars     = System.proc_info_get_input proc_info in
      let lVars     = System.proc_info_get_local proc_info in
      let k = if System.mem_var iVars id then
                System.find_var_kind iVars id
              else
                System.find_var_kind lVars id
              in
      let v = E.build_var id E.Bool false th proc_name ~nature:k in
      Formula.Atom(E.BoolVar v)
    )}

equals:
  _1 = term _2 = EQUALS _3 = term
    {    (
      let get_str_expr () = sprintf "%s = %s" (E.term_to_str _1)
                                              (E.term_to_str _3) in
      let t1 = _1 in
      let t2 = _3 in

      parser_check_compatibility t1 t2 get_str_expr ;
      (inject_sort t1, inject_sort t2)
    )}

disequals:
  _1 = term _2 = NOT_EQUALS _3 = term
    {    (
      let get_str_expr () = sprintf "%s != %s" (E.term_to_str _1)
                                               (E.term_to_str _3) in
      let t1= _1 in
      let t2= _3 in

      parser_check_compatibility t1 t2 get_str_expr ;
      (inject_sort t1, inject_sort t2)
    )}

term:
  _1 = ident
    {    ( _1 )}
| _1 = set
    {    ( E.SetT(_1) )}
| _1 = elem
    {    ( E.ElemT(_1) )}
| _1 = tid
    {    ( E.TidT(_1) )}
| _1 = addr
    {    ( E.AddrT(_1) )}
| _1 = cell
    {    ( E.CellT(_1) )}
| _1 = setth
    {    ( E.SetThT(_1) )}
| _1 = setint
    {    ( E.SetIntT(_1) )}
| _1 = setelem
    {    ( E.SetElemT(_1) )}
| _1 = setpair
    {    ( E.SetPairT(_1) )}
| _1 = path
    {    ( E.PathT(_1) )}
| _1 = mem
    {    ( E.MemT(_1) )}
| _1 = integer
    {    ( E.IntT(_1) )}
| _1 = pair
    {    ( E.PairT(_1) )}
| _1 = arrays
    {    ( _1 )}
| _1 = addrarr
    {    ( E.AddrArrayT(_1) )}
| _1 = tidarr
    {    ( E.TidArrayT(_1) )}
| _1 = mark
    {    ( E.MarkT(_1) )}
| _1 = bucket
    {    ( E.BucketT(_1) )}
| _1 = lock
    {    ( E.LockT(_1) )}
| _1 = OPEN_PAREN _2 = term _3 = CLOSE_PAREN
    {    ( _2 )}

ident:
  _1 = IDENT
    {    (
      define_ident E.V.GlobalScope (get_name _1) E.V.Shared
    )}
| _1 = IDENT _2 = DOUBLECOLON _3 = IDENT
    {    (
      define_ident (E.V.Scope (get_name _1)) (get_name _3) E.V.Shared
    )}
| _1 = IDENT _2 = DOUBLECOLON _3 = IDENT _4 = th_param
    {    (
      define_ident (E.V.Scope (get_name _1)) (get_name _3) _4
    )}

set:
  _1 = EMPTYSET
    {    ( E.EmptySet )}
| _1 = OPEN_SET _2 = term _3 = CLOSE_SET
    {    (
      let get_str_expr() = sprintf "{ %s }" (E.term_to_str _2) in
      let a = parser_check_type check_type_addr _2 E.Addr get_str_expr in
        E.Singl(a)
    )}
| _1 = UNION _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "union(%s,%s)" (E.term_to_str _3)
                                                  (E.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        E.Union(s1,s2)
    )}
| _1 = INTR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "intr(%s,%s)" (E.term_to_str _3)
                                                 (E.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        E.Intr(s1,s2)
    )}
| _1 = SETDIFF _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "diff(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        E.Setdiff(s1,s2)
    )}
| _1 = PATH2SET _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "path2set(%s)" (E.term_to_str _3) in
      let p = parser_check_type check_type_path _3 E.Path get_str_expr in
        E.PathToSet(p)
    )}
| _1 = ADDR2SET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "addr2set(%s,%s)" (E.term_to_str _3)
                                                      (E.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
        E.AddrToSet(h,a)
    )}
| _1 = ADDR2SET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "addr2set(%s,%s,%s)" (E.term_to_str _3)
                                                         (E.term_to_str _5)
                                                         (E.term_to_str _7) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let l = parser_check_type check_type_int _7 E.Int get_str_expr in
        E.AddrToSetAt(h,a,l)
    )}
| _1 = term _2 = DOT _3 = BREGION
    {    (
      let get_str_expr () = sprintf "%s.bregion" (E.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        E.BucketRegion(b)
    )}

elem:
  _1 = term _2 = DOT _3 = DATA
    {    (
      let get_str_expr () = sprintf "%s.data" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
        E.CellData(c)
    )}
| _1 = LOWEST_ELEM
    {    (
      E.LowestElem
    )}
| _1 = HIGHEST_ELEM
    {    (
      E.HighestElem
    )}

tid:
  _1 = term _2 = DOT _3 = LOCKID
    {    (
      let get_str_expr () = sprintf "%s.lockid" (E.term_to_str _1) in
      try
        let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
          E.CellLockId(c)
      with _ ->
        let l = parser_check_type check_type_lock _1 E.Lock get_str_expr in
          E.LockId(l)
    )}
| _1 = SHARP
    {    ( E.NoTid )}
| _1 = TIDOF _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tid_of(%s)" (E.term_to_str _3) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
        E.PairTid(p)
    )}
| _1 = term _2 = DOT _3 = BTID
    {    (
      let get_str_expr () = sprintf "%s.btid" (E.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        E.BucketTid(b)
    )}

addr:
  _1 = NULL
    {    ( E.Null )}
| _1 = term _2 = DOT _3 = NEXT
    {    (
      let get_str_expr () = sprintf "%s.next" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
        E.Next(c)
    )}
| _1 = term _2 = DOT _3 = NEXTAT _4 = OPEN_BRACKET _5 = term _6 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s.nextat[%s]" (E.term_to_str _1)
                                                    (E.term_to_str _5) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
      let l = parser_check_type check_type_int   _5 E.Cell get_str_expr in
        E.NextAt(c,l)
    )}
| _1 = FIRSTLOCKED _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "firstlocked(%s,%s)" (E.term_to_str _3)
                                                         (E.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
        E.FirstLocked(h,p)
    )}
| _1 = FIRSTLOCKED _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "firstlocked(%s,%s,%s)"
                                          (E.term_to_str _3)
                                          (E.term_to_str _5)
                                          (E.term_to_str _7) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
      let l = parser_check_type check_type_int _7 E.Int get_str_expr in
        E.FirstLockedAt(h,p,l)
    )}
| _1 = LASTLOCKED _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "lastlocked(%s,%s)" (E.term_to_str _3)
                                                        (E.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
        E.LastLocked(h,p)
    )}
| _1 = term _2 = DOT _3 = BINIT
    {    (
      let get_str_expr () = sprintf "%s.binit" (E.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        E.BucketInit(b)
    )}
| _1 = term _2 = DOT _3 = BEND
    {    (
      let get_str_expr () = sprintf "%s.bend" (E.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        E.BucketEnd(b)
    )}

cell:
  _1 = ERROR
    {    ( E.Error )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkcell(%s,%s,%s)"
                                           (E.term_to_str _3)
                                           (E.term_to_str _5)
                                           (E.term_to_str _7) in
      let d  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let a  = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let th = parser_check_type check_type_tid _7 E.Tid get_str_expr in
        E.MkCell(d,a,th)
    )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkcell(%s,%s,%s,%s)"
                                           (E.term_to_str _3)
                                           (E.term_to_str _5)
                                           (E.term_to_str _7)
                                           (E.term_to_str _9) in
      let e  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let aa = parser_check_type check_type_addrarr _5 E.AddrArray get_str_expr in
      let ta = parser_check_type check_type_tidarr _7 E.TidArray get_str_expr in
      let l  = parser_check_type check_type_int _9 E.Int get_str_expr in
        E.MkSLCell(e,aa,ta,l)
    )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = OPEN_BRACKET _6 = term_list _7 = CLOSE_BRACKET _8 = COMMA _9 = OPEN_BRACKET _10 = term_list _11 = CLOSE_BRACKET _12 = CLOSE_PAREN
    {    (
      let list_term_to_str ts = String.concat "," (List.map E.term_to_str ts) in
      let addrs_str = list_term_to_str _6 in
      let tids_str = list_term_to_str _10 in
      let get_str_expr () = sprintf "mkcell(%s,[%s],[%s])"
                                           (E.term_to_str _3)
                                           (addrs_str)
                                           (tids_str) in
      let e  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let addrs = List.map (fun a ->
                    parser_check_type check_type_addr a E.Addr get_str_expr
                  ) _6 in
      let tids = List.map (fun t ->
                   parser_check_type check_type_tid t E.Tid get_str_expr
                 ) _10 in
      if List.length addrs <> List.length tids then
        begin
          Interface.Err.msg "Different argument lengths" $
            sprintf "mkcell is invoked with an unequal number of addresses [%s] \
                     and thread ids [%s]." addrs_str tids_str;
          raise(Different_argument_length(addrs_str,tids_str))
        end
      else
        E.MkSLKCell(e,addrs,tids)
    )}
| _1 = term _2 = DOT _3 = LOCK _4 = OPEN_PAREN _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "%s.lock(%s)" (E.term_to_str _1)
                                                  (E.term_to_str _5) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
      let t = parser_check_type check_type_tid _5 E.Tid get_str_expr in
        E.CellLock(c,t)
    )}
| _1 = term _2 = DOT _3 = LOCKAT _4 = OPEN_PAREN _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "%s.lock(%s)" (E.term_to_str _1)
                                                  (E.term_to_str _5) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
      let l = parser_check_type check_type_int  _5 E.Int get_str_expr in
      let t = parser_check_type check_type_tid _7 E.Tid get_str_expr in
        E.CellLockAt(c,l,t)
    )}
| _1 = term _2 = DOT _3 = UNLOCK
    {    (
      let get_str_expr () = sprintf "%s.unlock" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        E.CellUnlock(c)
    )}
| _1 = term _2 = DOT _3 = UNLOCKAT _4 = OPEN_PAREN _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "%s.unlock" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
      let l = parser_check_type check_type_int  _5 E.Int get_str_expr in
        E.CellUnlockAt(c,l)
    )}
| _1 = MEMORY_READ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "%s [ %s ]" (E.term_to_str _3)
                                                (E.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
        E.CellAt(h,a)
    )}

term_list:
  _1 = term _2 = COMMA _3 = term
    {    ( [_1;_3] )}
| _1 = term _2 = COMMA _3 = term_list
    {    ( _1 :: _3 )}

setth:
  _1 = EMPTYSETTH
    {  ( E.EmptySetTh )}
| _1 = SINGLETH _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tsingle(%s)" (E.term_to_str _3) in
      let th = parser_check_type check_type_tid  _3 E.Tid get_str_expr in
        E.SinglTh(th)
    )}
| _1 = UNIONTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tunion(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        E.UnionTh(s1,s2)
    )}
| _1 = INTRTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tintr(%s,%s)" (E.term_to_str _3)
                                                   (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        E.IntrTh(s1,s2)
    )}
| _1 = SETDIFFTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tdiff(%s,%s)" (E.term_to_str _3)
                                                      (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        E.SetdiffTh(s1,s2)
    )}
| _1 = LOCKSET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "lockset(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let m = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
        E.LockSet(m,p)
    )}

setint:
  _1 = EMPTYSETINT
    {     ( E.EmptySetInt )}
| _1 = SINGLEINT _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "isingle(%s)" (E.term_to_str _3) in
      let th = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.SinglInt(th)
    )}
| _1 = UNIONINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "iunion(%s,%s)" (E.term_to_str _3)
                                                     (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setint  _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint  _5 E.SetInt get_str_expr in
        E.UnionInt(s1,s2)
    )}
| _1 = INTRINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "iintr(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setint  _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint  _5 E.SetInt get_str_expr in
        E.IntrInt(s1,s2)
    )}
| _1 = SETDIFFINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "idiff(%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        E.SetdiffInt(s1,s2)
    )}
| _1 = SETLOWER _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "setLower(%s,%s)" (E.term_to_str _3)
                                                     (E.term_to_str _5) in
      let s = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let i = parser_check_type check_type_int _5 E.Int get_str_expr in
        E.SetLower(s,i)
    )}

setpair:
  _1 = SETPAIREMPTY
    {     ( E.EmptySetPair )}
| _1 = SETPAIRSINGLE _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spsingle(%s)" (E.term_to_str _3) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
        E.SinglPair(p)
    )}
| _1 = SETPAIRUNION _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spunion(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair  _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair  _5 E.SetPair get_str_expr in
        E.UnionPair(s1,s2)
    )}
| _1 = SETPAIRINTR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spintr(%s,%s)" (E.term_to_str _3)
                                                   (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair  _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair  _5 E.SetPair get_str_expr in
        E.IntrPair(s1,s2)
    )}
| _1 = SETPAIRDIFF _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spdiff(%s,%s)" (E.term_to_str _3)
                                                   (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        E.SetdiffPair(s1,s2)
    )}
| _1 = SETPAIRLOWER _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "splower(%s,%s)" (E.term_to_str _3)
                                                    (E.term_to_str _5) in
      let s = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
      let i = parser_check_type check_type_int _5 E.Int get_str_expr in
        E.LowerPair(s,i)
    )}

setelem:
  _1 = EMPTYSETELEM
    {     ( E.EmptySetElem )}
| _1 = SINGLEELEM _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "esingle(%s)" (E.term_to_str _3) in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
        E.SinglElem(e)
    )}
| _1 = UNIONELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "eunion(%s,%s)" (E.term_to_str _3)
                                                      (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        E.UnionElem(s1,s2)
    )}
| _1 = INTRELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "eintr(%s,%s)" (E.term_to_str _3)
                                                     (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        E.IntrElem(s1,s2)
    )}
| _1 = SETDIFFELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "ediff(%s,%s)" (E.term_to_str _3)
                                                        (E.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        E.SetdiffElem(s1,s2)
    )}
| _1 = SET2ELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "set2elem(%s,%s)" (E.term_to_str _3)
                                                      (E.term_to_str _5) in
      let m = parser_check_type check_type_mem _3 E.Mem get_str_expr in
      let s = parser_check_type check_type_set _5 E.Set get_str_expr in
        E.SetToElems(s,m)
    )}

path:
  _1 = EPSILON
    {    ( E.Epsilon )}
| _1 = OPEN_BRACKET _2 = term _3 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "[ %s ]" (E.term_to_str _2) in
      let a = parser_check_type check_type_addr _2 E.Addr get_str_expr in
        E.SimplePath(a)
    )}
| _1 = GETP _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "getp(%s,%s,%s)" (E.term_to_str _3)
                                                     (E.term_to_str _5)
                                                     (E.term_to_str _7) in
      let h     = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let first = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let last  = parser_check_type check_type_addr _7 E.Addr get_str_expr in
        E.GetPath(h,first,last)
    )}
| _1 = GETP _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "getp(%s,%s,%s,%s)" (E.term_to_str _3)
                                                        (E.term_to_str _5)
                                                        (E.term_to_str _7)
                                                        (E.term_to_str _9) in
      let h     = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let first = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let last  = parser_check_type check_type_addr _7 E.Addr get_str_expr in
      let l     = parser_check_type check_type_int _9 E.Int get_str_expr in
        E.GetPathAt(h,first,last,l)
  )}

mem:
  _1 = UPDATE _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "update(%s,%s,%s)" (E.term_to_str _3)
                                                       (E.term_to_str _5)
                                                       (E.term_to_str _7) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let c = parser_check_type check_type_cell _7 E.Cell get_str_expr in
        E.Update(h,a,c)
    )}

integer:
  _1 = NUMBER
    {    ( E.IntVal _1 )}
| _1 = MATH_MINUS _2 = term %prec MATH_NEG
    {    (
      let get_str_expr () = sprintf "-%s" (E.term_to_str _2) in
      let i  = parser_check_type check_type_int _2 E.Int get_str_expr in
        E.IntNeg i
    )}
| _1 = term _2 = MATH_PLUS _3 = term
    {    (
      let get_str_expr () = sprintf "%s+%s" (E.term_to_str _1)
                                            (E.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.IntAdd (i1,i2)
    )}
| _1 = term _2 = MATH_MINUS _3 = term
    {    (
      let get_str_expr () = sprintf "%s-%s" (E.term_to_str _1)
                                            (E.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.IntSub (i1,i2)
    )}
| _1 = term _2 = MATH_MULT _3 = term
    {    (
      let get_str_expr () = sprintf "%s*%s" (E.term_to_str _1)
                                            (E.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.IntMul (i1,i2)
    )}
| _1 = term _2 = MATH_DIV _3 = term
    {    (
      let get_str_expr () = sprintf "%s/%s" (E.term_to_str _1)
                                            (E.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.IntDiv (i1,i2)
    )}
| _1 = term _2 = MATH_MOD _3 = term
    {    (
      let get_str_expr () = sprintf "%s %% %s" (E.term_to_str _1)
                                               (E.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        E.IntMod (i1,i2)
    )}
| _1 = SETINTMIN _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let iSet = _3 in
      let get_str_expr () = sprintf "setIntMin(%s)" (E.term_to_str iSet) in
      let s  = parser_check_type check_type_setint iSet E.SetInt get_str_expr
      in
        E.IntSetMin (s)
    )}
| _1 = SETINTMAX _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let iSet = _3 in
      let get_str_expr () = sprintf "setIntMax(%s)" (E.term_to_str iSet) in
      let s  = parser_check_type check_type_setint iSet E.SetInt get_str_expr
      in
        E.IntSetMax (s)
    )}
| _1 = term _2 = DOT _3 = MAX
    {    (
      let get_str_expr () = sprintf "%s.max" (E.term_to_str _1) in
      let c  = parser_check_type check_type_cell _1 E.Cell get_str_expr
      in
        E.CellMax (c)
    )}
| _1 = INTOF _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "int_of(%s)" (E.term_to_str _3) in
      let p  = parser_check_type check_type_pair _3 E.Pair get_str_expr
      in
        E.PairInt (p)
    )}

pair:
  _1 = OPEN_PAREN _2 = term _3 = COMMA _4 = term _5 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "(%s,%s)" (E.term_to_str _2)
                                              (E.term_to_str _4) in
      let i  = parser_check_type check_type_int _2 E.Int get_str_expr in
      let t  = parser_check_type check_type_tid _4 E.Tid get_str_expr in
        E.IntTidPair(i,t)
    )}
| _1 = SETPAIRMIN _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spmin(%s)" (E.term_to_str _3) in
      let s  = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        E.SetPairMin(s)
    )}
| _1 = SETPAIRMAX _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spmax(%s)" (E.term_to_str _3) in
      let s  = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        E.SetPairMax(s)
    )}

arrays:
  _1 = term _2 = OPEN_BRACKET _3 = term _4 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s[%s]" (E.term_to_str _1)
                                             (E.term_to_str _3) in
      let i = parser_check_type check_type_int _3 E.Int get_str_expr in
      try
        let at = parser_check_type check_type_tidarr _1 E.TidArray get_str_expr in
          E.TidT (E.TidArrRd (at,i))
      with _ ->
        try
          let aa = parser_check_type check_type_addrarr _1 E.AddrArray get_str_expr in
            E.AddrT (E.AddrArrRd (aa,i))
        with e ->
          try
            let bb = parser_check_type check_type_bucketarr _1 E.BucketArray get_str_expr in
              E.BucketT (E.BucketArrRd (bb,i))
            with e ->
              try
                let ll = parser_check_type check_type_lockarr _1 E.LockArray get_str_expr in
                  E.LockT (E.LockArrRd (ll,i))
              with e ->
                try
                  let t = parser_check_type check_type_tid _1 E.Tid get_str_expr in
                  match t with
                  | E.CellLockId c -> E.TidT (E.CellLockIdAt (c,i))
                  | _                 -> raise(e)
                with e ->
                  let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
                  match a with
                  | E.Next c -> E.AddrT (E.ArrAt (c,i))
                  | _           -> raise(e)
    )}
| _1 = ARR_UPDATE _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "arrUpd (%s,%s,%s)" (E.term_to_str _3)
                                                        (E.term_to_str _5)
                                                        (E.term_to_str _7) in
      let i = parser_check_type check_type_int _5 E.Int get_str_expr in
      try
        let ll = parser_check_type check_type_lockarr _3 E.LockArray get_str_expr in
        let l = parser_check_type check_type_lock _7 E.Lock get_str_expr in
          E.LockArrayT (E.LockArrayUp (ll,i,l))
      with _ ->
        try
          let bb = parser_check_type check_type_bucketarr _3 E.BucketArray get_str_expr in
          let b = parser_check_type check_type_bucket _7 E.Bucket get_str_expr in
            E.BucketArrayT (E.BucketArrayUp (bb,i,b))
        with _ ->
          try
            let aa = parser_check_type check_type_addrarr _3 E.AddrArray get_str_expr in
            let a = parser_check_type check_type_addr _7 E.Addr get_str_expr in
              E.AddrArrayT (E.AddrArrayUp (aa,i,a))
          with _ ->
            let at = parser_check_type check_type_tidarr _3 E.TidArray get_str_expr in
            let t = parser_check_type check_type_tid _7 E.Tid get_str_expr in
              E.TidArrayT (E.TidArrayUp (at,i,t))
    )}

addrarr:
  _1 = term _2 = DOT _3 = ARR
    {    (
      let get_str_expr () = sprintf "%s.arr" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        E.CellArr(c)
    )}

tidarr:
  _1 = term _2 = DOT _3 = TIDS
    {    (
      let get_str_expr () = sprintf "%s.tids" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        E.CellTids(c)
    )}

mark:
  _1 = MARK_T
    {    (
      E.MarkTrue
    )}
| _1 = MARK_F
    {    (
      E.MarkFalse
    )}
| _1 = term _2 = DOT _3 = MARKED
    {    (
      let get_str_expr () = sprintf "%s.marked" (E.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        E.Marked(c)
    )}

bucket:
  _1 = MKBUCKET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkbucket(%s,%s,%s,%s)"
                                           (E.term_to_str _3)
                                           (E.term_to_str _5)
                                           (E.term_to_str _7)
                                           (E.term_to_str _9) in
      let i = parser_check_type check_type_addr _3 E.Addr get_str_expr in
      let e = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let s = parser_check_type check_type_set _7 E.Set get_str_expr in
      let t = parser_check_type check_type_tid _9 E.Tid get_str_expr in
        E.MkBucket(i,e,s,t)
    )}

lock:
  _1 = LOCK _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "lock(%s,%s)"
                                           (E.term_to_str _3)
                                           (E.term_to_str _5) in
      let l = parser_check_type check_type_lock _3 E.Lock get_str_expr in
      let t = parser_check_type check_type_tid _5 E.Tid get_str_expr in
        E.LLock(l,t)
    )}
| _1 = UNLOCK _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "unlock(%s)"
                                           (E.term_to_str _3) in
      let l = parser_check_type check_type_lock _3 E.Lock get_str_expr in
        E.LUnlock(l)
    )}

vc_info:
  _1 = param _2 = COLON _3 = inv_var_declarations _4 = SUPPORT _5 = COLON _6 = formula_list _7 = TID_CONSTRAINT _8 = COLON _9 = tid_constraint_list _10 = RHO _11 = COLON _12 = formula _13 = GOAL _14 = COLON _15 = formula _16 = TRANSITION_TID _17 = COLON _18 = term _19 = LINE _20 = COLON _21 = NUMBER
    {      (
        let _ = System.clear_table invVars in
        let supp_list = _6 in
        let tid_const = _9 in
        let rho_phi = _12 in
        let goal_phi = _15 in
        let trans_tid = parser_check_type check_type_tid _18 E.Tid (fun _ -> (E.term_to_str _18)) in
        let (tid_eqs, tid_ineqs, voc_const) =
          List.fold_left (fun (eqs,ineqs,voc) a ->
                            match a with
                            | E.Eq (E.TidT t1, E.TidT t2) ->
                                let t_voc = E.ThreadSet.union (E.voc_tid t1) (E.voc_tid t2) in
                                ((t1,t2)::eqs, ineqs, E.ThreadSet.union t_voc voc)
                            | E.InEq (E.TidT t1, E.TidT t2) ->
                                let t_voc = E.ThreadSet.union (E.voc_tid t1) (E.voc_tid t2) in
                                (eqs,(t1,t2)::ineqs, E.ThreadSet.union t_voc voc)
                            | _ -> (eqs, ineqs, voc)
                         ) ([],[], E.ThreadSet.empty) tid_const in
        let tid_constraint = Tactics.new_tid_constraint tid_eqs tid_ineqs in

        let line = _21 in
        let vocab = E.ThreadSet.union (E.voc (Formula.conj_list [rho_phi;goal_phi]))
                                      voc_const in
        Tactics.create_vc_info supp_list tid_constraint rho_phi goal_phi vocab trans_tid line
      )}

formula_list:
  
    {    ( [] )}
| _1 = formula _2 = formula_list
    {    ( _1 :: _2 )}

tid_constraint_list:
  
    {    ( [] )}
| _1 = tid_constraint _2 = SEMICOLON _3 = tid_constraint_list
    {    ( _1 :: _3 )}

tid_constraint:
  _1 = equals
    {    (
      let (t1,t2) = _1 in
      let get_str_expr () = sprintf "%s = %s" (E.term_to_str t1)
                                              (E.term_to_str t2) in
      let t1' = parser_check_type check_type_tid t1 E.Tid get_str_expr in
      let t2' = parser_check_type check_type_tid t2 E.Tid get_str_expr
      in
        E.Eq (E.TidT t1', E.TidT t2')
    )}
| _1 = disequals
    {    (
      let (t1,t2) = _1 in
      let get_str_expr () = sprintf "%s != %s" (E.term_to_str t1)
                                               (E.term_to_str t2) in
      let t1' = parser_check_type check_type_tid t1 E.Tid get_str_expr in
      let t2' = parser_check_type check_type_tid t2 E.Tid get_str_expr
      in
        E.InEq (E.TidT t1', E.TidT t2')
    )}

single_formula:
  _1 = param _2 = COLON _3 = inv_var_declarations _4 = FORMULA _5 = COLON _6 = formula
    {      (
        let _ = System.clear_table invVars in
        let phi = _6 in
        phi
      )}

%%
