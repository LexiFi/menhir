State 0:
## Known stack suffix:
##
## LR(1) items:
system' -> . system [ # ]
## Transitions:
-- On GLOBAL shift to state 1
-- On system shift to state 787
## Reductions:

State 1:
## Known stack suffix:
## GLOBAL
## LR(1) items:
system -> GLOBAL . global_declarations initial_assumption procedure_list [ # ]
## Transitions:
-- On GHOST shift to state 2
-- On kind shift to state 3
-- On global_declarations shift to state 553
-- On global_decl_list shift to state 784
-- On global_decl shift to state 785
## Reductions:
-- On PROCEDURE ASSUME
--   reduce production global_declarations ->
-- On IDENT
--   reduce production kind ->

State 2:
## Known stack suffix:
## GHOST
## LR(1) items:
kind -> GHOST . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production kind -> GHOST

State 3:
## Known stack suffix:
## kind
## LR(1) items:
global_decl -> kind . IDENT IDENT [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT ASSIGN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT ASSIGN formula [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT MATH_LESS term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT MATH_GREATER term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT MATH_LESS_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT MATH_GREATER_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT IN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT SUBSETEQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT INTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT SUBSETEQTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT ININT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT SUBSETEQINT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT INELEM term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT IDENT SUBSETEQELEM term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind . IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On IDENT shift to state 4
## Reductions:

State 4:
## Known stack suffix:
## kind IDENT
## LR(1) items:
global_decl -> kind IDENT . IDENT [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT ASSIGN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT ASSIGN formula [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT MATH_LESS term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT MATH_GREATER term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT MATH_LESS_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT MATH_GREATER_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT IN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT SUBSETEQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT INTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT SUBSETEQTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT ININT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT SUBSETEQINT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT INELEM term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . IDENT SUBSETEQELEM term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . SETPAIRIN OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT . SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On SETPAIRSUBSETEQ shift to state 5
-- On SETPAIRIN shift to state 373
-- On IDENT shift to state 379
## Reductions:

State 5:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ
## LR(1) items:
global_decl -> kind IDENT SETPAIRSUBSETEQ . OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 6
## Reductions:

State 6:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ OPEN_PAREN
## LR(1) items:
global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN . IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On IDENT shift to state 7
## Reductions:

State 7:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT
## LR(1) items:
global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT . COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On COMMA shift to state 8
## Reductions:

State 8:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA
## LR(1) items:
global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA . term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 371
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 9:
## Known stack suffix:
## UPDATE
## LR(1) items:
mem -> UPDATE . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## UPDATE OPEN_PAREN
## LR(1) items:
mem -> UPDATE OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 365
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 11:
## Known stack suffix:
## UNLOCK
## LR(1) items:
lock -> UNLOCK . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 12
## Reductions:

State 12:
## Known stack suffix:
## UNLOCK OPEN_PAREN
## LR(1) items:
lock -> UNLOCK OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 363
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 13:
## Known stack suffix:
## UNIONTH
## LR(1) items:
setth -> UNIONTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 14
## Reductions:

State 14:
## Known stack suffix:
## UNIONTH OPEN_PAREN
## LR(1) items:
setth -> UNIONTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 359
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 15:
## Known stack suffix:
## UNIONINT
## LR(1) items:
setint -> UNIONINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 16
## Reductions:

State 16:
## Known stack suffix:
## UNIONINT OPEN_PAREN
## LR(1) items:
setint -> UNIONINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 355
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 17:
## Known stack suffix:
## UNIONELEM
## LR(1) items:
setelem -> UNIONELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 18
## Reductions:

State 18:
## Known stack suffix:
## UNIONELEM OPEN_PAREN
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 351
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 19:
## Known stack suffix:
## UNION
## LR(1) items:
set -> UNION . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 20
## Reductions:

State 20:
## Known stack suffix:
## UNION OPEN_PAREN
## LR(1) items:
set -> UNION OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 347
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 21:
## Known stack suffix:
## TIDOF
## LR(1) items:
tid -> TIDOF . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 22
## Reductions:

State 22:
## Known stack suffix:
## TIDOF OPEN_PAREN
## LR(1) items:
tid -> TIDOF OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 345
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 23:
## Known stack suffix:
## SINGLE_PATH
## LR(1) items:
path -> SINGLE_PATH . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 24
## Reductions:

State 24:
## Known stack suffix:
## SINGLE_PATH OPEN_PAREN
## LR(1) items:
path -> SINGLE_PATH OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 343
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 25:
## Known stack suffix:
## SINGLETH
## LR(1) items:
setth -> SINGLETH . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 26
## Reductions:

State 26:
## Known stack suffix:
## SINGLETH OPEN_PAREN
## LR(1) items:
setth -> SINGLETH OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 341
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 27:
## Known stack suffix:
## SINGLEINT
## LR(1) items:
setint -> SINGLEINT . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 28
## Reductions:

State 28:
## Known stack suffix:
## SINGLEINT OPEN_PAREN
## LR(1) items:
setint -> SINGLEINT OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 339
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 29:
## Known stack suffix:
## SINGLEELEM
## LR(1) items:
setelem -> SINGLEELEM . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 30
## Reductions:

State 30:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN
## LR(1) items:
setelem -> SINGLEELEM OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 337
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 31:
## Known stack suffix:
## SHARP
## LR(1) items:
tid -> SHARP . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> SHARP

State 32:
## Known stack suffix:
## SETPAIRUNION
## LR(1) items:
setpair -> SETPAIRUNION . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 33
## Reductions:

State 33:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 333
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 34:
## Known stack suffix:
## SETPAIRSINGLE
## LR(1) items:
setpair -> SETPAIRSINGLE . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 35
## Reductions:

State 35:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRSINGLE OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 331
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 36:
## Known stack suffix:
## SETPAIRMIN
## LR(1) items:
pair -> SETPAIRMIN . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 37
## Reductions:

State 37:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN
## LR(1) items:
pair -> SETPAIRMIN OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 329
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 38:
## Known stack suffix:
## SETPAIRMAX
## LR(1) items:
pair -> SETPAIRMAX . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN
## LR(1) items:
pair -> SETPAIRMAX OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 327
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 40:
## Known stack suffix:
## SETPAIRINTR
## LR(1) items:
setpair -> SETPAIRINTR . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 323
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 42:
## Known stack suffix:
## SETPAIREMPTY
## LR(1) items:
setpair -> SETPAIREMPTY . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setpair -> SETPAIREMPTY

State 43:
## Known stack suffix:
## SETPAIRDIFF
## LR(1) items:
setpair -> SETPAIRDIFF . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 44
## Reductions:

State 44:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 319
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 45:
## Known stack suffix:
## SETINTMIN
## LR(1) items:
integer -> SETINTMIN . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 46
## Reductions:

State 46:
## Known stack suffix:
## SETINTMIN OPEN_PAREN
## LR(1) items:
integer -> SETINTMIN OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 317
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 47:
## Known stack suffix:
## SETINTMAX
## LR(1) items:
integer -> SETINTMAX . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 48
## Reductions:

State 48:
## Known stack suffix:
## SETINTMAX OPEN_PAREN
## LR(1) items:
integer -> SETINTMAX OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 315
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 49:
## Known stack suffix:
## SETDIFFTH
## LR(1) items:
setth -> SETDIFFTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 311
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 51:
## Known stack suffix:
## SETDIFFINT
## LR(1) items:
setint -> SETDIFFINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 52
## Reductions:

State 52:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 307
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 53:
## Known stack suffix:
## SETDIFFELEM
## LR(1) items:
setelem -> SETDIFFELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 54
## Reductions:

State 54:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 303
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 55:
## Known stack suffix:
## SETDIFF
## LR(1) items:
set -> SETDIFF . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 56
## Reductions:

State 56:
## Known stack suffix:
## SETDIFF OPEN_PAREN
## LR(1) items:
set -> SETDIFF OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 299
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 57:
## Known stack suffix:
## SET2ELEM
## LR(1) items:
setelem -> SET2ELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 58
## Reductions:

State 58:
## Known stack suffix:
## SET2ELEM OPEN_PAREN
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 295
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 59:
## Known stack suffix:
## PATH2SET
## LR(1) items:
set -> PATH2SET . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 60
## Reductions:

State 60:
## Known stack suffix:
## PATH2SET OPEN_PAREN
## LR(1) items:
set -> PATH2SET OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 293
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 61:
## Known stack suffix:
## OPEN_SET
## LR(1) items:
set -> OPEN_SET . term CLOSE_SET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 291
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 62:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
pair -> OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
term -> OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 286
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 63:
## Known stack suffix:
## NUMBER
## LR(1) items:
integer -> NUMBER . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> NUMBER

State 64:
## Known stack suffix:
## NULL
## LR(1) items:
addr -> NULL . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> NULL

State 65:
## Known stack suffix:
## MKCELL
## LR(1) items:
cell -> MKCELL . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL . OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 66
## Reductions:

State 66:
## Known stack suffix:
## MKCELL OPEN_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN . term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 265
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 67:
## Known stack suffix:
## MKBUCKET
## LR(1) items:
bucket -> MKBUCKET . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 68
## Reductions:

State 68:
## Known stack suffix:
## MKBUCKET OPEN_PAREN
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 257
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 69:
## Known stack suffix:
## MEMORY_READ
## LR(1) items:
cell -> MEMORY_READ . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 70
## Reductions:

State 70:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 253
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 71:
## Known stack suffix:
## ME
## LR(1) items:
tid -> ME . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> ME

State 72:
## Known stack suffix:
## MATH_MINUS
## LR(1) items:
integer -> MATH_MINUS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 252
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 73:
## Known stack suffix:
## MARK_T
## LR(1) items:
mark -> MARK_T . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mark -> MARK_T

State 74:
## Known stack suffix:
## MARK_F
## LR(1) items:
mark -> MARK_F . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mark -> MARK_F

State 75:
## Known stack suffix:
## MALLOCSLK
## LR(1) items:
addr -> MALLOCSLK . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 76
## Reductions:

State 76:
## Known stack suffix:
## MALLOCSLK OPEN_PAREN
## LR(1) items:
addr -> MALLOCSLK OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 248
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 77:
## Known stack suffix:
## MALLOCSL
## LR(1) items:
addr -> MALLOCSL . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 78
## Reductions:

State 78:
## Known stack suffix:
## MALLOCSL OPEN_PAREN
## LR(1) items:
addr -> MALLOCSL OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 244
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 79:
## Known stack suffix:
## MALLOC
## LR(1) items:
addr -> MALLOC . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 80
## Reductions:

State 80:
## Known stack suffix:
## MALLOC OPEN_PAREN
## LR(1) items:
addr -> MALLOC OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 238
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 81:
## Known stack suffix:
## LOWEST_ELEM
## LR(1) items:
elem -> LOWEST_ELEM . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> LOWEST_ELEM

State 82:
## Known stack suffix:
## LOCK
## LR(1) items:
lock -> LOCK . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 83
## Reductions:

State 83:
## Known stack suffix:
## LOCK OPEN_PAREN
## LR(1) items:
lock -> LOCK OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 234
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 84:
## Known stack suffix:
## LASTLOCKED
## LR(1) items:
addr -> LASTLOCKED . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 85
## Reductions:

State 85:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 230
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 86:
## Known stack suffix:
## INTRTH
## LR(1) items:
setth -> INTRTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## INTRTH OPEN_PAREN
## LR(1) items:
setth -> INTRTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 226
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 88:
## Known stack suffix:
## INTRINT
## LR(1) items:
setint -> INTRINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 89
## Reductions:

State 89:
## Known stack suffix:
## INTRINT OPEN_PAREN
## LR(1) items:
setint -> INTRINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 222
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 90:
## Known stack suffix:
## INTRELEM
## LR(1) items:
setelem -> INTRELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## INTRELEM OPEN_PAREN
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 218
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 92:
## Known stack suffix:
## INTR
## LR(1) items:
set -> INTR . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 93
## Reductions:

State 93:
## Known stack suffix:
## INTR OPEN_PAREN
## LR(1) items:
set -> INTR OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 214
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 94:
## Known stack suffix:
## INTOF
## LR(1) items:
integer -> INTOF . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 95
## Reductions:

State 95:
## Known stack suffix:
## INTOF OPEN_PAREN
## LR(1) items:
integer -> INTOF OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 212
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 96:
## Known stack suffix:
## IDENT
## LR(1) items:
ident -> IDENT . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ident -> IDENT

State 97:
## Known stack suffix:
## HIGHEST_ELEM
## LR(1) items:
elem -> HIGHEST_ELEM . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> HIGHEST_ELEM

State 98:
## Known stack suffix:
## HAVOCSKIPLISTELEM
## LR(1) items:
elem -> HAVOCSKIPLISTELEM . OPEN_PAREN CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 99
## Reductions:

State 99:
## Known stack suffix:
## HAVOCSKIPLISTELEM OPEN_PAREN
## LR(1) items:
elem -> HAVOCSKIPLISTELEM OPEN_PAREN . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_PAREN shift to state 100
## Reductions:

State 100:
## Known stack suffix:
## HAVOCSKIPLISTELEM OPEN_PAREN CLOSE_PAREN
## LR(1) items:
elem -> HAVOCSKIPLISTELEM OPEN_PAREN CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> HAVOCSKIPLISTELEM OPEN_PAREN CLOSE_PAREN

State 101:
## Known stack suffix:
## HAVOCLISTELEM
## LR(1) items:
elem -> HAVOCLISTELEM . OPEN_PAREN CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 102
## Reductions:

State 102:
## Known stack suffix:
## HAVOCLISTELEM OPEN_PAREN
## LR(1) items:
elem -> HAVOCLISTELEM OPEN_PAREN . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_PAREN shift to state 103
## Reductions:

State 103:
## Known stack suffix:
## HAVOCLISTELEM OPEN_PAREN CLOSE_PAREN
## LR(1) items:
elem -> HAVOCLISTELEM OPEN_PAREN CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> HAVOCLISTELEM OPEN_PAREN CLOSE_PAREN

State 104:
## Known stack suffix:
## HAVOCLEVEL
## LR(1) items:
integer -> HAVOCLEVEL . OPEN_PAREN CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 105
## Reductions:

State 105:
## Known stack suffix:
## HAVOCLEVEL OPEN_PAREN
## LR(1) items:
integer -> HAVOCLEVEL OPEN_PAREN . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_PAREN shift to state 106
## Reductions:

State 106:
## Known stack suffix:
## HAVOCLEVEL OPEN_PAREN CLOSE_PAREN
## LR(1) items:
integer -> HAVOCLEVEL OPEN_PAREN CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> HAVOCLEVEL OPEN_PAREN CLOSE_PAREN

State 107:
## Known stack suffix:
## HASHCODE
## LR(1) items:
integer -> HASHCODE . OPEN_PAREN term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 108
## Reductions:

State 108:
## Known stack suffix:
## HASHCODE OPEN_PAREN
## LR(1) items:
integer -> HASHCODE OPEN_PAREN . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 210
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 109:
## Known stack suffix:
## GETP
## LR(1) items:
path -> GETP . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 110
## Reductions:

State 110:
## Known stack suffix:
## GETP OPEN_PAREN
## LR(1) items:
path -> GETP OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 204
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 111:
## Known stack suffix:
## FIRSTLOCKED
## LR(1) items:
addr -> FIRSTLOCKED . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 112
## Reductions:

State 112:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 200
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 113:
## Known stack suffix:
## ERROR
## LR(1) items:
cell -> ERROR . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> ERROR

State 114:
## Known stack suffix:
## EPSILON
## LR(1) items:
path -> EPSILON . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path -> EPSILON

State 115:
## Known stack suffix:
## EMPTYSETTH
## LR(1) items:
setth -> EMPTYSETTH . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setth -> EMPTYSETTH

State 116:
## Known stack suffix:
## EMPTYSETINT
## LR(1) items:
setint -> EMPTYSETINT . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setint -> EMPTYSETINT

State 117:
## Known stack suffix:
## EMPTYSETELEM
## LR(1) items:
setelem -> EMPTYSETELEM . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> EMPTYSETELEM

State 118:
## Known stack suffix:
## EMPTYSET
## LR(1) items:
set -> EMPTYSET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> EMPTYSET

State 119:
## Known stack suffix:
## ARR_UPDATE
## LR(1) items:
arrayupd -> ARR_UPDATE . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 120
## Reductions:

State 120:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN
## LR(1) items:
arrayupd -> ARR_UPDATE OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 194
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 121:
## Known stack suffix:
## ADDR2SET
## LR(1) items:
set -> ADDR2SET . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> ADDR2SET . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_PAREN shift to state 122
## Reductions:

State 122:
## Known stack suffix:
## ADDR2SET OPEN_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> ADDR2SET OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 124
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 123:
## Known stack suffix:
## tid
## LR(1) items:
term -> tid . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> tid

State 124:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> ADDR2SET OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> ADDR2SET OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 188
## Reductions:

State 125:
## Known stack suffix:
## term POINTER
## LR(1) items:
addr -> term POINTER . NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term POINTER . NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term POINTER . ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term POINTER . DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term POINTER . MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term POINTER . LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On NEXTAT shift to state 126
-- On NEXT shift to state 180
-- On MARKED shift to state 181
-- On LOCKID shift to state 182
-- On DATA shift to state 183
-- On ARR shift to state 184
## Reductions:

State 126:
## Known stack suffix:
## term POINTER NEXTAT
## LR(1) items:
addr -> term POINTER NEXTAT . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_BRACKET shift to state 127
## Reductions:

State 127:
## Known stack suffix:
## term POINTER NEXTAT OPEN_BRACKET
## LR(1) items:
addr -> term POINTER NEXTAT OPEN_BRACKET . term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 128
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 128:
## Known stack suffix:
## term POINTER NEXTAT OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term POINTER NEXTAT OPEN_BRACKET term . CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 179
## Reductions:

State 129:
## Known stack suffix:
## term OPEN_BRACKET
## LR(1) items:
arraylookup -> term OPEN_BRACKET . term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 130
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 130:
## Known stack suffix:
## term OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term OPEN_BRACKET term . CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 178
## Reductions:

State 131:
## Known stack suffix:
## term MATH_PLUS
## LR(1) items:
integer -> term MATH_PLUS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 132
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 132:
## Known stack suffix:
## term MATH_PLUS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term MATH_PLUS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> term MATH_PLUS term

State 133:
## Known stack suffix:
## term MATH_MULT
## LR(1) items:
integer -> term MATH_MULT . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 134
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 134:
## Known stack suffix:
## term MATH_MULT term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term MATH_MULT term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> term MATH_MULT term

State 135:
## Known stack suffix:
## term DOT
## LR(1) items:
addr -> term DOT . NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term DOT . NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term DOT . ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term DOT . BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term DOT . BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term DOT . LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term DOT . UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term DOT . DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term DOT . MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term DOT . BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term DOT . LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term DOT . BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UNLOCK shift to state 136
-- On NEXTAT shift to state 137
-- On NEXT shift to state 165
-- On MARKED shift to state 166
-- On LOCKID shift to state 167
-- On LOCK shift to state 168
-- On DATA shift to state 169
-- On BTID shift to state 170
-- On BREGION shift to state 171
-- On BINIT shift to state 172
-- On BEND shift to state 173
-- On ARR shift to state 174
## Reductions:

State 136:
## Known stack suffix:
## term DOT UNLOCK
## LR(1) items:
cell -> term DOT UNLOCK . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> term DOT UNLOCK

State 137:
## Known stack suffix:
## term DOT NEXTAT
## LR(1) items:
addr -> term DOT NEXTAT . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_BRACKET shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET
## LR(1) items:
addr -> term DOT NEXTAT OPEN_BRACKET . term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 139
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 139:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term DOT NEXTAT OPEN_BRACKET term . CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 164
## Reductions:

State 140:
## Known stack suffix:
## term MATH_MOD
## LR(1) items:
integer -> term MATH_MOD . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 141
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 141:
## Known stack suffix:
## term MATH_MOD term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term MATH_MOD term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> term MATH_MOD term

State 142:
## Known stack suffix:
## setth
## LR(1) items:
term -> setth . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> setth

State 143:
## Known stack suffix:
## setpair
## LR(1) items:
term -> setpair . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> setpair

State 144:
## Known stack suffix:
## setint
## LR(1) items:
term -> setint . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> setint

State 145:
## Known stack suffix:
## setelem
## LR(1) items:
term -> setelem . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> setelem

State 146:
## Known stack suffix:
## set
## LR(1) items:
term -> set . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> set

State 147:
## Known stack suffix:
## path
## LR(1) items:
term -> path . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> path

State 148:
## Known stack suffix:
## pair
## LR(1) items:
term -> pair . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> pair

State 149:
## Known stack suffix:
## mem
## LR(1) items:
term -> mem . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> mem

State 150:
## Known stack suffix:
## mark
## LR(1) items:
term -> mark . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> mark

State 151:
## Known stack suffix:
## lock
## LR(1) items:
term -> lock . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> lock

State 152:
## Known stack suffix:
## integer
## LR(1) items:
term -> integer . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> integer

State 153:
## Known stack suffix:
## ident
## LR(1) items:
term -> ident . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> ident

State 154:
## Known stack suffix:
## elem
## LR(1) items:
term -> elem . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> elem

State 155:
## Known stack suffix:
## cell
## LR(1) items:
term -> cell . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> cell

State 156:
## Known stack suffix:
## bucket
## LR(1) items:
term -> bucket . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> bucket

State 157:
## Known stack suffix:
## arrayupd
## LR(1) items:
term -> arrayupd . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> arrayupd

State 158:
## Known stack suffix:
## arraylookup
## LR(1) items:
term -> arraylookup . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> arraylookup

State 159:
## Known stack suffix:
## addr
## LR(1) items:
term -> addr . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> addr

State 160:
## Known stack suffix:
## term MATH_MINUS
## LR(1) items:
integer -> term MATH_MINUS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 161
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 161:
## Known stack suffix:
## term MATH_MINUS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term MATH_MINUS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> term MATH_MINUS term

State 162:
## Known stack suffix:
## term MATH_DIV
## LR(1) items:
integer -> term MATH_DIV . term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 163
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 163:
## Known stack suffix:
## term MATH_DIV term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term MATH_DIV term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> term MATH_DIV term

State 164:
## Known stack suffix:
## term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
addr -> term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET

State 165:
## Known stack suffix:
## term DOT NEXT
## LR(1) items:
addr -> term DOT NEXT . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term DOT NEXT

State 166:
## Known stack suffix:
## term DOT MARKED
## LR(1) items:
mark -> term DOT MARKED . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mark -> term DOT MARKED

State 167:
## Known stack suffix:
## term DOT LOCKID
## LR(1) items:
tid -> term DOT LOCKID . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> term DOT LOCKID

State 168:
## Known stack suffix:
## term DOT LOCK
## LR(1) items:
cell -> term DOT LOCK . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> term DOT LOCK

State 169:
## Known stack suffix:
## term DOT DATA
## LR(1) items:
elem -> term DOT DATA . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> term DOT DATA

State 170:
## Known stack suffix:
## term DOT BTID
## LR(1) items:
tid -> term DOT BTID . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> term DOT BTID

State 171:
## Known stack suffix:
## term DOT BREGION
## LR(1) items:
set -> term DOT BREGION . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> term DOT BREGION

State 172:
## Known stack suffix:
## term DOT BINIT
## LR(1) items:
addr -> term DOT BINIT . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term DOT BINIT

State 173:
## Known stack suffix:
## term DOT BEND
## LR(1) items:
addr -> term DOT BEND . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term DOT BEND

State 174:
## Known stack suffix:
## term DOT ARR
## LR(1) items:
addr -> term DOT ARR . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_BRACKET shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## term DOT ARR OPEN_BRACKET
## LR(1) items:
addr -> term DOT ARR OPEN_BRACKET . term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 176
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 176:
## Known stack suffix:
## term DOT ARR OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term DOT ARR OPEN_BRACKET term . CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## term DOT ARR OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
addr -> term DOT ARR OPEN_BRACKET term CLOSE_BRACKET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term DOT ARR OPEN_BRACKET term CLOSE_BRACKET

State 178:
## Known stack suffix:
## term OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
arraylookup -> term OPEN_BRACKET term CLOSE_BRACKET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arraylookup -> term OPEN_BRACKET term CLOSE_BRACKET

State 179:
## Known stack suffix:
## term POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
addr -> term POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET

State 180:
## Known stack suffix:
## term POINTER NEXT
## LR(1) items:
addr -> term POINTER NEXT . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term POINTER NEXT

State 181:
## Known stack suffix:
## term POINTER MARKED
## LR(1) items:
mark -> term POINTER MARKED . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mark -> term POINTER MARKED

State 182:
## Known stack suffix:
## term POINTER LOCKID
## LR(1) items:
tid -> term POINTER LOCKID . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> term POINTER LOCKID

State 183:
## Known stack suffix:
## term POINTER DATA
## LR(1) items:
elem -> term POINTER DATA . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elem -> term POINTER DATA

State 184:
## Known stack suffix:
## term POINTER ARR
## LR(1) items:
addr -> term POINTER ARR . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_BRACKET shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## term POINTER ARR OPEN_BRACKET
## LR(1) items:
addr -> term POINTER ARR OPEN_BRACKET . term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 186
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 186:
## Known stack suffix:
## term POINTER ARR OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term POINTER ARR OPEN_BRACKET term . CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 187
## Reductions:

State 187:
## Known stack suffix:
## term POINTER ARR OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
addr -> term POINTER ARR OPEN_BRACKET term CLOSE_BRACKET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> term POINTER ARR OPEN_BRACKET term CLOSE_BRACKET

State 188:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> ADDR2SET OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 189
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 189:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> ADDR2SET OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> ADDR2SET OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 190
-- On CLOSE_PAREN shift to state 193
## Reductions:

State 190:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 191
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 191:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 192
## Reductions:

State 192:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> ADDR2SET OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 193:
## Known stack suffix:
## ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> ADDR2SET OPEN_PAREN term COMMA term CLOSE_PAREN

State 194:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrayupd -> ARR_UPDATE OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 195
## Reductions:

State 195:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA
## LR(1) items:
arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 196
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 196:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA
## LR(1) items:
arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 198
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 198:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 199
## Reductions:

State 199:
## Known stack suffix:
## ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arrayupd -> ARR_UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 200:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> FIRSTLOCKED OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 201
## Reductions:

State 201:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 202
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 202:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 203
## Reductions:

State 203:
## Known stack suffix:
## FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> FIRSTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN

State 204:
## Known stack suffix:
## GETP OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
path -> GETP OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 205
## Reductions:

State 205:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 206
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 206:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
path -> GETP OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 207
## Reductions:

State 207:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 208
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 208:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
path -> GETP OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
path -> GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path -> GETP OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 210:
## Known stack suffix:
## HASHCODE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> HASHCODE OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 211
## Reductions:

State 211:
## Known stack suffix:
## HASHCODE OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> HASHCODE OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> HASHCODE OPEN_PAREN term CLOSE_PAREN

State 212:
## Known stack suffix:
## INTOF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> INTOF OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 213
## Reductions:

State 213:
## Known stack suffix:
## INTOF OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> INTOF OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> INTOF OPEN_PAREN term CLOSE_PAREN

State 214:
## Known stack suffix:
## INTR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> INTR OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 215
## Reductions:

State 215:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA
## LR(1) items:
set -> INTR OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 216
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 216:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> INTR OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 217
## Reductions:

State 217:
## Known stack suffix:
## INTR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> INTR OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> INTR OPEN_PAREN term COMMA term CLOSE_PAREN

State 218:
## Known stack suffix:
## INTRELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> INTRELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 219
## Reductions:

State 219:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 220
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 220:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> INTRELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> INTRELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 222:
## Known stack suffix:
## INTRINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> INTRINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 223
## Reductions:

State 223:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> INTRINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 224
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 224:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> INTRINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setint -> INTRINT OPEN_PAREN term COMMA term CLOSE_PAREN

State 226:
## Known stack suffix:
## INTRTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> INTRTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 227
## Reductions:

State 227:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> INTRTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 228
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 228:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> INTRTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 229
## Reductions:

State 229:
## Known stack suffix:
## INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setth -> INTRTH OPEN_PAREN term COMMA term CLOSE_PAREN

State 230:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> LASTLOCKED OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 231
## Reductions:

State 231:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 232
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 232:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> LASTLOCKED OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 233
## Reductions:

State 233:
## Known stack suffix:
## LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> LASTLOCKED OPEN_PAREN term COMMA term CLOSE_PAREN

State 234:
## Known stack suffix:
## LOCK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
lock -> LOCK OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA
## LR(1) items:
lock -> LOCK OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 236
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 236:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
lock -> LOCK OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 237
## Reductions:

State 237:
## Known stack suffix:
## LOCK OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
lock -> LOCK OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lock -> LOCK OPEN_PAREN term COMMA term CLOSE_PAREN

State 238:
## Known stack suffix:
## MALLOC OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> MALLOC OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## MALLOC OPEN_PAREN term COMMA
## LR(1) items:
addr -> MALLOC OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 240
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 240:
## Known stack suffix:
## MALLOC OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> MALLOC OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 241
## Reductions:

State 241:
## Known stack suffix:
## MALLOC OPEN_PAREN term COMMA term COMMA
## LR(1) items:
addr -> MALLOC OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 242
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 242:
## Known stack suffix:
## MALLOC OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> MALLOC OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 243
## Reductions:

State 243:
## Known stack suffix:
## MALLOC OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> MALLOC OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> MALLOC OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 244:
## Known stack suffix:
## MALLOCSL OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> MALLOCSL OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 245
## Reductions:

State 245:
## Known stack suffix:
## MALLOCSL OPEN_PAREN term COMMA
## LR(1) items:
addr -> MALLOCSL OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 246
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 246:
## Known stack suffix:
## MALLOCSL OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> MALLOCSL OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## MALLOCSL OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> MALLOCSL OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> MALLOCSL OPEN_PAREN term COMMA term CLOSE_PAREN

State 248:
## Known stack suffix:
## MALLOCSLK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> MALLOCSLK OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 249
## Reductions:

State 249:
## Known stack suffix:
## MALLOCSLK OPEN_PAREN term COMMA
## LR(1) items:
addr -> MALLOCSLK OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 250
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 250:
## Known stack suffix:
## MALLOCSLK OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> MALLOCSLK OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 251
## Reductions:

State 251:
## Known stack suffix:
## MALLOCSLK OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
addr -> MALLOCSLK OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production addr -> MALLOCSLK OPEN_PAREN term COMMA term CLOSE_PAREN

State 252:
## Known stack suffix:
## MATH_MINUS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> MATH_MINUS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN
--   reduce production integer -> MATH_MINUS term

State 253:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MEMORY_READ OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 255
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 255:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> MEMORY_READ OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 256
## Reductions:

State 256:
## Known stack suffix:
## MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> MEMORY_READ OPEN_PAREN term COMMA term CLOSE_PAREN

State 257:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 259
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 259:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 261
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 261:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 263
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 263:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 264
## Reductions:

State 264:
## Known stack suffix:
## MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production bucket -> MKBUCKET OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN

State 265:
## Known stack suffix:
## MKCELL OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MKCELL OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term . COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 266
## Reductions:

State 266:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term COMMA . OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On OPEN_BRACKET shift to state 267
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 279
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 267:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET . term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term_list shift to state 268
-- On term shift to state 275
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 268:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list . CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_BRACKET shift to state 269
## Reductions:

State 269:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET . COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On COMMA shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA . OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On OPEN_BRACKET shift to state 271
## Reductions:

State 271:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET . term_list CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term_list shift to state 272
-- On term shift to state 275
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 272:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list . CLOSE_BRACKET CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_BRACKET shift to state 273
## Reductions:

State 273:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On CLOSE_PAREN shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> MKCELL OPEN_PAREN term COMMA OPEN_BRACKET term_list CLOSE_BRACKET COMMA OPEN_BRACKET term_list CLOSE_BRACKET CLOSE_PAREN

State 275:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
term_list -> term . COMMA term [ CLOSE_BRACKET ]
term_list -> term . COMMA term_list [ CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 276
## Reductions:

State 276:
## Known stack suffix:
## term COMMA
## LR(1) items:
term_list -> term COMMA . term [ CLOSE_BRACKET ]
term_list -> term COMMA . term_list [ CLOSE_BRACKET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term_list shift to state 277
-- On term shift to state 278
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 277:
## Known stack suffix:
## term COMMA term_list
## LR(1) items:
term_list -> term COMMA term_list . [ CLOSE_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term_list -> term COMMA term_list

State 278:
## Known stack suffix:
## term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
term_list -> term . COMMA term [ CLOSE_BRACKET ]
term_list -> term COMMA term . [ CLOSE_BRACKET ]
term_list -> term . COMMA term_list [ CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 276
## Reductions:
-- On CLOSE_BRACKET
--   reduce production term_list -> term COMMA term

State 279:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> MKCELL OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 280
## Reductions:

State 280:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 281
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 281:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 282
-- On CLOSE_PAREN shift to state 285
## Reductions:

State 282:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 283
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 283:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN

State 285:
## Known stack suffix:
## MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
cell -> MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cell -> MKCELL OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 286:
## Known stack suffix:
## OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
pair -> OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
term -> OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 287
-- On CLOSE_PAREN shift to state 290
## Reductions:

State 287:
## Known stack suffix:
## OPEN_PAREN term COMMA
## LR(1) items:
pair -> OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 288
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 288:
## Known stack suffix:
## OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
pair -> OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pair -> OPEN_PAREN term COMMA term CLOSE_PAREN

State 290:
## Known stack suffix:
## OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
term -> OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production term -> OPEN_PAREN term CLOSE_PAREN

State 291:
## Known stack suffix:
## OPEN_SET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
set -> OPEN_SET term . CLOSE_SET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_SET shift to state 292
## Reductions:

State 292:
## Known stack suffix:
## OPEN_SET term CLOSE_SET
## LR(1) items:
set -> OPEN_SET term CLOSE_SET . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> OPEN_SET term CLOSE_SET

State 293:
## Known stack suffix:
## PATH2SET OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> PATH2SET OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 294
## Reductions:

State 294:
## Known stack suffix:
## PATH2SET OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
set -> PATH2SET OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> PATH2SET OPEN_PAREN term CLOSE_PAREN

State 295:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> SET2ELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 297
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 297:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SET2ELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 298
## Reductions:

State 298:
## Known stack suffix:
## SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> SET2ELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 299:
## Known stack suffix:
## SETDIFF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> SETDIFF OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 300
## Reductions:

State 300:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA
## LR(1) items:
set -> SETDIFF OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 301
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 301:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> SETDIFF OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 302
## Reductions:

State 302:
## Known stack suffix:
## SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> SETDIFF OPEN_PAREN term COMMA term CLOSE_PAREN

State 303:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> SETDIFFELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 304
## Reductions:

State 304:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 305
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 305:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SETDIFFELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> SETDIFFELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 307:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> SETDIFFINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 309
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 309:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> SETDIFFINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setint -> SETDIFFINT OPEN_PAREN term COMMA term CLOSE_PAREN

State 311:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> SETDIFFTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 313
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 313:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> SETDIFFTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 314
## Reductions:

State 314:
## Known stack suffix:
## SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setth -> SETDIFFTH OPEN_PAREN term COMMA term CLOSE_PAREN

State 315:
## Known stack suffix:
## SETINTMAX OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> SETINTMAX OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 316
## Reductions:

State 316:
## Known stack suffix:
## SETINTMAX OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> SETINTMAX OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> SETINTMAX OPEN_PAREN term CLOSE_PAREN

State 317:
## Known stack suffix:
## SETINTMIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> SETINTMIN OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 318
## Reductions:

State 318:
## Known stack suffix:
## SETINTMIN OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
integer -> SETINTMIN OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production integer -> SETINTMIN OPEN_PAREN term CLOSE_PAREN

State 319:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRDIFF OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 321
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 321:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 322
## Reductions:

State 322:
## Known stack suffix:
## SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setpair -> SETPAIRDIFF OPEN_PAREN term COMMA term CLOSE_PAREN

State 323:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRINTR OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 324
## Reductions:

State 324:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 325
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 325:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRINTR OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setpair -> SETPAIRINTR OPEN_PAREN term COMMA term CLOSE_PAREN

State 327:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> SETPAIRMAX OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## SETPAIRMAX OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
pair -> SETPAIRMAX OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pair -> SETPAIRMAX OPEN_PAREN term CLOSE_PAREN

State 329:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
pair -> SETPAIRMIN OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## SETPAIRMIN OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
pair -> SETPAIRMIN OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production pair -> SETPAIRMIN OPEN_PAREN term CLOSE_PAREN

State 331:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRSINGLE OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setpair -> SETPAIRSINGLE OPEN_PAREN term CLOSE_PAREN

State 333:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setpair -> SETPAIRUNION OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 335
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 335:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setpair -> SETPAIRUNION OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setpair -> SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setpair -> SETPAIRUNION OPEN_PAREN term COMMA term CLOSE_PAREN

State 337:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> SINGLEELEM OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## SINGLEELEM OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setelem -> SINGLEELEM OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> SINGLEELEM OPEN_PAREN term CLOSE_PAREN

State 339:
## Known stack suffix:
## SINGLEINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> SINGLEINT OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 340
## Reductions:

State 340:
## Known stack suffix:
## SINGLEINT OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setint -> SINGLEINT OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setint -> SINGLEINT OPEN_PAREN term CLOSE_PAREN

State 341:
## Known stack suffix:
## SINGLETH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> SINGLETH OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 342
## Reductions:

State 342:
## Known stack suffix:
## SINGLETH OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
setth -> SINGLETH OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setth -> SINGLETH OPEN_PAREN term CLOSE_PAREN

State 343:
## Known stack suffix:
## SINGLE_PATH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
path -> SINGLE_PATH OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## SINGLE_PATH OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
path -> SINGLE_PATH OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production path -> SINGLE_PATH OPEN_PAREN term CLOSE_PAREN

State 345:
## Known stack suffix:
## TIDOF OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> TIDOF OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 346
## Reductions:

State 346:
## Known stack suffix:
## TIDOF OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
tid -> TIDOF OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tid -> TIDOF OPEN_PAREN term CLOSE_PAREN

State 347:
## Known stack suffix:
## UNION OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> UNION OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 348
## Reductions:

State 348:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA
## LR(1) items:
set -> UNION OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 349
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 349:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> UNION OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## UNION OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
set -> UNION OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production set -> UNION OPEN_PAREN term COMMA term CLOSE_PAREN

State 351:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setelem -> UNIONELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 353
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 353:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setelem -> UNIONELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setelem -> UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setelem -> UNIONELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 355:
## Known stack suffix:
## UNIONINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setint -> UNIONINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 356
## Reductions:

State 356:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA
## LR(1) items:
setint -> UNIONINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 357
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 357:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setint -> UNIONINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 358
## Reductions:

State 358:
## Known stack suffix:
## UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setint -> UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setint -> UNIONINT OPEN_PAREN term COMMA term CLOSE_PAREN

State 359:
## Known stack suffix:
## UNIONTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
setth -> UNIONTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 360
## Reductions:

State 360:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA
## LR(1) items:
setth -> UNIONTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 361
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 361:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
setth -> UNIONTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
setth -> UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production setth -> UNIONTH OPEN_PAREN term COMMA term CLOSE_PAREN

State 363:
## Known stack suffix:
## UNLOCK OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
lock -> UNLOCK OPEN_PAREN term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 364
## Reductions:

State 364:
## Known stack suffix:
## UNLOCK OPEN_PAREN term CLOSE_PAREN
## LR(1) items:
lock -> UNLOCK OPEN_PAREN term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lock -> UNLOCK OPEN_PAREN term CLOSE_PAREN

State 365:
## Known stack suffix:
## UPDATE OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mem -> UPDATE OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 366
## Reductions:

State 366:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 367
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 367:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mem -> UPDATE OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 368
## Reductions:

State 368:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 369
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 369:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mem -> UPDATE OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 370
## Reductions:

State 370:
## Known stack suffix:
## UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
mem -> UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_SET CLOSE_PAREN CLOSE_BRACKET BEGIN ASSUME ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mem -> UPDATE OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 371:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term . CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term CLOSE_PAREN
## LR(1) items:
global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term CLOSE_PAREN . [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production global_decl -> kind IDENT SETPAIRSUBSETEQ OPEN_PAREN IDENT COMMA term CLOSE_PAREN

State 373:
## Known stack suffix:
## kind IDENT SETPAIRIN
## LR(1) items:
global_decl -> kind IDENT SETPAIRIN . OPEN_PAREN IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## kind IDENT SETPAIRIN OPEN_PAREN
## LR(1) items:
global_decl -> kind IDENT SETPAIRIN OPEN_PAREN . IDENT COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On IDENT shift to state 375
## Reductions:

State 375:
## Known stack suffix:
## kind IDENT SETPAIRIN OPEN_PAREN IDENT
## LR(1) items:
global_decl -> kind IDENT SETPAIRIN OPEN_PAREN IDENT . COMMA term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On COMMA shift to state 376
## Reductions:

State 376:
## Known stack suffix:
## kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA
## LR(1) items:
global_decl -> kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA . term CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 377
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 377:
## Known stack suffix:
## kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
global_decl -> kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term . CLOSE_PAREN [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 378
## Reductions:

State 378:
## Known stack suffix:
## kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term CLOSE_PAREN
## LR(1) items:
global_decl -> kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term CLOSE_PAREN . [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production global_decl -> kind IDENT SETPAIRIN OPEN_PAREN IDENT COMMA term CLOSE_PAREN

State 379:
## Known stack suffix:
## kind IDENT IDENT
## LR(1) items:
global_decl -> kind IDENT IDENT . [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . ASSIGN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . ASSIGN formula [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . MATH_LESS term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . MATH_GREATER term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . MATH_LESS_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . MATH_GREATER_EQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . IN term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . SUBSETEQ term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . INTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . SUBSETEQTH term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . ININT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . SUBSETEQINT term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . INELEM term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT . SUBSETEQELEM term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On SUBSETEQTH shift to state 380
-- On SUBSETEQINT shift to state 382
-- On SUBSETEQELEM shift to state 384
-- On SUBSETEQ shift to state 386
-- On MATH_LESS_EQ shift to state 388
-- On MATH_LESS shift to state 390
-- On MATH_GREATER_EQ shift to state 392
-- On MATH_GREATER shift to state 394
-- On INTH shift to state 396
-- On ININT shift to state 398
-- On INELEM shift to state 400
-- On IN shift to state 402
-- On ASSIGN shift to state 404
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT

State 380:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQTH
## LR(1) items:
global_decl -> kind IDENT IDENT SUBSETEQTH . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 381
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 381:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQTH term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT SUBSETEQTH term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT SUBSETEQTH term

State 382:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQINT
## LR(1) items:
global_decl -> kind IDENT IDENT SUBSETEQINT . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 383
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 383:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQINT term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT SUBSETEQINT term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT SUBSETEQINT term

State 384:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQELEM
## LR(1) items:
global_decl -> kind IDENT IDENT SUBSETEQELEM . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 385
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 385:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQELEM term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT SUBSETEQELEM term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT SUBSETEQELEM term

State 386:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQ
## LR(1) items:
global_decl -> kind IDENT IDENT SUBSETEQ . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 387
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 387:
## Known stack suffix:
## kind IDENT IDENT SUBSETEQ term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT SUBSETEQ term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT SUBSETEQ term

State 388:
## Known stack suffix:
## kind IDENT IDENT MATH_LESS_EQ
## LR(1) items:
global_decl -> kind IDENT IDENT MATH_LESS_EQ . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 389
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 389:
## Known stack suffix:
## kind IDENT IDENT MATH_LESS_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT MATH_LESS_EQ term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT MATH_LESS_EQ term

State 390:
## Known stack suffix:
## kind IDENT IDENT MATH_LESS
## LR(1) items:
global_decl -> kind IDENT IDENT MATH_LESS . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 391
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 391:
## Known stack suffix:
## kind IDENT IDENT MATH_LESS term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT MATH_LESS term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT MATH_LESS term

State 392:
## Known stack suffix:
## kind IDENT IDENT MATH_GREATER_EQ
## LR(1) items:
global_decl -> kind IDENT IDENT MATH_GREATER_EQ . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 393
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 393:
## Known stack suffix:
## kind IDENT IDENT MATH_GREATER_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT MATH_GREATER_EQ term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT MATH_GREATER_EQ term

State 394:
## Known stack suffix:
## kind IDENT IDENT MATH_GREATER
## LR(1) items:
global_decl -> kind IDENT IDENT MATH_GREATER . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 395
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 395:
## Known stack suffix:
## kind IDENT IDENT MATH_GREATER term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT MATH_GREATER term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT MATH_GREATER term

State 396:
## Known stack suffix:
## kind IDENT IDENT INTH
## LR(1) items:
global_decl -> kind IDENT IDENT INTH . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 397
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 397:
## Known stack suffix:
## kind IDENT IDENT INTH term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT INTH term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT INTH term

State 398:
## Known stack suffix:
## kind IDENT IDENT ININT
## LR(1) items:
global_decl -> kind IDENT IDENT ININT . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 399
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 399:
## Known stack suffix:
## kind IDENT IDENT ININT term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT ININT term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT ININT term

State 400:
## Known stack suffix:
## kind IDENT IDENT INELEM
## LR(1) items:
global_decl -> kind IDENT IDENT INELEM . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 401
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 401:
## Known stack suffix:
## kind IDENT IDENT INELEM term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT INELEM term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT INELEM term

State 402:
## Known stack suffix:
## kind IDENT IDENT IN
## LR(1) items:
global_decl -> kind IDENT IDENT IN . term [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 403
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 403:
## Known stack suffix:
## kind IDENT IDENT IN term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
global_decl -> kind IDENT IDENT IN term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV IDENT GHOST DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT IN term

State 404:
## Known stack suffix:
## kind IDENT IDENT ASSIGN
## LR(1) items:
global_decl -> kind IDENT IDENT ASSIGN . term [ PROCEDURE IDENT GHOST ASSUME ]
global_decl -> kind IDENT IDENT ASSIGN . formula [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 551
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 552
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 405:
## Known stack suffix:
## SUBSETEQTH
## LR(1) items:
atom -> SUBSETEQTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 406
## Reductions:

State 406:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN
## LR(1) items:
atom -> SUBSETEQTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 407
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 407:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SUBSETEQTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA
## LR(1) items:
atom -> SUBSETEQTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 409
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 409:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SUBSETEQTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 410
## Reductions:

State 410:
## Known stack suffix:
## SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SUBSETEQTH OPEN_PAREN term COMMA term CLOSE_PAREN

State 411:
## Known stack suffix:
## SUBSETEQINT
## LR(1) items:
atom -> SUBSETEQINT . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 412
## Reductions:

State 412:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN
## LR(1) items:
atom -> SUBSETEQINT OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 413
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 413:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SUBSETEQINT OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 414
## Reductions:

State 414:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA
## LR(1) items:
atom -> SUBSETEQINT OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 415
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 415:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SUBSETEQINT OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 416
## Reductions:

State 416:
## Known stack suffix:
## SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SUBSETEQINT OPEN_PAREN term COMMA term CLOSE_PAREN

State 417:
## Known stack suffix:
## SUBSETEQELEM
## LR(1) items:
atom -> SUBSETEQELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 418
## Reductions:

State 418:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN
## LR(1) items:
atom -> SUBSETEQELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 419
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 419:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SUBSETEQELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 420
## Reductions:

State 420:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA
## LR(1) items:
atom -> SUBSETEQELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 421
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 421:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SUBSETEQELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 422
## Reductions:

State 422:
## Known stack suffix:
## SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SUBSETEQELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 423:
## Known stack suffix:
## SUBSETEQ
## LR(1) items:
atom -> SUBSETEQ . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN
## LR(1) items:
atom -> SUBSETEQ OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 425
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 425:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SUBSETEQ OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 426
## Reductions:

State 426:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA
## LR(1) items:
atom -> SUBSETEQ OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 427
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 427:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SUBSETEQ OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 428
## Reductions:

State 428:
## Known stack suffix:
## SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN

State 429:
## Known stack suffix:
## SKIPLIST
## LR(1) items:
atom -> SKIPLIST . OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 430
## Reductions:

State 430:
## Known stack suffix:
## SKIPLIST OPEN_PAREN
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN . term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 431
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 431:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SKIPLIST OPEN_PAREN term . COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 432
## Reductions:

State 432:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA . term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 433
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 433:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SKIPLIST OPEN_PAREN term COMMA term . COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA . term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 435
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 435:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term . COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 436
## Reductions:

State 436:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 437
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 437:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 438
## Reductions:

State 438:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 439
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 439:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 440
## Reductions:

State 440:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 441
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 441:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 442
## Reductions:

State 442:
## Known stack suffix:
## SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SKIPLIST OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN

State 443:
## Known stack suffix:
## SETPAIRSUBSETEQ
## LR(1) items:
atom -> SETPAIRSUBSETEQ . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 444
## Reductions:

State 444:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN
## LR(1) items:
atom -> SETPAIRSUBSETEQ OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 445
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 445:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SETPAIRSUBSETEQ OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 446
## Reductions:

State 446:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA
## LR(1) items:
atom -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 447
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 447:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 448
## Reductions:

State 448:
## Known stack suffix:
## SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SETPAIRSUBSETEQ OPEN_PAREN term COMMA term CLOSE_PAREN

State 449:
## Known stack suffix:
## SETPAIRIN
## LR(1) items:
atom -> SETPAIRIN . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 450
## Reductions:

State 450:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN
## LR(1) items:
atom -> SETPAIRIN OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 451
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 451:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> SETPAIRIN OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA
## LR(1) items:
atom -> SETPAIRIN OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 453
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 453:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> SETPAIRIN OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> SETPAIRIN OPEN_PAREN term COMMA term CLOSE_PAREN

State 455:
## Known stack suffix:
## REACH
## LR(1) items:
atom -> REACH . OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 456
## Reductions:

State 456:
## Known stack suffix:
## REACH OPEN_PAREN
## LR(1) items:
atom -> REACH OPEN_PAREN . term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 457
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 457:
## Known stack suffix:
## REACH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> REACH OPEN_PAREN term . COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 458
## Reductions:

State 458:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA
## LR(1) items:
atom -> REACH OPEN_PAREN term COMMA . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 459
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 459:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> REACH OPEN_PAREN term COMMA term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 460
## Reductions:

State 460:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA
## LR(1) items:
atom -> REACH OPEN_PAREN term COMMA term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 461
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 461:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> REACH OPEN_PAREN term COMMA term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 462
## Reductions:

State 462:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
atom -> REACH OPEN_PAREN term COMMA term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 463
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 463:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 464
## Reductions:

State 464:
## Known stack suffix:
## REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> REACH OPEN_PAREN term COMMA term COMMA term COMMA term CLOSE_PAREN

State 465:
## Known stack suffix:
## ORDERLIST
## LR(1) items:
atom -> ORDERLIST . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 466
## Reductions:

State 466:
## Known stack suffix:
## ORDERLIST OPEN_PAREN
## LR(1) items:
atom -> ORDERLIST OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 467
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 467:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> ORDERLIST OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 468
## Reductions:

State 468:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA
## LR(1) items:
atom -> ORDERLIST OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 469
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 469:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> ORDERLIST OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 470
## Reductions:

State 470:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA
## LR(1) items:
atom -> ORDERLIST OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 471
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 471:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> ORDERLIST OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 472
## Reductions:

State 472:
## Known stack suffix:
## ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> ORDERLIST OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 473:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
formula -> OPEN_PAREN . formula CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> OPEN_PAREN . IDENT CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
pair -> OPEN_PAREN . term COMMA term CLOSE_PAREN [ SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_PAREN BEGIN ASSUME ]
term -> OPEN_PAREN . term CLOSE_PAREN [ SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 538
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 540
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 541
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 474:
## Known stack suffix:
## LOGICAL_TRUE
## LR(1) items:
formula -> LOGICAL_TRUE . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> LOGICAL_TRUE

State 475:
## Known stack suffix:
## LOGICAL_NOT
## LR(1) items:
formula -> LOGICAL_NOT . formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 534
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 476:
## Known stack suffix:
## LOGICAL_FALSE
## LR(1) items:
formula -> LOGICAL_FALSE . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> LOGICAL_FALSE

State 477:
## Known stack suffix:
## INTH
## LR(1) items:
atom -> INTH . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 478
## Reductions:

State 478:
## Known stack suffix:
## INTH OPEN_PAREN
## LR(1) items:
atom -> INTH OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 479
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 479:
## Known stack suffix:
## INTH OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> INTH OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 480
## Reductions:

State 480:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA
## LR(1) items:
atom -> INTH OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 481
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 481:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> INTH OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## INTH OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> INTH OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> INTH OPEN_PAREN term COMMA term CLOSE_PAREN

State 483:
## Known stack suffix:
## ININT
## LR(1) items:
atom -> ININT . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 484
## Reductions:

State 484:
## Known stack suffix:
## ININT OPEN_PAREN
## LR(1) items:
atom -> ININT OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 485
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 485:
## Known stack suffix:
## ININT OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> ININT OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 486
## Reductions:

State 486:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA
## LR(1) items:
atom -> ININT OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 487
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 487:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> ININT OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 488
## Reductions:

State 488:
## Known stack suffix:
## ININT OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> ININT OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> ININT OPEN_PAREN term COMMA term CLOSE_PAREN

State 489:
## Known stack suffix:
## INELEM
## LR(1) items:
atom -> INELEM . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 490
## Reductions:

State 490:
## Known stack suffix:
## INELEM OPEN_PAREN
## LR(1) items:
atom -> INELEM OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 491
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 491:
## Known stack suffix:
## INELEM OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> INELEM OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA
## LR(1) items:
atom -> INELEM OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 493
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 493:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> INELEM OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 494
## Reductions:

State 494:
## Known stack suffix:
## INELEM OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> INELEM OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> INELEM OPEN_PAREN term COMMA term CLOSE_PAREN

State 495:
## Known stack suffix:
## IN
## LR(1) items:
atom -> IN . OPEN_PAREN term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 496
## Reductions:

State 496:
## Known stack suffix:
## IN OPEN_PAREN
## LR(1) items:
atom -> IN OPEN_PAREN . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 497
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 497:
## Known stack suffix:
## IN OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> IN OPEN_PAREN term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 498
## Reductions:

State 498:
## Known stack suffix:
## IN OPEN_PAREN term COMMA
## LR(1) items:
atom -> IN OPEN_PAREN term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 499
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 499:
## Known stack suffix:
## IN OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> IN OPEN_PAREN term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 500
## Reductions:

State 500:
## Known stack suffix:
## IN OPEN_PAREN term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> IN OPEN_PAREN term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> IN OPEN_PAREN term COMMA term CLOSE_PAREN

State 501:
## Known stack suffix:
## HASHTBL
## LR(1) items:
atom -> HASHTBL . OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 502
## Reductions:

State 502:
## Known stack suffix:
## HASHTBL OPEN_PAREN
## LR(1) items:
atom -> HASHTBL OPEN_PAREN . term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 503
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 503:
## Known stack suffix:
## HASHTBL OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> HASHTBL OPEN_PAREN term . COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA
## LR(1) items:
atom -> HASHTBL OPEN_PAREN term COMMA . term COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 505
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 505:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> HASHTBL OPEN_PAREN term COMMA term . COMMA term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 506
## Reductions:

State 506:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA
## LR(1) items:
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 507
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 507:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 508
## Reductions:

State 508:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA
## LR(1) items:
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 509
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 509:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA
## LR(1) items:
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 511
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 511:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> HASHTBL OPEN_PAREN term COMMA term COMMA term COMMA term COMMA term CLOSE_PAREN

State 513:
## Known stack suffix:
## APPEND
## LR(1) items:
atom -> APPEND . OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On OPEN_PAREN shift to state 514
## Reductions:

State 514:
## Known stack suffix:
## APPEND OPEN_PAREN
## LR(1) items:
atom -> APPEND OPEN_PAREN . term COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 515
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 515:
## Known stack suffix:
## APPEND OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> APPEND OPEN_PAREN term . COMMA term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 516
## Reductions:

State 516:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA
## LR(1) items:
atom -> APPEND OPEN_PAREN term COMMA . term COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 517
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 517:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
atom -> APPEND OPEN_PAREN term COMMA term . COMMA term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 518
## Reductions:

State 518:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA
## LR(1) items:
atom -> APPEND OPEN_PAREN term COMMA term COMMA . term CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 519
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 519:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
atom -> APPEND OPEN_PAREN term COMMA term COMMA term . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_PAREN shift to state 520
## Reductions:

State 520:
## Known stack suffix:
## APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN
## LR(1) items:
atom -> APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> APPEND OPEN_PAREN term COMMA term COMMA term CLOSE_PAREN

State 521:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
atom -> term . MATH_LESS term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
atom -> term . MATH_GREATER term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
atom -> term . MATH_LESS_EQ term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
atom -> term . MATH_GREATER_EQ term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
equals -> term . EQUALS term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
## Reductions:

State 522:
## Known stack suffix:
## term NOT_EQUALS
## LR(1) items:
disequals -> term NOT_EQUALS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 523
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 523:
## Known stack suffix:
## term NOT_EQUALS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
disequals -> term NOT_EQUALS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production disequals -> term NOT_EQUALS term

State 524:
## Known stack suffix:
## term MATH_LESS_EQ
## LR(1) items:
atom -> term MATH_LESS_EQ . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 525
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 525:
## Known stack suffix:
## term MATH_LESS_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
atom -> term MATH_LESS_EQ term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production atom -> term MATH_LESS_EQ term

State 526:
## Known stack suffix:
## term MATH_LESS
## LR(1) items:
atom -> term MATH_LESS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 527
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 527:
## Known stack suffix:
## term MATH_LESS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
atom -> term MATH_LESS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production atom -> term MATH_LESS term

State 528:
## Known stack suffix:
## term MATH_GREATER_EQ
## LR(1) items:
atom -> term MATH_GREATER_EQ . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 529
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 529:
## Known stack suffix:
## term MATH_GREATER_EQ term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
atom -> term MATH_GREATER_EQ term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production atom -> term MATH_GREATER_EQ term

State 530:
## Known stack suffix:
## term MATH_GREATER
## LR(1) items:
atom -> term MATH_GREATER . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 531
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 531:
## Known stack suffix:
## term MATH_GREATER term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
atom -> term MATH_GREATER term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production atom -> term MATH_GREATER term

State 532:
## Known stack suffix:
## term EQUALS
## LR(1) items:
equals -> term EQUALS . term [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 533
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 533:
## Known stack suffix:
## term EQUALS term
## LR(1) items:
addr -> term . DOT NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BINIT [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
addr -> term . DOT BEND [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT LOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
cell -> term . DOT UNLOCK [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . DOT DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
elem -> term . POINTER DATA [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
equals -> term EQUALS term . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_PLUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MINUS term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MULT term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_DIV term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
integer -> term . MATH_MOD term [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . DOT MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
mark -> term . POINTER MARKED [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . POINTER LOCKID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT BTID [ ST_THEN ST_DO SEMICOLON PROCEDURE POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS DOT CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production equals -> term EQUALS term

State 534:
## Known stack suffix:
## LOGICAL_NOT formula
## LR(1) items:
formula -> LOGICAL_NOT formula . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_AND formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_OR formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . EQUALS formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> LOGICAL_NOT formula

State 535:
## Known stack suffix:
## equals
## LR(1) items:
atom -> equals . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> equals

State 536:
## Known stack suffix:
## disequals
## LR(1) items:
atom -> disequals . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atom -> disequals

State 537:
## Known stack suffix:
## atom
## LR(1) items:
formula -> atom . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> atom

State 538:
## Known stack suffix:
## OPEN_PAREN IDENT
## LR(1) items:
formula -> OPEN_PAREN IDENT . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
ident -> IDENT . [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On CLOSE_PAREN shift to state 539
## Reductions:
-- On POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA
--   reduce production ident -> IDENT

State 539:
## Known stack suffix:
## OPEN_PAREN IDENT CLOSE_PAREN
## LR(1) items:
formula -> OPEN_PAREN IDENT CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> OPEN_PAREN IDENT CLOSE_PAREN

State 540:
## Known stack suffix:
## OPEN_PAREN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
atom -> term . MATH_LESS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
atom -> term . MATH_GREATER term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
atom -> term . MATH_LESS_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
atom -> term . MATH_GREATER_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
disequals -> term . NOT_EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
equals -> term . EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
pair -> OPEN_PAREN term . COMMA term CLOSE_PAREN [ SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_PAREN BEGIN ASSUME ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
term -> OPEN_PAREN term . CLOSE_PAREN [ SEMICOLON PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST_DELIMITER GHOST EQUALS DOT COMMA CLOSE_PAREN BEGIN ASSUME ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
-- On COMMA shift to state 287
-- On CLOSE_PAREN shift to state 290
## Reductions:

State 541:
## Known stack suffix:
## OPEN_PAREN formula
## LR(1) items:
formula -> OPEN_PAREN formula . CLOSE_PAREN [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS CLOSE_PAREN ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
-- On CLOSE_PAREN shift to state 550
## Reductions:

State 542:
## Known stack suffix:
## formula LOGICAL_THEN
## LR(1) items:
formula -> formula LOGICAL_THEN . formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 543
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 543:
## Known stack suffix:
## formula LOGICAL_THEN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_OR formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula LOGICAL_THEN formula . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . EQUALS formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production formula -> formula LOGICAL_THEN formula

State 544:
## Known stack suffix:
## formula LOGICAL_OR
## LR(1) items:
formula -> formula LOGICAL_OR . formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 545
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 545:
## Known stack suffix:
## formula LOGICAL_OR formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_OR formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula LOGICAL_OR formula . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . EQUALS formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production formula -> formula LOGICAL_OR formula

State 546:
## Known stack suffix:
## formula LOGICAL_AND
## LR(1) items:
formula -> formula LOGICAL_AND . formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 547
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 547:
## Known stack suffix:
## formula LOGICAL_AND formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula LOGICAL_AND formula . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_OR formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . EQUALS formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME
--   reduce production formula -> formula LOGICAL_AND formula

State 548:
## Known stack suffix:
## formula EQUALS
## LR(1) items:
formula -> formula EQUALS . formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 549
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 549:
## Known stack suffix:
## formula EQUALS formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_OR formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula . EQUALS formula [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
formula -> formula EQUALS formula . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
## Reductions:
-- On ST_THEN ST_DO SEMICOLON PROCEDURE IDENT GHOST_DELIMITER GHOST CLOSE_PAREN BEGIN ASSUME
--   reduce production formula -> formula EQUALS formula

State 550:
## Known stack suffix:
## OPEN_PAREN formula CLOSE_PAREN
## LR(1) items:
formula -> OPEN_PAREN formula CLOSE_PAREN . [ ST_THEN ST_DO SEMICOLON PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST_DELIMITER GHOST EQUALS CLOSE_PAREN BEGIN ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula -> OPEN_PAREN formula CLOSE_PAREN

State 551:
## Known stack suffix:
## kind IDENT IDENT ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . POINTER NEXT [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . DOT BINIT [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
addr -> term . DOT BEND [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
atom -> term . MATH_LESS term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
atom -> term . MATH_GREATER term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
atom -> term . MATH_LESS_EQ term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
atom -> term . MATH_GREATER_EQ term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
cell -> term . DOT LOCK [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
cell -> term . DOT UNLOCK [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
disequals -> term . NOT_EQUALS term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
elem -> term . DOT DATA [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
elem -> term . POINTER DATA [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
equals -> term . EQUALS term [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
global_decl -> kind IDENT IDENT ASSIGN term . [ PROCEDURE IDENT GHOST ASSUME ]
integer -> term . MATH_PLUS term [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
integer -> term . MATH_MINUS term [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
integer -> term . MATH_MULT term [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
integer -> term . MATH_DIV term [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
integer -> term . MATH_MOD term [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
mark -> term . DOT MARKED [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
mark -> term . POINTER MARKED [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
set -> term . DOT BREGION [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
tid -> term . DOT LOCKID [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
tid -> term . POINTER LOCKID [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
tid -> term . DOT BTID [ PROCEDURE POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT ASSUME ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT ASSIGN term

State 552:
## Known stack suffix:
## kind IDENT IDENT ASSIGN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
formula -> formula . LOGICAL_OR formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
formula -> formula . LOGICAL_THEN formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
formula -> formula . EQUALS formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS ASSUME ]
global_decl -> kind IDENT IDENT ASSIGN formula . [ PROCEDURE IDENT GHOST ASSUME ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:
-- On PROCEDURE IDENT GHOST ASSUME
--   reduce production global_decl -> kind IDENT IDENT ASSIGN formula

State 553:
## Known stack suffix:
## GLOBAL global_declarations
## LR(1) items:
system -> GLOBAL global_declarations . initial_assumption procedure_list [ # ]
## Transitions:
-- On ASSUME shift to state 554
-- On initial_assumption shift to state 556
## Reductions:
-- On PROCEDURE
--   reduce production initial_assumption ->

State 554:
## Known stack suffix:
## ASSUME
## LR(1) items:
initial_assumption -> ASSUME . formula [ PROCEDURE ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 555
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 555:
## Known stack suffix:
## ASSUME formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ PROCEDURE LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
initial_assumption -> ASSUME formula . [ PROCEDURE ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:
-- On PROCEDURE
--   reduce production initial_assumption -> ASSUME formula

State 556:
## Known stack suffix:
## GLOBAL global_declarations initial_assumption
## LR(1) items:
system -> GLOBAL global_declarations initial_assumption . procedure_list [ # ]
## Transitions:
-- On PROCEDURE shift to state 557
-- On procedure_list shift to state 781
-- On procedure shift to state 782
## Reductions:

State 557:
## Known stack suffix:
## PROCEDURE
## LR(1) items:
procedure -> PROCEDURE . procedure_name args procedure_sort local_declarations BEGIN program END [ PROCEDURE # ]
## Transitions:
-- On IDENT shift to state 558
-- On procedure_name shift to state 559
## Reductions:

State 558:
## Known stack suffix:
## IDENT
## LR(1) items:
procedure_name -> IDENT . [ OPEN_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production procedure_name -> IDENT

State 559:
## Known stack suffix:
## PROCEDURE procedure_name
## LR(1) items:
procedure -> PROCEDURE procedure_name . args procedure_sort local_declarations BEGIN program END [ PROCEDURE # ]
## Transitions:
-- On OPEN_PAREN shift to state 560
-- On args shift to state 570
## Reductions:

State 560:
## Known stack suffix:
## OPEN_PAREN
## LR(1) items:
args -> OPEN_PAREN . CLOSE_PAREN [ IDENT GHOST COLON BEGIN ]
args -> OPEN_PAREN . arg_list CLOSE_PAREN [ IDENT GHOST COLON BEGIN ]
## Transitions:
-- On IDENT shift to state 561
-- On CLOSE_PAREN shift to state 564
-- On arg_list shift to state 565
-- On arg shift to state 567
## Reductions:

State 561:
## Known stack suffix:
## IDENT
## LR(1) items:
arg -> IDENT . COLON IDENT [ COMMA CLOSE_PAREN ]
## Transitions:
-- On COLON shift to state 562
## Reductions:

State 562:
## Known stack suffix:
## IDENT COLON
## LR(1) items:
arg -> IDENT COLON . IDENT [ COMMA CLOSE_PAREN ]
## Transitions:
-- On IDENT shift to state 563
## Reductions:

State 563:
## Known stack suffix:
## IDENT COLON IDENT
## LR(1) items:
arg -> IDENT COLON IDENT . [ COMMA CLOSE_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arg -> IDENT COLON IDENT

State 564:
## Known stack suffix:
## OPEN_PAREN CLOSE_PAREN
## LR(1) items:
args -> OPEN_PAREN CLOSE_PAREN . [ IDENT GHOST COLON BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production args -> OPEN_PAREN CLOSE_PAREN

State 565:
## Known stack suffix:
## OPEN_PAREN arg_list
## LR(1) items:
args -> OPEN_PAREN arg_list . CLOSE_PAREN [ IDENT GHOST COLON BEGIN ]
## Transitions:
-- On CLOSE_PAREN shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## OPEN_PAREN arg_list CLOSE_PAREN
## LR(1) items:
args -> OPEN_PAREN arg_list CLOSE_PAREN . [ IDENT GHOST COLON BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production args -> OPEN_PAREN arg_list CLOSE_PAREN

State 567:
## Known stack suffix:
## arg
## LR(1) items:
arg_list -> arg . [ CLOSE_PAREN ]
arg_list -> arg . COMMA arg_list [ CLOSE_PAREN ]
## Transitions:
-- On COMMA shift to state 568
## Reductions:
-- On CLOSE_PAREN
--   reduce production arg_list -> arg

State 568:
## Known stack suffix:
## arg COMMA
## LR(1) items:
arg_list -> arg COMMA . arg_list [ CLOSE_PAREN ]
## Transitions:
-- On IDENT shift to state 561
-- On arg_list shift to state 569
-- On arg shift to state 567
## Reductions:

State 569:
## Known stack suffix:
## arg COMMA arg_list
## LR(1) items:
arg_list -> arg COMMA arg_list . [ CLOSE_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production arg_list -> arg COMMA arg_list

State 570:
## Known stack suffix:
## PROCEDURE procedure_name args
## LR(1) items:
procedure -> PROCEDURE procedure_name args . procedure_sort local_declarations BEGIN program END [ PROCEDURE # ]
## Transitions:
-- On COLON shift to state 571
-- On procedure_sort shift to state 573
## Reductions:
-- On IDENT GHOST BEGIN
--   reduce production procedure_sort ->

State 571:
## Known stack suffix:
## COLON
## LR(1) items:
procedure_sort -> COLON . IDENT [ IDENT GHOST BEGIN ]
## Transitions:
-- On IDENT shift to state 572
## Reductions:

State 572:
## Known stack suffix:
## COLON IDENT
## LR(1) items:
procedure_sort -> COLON IDENT . [ IDENT GHOST BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production procedure_sort -> COLON IDENT

State 573:
## Known stack suffix:
## PROCEDURE procedure_name args procedure_sort
## LR(1) items:
procedure -> PROCEDURE procedure_name args procedure_sort . local_declarations BEGIN program END [ PROCEDURE # ]
## Transitions:
-- On GHOST shift to state 2
-- On local_declarations shift to state 574
-- On local_decl_list shift to state 772
-- On local_decl shift to state 773
-- On kind shift to state 775
## Reductions:
-- On IDENT
--   reduce production kind ->
-- On BEGIN
--   reduce production local_declarations ->

State 574:
## Known stack suffix:
## PROCEDURE procedure_name args procedure_sort local_declarations
## LR(1) items:
procedure -> PROCEDURE procedure_name args procedure_sort local_declarations . BEGIN program END [ PROCEDURE # ]
## Transitions:
-- On BEGIN shift to state 575
## Reductions:

State 575:
## Known stack suffix:
## PROCEDURE procedure_name args procedure_sort local_declarations BEGIN
## LR(1) items:
procedure -> PROCEDURE procedure_name args procedure_sort local_declarations BEGIN . program END [ PROCEDURE # ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statement_list shift to state 769
-- On statement shift to state 585
-- On program shift to state 770
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->
-- On END
--   reduce production program ->

State 576:
## Known stack suffix:
## COLON
## LR(1) items:
line_label -> COLON . IDENT [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
line_label -> COLON . IDENT OPEN_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
line_label -> COLON . IDENT CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On IDENT shift to state 577
## Reductions:

State 577:
## Known stack suffix:
## COLON IDENT
## LR(1) items:
line_label -> COLON IDENT . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
line_label -> COLON IDENT . OPEN_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
line_label -> COLON IDENT . CLOSE_BRACKET [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_BRACKET shift to state 578
-- On CLOSE_BRACKET shift to state 579
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET
--   reduce production line_label -> COLON IDENT

State 578:
## Known stack suffix:
## COLON IDENT OPEN_BRACKET
## LR(1) items:
line_label -> COLON IDENT OPEN_BRACKET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production line_label -> COLON IDENT OPEN_BRACKET

State 579:
## Known stack suffix:
## COLON IDENT CLOSE_BRACKET
## LR(1) items:
line_label -> COLON IDENT CLOSE_BRACKET . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production line_label -> COLON IDENT CLOSE_BRACKET

State 580:
## Known stack suffix:
## while_keyword
## LR(1) items:
statement -> while_keyword . formula ST_DO statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 581
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 581:
## Known stack suffix:
## while_keyword formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
statement -> while_keyword formula . ST_DO statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_DO shift to state 582
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 582:
## Known stack suffix:
## while_keyword formula ST_DO
## LR(1) items:
statement -> while_keyword formula ST_DO . statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statement_list shift to state 583
-- On statement shift to state 585
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 583:
## Known stack suffix:
## while_keyword formula ST_DO statement_list
## LR(1) items:
statement -> while_keyword formula ST_DO statement_list . ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDWHILE shift to state 584
## Reductions:

State 584:
## Known stack suffix:
## while_keyword formula ST_DO statement_list ST_ENDWHILE
## LR(1) items:
statement -> while_keyword formula ST_DO statement_list ST_ENDWHILE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> while_keyword formula ST_DO statement_list ST_ENDWHILE

State 585:
## Known stack suffix:
## statement
## LR(1) items:
statement_list -> statement . line_label_list [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE END ]
statement_list -> statement . statement_list [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE END ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statement_list shift to state 586
-- On statement shift to state 585
-- On line_label_list shift to state 587
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 586:
## Known stack suffix:
## statement statement_list
## LR(1) items:
statement_list -> statement statement_list . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_list -> statement statement_list

State 587:
## Known stack suffix:
## statement line_label_list
## LR(1) items:
choice_keyword -> line_label_list . ST_CHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
if_keyword -> line_label_list . ST_IF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
statement -> line_label_list . ST_SKIP ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_ASSERT formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_AWAIT formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_NONCRITICAL ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_CRITICAL ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term POINTER LOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term POINTER UNLOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . OPEN_SET atomic_statement_list CLOSE_SET ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . RETURN OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement_list -> statement line_label_list . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE END ]
while_keyword -> line_label_list . ST_WHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_WHILE shift to state 588
-- On ST_SKIP shift to state 589
-- On ST_NONCRITICAL shift to state 645
-- On ST_IF shift to state 647
-- On ST_CRITICAL shift to state 648
-- On ST_CHOICE shift to state 620
-- On ST_AWAIT shift to state 650
-- On ST_ASSERT shift to state 653
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On RETURN shift to state 656
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 662
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 711
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On CALL shift to state 727
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 733
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE END
--   reduce production statement_list -> statement line_label_list

State 588:
## Known stack suffix:
## line_label_list ST_WHILE
## LR(1) items:
while_keyword -> line_label_list ST_WHILE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production while_keyword -> line_label_list ST_WHILE

State 589:
## Known stack suffix:
## line_label_list ST_SKIP
## LR(1) items:
statement -> line_label_list ST_SKIP . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 643
-- On ghost_block shift to state 644
## Reductions:

State 590:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
ghost_block_or_semicolon -> SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_block_or_semicolon -> SEMICOLON

State 591:
## Known stack suffix:
## GHOST_DELIMITER
## LR(1) items:
ghost_block -> GHOST_DELIMITER . GHOST_DELIMITER [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
ghost_block -> GHOST_DELIMITER . ghost_statement_list GHOST_DELIMITER [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GHOST_DELIMITER shift to state 610
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statement_list shift to state 641
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 592:
## Known stack suffix:
## ST_SKIP
## LR(1) items:
ghost_statement -> ST_SKIP . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## ST_SKIP SEMICOLON
## LR(1) items:
ghost_statement -> ST_SKIP SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> ST_SKIP SEMICOLON

State 594:
## Known stack suffix:
## ST_NONCRITICAL
## LR(1) items:
ghost_statement -> ST_NONCRITICAL . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 595
## Reductions:

State 595:
## Known stack suffix:
## ST_NONCRITICAL SEMICOLON
## LR(1) items:
ghost_statement -> ST_NONCRITICAL SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> ST_NONCRITICAL SEMICOLON

State 596:
## Known stack suffix:
## ST_CRITICAL
## LR(1) items:
ghost_statement -> ST_CRITICAL . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## ST_CRITICAL SEMICOLON
## LR(1) items:
ghost_statement -> ST_CRITICAL SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> ST_CRITICAL SEMICOLON

State 598:
## Known stack suffix:
## ST_AWAIT
## LR(1) items:
ghost_statement -> ST_AWAIT . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 599
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 599:
## Known stack suffix:
## ST_AWAIT formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> ST_AWAIT formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 600
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 600:
## Known stack suffix:
## ST_AWAIT formula SEMICOLON
## LR(1) items:
ghost_statement -> ST_AWAIT formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> ST_AWAIT formula SEMICOLON

State 601:
## Known stack suffix:
## ST_ASSERT
## LR(1) items:
ghost_statement -> ST_ASSERT . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 602
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 602:
## Known stack suffix:
## ST_ASSERT formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> ST_ASSERT formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 603
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 603:
## Known stack suffix:
## ST_ASSERT formula SEMICOLON
## LR(1) items:
ghost_statement -> ST_ASSERT formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> ST_ASSERT formula SEMICOLON

State 604:
## Known stack suffix:
## IDENT
## LR(1) items:
ghost_statement -> IDENT . ASSIGN term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
ghost_statement -> IDENT . ASSIGN formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
ident -> IDENT . [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
## Transitions:
-- On ASSIGN shift to state 605
## Reductions:
-- On POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT
--   reduce production ident -> IDENT

State 605:
## Known stack suffix:
## IDENT ASSIGN
## LR(1) items:
ghost_statement -> IDENT ASSIGN . term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
ghost_statement -> IDENT ASSIGN . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 606
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 608
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 606:
## Known stack suffix:
## IDENT ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
atom -> term . MATH_LESS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_GREATER term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_LESS_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_GREATER_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
equals -> term . EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> IDENT ASSIGN term . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
## Transitions:
-- On SEMICOLON shift to state 607
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
## Reductions:

State 607:
## Known stack suffix:
## IDENT ASSIGN term SEMICOLON
## LR(1) items:
ghost_statement -> IDENT ASSIGN term SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> IDENT ASSIGN term SEMICOLON

State 608:
## Known stack suffix:
## IDENT ASSIGN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> IDENT ASSIGN formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 609
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 609:
## Known stack suffix:
## IDENT ASSIGN formula SEMICOLON
## LR(1) items:
ghost_statement -> IDENT ASSIGN formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> IDENT ASSIGN formula SEMICOLON

State 610:
## Known stack suffix:
## GHOST_DELIMITER GHOST_DELIMITER
## LR(1) items:
ghost_block -> GHOST_DELIMITER GHOST_DELIMITER . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_block -> GHOST_DELIMITER GHOST_DELIMITER

State 611:
## Known stack suffix:
## while_keyword
## LR(1) items:
ghost_statement -> while_keyword . formula ST_DO ghost_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 612
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 612:
## Known stack suffix:
## while_keyword formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> while_keyword formula . ST_DO ghost_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_DO shift to state 613
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 613:
## Known stack suffix:
## while_keyword formula ST_DO
## LR(1) items:
ghost_statement -> while_keyword formula ST_DO . ghost_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statement_list shift to state 639
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 614:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
ghost_statement -> term . ASSIGN term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On ASSIGN shift to state 615
## Reductions:

State 615:
## Known stack suffix:
## term ASSIGN
## LR(1) items:
ghost_statement -> term ASSIGN . term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 616
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 616:
## Known stack suffix:
## term ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
ghost_statement -> term ASSIGN term . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
## Transitions:
-- On SEMICOLON shift to state 617
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:

State 617:
## Known stack suffix:
## term ASSIGN term SEMICOLON
## LR(1) items:
ghost_statement -> term ASSIGN term SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> term ASSIGN term SEMICOLON

State 618:
## Known stack suffix:
## line_label_list
## LR(1) items:
choice_keyword -> line_label_list . ST_CHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
if_ghost_atomic_keyword -> line_label_list . ST_IF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
while_keyword -> line_label_list . ST_WHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
-- On ST_WHILE shift to state 588
-- On ST_IF shift to state 619
-- On ST_CHOICE shift to state 620
## Reductions:

State 619:
## Known stack suffix:
## line_label_list ST_IF
## LR(1) items:
if_ghost_atomic_keyword -> line_label_list ST_IF . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_ghost_atomic_keyword -> line_label_list ST_IF

State 620:
## Known stack suffix:
## line_label_list ST_CHOICE
## LR(1) items:
choice_keyword -> line_label_list ST_CHOICE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production choice_keyword -> line_label_list ST_CHOICE

State 621:
## Known stack suffix:
## line_label
## LR(1) items:
line_label_list -> line_label . line_label_list [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On COLON shift to state 576
-- On line_label_list shift to state 622
-- On line_label shift to state 621
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 622:
## Known stack suffix:
## line_label line_label_list
## LR(1) items:
line_label_list -> line_label line_label_list . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production line_label_list -> line_label line_label_list

State 623:
## Known stack suffix:
## if_ghost_atomic_keyword
## LR(1) items:
ghost_statement -> if_ghost_atomic_keyword . formula ST_THEN ghost_statement_list ghost_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 624
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 624:
## Known stack suffix:
## if_ghost_atomic_keyword formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
ghost_statement -> if_ghost_atomic_keyword formula . ST_THEN ghost_statement_list ghost_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_THEN shift to state 625
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 625:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN
## LR(1) items:
ghost_statement -> if_ghost_atomic_keyword formula ST_THEN . ghost_statement_list ghost_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statement_list shift to state 626
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 626:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN ghost_statement_list
## LR(1) items:
ghost_statement -> if_ghost_atomic_keyword formula ST_THEN ghost_statement_list . ghost_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ELSE shift to state 627
-- On ghost_statements_else_if shift to state 637
## Reductions:
-- On ST_ENDIF
--   reduce production ghost_statements_else_if ->

State 627:
## Known stack suffix:
## ST_ELSE
## LR(1) items:
ghost_statements_else_if -> ST_ELSE . ghost_statement_list [ ST_ENDIF ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statement_list shift to state 628
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 628:
## Known stack suffix:
## ST_ELSE ghost_statement_list
## LR(1) items:
ghost_statements_else_if -> ST_ELSE ghost_statement_list . [ ST_ENDIF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statements_else_if -> ST_ELSE ghost_statement_list

State 629:
## Known stack suffix:
## ghost_statement
## LR(1) items:
ghost_statement_list -> ghost_statement . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE GHOST_DELIMITER ]
ghost_statement_list -> ghost_statement . ghost_statement_list [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE GHOST_DELIMITER ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statement_list shift to state 630
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE GHOST_DELIMITER
--   reduce production ghost_statement_list -> ghost_statement
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 630:
## Known stack suffix:
## ghost_statement ghost_statement_list
## LR(1) items:
ghost_statement_list -> ghost_statement ghost_statement_list . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE GHOST_DELIMITER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement_list -> ghost_statement ghost_statement_list

State 631:
## Known stack suffix:
## choice_keyword
## LR(1) items:
ghost_statement -> choice_keyword . ghost_statements_choice ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statements_choice shift to state 632
-- On ghost_statement_list shift to state 634
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 632:
## Known stack suffix:
## choice_keyword ghost_statements_choice
## LR(1) items:
ghost_statement -> choice_keyword ghost_statements_choice . ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDCHOICE shift to state 633
## Reductions:

State 633:
## Known stack suffix:
## choice_keyword ghost_statements_choice ST_ENDCHOICE
## LR(1) items:
ghost_statement -> choice_keyword ghost_statements_choice ST_ENDCHOICE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> choice_keyword ghost_statements_choice ST_ENDCHOICE

State 634:
## Known stack suffix:
## ghost_statement_list
## LR(1) items:
ghost_statements_choice -> ghost_statement_list . [ ST_ENDCHOICE ]
ghost_statements_choice -> ghost_statement_list . ST_OR ghost_statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On ST_OR shift to state 635
## Reductions:
-- On ST_ENDCHOICE
--   reduce production ghost_statements_choice -> ghost_statement_list

State 635:
## Known stack suffix:
## ghost_statement_list ST_OR
## LR(1) items:
ghost_statements_choice -> ghost_statement_list ST_OR . ghost_statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 592
-- On ST_NONCRITICAL shift to state 594
-- On ST_CRITICAL shift to state 596
-- On ST_AWAIT shift to state 598
-- On ST_ASSERT shift to state 601
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 604
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 611
-- On tid shift to state 123
-- On term shift to state 614
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 623
-- On ident shift to state 153
-- On ghost_statements_choice shift to state 636
-- On ghost_statement_list shift to state 634
-- On ghost_statement shift to state 629
-- On elem shift to state 154
-- On choice_keyword shift to state 631
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 636:
## Known stack suffix:
## ghost_statement_list ST_OR ghost_statements_choice
## LR(1) items:
ghost_statements_choice -> ghost_statement_list ST_OR ghost_statements_choice . [ ST_ENDCHOICE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statements_choice -> ghost_statement_list ST_OR ghost_statements_choice

State 637:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN ghost_statement_list ghost_statements_else_if
## LR(1) items:
ghost_statement -> if_ghost_atomic_keyword formula ST_THEN ghost_statement_list ghost_statements_else_if . ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDIF shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN ghost_statement_list ghost_statements_else_if ST_ENDIF
## LR(1) items:
ghost_statement -> if_ghost_atomic_keyword formula ST_THEN ghost_statement_list ghost_statements_else_if ST_ENDIF . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> if_ghost_atomic_keyword formula ST_THEN ghost_statement_list ghost_statements_else_if ST_ENDIF

State 639:
## Known stack suffix:
## while_keyword formula ST_DO ghost_statement_list
## LR(1) items:
ghost_statement -> while_keyword formula ST_DO ghost_statement_list . ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDWHILE shift to state 640
## Reductions:

State 640:
## Known stack suffix:
## while_keyword formula ST_DO ghost_statement_list ST_ENDWHILE
## LR(1) items:
ghost_statement -> while_keyword formula ST_DO ghost_statement_list ST_ENDWHILE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GHOST_DELIMITER GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_statement -> while_keyword formula ST_DO ghost_statement_list ST_ENDWHILE

State 641:
## Known stack suffix:
## GHOST_DELIMITER ghost_statement_list
## LR(1) items:
ghost_block -> GHOST_DELIMITER ghost_statement_list . GHOST_DELIMITER [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On GHOST_DELIMITER shift to state 642
## Reductions:

State 642:
## Known stack suffix:
## GHOST_DELIMITER ghost_statement_list GHOST_DELIMITER
## LR(1) items:
ghost_block -> GHOST_DELIMITER ghost_statement_list GHOST_DELIMITER . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_block -> GHOST_DELIMITER ghost_statement_list GHOST_DELIMITER

State 643:
## Known stack suffix:
## line_label_list ST_SKIP ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list ST_SKIP ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list ST_SKIP ghost_block_or_semicolon

State 644:
## Known stack suffix:
## ghost_block
## LR(1) items:
ghost_block_or_semicolon -> ghost_block . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_block_or_semicolon -> ghost_block

State 645:
## Known stack suffix:
## line_label_list ST_NONCRITICAL
## LR(1) items:
statement -> line_label_list ST_NONCRITICAL . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 646
-- On ghost_block shift to state 644
## Reductions:

State 646:
## Known stack suffix:
## line_label_list ST_NONCRITICAL ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list ST_NONCRITICAL ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list ST_NONCRITICAL ghost_block_or_semicolon

State 647:
## Known stack suffix:
## line_label_list ST_IF
## LR(1) items:
if_keyword -> line_label_list ST_IF . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_keyword -> line_label_list ST_IF

State 648:
## Known stack suffix:
## line_label_list ST_CRITICAL
## LR(1) items:
statement -> line_label_list ST_CRITICAL . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 649
-- On ghost_block shift to state 644
## Reductions:

State 649:
## Known stack suffix:
## line_label_list ST_CRITICAL ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list ST_CRITICAL ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list ST_CRITICAL ghost_block_or_semicolon

State 650:
## Known stack suffix:
## line_label_list ST_AWAIT
## LR(1) items:
statement -> line_label_list ST_AWAIT . formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 651
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 651:
## Known stack suffix:
## line_label_list ST_AWAIT formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
statement -> line_label_list ST_AWAIT formula . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On GHOST_DELIMITER shift to state 591
-- On EQUALS shift to state 548
-- On ghost_block_or_semicolon shift to state 652
-- On ghost_block shift to state 644
## Reductions:

State 652:
## Known stack suffix:
## line_label_list ST_AWAIT formula ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list ST_AWAIT formula ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list ST_AWAIT formula ghost_block_or_semicolon

State 653:
## Known stack suffix:
## line_label_list ST_ASSERT
## LR(1) items:
statement -> line_label_list ST_ASSERT . formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 654
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 654:
## Known stack suffix:
## line_label_list ST_ASSERT formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
statement -> line_label_list ST_ASSERT formula . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On GHOST_DELIMITER shift to state 591
-- On EQUALS shift to state 548
-- On ghost_block_or_semicolon shift to state 655
-- On ghost_block shift to state 644
## Reductions:

State 655:
## Known stack suffix:
## line_label_list ST_ASSERT formula ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list ST_ASSERT formula ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list ST_ASSERT formula ghost_block_or_semicolon

State 656:
## Known stack suffix:
## line_label_list RETURN
## LR(1) items:
statement -> line_label_list RETURN . OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_PAREN shift to state 657
## Reductions:

State 657:
## Known stack suffix:
## line_label_list RETURN OPEN_PAREN
## LR(1) items:
statement -> line_label_list RETURN OPEN_PAREN . maybe_term CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 658
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On maybe_term shift to state 659
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On CLOSE_PAREN
--   reduce production maybe_term ->

State 658:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
maybe_term -> term . [ CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:
-- On CLOSE_PAREN
--   reduce production maybe_term -> term

State 659:
## Known stack suffix:
## line_label_list RETURN OPEN_PAREN maybe_term
## LR(1) items:
statement -> line_label_list RETURN OPEN_PAREN maybe_term . CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On CLOSE_PAREN shift to state 660
## Reductions:

State 660:
## Known stack suffix:
## line_label_list RETURN OPEN_PAREN maybe_term CLOSE_PAREN
## LR(1) items:
statement -> line_label_list RETURN OPEN_PAREN maybe_term CLOSE_PAREN . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 661
-- On ghost_block shift to state 644
## Reductions:

State 661:
## Known stack suffix:
## line_label_list RETURN OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list RETURN OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list RETURN OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon

State 662:
## Known stack suffix:
## line_label_list OPEN_SET
## LR(1) items:
set -> OPEN_SET . term CLOSE_SET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
statement -> line_label_list OPEN_SET . atomic_statement_list CLOSE_SET ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 706
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statement_list shift to state 707
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 663:
## Known stack suffix:
## ST_SKIP
## LR(1) items:
atomic_statement -> ST_SKIP . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 664
## Reductions:

State 664:
## Known stack suffix:
## ST_SKIP SEMICOLON
## LR(1) items:
atomic_statement -> ST_SKIP SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> ST_SKIP SEMICOLON

State 665:
## Known stack suffix:
## ST_NONCRITICAL
## LR(1) items:
atomic_statement -> ST_NONCRITICAL . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 666
## Reductions:

State 666:
## Known stack suffix:
## ST_NONCRITICAL SEMICOLON
## LR(1) items:
atomic_statement -> ST_NONCRITICAL SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> ST_NONCRITICAL SEMICOLON

State 667:
## Known stack suffix:
## ST_CRITICAL
## LR(1) items:
atomic_statement -> ST_CRITICAL . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 668
## Reductions:

State 668:
## Known stack suffix:
## ST_CRITICAL SEMICOLON
## LR(1) items:
atomic_statement -> ST_CRITICAL SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> ST_CRITICAL SEMICOLON

State 669:
## Known stack suffix:
## ST_AWAIT
## LR(1) items:
atomic_statement -> ST_AWAIT . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 670
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 670:
## Known stack suffix:
## ST_AWAIT formula
## LR(1) items:
atomic_statement -> ST_AWAIT formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
## Transitions:
-- On SEMICOLON shift to state 671
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 671:
## Known stack suffix:
## ST_AWAIT formula SEMICOLON
## LR(1) items:
atomic_statement -> ST_AWAIT formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> ST_AWAIT formula SEMICOLON

State 672:
## Known stack suffix:
## ST_ASSERT
## LR(1) items:
atomic_statement -> ST_ASSERT . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 673
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 673:
## Known stack suffix:
## ST_ASSERT formula
## LR(1) items:
atomic_statement -> ST_ASSERT formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
## Transitions:
-- On SEMICOLON shift to state 674
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 674:
## Known stack suffix:
## ST_ASSERT formula SEMICOLON
## LR(1) items:
atomic_statement -> ST_ASSERT formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> ST_ASSERT formula SEMICOLON

State 675:
## Known stack suffix:
## IDENT
## LR(1) items:
atomic_statement -> IDENT . ASSIGN term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
atomic_statement -> IDENT . ASSIGN formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
ident -> IDENT . [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
## Transitions:
-- On ASSIGN shift to state 676
## Reductions:
-- On POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET
--   reduce production ident -> IDENT

State 676:
## Known stack suffix:
## IDENT ASSIGN
## LR(1) items:
atomic_statement -> IDENT ASSIGN . term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
atomic_statement -> IDENT ASSIGN . formula SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 677
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 679
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 677:
## Known stack suffix:
## IDENT ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
atom -> term . MATH_LESS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_GREATER term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_LESS_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atom -> term . MATH_GREATER_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
atomic_statement -> IDENT ASSIGN term . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
equals -> term . EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV EQUALS DOT ]
## Transitions:
-- On SEMICOLON shift to state 678
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
## Reductions:

State 678:
## Known stack suffix:
## IDENT ASSIGN term SEMICOLON
## LR(1) items:
atomic_statement -> IDENT ASSIGN term SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> IDENT ASSIGN term SEMICOLON

State 679:
## Known stack suffix:
## IDENT ASSIGN formula
## LR(1) items:
atomic_statement -> IDENT ASSIGN formula . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
## Transitions:
-- On SEMICOLON shift to state 680
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 680:
## Known stack suffix:
## IDENT ASSIGN formula SEMICOLON
## LR(1) items:
atomic_statement -> IDENT ASSIGN formula SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> IDENT ASSIGN formula SEMICOLON

State 681:
## Known stack suffix:
## while_keyword
## LR(1) items:
atomic_statement -> while_keyword . formula ST_DO atomic_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 682
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 682:
## Known stack suffix:
## while_keyword formula
## LR(1) items:
atomic_statement -> while_keyword formula . ST_DO atomic_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
formula -> formula . LOGICAL_AND formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_DO LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
## Transitions:
-- On ST_DO shift to state 683
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 683:
## Known stack suffix:
## while_keyword formula ST_DO
## LR(1) items:
atomic_statement -> while_keyword formula ST_DO . atomic_statement_list ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statement_list shift to state 704
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 684:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
atomic_statement -> term . ASSIGN term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On ASSIGN shift to state 685
## Reductions:

State 685:
## Known stack suffix:
## term ASSIGN
## LR(1) items:
atomic_statement -> term ASSIGN . term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 686
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 686:
## Known stack suffix:
## term ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
atomic_statement -> term ASSIGN term . SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ]
## Transitions:
-- On SEMICOLON shift to state 687
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
## Reductions:

State 687:
## Known stack suffix:
## term ASSIGN term SEMICOLON
## LR(1) items:
atomic_statement -> term ASSIGN term SEMICOLON . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> term ASSIGN term SEMICOLON

State 688:
## Known stack suffix:
## if_ghost_atomic_keyword
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword . formula ST_THEN atomic_statement_list atomic_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 689
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 689:
## Known stack suffix:
## if_ghost_atomic_keyword formula
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword formula . ST_THEN atomic_statement_list atomic_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
formula -> formula . LOGICAL_AND formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
## Transitions:
-- On ST_THEN shift to state 690
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 690:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword formula ST_THEN . atomic_statement_list atomic_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statement_list shift to state 699
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 691:
## Known stack suffix:
## choice_keyword
## LR(1) items:
atomic_statement -> choice_keyword . atomic_statements_choice ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statements_choice shift to state 692
-- On atomic_statement_list shift to state 694
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 692:
## Known stack suffix:
## choice_keyword atomic_statements_choice
## LR(1) items:
atomic_statement -> choice_keyword atomic_statements_choice . ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDCHOICE shift to state 693
## Reductions:

State 693:
## Known stack suffix:
## choice_keyword atomic_statements_choice ST_ENDCHOICE
## LR(1) items:
atomic_statement -> choice_keyword atomic_statements_choice ST_ENDCHOICE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> choice_keyword atomic_statements_choice ST_ENDCHOICE

State 694:
## Known stack suffix:
## atomic_statement_list
## LR(1) items:
atomic_statements_choice -> atomic_statement_list . [ ST_ENDCHOICE ]
atomic_statements_choice -> atomic_statement_list . ST_OR atomic_statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On ST_OR shift to state 695
## Reductions:
-- On ST_ENDCHOICE
--   reduce production atomic_statements_choice -> atomic_statement_list

State 695:
## Known stack suffix:
## atomic_statement_list ST_OR
## LR(1) items:
atomic_statements_choice -> atomic_statement_list ST_OR . atomic_statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statements_choice shift to state 696
-- On atomic_statement_list shift to state 694
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 696:
## Known stack suffix:
## atomic_statement_list ST_OR atomic_statements_choice
## LR(1) items:
atomic_statements_choice -> atomic_statement_list ST_OR atomic_statements_choice . [ ST_ENDCHOICE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statements_choice -> atomic_statement_list ST_OR atomic_statements_choice

State 697:
## Known stack suffix:
## atomic_statement
## LR(1) items:
atomic_statement_list -> atomic_statement . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE CLOSE_SET ]
atomic_statement_list -> atomic_statement . atomic_statement_list [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE CLOSE_SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statement_list shift to state 698
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE CLOSE_SET
--   reduce production atomic_statement_list -> atomic_statement
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 698:
## Known stack suffix:
## atomic_statement atomic_statement_list
## LR(1) items:
atomic_statement_list -> atomic_statement atomic_statement_list . [ ST_OR ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE CLOSE_SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement_list -> atomic_statement atomic_statement_list

State 699:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN atomic_statement_list
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword formula ST_THEN atomic_statement_list . atomic_statements_else_if ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ELSE shift to state 700
-- On atomic_statements_else_if shift to state 702
## Reductions:
-- On ST_ENDIF
--   reduce production atomic_statements_else_if ->

State 700:
## Known stack suffix:
## ST_ELSE
## LR(1) items:
atomic_statements_else_if -> ST_ELSE . atomic_statement_list [ ST_ENDIF ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_SKIP shift to state 663
-- On ST_NONCRITICAL shift to state 665
-- On ST_CRITICAL shift to state 667
-- On ST_AWAIT shift to state 669
-- On ST_ASSERT shift to state 672
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 675
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On COLON shift to state 576
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On while_keyword shift to state 681
-- On tid shift to state 123
-- On term shift to state 684
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On line_label_list shift to state 618
-- On line_label shift to state 621
-- On integer shift to state 152
-- On if_ghost_atomic_keyword shift to state 688
-- On ident shift to state 153
-- On elem shift to state 154
-- On choice_keyword shift to state 691
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atomic_statement_list shift to state 701
-- On atomic_statement shift to state 697
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On ST_WHILE ST_IF ST_CHOICE
--   reduce production line_label_list ->

State 701:
## Known stack suffix:
## ST_ELSE atomic_statement_list
## LR(1) items:
atomic_statements_else_if -> ST_ELSE atomic_statement_list . [ ST_ENDIF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statements_else_if -> ST_ELSE atomic_statement_list

State 702:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN atomic_statement_list atomic_statements_else_if
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword formula ST_THEN atomic_statement_list atomic_statements_else_if . ST_ENDIF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDIF shift to state 703
## Reductions:

State 703:
## Known stack suffix:
## if_ghost_atomic_keyword formula ST_THEN atomic_statement_list atomic_statements_else_if ST_ENDIF
## LR(1) items:
atomic_statement -> if_ghost_atomic_keyword formula ST_THEN atomic_statement_list atomic_statements_else_if ST_ENDIF . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> if_ghost_atomic_keyword formula ST_THEN atomic_statement_list atomic_statements_else_if ST_ENDIF

State 704:
## Known stack suffix:
## while_keyword formula ST_DO atomic_statement_list
## LR(1) items:
atomic_statement -> while_keyword formula ST_DO atomic_statement_list . ST_ENDWHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDWHILE shift to state 705
## Reductions:

State 705:
## Known stack suffix:
## while_keyword formula ST_DO atomic_statement_list ST_ENDWHILE
## LR(1) items:
atomic_statement -> while_keyword formula ST_DO atomic_statement_list ST_ENDWHILE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production atomic_statement -> while_keyword formula ST_DO atomic_statement_list ST_ENDWHILE

State 706:
## Known stack suffix:
## OPEN_SET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
atomic_statement -> term . ASSIGN term SEMICOLON [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CLOSE_SET ARR_UPDATE ADDR2SET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
set -> OPEN_SET term . CLOSE_SET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_SET ASSIGN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_SET shift to state 292
-- On ASSIGN shift to state 685
## Reductions:

State 707:
## Known stack suffix:
## line_label_list OPEN_SET atomic_statement_list
## LR(1) items:
statement -> line_label_list OPEN_SET atomic_statement_list . CLOSE_SET ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On CLOSE_SET shift to state 708
## Reductions:

State 708:
## Known stack suffix:
## line_label_list OPEN_SET atomic_statement_list CLOSE_SET
## LR(1) items:
statement -> line_label_list OPEN_SET atomic_statement_list CLOSE_SET . ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_nothing shift to state 709
-- On ghost_block shift to state 710
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET
--   reduce production ghost_block_or_nothing ->

State 709:
## Known stack suffix:
## line_label_list OPEN_SET atomic_statement_list CLOSE_SET ghost_block_or_nothing
## LR(1) items:
statement -> line_label_list OPEN_SET atomic_statement_list CLOSE_SET ghost_block_or_nothing . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list OPEN_SET atomic_statement_list CLOSE_SET ghost_block_or_nothing

State 710:
## Known stack suffix:
## ghost_block
## LR(1) items:
ghost_block_or_nothing -> ghost_block . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ghost_block_or_nothing -> ghost_block

State 711:
## Known stack suffix:
## line_label_list IDENT
## LR(1) items:
ident -> IDENT . [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
statement -> line_label_list IDENT . ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list IDENT . ASSIGN formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list IDENT . ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ASSIGN shift to state 712
## Reductions:
-- On POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT
--   reduce production ident -> IDENT

State 712:
## Known stack suffix:
## line_label_list IDENT ASSIGN
## LR(1) items:
statement -> line_label_list IDENT ASSIGN . term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list IDENT ASSIGN . formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list IDENT ASSIGN . CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On CALL shift to state 713
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 723
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 725
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 713:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL . IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On IDENT shift to state 714
## Reductions:

State 714:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL IDENT
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL IDENT . OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_PAREN shift to state 715
## Reductions:

State 715:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN . params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 716
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On params shift to state 719
-- On param_list shift to state 722
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On CLOSE_PAREN
--   reduce production params ->

State 716:
## Known stack suffix:
## term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
param_list -> term . [ CLOSE_PAREN ]
param_list -> term . COMMA param_list [ CLOSE_PAREN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT COMMA CLOSE_PAREN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On COMMA shift to state 717
## Reductions:
-- On CLOSE_PAREN
--   reduce production param_list -> term

State 717:
## Known stack suffix:
## term COMMA
## LR(1) items:
param_list -> term COMMA . param_list [ CLOSE_PAREN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 716
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On param_list shift to state 718
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 718:
## Known stack suffix:
## term COMMA param_list
## LR(1) items:
param_list -> term COMMA param_list . [ CLOSE_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production param_list -> term COMMA param_list

State 719:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params . CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On CLOSE_PAREN shift to state 720
## Reductions:

State 720:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 721
-- On ghost_block shift to state 644
## Reductions:

State 721:
## Known stack suffix:
## line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon

State 722:
## Known stack suffix:
## param_list
## LR(1) items:
params -> param_list . [ CLOSE_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production params -> param_list

State 723:
## Known stack suffix:
## line_label_list IDENT ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
atom -> term . MATH_LESS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
atom -> term . MATH_GREATER term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
atom -> term . MATH_LESS_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
atom -> term . MATH_GREATER_EQ term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
disequals -> term . NOT_EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
equals -> term . EQUALS term [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
statement -> line_label_list IDENT ASSIGN term . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV GHOST_DELIMITER EQUALS DOT ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On GHOST_DELIMITER shift to state 591
-- On EQUALS shift to state 532
-- On DOT shift to state 135
-- On ghost_block_or_semicolon shift to state 724
-- On ghost_block shift to state 644
## Reductions:

State 724:
## Known stack suffix:
## line_label_list IDENT ASSIGN term ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list IDENT ASSIGN term ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list IDENT ASSIGN term ghost_block_or_semicolon

State 725:
## Known stack suffix:
## line_label_list IDENT ASSIGN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_OR formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . LOGICAL_THEN formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
formula -> formula . EQUALS formula [ SEMICOLON LOGICAL_THEN LOGICAL_OR LOGICAL_AND GHOST_DELIMITER EQUALS ]
statement -> line_label_list IDENT ASSIGN formula . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On GHOST_DELIMITER shift to state 591
-- On EQUALS shift to state 548
-- On ghost_block_or_semicolon shift to state 726
-- On ghost_block shift to state 644
## Reductions:

State 726:
## Known stack suffix:
## line_label_list IDENT ASSIGN formula ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list IDENT ASSIGN formula ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list IDENT ASSIGN formula ghost_block_or_semicolon

State 727:
## Known stack suffix:
## line_label_list CALL
## LR(1) items:
statement -> line_label_list CALL . IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On IDENT shift to state 728
## Reductions:

State 728:
## Known stack suffix:
## line_label_list CALL IDENT
## LR(1) items:
statement -> line_label_list CALL IDENT . OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_PAREN shift to state 729
## Reductions:

State 729:
## Known stack suffix:
## line_label_list CALL IDENT OPEN_PAREN
## LR(1) items:
statement -> line_label_list CALL IDENT OPEN_PAREN . params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 716
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On params shift to state 730
-- On param_list shift to state 722
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On CLOSE_PAREN
--   reduce production params ->

State 730:
## Known stack suffix:
## line_label_list CALL IDENT OPEN_PAREN params
## LR(1) items:
statement -> line_label_list CALL IDENT OPEN_PAREN params . CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On CLOSE_PAREN shift to state 731
## Reductions:

State 731:
## Known stack suffix:
## line_label_list CALL IDENT OPEN_PAREN params CLOSE_PAREN
## LR(1) items:
statement -> line_label_list CALL IDENT OPEN_PAREN params CLOSE_PAREN . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 732
-- On ghost_block shift to state 644
## Reductions:

State 732:
## Known stack suffix:
## line_label_list CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon

State 733:
## Known stack suffix:
## line_label_list term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
statement -> line_label_list term . ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list term . ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list term . POINTER LOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list term . POINTER UNLOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
## Transitions:
-- On POINTER shift to state 734
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On ASSIGN shift to state 744
## Reductions:

State 734:
## Known stack suffix:
## line_label_list term POINTER
## LR(1) items:
addr -> term POINTER . NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term POINTER . NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
addr -> term POINTER . ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
elem -> term POINTER . DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
mark -> term POINTER . MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
statement -> line_label_list term POINTER . LOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list term POINTER . UNLOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
tid -> term POINTER . LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT ASSIGN ]
## Transitions:
-- On UNLOCK shift to state 735
-- On NEXTAT shift to state 126
-- On NEXT shift to state 180
-- On MARKED shift to state 181
-- On LOCKID shift to state 182
-- On LOCK shift to state 741
-- On DATA shift to state 183
-- On ARR shift to state 184
## Reductions:

State 735:
## Known stack suffix:
## line_label_list term POINTER UNLOCK
## LR(1) items:
statement -> line_label_list term POINTER UNLOCK . lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_BRACKET shift to state 736
-- On lock_pos shift to state 739
## Reductions:
-- On SEMICOLON GHOST_DELIMITER
--   reduce production lock_pos ->

State 736:
## Known stack suffix:
## OPEN_BRACKET
## LR(1) items:
lock_pos -> OPEN_BRACKET . term CLOSE_BRACKET [ SEMICOLON GHOST_DELIMITER ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 737
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 737:
## Known stack suffix:
## OPEN_BRACKET term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
lock_pos -> OPEN_BRACKET term . CLOSE_BRACKET [ SEMICOLON GHOST_DELIMITER ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV DOT CLOSE_BRACKET ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On DOT shift to state 135
-- On CLOSE_BRACKET shift to state 738
## Reductions:

State 738:
## Known stack suffix:
## OPEN_BRACKET term CLOSE_BRACKET
## LR(1) items:
lock_pos -> OPEN_BRACKET term CLOSE_BRACKET . [ SEMICOLON GHOST_DELIMITER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lock_pos -> OPEN_BRACKET term CLOSE_BRACKET

State 739:
## Known stack suffix:
## line_label_list term POINTER UNLOCK lock_pos
## LR(1) items:
statement -> line_label_list term POINTER UNLOCK lock_pos . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 740
-- On ghost_block shift to state 644
## Reductions:

State 740:
## Known stack suffix:
## line_label_list term POINTER UNLOCK lock_pos ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list term POINTER UNLOCK lock_pos ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list term POINTER UNLOCK lock_pos ghost_block_or_semicolon

State 741:
## Known stack suffix:
## line_label_list term POINTER LOCK
## LR(1) items:
statement -> line_label_list term POINTER LOCK . lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_BRACKET shift to state 736
-- On lock_pos shift to state 742
## Reductions:
-- On SEMICOLON GHOST_DELIMITER
--   reduce production lock_pos ->

State 742:
## Known stack suffix:
## line_label_list term POINTER LOCK lock_pos
## LR(1) items:
statement -> line_label_list term POINTER LOCK lock_pos . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 743
-- On ghost_block shift to state 644
## Reductions:

State 743:
## Known stack suffix:
## line_label_list term POINTER LOCK lock_pos ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list term POINTER LOCK lock_pos ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list term POINTER LOCK lock_pos ghost_block_or_semicolon

State 744:
## Known stack suffix:
## line_label_list term ASSIGN
## LR(1) items:
statement -> line_label_list term ASSIGN . term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list term ASSIGN . CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On CALL shift to state 745
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 751
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 745:
## Known stack suffix:
## line_label_list term ASSIGN CALL
## LR(1) items:
statement -> line_label_list term ASSIGN CALL . IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On IDENT shift to state 746
## Reductions:

State 746:
## Known stack suffix:
## line_label_list term ASSIGN CALL IDENT
## LR(1) items:
statement -> line_label_list term ASSIGN CALL IDENT . OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On OPEN_PAREN shift to state 747
## Reductions:

State 747:
## Known stack suffix:
## line_label_list term ASSIGN CALL IDENT OPEN_PAREN
## LR(1) items:
statement -> line_label_list term ASSIGN CALL IDENT OPEN_PAREN . params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 716
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On params shift to state 748
-- On param_list shift to state 722
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:
-- On CLOSE_PAREN
--   reduce production params ->

State 748:
## Known stack suffix:
## line_label_list term ASSIGN CALL IDENT OPEN_PAREN params
## LR(1) items:
statement -> line_label_list term ASSIGN CALL IDENT OPEN_PAREN params . CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On CLOSE_PAREN shift to state 749
## Reductions:

State 749:
## Known stack suffix:
## line_label_list term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN
## LR(1) items:
statement -> line_label_list term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_semicolon shift to state 750
-- On ghost_block shift to state 644
## Reductions:

State 750:
## Known stack suffix:
## line_label_list term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon

State 751:
## Known stack suffix:
## line_label_list term ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . POINTER NEXT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . DOT BINIT [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
addr -> term . DOT BEND [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
cell -> term . DOT LOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
cell -> term . DOT UNLOCK [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
elem -> term . DOT DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
elem -> term . POINTER DATA [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
integer -> term . MATH_PLUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
integer -> term . MATH_MINUS term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
integer -> term . MATH_MULT term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
integer -> term . MATH_DIV term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
integer -> term . MATH_MOD term [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
mark -> term . DOT MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
mark -> term . POINTER MARKED [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
set -> term . DOT BREGION [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
statement -> line_label_list term ASSIGN term . ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
tid -> term . DOT LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
tid -> term . POINTER LOCKID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
tid -> term . DOT BTID [ SEMICOLON POINTER OPEN_BRACKET MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_DIV GHOST_DELIMITER DOT ]
## Transitions:
-- On SEMICOLON shift to state 590
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_DIV shift to state 162
-- On GHOST_DELIMITER shift to state 591
-- On DOT shift to state 135
-- On ghost_block_or_semicolon shift to state 752
-- On ghost_block shift to state 644
## Reductions:

State 752:
## Known stack suffix:
## line_label_list term ASSIGN term ghost_block_or_semicolon
## LR(1) items:
statement -> line_label_list term ASSIGN term ghost_block_or_semicolon . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> line_label_list term ASSIGN term ghost_block_or_semicolon

State 753:
## Known stack suffix:
## if_keyword
## LR(1) items:
statement -> if_keyword . formula ST_THEN statement_list statements_else_if ST_ENDIF ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 521
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 754
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 754:
## Known stack suffix:
## if_keyword formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_OR formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . LOGICAL_THEN formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
formula -> formula . EQUALS formula [ ST_THEN LOGICAL_THEN LOGICAL_OR LOGICAL_AND EQUALS ]
statement -> if_keyword formula . ST_THEN statement_list statements_else_if ST_ENDIF ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_THEN shift to state 755
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:

State 755:
## Known stack suffix:
## if_keyword formula ST_THEN
## LR(1) items:
statement -> if_keyword formula ST_THEN . statement_list statements_else_if ST_ENDIF ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statement_list shift to state 756
-- On statement shift to state 585
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 756:
## Known stack suffix:
## if_keyword formula ST_THEN statement_list
## LR(1) items:
statement -> if_keyword formula ST_THEN statement_list . statements_else_if ST_ENDIF ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ELSE shift to state 757
-- On statements_else_if shift to state 766
## Reductions:
-- On ST_ENDIF
--   reduce production statements_else_if ->

State 757:
## Known stack suffix:
## ST_ELSE
## LR(1) items:
statements_else_if -> ST_ELSE . statement_list [ ST_ENDIF ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statement_list shift to state 758
-- On statement shift to state 585
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 758:
## Known stack suffix:
## ST_ELSE statement_list
## LR(1) items:
statements_else_if -> ST_ELSE statement_list . [ ST_ENDIF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statements_else_if -> ST_ELSE statement_list

State 759:
## Known stack suffix:
## line_label_list
## LR(1) items:
choice_keyword -> line_label_list . ST_CHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
if_keyword -> line_label_list . ST_IF [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
statement -> line_label_list . ST_SKIP ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_ASSERT formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_AWAIT formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_NONCRITICAL ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . ST_CRITICAL ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN term ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN formula ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . IDENT ASSIGN CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term POINTER LOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . term POINTER UNLOCK lock_pos ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . OPEN_SET atomic_statement_list CLOSE_SET ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . CALL IDENT OPEN_PAREN params CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
statement -> line_label_list . RETURN OPEN_PAREN maybe_term CLOSE_PAREN ghost_block_or_semicolon [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
while_keyword -> line_label_list . ST_WHILE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF SUBSETEQTH SUBSETEQINT SUBSETEQELEM SUBSETEQ SKIPLIST SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSUBSETEQ SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIRIN SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM REACH PATH2SET ORDERLIST OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOGICAL_TRUE LOGICAL_NOT LOGICAL_FALSE LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF INTH ININT INELEM IN IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHTBL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET ARR_UPDATE APPEND ADDR2SET ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On ST_WHILE shift to state 588
-- On ST_SKIP shift to state 589
-- On ST_NONCRITICAL shift to state 645
-- On ST_IF shift to state 647
-- On ST_CRITICAL shift to state 648
-- On ST_CHOICE shift to state 620
-- On ST_AWAIT shift to state 650
-- On ST_ASSERT shift to state 653
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On RETURN shift to state 656
-- On PATH2SET shift to state 59
-- On OPEN_SET shift to state 662
-- On OPEN_PAREN shift to state 62
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On IDENT shift to state 711
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On CALL shift to state 727
-- On ARR_UPDATE shift to state 119
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 733
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On elem shift to state 154
-- On cell shift to state 155
-- On bucket shift to state 156
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 760:
## Known stack suffix:
## choice_keyword
## LR(1) items:
statement -> choice_keyword . statements_choice ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statements_choice shift to state 761
-- On statement_list shift to state 763
-- On statement shift to state 585
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 761:
## Known stack suffix:
## choice_keyword statements_choice
## LR(1) items:
statement -> choice_keyword statements_choice . ST_ENDCHOICE [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDCHOICE shift to state 762
## Reductions:

State 762:
## Known stack suffix:
## choice_keyword statements_choice ST_ENDCHOICE
## LR(1) items:
statement -> choice_keyword statements_choice ST_ENDCHOICE . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> choice_keyword statements_choice ST_ENDCHOICE

State 763:
## Known stack suffix:
## statement_list
## LR(1) items:
statements_choice -> statement_list . [ ST_ENDCHOICE ]
statements_choice -> statement_list . ST_OR statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On ST_OR shift to state 764
## Reductions:
-- On ST_ENDCHOICE
--   reduce production statements_choice -> statement_list

State 764:
## Known stack suffix:
## statement_list ST_OR
## LR(1) items:
statements_choice -> statement_list ST_OR . statements_choice [ ST_ENDCHOICE ]
## Transitions:
-- On COLON shift to state 576
-- On while_keyword shift to state 580
-- On statements_choice shift to state 765
-- On statement_list shift to state 763
-- On statement shift to state 585
-- On line_label_list shift to state 759
-- On line_label shift to state 621
-- On if_keyword shift to state 753
-- On choice_keyword shift to state 760
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_NONCRITICAL ST_IF ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET CALL ARR_UPDATE ADDR2SET
--   reduce production line_label_list ->

State 765:
## Known stack suffix:
## statement_list ST_OR statements_choice
## LR(1) items:
statements_choice -> statement_list ST_OR statements_choice . [ ST_ENDCHOICE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statements_choice -> statement_list ST_OR statements_choice

State 766:
## Known stack suffix:
## if_keyword formula ST_THEN statement_list statements_else_if
## LR(1) items:
statement -> if_keyword formula ST_THEN statement_list statements_else_if . ST_ENDIF ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On ST_ENDIF shift to state 767
## Reductions:

State 767:
## Known stack suffix:
## if_keyword formula ST_THEN statement_list statements_else_if ST_ENDIF
## LR(1) items:
statement -> if_keyword formula ST_THEN statement_list statements_else_if ST_ENDIF . ghost_block_or_nothing [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
-- On GHOST_DELIMITER shift to state 591
-- On ghost_block_or_nothing shift to state 768
-- On ghost_block shift to state 710
## Reductions:
-- On UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET
--   reduce production ghost_block_or_nothing ->

State 768:
## Known stack suffix:
## if_keyword formula ST_THEN statement_list statements_else_if ST_ENDIF ghost_block_or_nothing
## LR(1) items:
statement -> if_keyword formula ST_THEN statement_list statements_else_if ST_ENDIF ghost_block_or_nothing . [ UPDATE UNLOCK UNIONTH UNIONINT UNIONELEM UNION TIDOF ST_WHILE ST_SKIP ST_OR ST_NONCRITICAL ST_IF ST_ENDWHILE ST_ENDIF ST_ENDCHOICE ST_ELSE ST_CRITICAL ST_CHOICE ST_AWAIT ST_ASSERT SINGLE_PATH SINGLETH SINGLEINT SINGLEELEM SHARP SETPAIRUNION SETPAIRSINGLE SETPAIRMIN SETPAIRMAX SETPAIRINTR SETPAIREMPTY SETPAIRDIFF SETINTMIN SETINTMAX SETDIFFTH SETDIFFINT SETDIFFELEM SETDIFF SET2ELEM RETURN PATH2SET OPEN_SET OPEN_PAREN NUMBER NULL MKCELL MKBUCKET MEMORY_READ ME MATH_MINUS MARK_T MARK_F MALLOCSLK MALLOCSL MALLOC LOWEST_ELEM LOCK LASTLOCKED INTRTH INTRINT INTRELEM INTR INTOF IDENT HIGHEST_ELEM HAVOCSKIPLISTELEM HAVOCLISTELEM HAVOCLEVEL HASHCODE GETP FIRSTLOCKED ERROR EPSILON END EMPTYSETTH EMPTYSETINT EMPTYSETELEM EMPTYSET COLON CALL ARR_UPDATE ADDR2SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> if_keyword formula ST_THEN statement_list statements_else_if ST_ENDIF ghost_block_or_nothing

State 769:
## Known stack suffix:
## statement_list
## LR(1) items:
program -> statement_list . [ END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production program -> statement_list

State 770:
## Known stack suffix:
## PROCEDURE procedure_name args procedure_sort local_declarations BEGIN program
## LR(1) items:
procedure -> PROCEDURE procedure_name args procedure_sort local_declarations BEGIN program . END [ PROCEDURE # ]
## Transitions:
-- On END shift to state 771
## Reductions:

State 771:
## Known stack suffix:
## PROCEDURE procedure_name args procedure_sort local_declarations BEGIN program END
## LR(1) items:
procedure -> PROCEDURE procedure_name args procedure_sort local_declarations BEGIN program END . [ PROCEDURE # ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production procedure -> PROCEDURE procedure_name args procedure_sort local_declarations BEGIN program END

State 772:
## Known stack suffix:
## local_decl_list
## LR(1) items:
local_declarations -> local_decl_list . [ BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production local_declarations -> local_decl_list

State 773:
## Known stack suffix:
## local_decl
## LR(1) items:
local_decl_list -> local_decl . [ BEGIN ]
local_decl_list -> local_decl . local_decl_list [ BEGIN ]
## Transitions:
-- On GHOST shift to state 2
-- On local_decl_list shift to state 774
-- On local_decl shift to state 773
-- On kind shift to state 775
## Reductions:
-- On IDENT
--   reduce production kind ->
-- On BEGIN
--   reduce production local_decl_list -> local_decl

State 774:
## Known stack suffix:
## local_decl local_decl_list
## LR(1) items:
local_decl_list -> local_decl local_decl_list . [ BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production local_decl_list -> local_decl local_decl_list

State 775:
## Known stack suffix:
## kind
## LR(1) items:
local_decl -> kind . IDENT IDENT [ IDENT GHOST BEGIN ]
local_decl -> kind . IDENT IDENT ASSIGN term [ IDENT GHOST BEGIN ]
local_decl -> kind . IDENT IDENT ASSIGN formula [ IDENT GHOST BEGIN ]
## Transitions:
-- On IDENT shift to state 776
## Reductions:

State 776:
## Known stack suffix:
## kind IDENT
## LR(1) items:
local_decl -> kind IDENT . IDENT [ IDENT GHOST BEGIN ]
local_decl -> kind IDENT . IDENT ASSIGN term [ IDENT GHOST BEGIN ]
local_decl -> kind IDENT . IDENT ASSIGN formula [ IDENT GHOST BEGIN ]
## Transitions:
-- On IDENT shift to state 777
## Reductions:

State 777:
## Known stack suffix:
## kind IDENT IDENT
## LR(1) items:
local_decl -> kind IDENT IDENT . [ IDENT GHOST BEGIN ]
local_decl -> kind IDENT IDENT . ASSIGN term [ IDENT GHOST BEGIN ]
local_decl -> kind IDENT IDENT . ASSIGN formula [ IDENT GHOST BEGIN ]
## Transitions:
-- On ASSIGN shift to state 778
## Reductions:
-- On IDENT GHOST BEGIN
--   reduce production local_decl -> kind IDENT IDENT

State 778:
## Known stack suffix:
## kind IDENT IDENT ASSIGN
## LR(1) items:
local_decl -> kind IDENT IDENT ASSIGN . term [ IDENT GHOST BEGIN ]
local_decl -> kind IDENT IDENT ASSIGN . formula [ IDENT GHOST BEGIN ]
## Transitions:
-- On UPDATE shift to state 9
-- On UNLOCK shift to state 11
-- On UNIONTH shift to state 13
-- On UNIONINT shift to state 15
-- On UNIONELEM shift to state 17
-- On UNION shift to state 19
-- On TIDOF shift to state 21
-- On SUBSETEQTH shift to state 405
-- On SUBSETEQINT shift to state 411
-- On SUBSETEQELEM shift to state 417
-- On SUBSETEQ shift to state 423
-- On SKIPLIST shift to state 429
-- On SINGLE_PATH shift to state 23
-- On SINGLETH shift to state 25
-- On SINGLEINT shift to state 27
-- On SINGLEELEM shift to state 29
-- On SHARP shift to state 31
-- On SETPAIRUNION shift to state 32
-- On SETPAIRSUBSETEQ shift to state 443
-- On SETPAIRSINGLE shift to state 34
-- On SETPAIRMIN shift to state 36
-- On SETPAIRMAX shift to state 38
-- On SETPAIRINTR shift to state 40
-- On SETPAIRIN shift to state 449
-- On SETPAIREMPTY shift to state 42
-- On SETPAIRDIFF shift to state 43
-- On SETINTMIN shift to state 45
-- On SETINTMAX shift to state 47
-- On SETDIFFTH shift to state 49
-- On SETDIFFINT shift to state 51
-- On SETDIFFELEM shift to state 53
-- On SETDIFF shift to state 55
-- On SET2ELEM shift to state 57
-- On REACH shift to state 455
-- On PATH2SET shift to state 59
-- On ORDERLIST shift to state 465
-- On OPEN_SET shift to state 61
-- On OPEN_PAREN shift to state 473
-- On NUMBER shift to state 63
-- On NULL shift to state 64
-- On MKCELL shift to state 65
-- On MKBUCKET shift to state 67
-- On MEMORY_READ shift to state 69
-- On ME shift to state 71
-- On MATH_MINUS shift to state 72
-- On MARK_T shift to state 73
-- On MARK_F shift to state 74
-- On MALLOCSLK shift to state 75
-- On MALLOCSL shift to state 77
-- On MALLOC shift to state 79
-- On LOWEST_ELEM shift to state 81
-- On LOGICAL_TRUE shift to state 474
-- On LOGICAL_NOT shift to state 475
-- On LOGICAL_FALSE shift to state 476
-- On LOCK shift to state 82
-- On LASTLOCKED shift to state 84
-- On INTRTH shift to state 86
-- On INTRINT shift to state 88
-- On INTRELEM shift to state 90
-- On INTR shift to state 92
-- On INTOF shift to state 94
-- On INTH shift to state 477
-- On ININT shift to state 483
-- On INELEM shift to state 489
-- On IN shift to state 495
-- On IDENT shift to state 96
-- On HIGHEST_ELEM shift to state 97
-- On HAVOCSKIPLISTELEM shift to state 98
-- On HAVOCLISTELEM shift to state 101
-- On HAVOCLEVEL shift to state 104
-- On HASHTBL shift to state 501
-- On HASHCODE shift to state 107
-- On GETP shift to state 109
-- On FIRSTLOCKED shift to state 111
-- On ERROR shift to state 113
-- On EPSILON shift to state 114
-- On EMPTYSETTH shift to state 115
-- On EMPTYSETINT shift to state 116
-- On EMPTYSETELEM shift to state 117
-- On EMPTYSET shift to state 118
-- On ARR_UPDATE shift to state 119
-- On APPEND shift to state 513
-- On ADDR2SET shift to state 121
-- On tid shift to state 123
-- On term shift to state 779
-- On setth shift to state 142
-- On setpair shift to state 143
-- On setint shift to state 144
-- On setelem shift to state 145
-- On set shift to state 146
-- On path shift to state 147
-- On pair shift to state 148
-- On mem shift to state 149
-- On mark shift to state 150
-- On lock shift to state 151
-- On integer shift to state 152
-- On ident shift to state 153
-- On formula shift to state 780
-- On equals shift to state 535
-- On elem shift to state 154
-- On disequals shift to state 536
-- On cell shift to state 155
-- On bucket shift to state 156
-- On atom shift to state 537
-- On arrayupd shift to state 157
-- On arraylookup shift to state 158
-- On addr shift to state 159
## Reductions:

State 779:
## Known stack suffix:
## kind IDENT IDENT ASSIGN term
## LR(1) items:
addr -> term . DOT NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . DOT NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . DOT ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . POINTER NEXT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . POINTER NEXTAT OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . POINTER ARR OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . DOT BINIT [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
addr -> term . DOT BEND [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
arraylookup -> term . OPEN_BRACKET term CLOSE_BRACKET [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
atom -> term . MATH_LESS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
atom -> term . MATH_GREATER term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
atom -> term . MATH_LESS_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
atom -> term . MATH_GREATER_EQ term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
cell -> term . DOT LOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
cell -> term . DOT UNLOCK [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
disequals -> term . NOT_EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
elem -> term . DOT DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
elem -> term . POINTER DATA [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
equals -> term . EQUALS term [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
integer -> term . MATH_PLUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
integer -> term . MATH_MINUS term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
integer -> term . MATH_MULT term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
integer -> term . MATH_DIV term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
integer -> term . MATH_MOD term [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
local_decl -> kind IDENT IDENT ASSIGN term . [ IDENT GHOST BEGIN ]
mark -> term . DOT MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
mark -> term . POINTER MARKED [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
set -> term . DOT BREGION [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
tid -> term . DOT LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
tid -> term . POINTER LOCKID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
tid -> term . DOT BTID [ POINTER OPEN_BRACKET NOT_EQUALS MATH_PLUS MATH_MULT MATH_MOD MATH_MINUS MATH_LESS_EQ MATH_LESS MATH_GREATER_EQ MATH_GREATER MATH_DIV IDENT GHOST EQUALS DOT BEGIN ]
## Transitions:
-- On POINTER shift to state 125
-- On OPEN_BRACKET shift to state 129
-- On NOT_EQUALS shift to state 522
-- On MATH_PLUS shift to state 131
-- On MATH_MULT shift to state 133
-- On MATH_MOD shift to state 140
-- On MATH_MINUS shift to state 160
-- On MATH_LESS_EQ shift to state 524
-- On MATH_LESS shift to state 526
-- On MATH_GREATER_EQ shift to state 528
-- On MATH_GREATER shift to state 530
-- On MATH_DIV shift to state 162
-- On EQUALS shift to state 532
-- On DOT shift to state 135
## Reductions:
-- On IDENT GHOST BEGIN
--   reduce production local_decl -> kind IDENT IDENT ASSIGN term

State 780:
## Known stack suffix:
## kind IDENT IDENT ASSIGN formula
## LR(1) items:
formula -> formula . LOGICAL_AND formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
formula -> formula . LOGICAL_OR formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
formula -> formula . LOGICAL_THEN formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
formula -> formula . EQUALS formula [ LOGICAL_THEN LOGICAL_OR LOGICAL_AND IDENT GHOST EQUALS BEGIN ]
local_decl -> kind IDENT IDENT ASSIGN formula . [ IDENT GHOST BEGIN ]
## Transitions:
-- On LOGICAL_THEN shift to state 542
-- On LOGICAL_OR shift to state 544
-- On LOGICAL_AND shift to state 546
-- On EQUALS shift to state 548
## Reductions:
-- On IDENT GHOST BEGIN
--   reduce production local_decl -> kind IDENT IDENT ASSIGN formula

State 781:
## Known stack suffix:
## GLOBAL global_declarations initial_assumption procedure_list
## LR(1) items:
system -> GLOBAL global_declarations initial_assumption procedure_list . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production system -> GLOBAL global_declarations initial_assumption procedure_list

State 782:
## Known stack suffix:
## procedure
## LR(1) items:
procedure_list -> procedure . [ # ]
procedure_list -> procedure . procedure_list [ # ]
## Transitions:
-- On PROCEDURE shift to state 557
-- On procedure_list shift to state 783
-- On procedure shift to state 782
## Reductions:

State 783:
## Known stack suffix:
## procedure procedure_list
## LR(1) items:
procedure_list -> procedure procedure_list . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production procedure_list -> procedure procedure_list

State 784:
## Known stack suffix:
## global_decl_list
## LR(1) items:
global_declarations -> global_decl_list . [ PROCEDURE ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production global_declarations -> global_decl_list

State 785:
## Known stack suffix:
## global_decl
## LR(1) items:
global_decl_list -> global_decl . [ PROCEDURE ASSUME ]
global_decl_list -> global_decl . global_decl_list [ PROCEDURE ASSUME ]
## Transitions:
-- On GHOST shift to state 2
-- On kind shift to state 3
-- On global_decl_list shift to state 786
-- On global_decl shift to state 785
## Reductions:
-- On PROCEDURE ASSUME
--   reduce production global_decl_list -> global_decl
-- On IDENT
--   reduce production kind ->

State 786:
## Known stack suffix:
## global_decl global_decl_list
## LR(1) items:
global_decl_list -> global_decl global_decl_list . [ PROCEDURE ASSUME ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production global_decl_list -> global_decl global_decl_list

State 787:
## Known stack suffix:
## system
## LR(1) items:
system' -> system . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept system

