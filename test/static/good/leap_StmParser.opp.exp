File "leap_StmParser.mly", line 925, characters 7-9:
Warning: the token AT is unused.
File "leap_StmParser.mly", line 911, characters 40-49:
Warning: the token BARRAYUPD is unused.
File "leap_StmParser.mly", line 918, characters 13-24:
Warning: the token DOUBLECOLON is unused.
File "leap_StmParser.mly", line 929, characters 7-10:
Warning: the token EOF is unused.
File "leap_StmParser.mly", line 924, characters 7-16:
Warning: the token INVARIANT is unused.
File "leap_StmParser.mly", line 920, characters 55-66:
Warning: the token LOGICAL_IFF is unused.
File "leap_StmParser.mly", line 924, characters 17-22:
Warning: the token PARAM is unused.
File "leap_StmParser.mly", line 910, characters 7-13:
Warning: the token THREAD is unused.
File "leap_StmParser.mly", line 925, characters 10-20:
Warning: the token UNDERSCORE is unused.
File "leap_StmParser.mly", line 917, characters 7-19:
Warning: the token VERTICAL_BAR is unused.
%{

(***********************************************************************)
(*                                                                     *)
(*                                 LEAP                                *)
(*                                                                     *)
(*               Alejandro Sanchez, IMDEA Software Institute           *)
(*                                                                     *)
(*                                                                     *)
(*      Copyright 2011 IMDEA Software Institute                        *)
(*                                                                     *)
(*  Licensed under the Apache License, Version 2.0 (the "License");    *)
(*  you may not use this file except in compliance with the License.   *)
(*  You may obtain a copy of the License at                            *)
(*                                                                     *)
(*      http://www.apache.org/licenses/LICENSE-2.0                     *)
(*                                                                     *)
(*  Unless required by applicable law or agreed to in writing,         *)
(*  software distributed under the License is distributed on an        *)
(*  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,       *)
(*  either express or implied.                                         *)
(*  See the License for the specific language governing permissions    *)
(*  and limitations under the License.                                 *)
(*                                                                     *)
(***********************************************************************)

open Printf

open LeapLib
open Global

module E = Expression
module Sys  = System
module Stm  = Statement
module F = Formula


type cond_op_t =
  | Less
  | Greater
  | LessEq
  | GreaterEq
  | In
  | SubsetEq
  | InTh
  | SubsetEqTh
  | InInt
  | SubsetEqInt
  | InElem
  | SubsetEqElem
  | InPair
  | SubsetEqPair


exception WrongType of Stm.term
exception Sort_mismatch of E.V.id * E.sort * E.sort
exception Not_sort_name of string
exception Duplicated_local_var of E.V.id * E.sort
exception No_main
exception No_valid_main
exception Unknown_procedure of string
exception Variable_not_in_procedure of E.V.id * string
exception Wrong_assignment of Stm.term
exception Atomic_double_assignment of Stm.expr_t
exception Unexpected_statement of string
exception Ghost_var_in_global_decl
              of E.V.id * E.sort * E.initVal_t option * E.var_nature
exception Ghost_var_in_local_decl
              of E.V.id * E.sort * E.initVal_t option * E.var_nature
exception Ghost_vars_in_assignment of Stm.term list
exception Normal_vars_in_ghost_assignment of Stm.term list
exception Procedure_args_mismatch of string
exception Incompatible_call_sort of Stm.term * string
exception Incompatible_return_sort of string
exception Different_argument_length of string * string


(* Temporal variable tables for input and local variables *)
let globalVars = System.empty_var_table ()
let inputVars = System.empty_var_table ()
let localVars = System.empty_var_table ()
let invVars = System.empty_var_table ()

let transitions = System.new_tran_table

let labelTbl : (string, (E.pc_t * E.pc_t)) Hashtbl.t =
  Hashtbl.create System.initLabelNum

let procedures : (string * System.proc_info_t) list ref = ref []

let current_proc : string ref = ref ""

let call_points : (string, E.pc_t) Hashtbl.t = Hashtbl.create 5

let return_points : (string, E.pc_t) Hashtbl.t = Hashtbl.create 5

let flag_parsingInv : bool ref = ref false

let flag_parsingDia : bool ref = ref false

let undefTids : E.V.id list ref = ref []

let cond_stm_list : (E.pc_t list) ref = ref []


(* Position and jump management for procedures *)
let pos : int ref = ref 1
let pos_st : (E.pc_t, string * Statement.statement_t) Hashtbl.t =
  Hashtbl.create 400




(* Variable declaration functions *)

let decl_global_var (v:E.V.id)
                    (s:E.sort)
                    (e:E.initVal_t option)
                    (k:E.var_nature) : unit =
  let cond = Option.lift (E.get_initVal_restriction) e in
  let _ = match k with
            E.RealVar -> let ghosts = Option.map_default
                                          (E.var_kind E.GhostVar) [] cond
                            in
                            if ghosts <> [] then
                              begin
                                Interface.Err.msg "Ghost variable used in \
                                                   non-ghost declaration" $
                                sprintf "Global variable \"%s\" of sort \"%s\" \
                                         is assigned in its declaration to \
                                         expression \"%s\", which contains \
                                         ghost variables: %s."
                                 (v)
                                 (E.sort_to_str s)
                                 (Option.map_default E.expr_to_str "" cond)
                                 (String.concat ", " $
                                     List.map E.term_to_str ghosts);
                                raise(Ghost_var_in_global_decl(v,s,e,k))
                              end
           | E.GhostVar -> ()
  in
  System.add_var globalVars v s e E.V.Shared k


let decl_input_var (v:E.V.id)
                   (s:E.sort)
                   (e:E.initVal_t option) : unit =
  System.add_var inputVars v s e E.V.Shared E.RealVar


let decl_local_var (v:E.V.id)
                   (s:E.sort)
                   (e:E.initVal_t option)
                   (k:E.var_nature) : unit =
  let cond = Option.lift (E.get_initVal_restriction) e in
  if System.mem_var inputVars v then
    begin
      Interface.Err.msg "Input and local variables conflict" $
              sprintf "Variable \"%s\" of sort %s cannot be defined as local \
                       since its name conflicts with a procedure input \
                       variable." v (E.sort_to_str s);
      raise(Duplicated_local_var(v, s))
    end
  else
    begin
    let _ = match k with
              E.RealVar -> let ghosts = Option.map_default
                                            (E.var_kind E.GhostVar) [] cond
                             in
                             if ghosts <> [] then
                               begin
                                 Interface.Err.msg "Ghost variable used in \
                                                    non-ghost declaration" $
                                 sprintf "Local variable \"%s\" of sort \
                                          \"%s\" is assigned in its \
                                          declaration to expression \"%s\", \
                                          which contains ghost variables: \
                                          %s."
                                   (v)
                                   (E.sort_to_str s)
                                   (Option.map_default E.expr_to_str "" cond)
                                   (String.concat ", " $
                                       List.map E.term_to_str ghosts);
                                 raise(Ghost_var_in_local_decl(v,s,e,k))
                              end
            | E.GhostVar  -> ()
    in
      System.add_var localVars v s e E.V.Shared k
    end




let decl_inv_var (v:E.V.id) (s:E.sort) (e:E.initVal_t option) : unit =
  System.add_var invVars v s e E.V.Shared E.RealVar


let get_sort_from_tables (stm_t:Stm.term)
                         (inpTbl:Sys.var_table_t)
                         (locTbl:Sys.var_table_t) : E.sort =
  match stm_t with
  | Stm.AddrT (Stm.Malloc _)    -> E.Addr
  | Stm.AddrT (Stm.MallocSL _)  -> E.Addr
  | Stm.AddrT (Stm.MallocSLK _) -> E.Addr
  | _ -> let t = Stm.term_to_expr_term stm_t
         in
           System.get_sort_from_term globalVars inpTbl locTbl invVars t


(* Looks for a term sort in the global and temporal var tables. *)
(* BEWARE! Works only with current local tables. Hence, if called from
   outside a procedure, it will assign tid to a local variable not belonging
   to the current procedure *)
let get_sort (stm_t:Stm.term) : E.sort =
  get_sort_from_tables stm_t inputVars localVars


let get_var_kind (v:E.V.id) : E.var_nature =
  let k = if System.mem_var localVars v then
            System.find_var_kind localVars v
          else if System.mem_var inputVars v then
            System.find_var_kind inputVars v
          else if System.mem_var globalVars v then
            System.find_var_kind globalVars v
          else if !flag_parsingInv then
            System.find_var_kind invVars v
          else
            let _ = undefTids := v :: !undefTids in
            let _ = decl_global_var v E.Tid None E.RealVar in
              E.RealVar
  in
    k

(* Parsing error message funtion *)
let parser_error msg =
  let msg = sprintf "Error at line %i:\n%s" (Global.get_linenum ()) msg in
    raise(ParserError msg)



let parser_typing_error term a_sort get_expr =
  let term_str = (Stm.term_to_str term) in
  let term_sort_str = (E.sort_to_str (get_sort term)) in
  let sort_str = (E.sort_to_str a_sort) in
  let str_expr = (get_expr ()) in
  let str = sprintf "Term \"%s\" is of sort %s, but it was \
                     expected to be of sort %s in expression \"%s\""
                     term_str term_sort_str sort_str str_expr in
  parser_error str



let parser_types_incompatible (t1:Stm.term) (t2:Stm.term) get_expr_str =
  let t1_str = (Stm.term_to_str t1) in
  let s1_str = (E.sort_to_str (get_sort t1)) in
  let t2_str = (Stm.term_to_str t2) in
  let s2_str = (E.sort_to_str (get_sort t2)) in
  let str_expr = (get_expr_str ()) in
  let str = (Printf.sprintf "Unexpectedly \"%s\" is of type \"%s\" and  \
                             \"%s\" is of type \"%s\", when they should \
                             have the same type in expression \"%s\"."
                            t1_str s1_str t2_str s2_str str_expr) in
    parser_error str



let parser_check_compatibility t1 t2 get_expr_str =
  let s1 = get_sort t1 in
  let s2 = get_sort t2 in
    if (s1 != s2) then
      parser_types_incompatible t1 t2 get_expr_str


let parser_check_compatibility_with_op_cond t1 t2 get_expr_str op =
  let s1 = get_sort t1 in
  let s2 = get_sort t2 in
  match op with
    In          -> if (s1 != E.Addr || s2 != E.Set) then
                     parser_types_incompatible t1 t2 get_expr_str
  | SubsetEq    -> if (s1 != E.Set || s2 != E.Set) then
                     parser_types_incompatible t1 t2 get_expr_str
  | InTh        -> if (s1 != E.Tid || s2 != E.SetTh) then
                     parser_types_incompatible t1 t2 get_expr_str
  | SubsetEqTh  -> if (s1 != E.SetTh || s2 != E.SetTh) then
                     parser_types_incompatible t1 t2 get_expr_str
  | InInt       -> if (s1 != E.Int || s2 != E.SetInt) then
                     parser_types_incompatible t1 t2 get_expr_str
  | SubsetEqInt -> if (s1 != E.SetInt || s2 != E.SetInt) then
                     parser_types_incompatible t1 t2 get_expr_str
  | _           -> if (s1 != s2) then
                     parser_types_incompatible t1 t2 get_expr_str



let parser_check_var_assign v s1 s2 get_expr_str =
  let str_expr = (get_expr_str()) in
  if (s1 != s2) then
    begin
      Interface.Err.msg "Unexpected sort" $
              sprintf "Variable %s has sort %s, but sort %s was expected \
                       in:\n\n%s"
                      v (E.sort_to_str s1) (E.sort_to_str s2) (str_expr);
      raise(Sort_mismatch(v, s1, s2))
    end


let parser_check_type checker a_term a_sort get_expr_str =
  try
    checker a_term
  with
    | WrongType(_) -> parser_typing_error a_term a_sort get_expr_str



(* slow way to project: traverse one time per entry *)
let get_name id = fst id
let get_line id = snd id


let check_sort_var (v:Stm.varId)
                   (p:Stm.procedure_name)
                   (s:E.sort)
                   (k:E.var_nature) : unit =
  let generic_var = Stm.VarT (Stm.build_var v E.Unknown p ~nature:k) in
  let knownSort = get_sort generic_var in
    if (knownSort != s) then
      begin
        Interface.Err.msg "Mismatch variable type" $
          sprintf "Variable %s is of sort %s, while it is trying to be \
                   assigned to an expression of sort %s"
                    v (E.sort_to_str knownSort) (E.sort_to_str s);
        raise(Sort_mismatch(v, knownSort, s))
      end


let wrong_sort_msg_for (t:Stm.term) (s:E.sort) : unit =
  Interface.Err.msg "Wrong type" $
  sprintf "A term of sort %s was expected, but term \"%s\" has sort %s."
              (E.sort_to_str s) (Stm.term_to_str t)
              (E.sort_to_str (get_sort t))


let parser_check_boolean_type a_term get_expr_str =
  match a_term with
    | Stm.VarT v -> check_sort_var v.Stm.id v.Stm.scope E.Bool v.Stm.nature; a_term
    | _          -> parser_typing_error a_term E.Bool get_expr_str


let check_type_int t =
  match t with
      Stm.IntT(i) -> i
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Int v.Stm.nature; Stm.VarInt v
    | _           -> raise(WrongType t)


let check_type_pair t =
  match t with
      Stm.PairT(i) -> i
    | Stm.VarT v   -> check_sort_var v.Stm.id v.Stm.scope E.Pair v.Stm.nature; Stm.VarPair v
    | _            -> raise(WrongType t)


let check_type_set t =
  match t with
      Stm.SetT(s) -> s
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Set v.Stm.nature; Stm.VarSet v
    | _           -> raise(WrongType t)


let check_type_elem t =
  match t with
      Stm.ElemT(e) -> e
    | Stm.VarT v   -> check_sort_var v.Stm.id v.Stm.scope E.Elem v.Stm.nature; Stm.VarElem v
    | _            -> raise(WrongType t)


let check_type_tid t =
  match t with
      Stm.TidT(th) -> th
    | Stm.VarT v    -> check_sort_var v.Stm.id v.Stm.scope E.Tid v.Stm.nature; Stm.VarTh v
    | _             -> raise(WrongType t)


let check_type_addr t =
  match t with
      Stm.AddrT(a) -> a
    | Stm.VarT v   -> check_sort_var v.Stm.id v.Stm.scope E.Addr v.Stm.nature; Stm.VarAddr v
    | _            -> raise(WrongType t)


let check_type_cell t =
  match t with
      Stm.CellT(c) -> c
    | Stm.VarT v   -> check_sort_var v.Stm.id v.Stm.scope E.Cell v.Stm.nature; Stm.VarCell v
    | _            -> raise(WrongType t)


let check_type_setth t =
  match t with
      Stm.SetThT(sth) -> sth
    | Stm.VarT v      -> check_sort_var v.Stm.id v.Stm.scope E.SetTh v.Stm.nature; Stm.VarSetTh v
    | _               -> raise(WrongType t)


let check_type_setint t =
  match t with
      Stm.SetIntT(sth) -> sth
    | Stm.VarT v       -> check_sort_var v.Stm.id v.Stm.scope E.SetInt v.Stm.nature; Stm.VarSetInt v
    | _                -> raise(WrongType t)


let check_type_setelem t =
  match t with
      Stm.SetElemT(se) -> se
    | Stm.VarT v       -> check_sort_var v.Stm.id v.Stm.scope E.SetElem v.Stm.nature; Stm.VarSetElem v
    | _                -> raise(WrongType t)


let check_type_setpair t =
  match t with
      Stm.SetPairT(sp) -> sp
    | Stm.VarT v       -> check_sort_var v.Stm.id v.Stm.scope E.SetPair v.Stm.nature; Stm.VarSetPair v
    | _                -> raise(WrongType t)


let check_type_path t =
  match t with
      Stm.PathT(p) -> p
    | Stm.VarT v   -> check_sort_var v.Stm.id v.Stm.scope E.Path v.Stm.nature; Stm.VarPath v
    | _            -> raise(WrongType t)


let check_type_mem t =
  match t with
      Stm.MemT(m) -> m
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Mem v.Stm.nature; Stm.VarMem v
    | _           -> raise(WrongType t)


let check_type_addrarr t =
  match t with
      Stm.AddrArrayT(arr) -> arr
    | Stm.VarT v          -> check_sort_var v.Stm.id v.Stm.scope E.AddrArray v.Stm.nature; Stm.VarAddrArray v
    | _                   -> raise(WrongType t)


let check_type_tidarr t =
  match t with
      Stm.TidArrayT(arr) -> arr
    | Stm.VarT v         -> check_sort_var v.Stm.id v.Stm.scope E.TidArray v.Stm.nature; Stm.VarTidArray v
    | _                  -> raise(WrongType t)


let check_type_mark t =
  match t with
      Stm.MarkT m -> m
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Mark v.Stm.nature; Stm.VarMark v
    | _           -> raise(WrongType t)


let check_type_bucket t =
  match t with
      Stm.BucketT b -> b
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Bucket v.Stm.nature; Stm.VarBucket v
    | _           -> raise(WrongType t)


let check_type_bucketarr t =
  match t with
      Stm.BucketArrayT arr -> arr
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.BucketArray v.Stm.nature; Stm.VarBucketArray v
    | _           -> raise(WrongType t)


let check_type_lock t =
  match t with
      Stm.LockT l -> l
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.Lock v.Stm.nature; Stm.VarLock v
    | _           -> raise(WrongType t)


let check_type_lockarr t =
  match t with
      Stm.LockArrayT arr -> arr
    | Stm.VarT v  -> check_sort_var v.Stm.id v.Stm.scope E.LockArray v.Stm.nature; Stm.VarLockArray v
    | _           -> raise(WrongType t)

let check_and_get_sort (id:string) : E.sort =
  match id with
    "tid"       -> E.Tid
  | "elem"      -> E.Elem
  | "addr"      -> E.Addr
  | "cell"      -> E.Cell
  | "mem"       -> E.Mem
  | "path"      -> E.Path
  | "bool"      -> E.Bool
  | "addrSet"   -> E.Set
  | "tidSet"    -> E.SetTh
  | "intSet"    -> E.SetInt
  | "elemSet"   -> E.SetElem
  | "pairSet"   -> E.SetPair
  | "int"       -> E.Int
  | "pair"      -> E.Pair
  | "addrarr"   -> E.AddrArray
  | "tidarr"    -> E.TidArray
  | "mark"      -> E.Mark
  | "bucket"    -> E.Bucket
  | "bucketarr" -> E.BucketArray
  | "tlock"     -> E.Lock
  | "lockarr"   -> E.LockArray
  | _ -> begin
           Interface.Err.msg "Unrecognized sort" $
             sprintf "A sort was expected, but \"%s\" was found" id;
           raise(Not_sort_name id)
         end


  let check_is_procedure (id:string) : unit =
    if not (List.mem_assoc id !procedures) then
      begin
        Interface.Err.msg "Unknown procedure" $
                sprintf "Identifier \"%s\" is used as a procedure identifier, \
                         but no procedure with such name has been parsed." id;
        raise(Unknown_procedure id)
      end


  let check_call_args (p_info:Sys.proc_info_t)
                      (p_name:string)
                      (ps:Stm.term list) : unit =
    let args_signature = Sys.proc_info_get_args_sig p_info in
    let call_args = List.map get_sort ps in
    if (args_signature <> call_args) then
      begin
        Interface.Err.msg "Procedure arguments signature mismatched" $
          Printf.sprintf "Procedure %s expected arguments of sort\n\t%s\n \
                          but it was called with arguments (%s), of sort\n\t %s"
                          p_name
                          (String.concat " -> " $
                            List.map E.sort_to_str args_signature)
                          (String.concat ", " $ List.map Stm.term_to_str ps)
                          (String.concat " -> " $
                            List.map E.sort_to_str call_args);
        raise(Procedure_args_mismatch p_name)
      end


  let inject_sort (exp:Stm.term) : Stm.term =
    match exp with
      Stm.VarT v ->
        let s = get_sort exp in
        let modif_v = Stm.var_replace_sort v s in
          begin
            match s with
              E.Set          -> Stm.SetT         (Stm.VarSet          modif_v)
            | E.Elem         -> Stm.ElemT        (Stm.VarElem         modif_v)
            | E.Tid          -> Stm.TidT         (Stm.VarTh           modif_v)
            | E.Addr         -> Stm.AddrT        (Stm.VarAddr         modif_v)
            | E.Cell         -> Stm.CellT        (Stm.VarCell         modif_v)
            | E.SetTh        -> Stm.SetThT       (Stm.VarSetTh        modif_v)
            | E.SetInt       -> Stm.SetIntT      (Stm.VarSetInt       modif_v)
            | E.SetElem      -> Stm.SetElemT     (Stm.VarSetElem      modif_v)
            | E.SetPair      -> Stm.SetPairT     (Stm.VarSetPair      modif_v)
            | E.Path         -> Stm.PathT        (Stm.VarPath         modif_v)
            | E.Mem          -> Stm.MemT         (Stm.VarMem          modif_v)
            | E.Bool         -> Stm.VarT         modif_v
            | E.Int          -> Stm.IntT         (Stm.VarInt          modif_v)
            | E.Pair         -> Stm.PairT        (Stm.VarPair         modif_v)
            | E.Array        -> Stm.ArrayT       (Stm.VarArray        modif_v)
            | E.AddrArray    -> Stm.AddrArrayT   (Stm.VarAddrArray    modif_v)
            | E.TidArray     -> Stm.TidArrayT    (Stm.VarTidArray     modif_v)
            | E.BucketArray  -> Stm.BucketArrayT (Stm.VarBucketArray  modif_v)
            | E.Mark         -> Stm.MarkT        (Stm.VarMark         modif_v)
            | E.Bucket       -> Stm.BucketT      (Stm.VarBucket       modif_v)
            | E.Lock         -> Stm.LockT        (Stm.VarLock         modif_v)
            | E.LockArray    -> Stm.LockArrayT   (Stm.VarLockArray    modif_v)
            | E.Unknown      -> Stm.VarT         modif_v
          end
    | _                   -> exp


  let check_assignment_term (t:Stm.term) (get_expr_str:unit -> string) =
    match t with
      Stm.VarT _                               -> ()
    | Stm.SetT(Stm.VarSet _)                   -> ()
    | Stm.ElemT(Stm.VarElem _)                 -> ()
    | Stm.ElemT(Stm.CellData(Stm.VarCell _ ))  -> ()
    | Stm.TidT(Stm.VarTh _ )                   -> ()
    | Stm.BucketT(Stm.VarBucket _ )            -> ()
    | Stm.BucketT(Stm.BucketArrRd _)           -> ()
    | Stm.LockT(Stm.VarLock _ )                -> ()
    | Stm.LockT(Stm.LockArrRd _)               -> ()
    | Stm.MarkT(Stm.VarMark _ )                -> ()
    | Stm.AddrT(Stm.VarAddr _)                 -> ()
    | Stm.AddrT(Stm.Next(Stm.VarCell _))       -> ()
    | Stm.AddrT(Stm.NextAt(Stm.VarCell _,_))   -> ()
    | Stm.MarkT(Stm.Marked(Stm.VarCell _))     -> ()
    | Stm.CellT(Stm.VarCell _)                 -> ()
    | Stm.SetThT(Stm.VarSetTh _ )              -> ()
    | Stm.PathT(Stm.VarPath _ )                -> ()
    | Stm.MemT(Stm.VarMem _)                   -> ()
    | Stm.IntT(Stm.VarInt _)                   -> ()
    | Stm.ElemT(Stm.PointerData _)             -> ()
    | Stm.AddrT(Stm.PointerNext _)             -> ()
    | Stm.AddrT(Stm.PointerNextAt _)           -> ()
    | Stm.AddrT(Stm.PointerArrAt _)            -> ()
    | Stm.AddrT(Stm.AddrArrRd _)               -> ()
    | Stm.TidT(Stm.PointerLockid _)            -> ()
    | Stm.TidT(Stm.PointerLockidAt _)          -> ()
    | Stm.MarkT(Stm.PointerMarked _)           -> ()
    | Stm.TidT(Stm.TidArrRd _)                 -> ()
    | Stm.AddrT(Stm.BucketInit _)              -> ()
    | Stm.AddrT(Stm.BucketEnd _)               -> ()
    | Stm.SetT(Stm.BucketRegion _)             -> ()
    | Stm.TidT(Stm.BucketTid _)                -> ()
    | _ -> begin
             Interface.Err.msg "Invalid assignment" $
                      sprintf "The assignment \"%s\" is invalid. Assignments \
                               can be done only over variables, cells fields \
                               or array locations."
                               (get_expr_str ());
             raise(Wrong_assignment t)
           end


  let check_assignment_kind (t:Stm.term) (e:Stm.expr_t) (str:string) : unit =
    let t_ghost = Stm.var_kind (E.GhostVar) (Stm.Term t) in
    let e_ghost = Stm.var_kind (E.GhostVar) e in
    if (t_ghost <> [] || e_ghost <> []) then
      begin
        let ghost_list = t_ghost @ e_ghost in
        Interface.Err.msg "Ghost variable in assignment" $
                  sprintf "Ghost variables [%s] are present in the \
                           assignment:\n%s\n"
                           (String.concat ", "
                              (List.map Stm.term_to_str ghost_list))
                           (str);
        raise(Ghost_vars_in_assignment ghost_list)
      end


  let check_ghost_assignment_kind (t:Stm.term)
                                  (str:string) : unit =
    let t_normal = Stm.var_kind (E.RealVar) (Stm.Term t) in
    if (t_normal <> []) then
      begin
        Interface.Err.msg "No ghost variable in ghost assignment" $
                  sprintf "No ghost variables [%s] are assigned within the \
                           ghost assignment:\n%s\n"
                           (String.concat ", "
                              (List.map Stm.term_to_str t_normal))
                           (str);
        raise(Normal_vars_in_ghost_assignment t_normal)
      end


  let check_no_assigned (e:Stm.expr_t)
                        (l:Stm.expr_t list)
                        (st_str:string) : unit =
    if List.mem e l then
      begin
        Interface.Err.msg "Double assignment to term" $
          sprintf "The term [%s] is assigned twice within the following \
                   ghost code or atomic assignment:\n\n%s\n"
                  (Stm.expr_to_str e) st_str;
        raise(Atomic_double_assignment e)
      end


  let check_no_double_assignment (l1:Stm.expr_t list)
                                 (l2:Stm.expr_t list)
                                 (st_str:string): Stm.expr_t list =
    let rec find xs ys zs = match xs with
                              []   -> zs
                            | e::l -> let _ = check_no_assigned e ys st_str
                                      in
                                        find l ys (e::zs)
    in
      find l1 l2 l2


let unexpected_statement get_str_expr =
  let str_expr = (get_str_expr()) in
    Interface.Err.msg "Unexpected statement" $
      sprintf "Ghost and atomic statements admit only assignments or \
               conditional statements. However, the following statement \
               was found:\n\n%s\n" str_expr;
    raise(Unexpected_statement str_expr)


let check_var_belongs_to_procedure (v:E.V.id) (p_name:string) =
  let p_info = List.assoc p_name !procedures in
  let iVars = System.proc_info_get_input p_info in
  let lVars = System.proc_info_get_local p_info in
    if not (System.mem_var iVars v || System.mem_var lVars v) then
      begin
        Interface.Err.msg "Variable not declared in procedure" $
                sprintf "Variable \"%s\" does not belong to procedure %s"
                        v p_name;
        raise(Variable_not_in_procedure(v, p_name))
      end


let check_call_sort (t_opt:Stm.term option)
                    (t_proc_info:Sys.proc_info_t)
                    (p_name:string)
                    (proc_info:Sys.proc_info_t) : unit =
  let tlVars = Sys.proc_info_get_local t_proc_info in
  let tiVars = Sys.proc_info_get_input t_proc_info in
  let proc_sort = Sys.proc_info_get_sort proc_info in
  let find_sort x = get_sort_from_tables x tiVars tlVars in
  match (t_opt,proc_sort) with
  | (None  , None  ) -> ()
  | (None  , Some _) -> ()
  | (Some t, None  ) -> begin
                          let t_sort = find_sort t in
                          Interface.Err.msg "Incompatible call assignment" $
                            sprintf "Term %s of sort %s is assigned the value \
                                     returned by procedure %s. But %s returns \
                                     no value." (Stm.term_to_str t)
                                                (E.sort_to_str t_sort)
                                                (p_name) (p_name) ;
                          raise(Incompatible_call_sort(t, p_name))
                        end
  | (Some t, Some s) -> let t_sort = find_sort t in
                        if t_sort <> s then
                          begin
                            Interface.Err.msg "Incompatible call assignment" $
                              sprintf "Term %s is of sort %s, while procedure \
                                       %s returns a value of sort %s."
                                        (Stm.term_to_str t)
                                        (E.sort_to_str t_sort)
                                        (p_name)
                                        (E.sort_to_str s);
                            raise(Incompatible_call_sort(t, p_name))
                          end


let check_return_sort (t_opt:Stm.term option)
                      (p_name:string)
                      (proc_info:Sys.proc_info_t) : unit =
  let p_sort = Sys.proc_info_get_sort proc_info in
  match (t_opt,p_sort) with
  | (None  , None  ) -> ()
  | (None  , Some s) -> begin
                          Interface.Err.msg "Return value expected" $
                            sprintf "Procedure %s expects to return a value of \
                                     sort %s, but no value was returned."
                              (p_name) (E.sort_to_str s) ;
                          raise(Incompatible_return_sort p_name)
                        end
  | (Some t, None  ) -> begin
                          let iVars = Sys.proc_info_get_input proc_info in
                          let lVars = Sys.proc_info_get_local proc_info in
                          let t_sort = get_sort_from_tables t iVars lVars in
                          Interface.Err.msg "Return value unexpected" $
                            sprintf "Procedure %s returns term %s of sort %s, \
                                     but no sort was declared for such procedure."
                              p_name (Stm.term_to_str t) (E.sort_to_str t_sort);
                          raise(Incompatible_return_sort p_name)
                        end
  | (Some t, Some s) -> begin
                          let iVars = Sys.proc_info_get_input proc_info in
                          let lVars = Sys.proc_info_get_local proc_info in
                          let t_sort = get_sort_from_tables t iVars lVars in
                          if t_sort <> s then
                            begin
                              Interface.Err.msg "Return value incompatibility" $
                                sprintf "Procedure %s expects to return a \
                                         value of sort %s, but term %s of \
                                         sort %s is returned."
                                  p_name (E.sort_to_str s)
                                  (Stm.term_to_str t) (E.sort_to_str t_sort);
                              raise(Incompatible_return_sort p_name)
                            end
                        end


let global_decl_cond (k:E.var_nature)
                     (sort_name:string)
                     (v_name:E.V.id)
                     (op:cond_op_t)
                     (t:Stm.term) : unit =
  let s      = check_and_get_sort sort_name in
  let var    = Stm.build_var v_name s Stm.GlobalScope ~nature:k in
  let (op_symb_str, expr_cond) =
    match op with
      Less        -> ("<",  Stm.Less     (Stm.VarInt var,Stm.term_to_integer t))
    | Greater     -> (">",  Stm.Greater  (Stm.VarInt var,Stm.term_to_integer t))
    | LessEq      -> ("<=", Stm.LessEq   (Stm.VarInt var,Stm.term_to_integer t))
    | GreaterEq   -> (">=", Stm.GreaterEq(Stm.VarInt var,Stm.term_to_integer t))
    | In          -> ("in", Stm.In       (Stm.VarAddr var, Stm.term_to_set t))
    | SubsetEq    -> ("subseteq",    Stm.SubsetEq    (Stm.VarSet var,
                                                      Stm.term_to_set t))
    | InTh        -> ("inTh",        Stm.InTh        (Stm.VarTh var,
                                                      Stm.term_to_setth t))
    | SubsetEqTh  -> ("subseteqTh",  Stm.SubsetEqTh  (Stm.VarSetTh var,
                                                      Stm.term_to_setth t))
    | InInt       -> ("inInt",       Stm.InInt       (Stm.VarInt var,
                                                      Stm.term_to_setint t))
    | SubsetEqInt -> ("subseteqInt", Stm.SubsetEqInt (Stm.VarSetInt var,
                                                      Stm.term_to_setint t))
    | InElem      -> ("inElem",      Stm.InElem      (Stm.VarElem var,
                                                      Stm.term_to_setelem t))
    | SubsetEqElem-> ("subseteqElem",Stm.SubsetEqElem(Stm.VarSetElem var,
                                                      Stm.term_to_setelem t))
    | InPair      -> ("spin",        Stm.InPair      (Stm.VarPair var,
                                                      Stm.term_to_setpair t))
    | SubsetEqPair-> ("spsubseteq",  Stm.SubsetEqPair(Stm.VarSetPair var,
                                                      Stm.term_to_setpair t)) in



  let cond = Stm.boolean_to_expr_formula (Formula.atom_to_formula expr_cond) in
  let get_str_expr () = sprintf "%s %s %s %s" (E.sort_to_str s)
                                              (v_name)
                                              (op_symb_str)
                                              (Stm.term_to_str t) in
  let _    = decl_global_var v_name s (Some (E.Condition cond)) k
  in
    parser_check_compatibility_with_op_cond (Stm.VarT var) t get_str_expr op


let lock_pos_to_str (pos:Stm.integer option) : string =
  match pos with
  | None   -> ""
  | Some i -> sprintf "[%s]" (Stm.term_to_str (Stm.IntT i))


let fix_conditional_jumps () : unit =
  List.iter (fun n ->
    try
      let (_,stm) = Hashtbl.find pos_st n in
      match stm with
      | Stm.StIf(_,Stm.StSeq xs,else_stm,_,_) ->
          begin
            let jump_pos = match else_stm with
                           | None -> (Stm.get_st_info stm).Stm.else_pos
                           | Some ys -> (Stm.get_last_st_info ys).Stm.next_pos in
            let last_xs = lastElem xs in
            match last_xs with
            | Stm.StWhile _
            | Stm.StReturn _ -> ()
            | Stm.StIf (_,Stm.StSeq _,None,_,_) ->
                begin
                  (Stm.get_st_info last_xs).Stm.else_pos <- jump_pos
                end
            | Stm.StIf (_,Stm.StSeq xs,Some ys,_,_) ->
                begin
                  (match (lastElem xs) with
                   | Stm.StIf _ -> ()
                   | _ -> (Stm.get_st_info (lastElem xs)).Stm.next_pos <- jump_pos
                  );
                  (Stm.get_last_st_info ys).Stm.next_pos <- jump_pos
                end
            | _ -> begin
                    (Stm.get_st_info last_xs).Stm.next_pos <- jump_pos
                   end
          end
      | _ -> ()
    with Not_found -> ()
  ) !cond_stm_list




%}
%start system
%token ADDR2SET
%token APPEND
%token ARR
%token ARR_UPDATE
%token ASSIGN
%token ASSUME
%token AT
%token BARRAYUPD
%token BEGIN
%token BEND
%token BINIT
%token BREGION
%token BTID
%token CALL
%token CLOSE_BRACKET
%token CLOSE_PAREN
%token CLOSE_SET
%token COLON
%token COMMA
%token DATA
%token DOT
%token DOUBLECOLON
%token EMPTYSET
%token EMPTYSETELEM
%token EMPTYSETINT
%token EMPTYSETTH
%token END
%token EOF
%token EPSILON
%token EQUALS
%token ERROR
%token FIRSTLOCKED
%token GETP
%token GHOST
%token GHOST_DELIMITER
%token GLOBAL
%token HASHCODE
%token HASHTBL
%token HAVOCLEVEL
%token HAVOCLISTELEM
%token HAVOCSKIPLISTELEM
%token HIGHEST_ELEM
%token <string*int> IDENT
%token IN
%token INELEM
%token ININT
%token INTH
%token INTOF
%token INTR
%token INTRELEM
%token INTRINT
%token INTRTH
%token INVARIANT
%token LASTLOCKED
%token LOCK
%token LOCKID
%token LOGICAL_AND
%token LOGICAL_FALSE
%token LOGICAL_IFF
%token LOGICAL_NOT
%token LOGICAL_OR
%token LOGICAL_THEN
%token LOGICAL_TRUE
%token LOWEST_ELEM
%token MALLOC
%token MALLOCSL
%token MALLOCSLK
%token MARKED
%token MARK_F
%token MARK_T
%token MATH_DIV
%token MATH_GREATER
%token MATH_GREATER_EQ
%token MATH_LESS
%token MATH_LESS_EQ
%token MATH_MINUS
%token MATH_MOD
%token MATH_MULT
%token MATH_PLUS
%token ME
%token MEMORY_READ
%token MKBUCKET
%token MKCELL
%token NEXT
%token NEXTAT
%token NOT_EQUALS
%token NULL
%token <int> NUMBER
%token OPEN_BRACKET
%token OPEN_PAREN
%token OPEN_SET
%token ORDERLIST
%token PARAM
%token PATH2SET
%token POINTER
%token PROCEDURE
%token REACH
%token RETURN
%token SEMICOLON
%token SET2ELEM
%token SETDIFF
%token SETDIFFELEM
%token SETDIFFINT
%token SETDIFFTH
%token SETINTMAX
%token SETINTMIN
%token SETPAIRDIFF
%token SETPAIREMPTY
%token SETPAIRIN
%token SETPAIRINTR
%token SETPAIRMAX
%token SETPAIRMIN
%token SETPAIRSINGLE
%token SETPAIRSUBSETEQ
%token SETPAIRUNION
%token SHARP
%token SINGLEELEM
%token SINGLEINT
%token SINGLETH
%token SINGLE_PATH
%token SKIPLIST
%token ST_ASSERT
%token ST_AWAIT
%token ST_CHOICE
%token ST_CRITICAL
%token ST_DO
%token ST_ELSE
%token ST_ENDCHOICE
%token ST_ENDIF
%token ST_ENDWHILE
%token ST_IF
%token ST_NONCRITICAL
%token ST_OR
%token ST_SKIP
%token ST_THEN
%token ST_WHILE
%token SUBSETEQ
%token SUBSETEQELEM
%token SUBSETEQINT
%token SUBSETEQTH
%token THREAD
%token TIDOF
%token UNDERSCORE
%token UNION
%token UNIONELEM
%token UNIONINT
%token UNIONTH
%token UNLOCK
%token UPDATE
%token VERTICAL_BAR
%nonassoc EQUALS MATH_GREATER MATH_GREATER_EQ MATH_LESS MATH_LESS_EQ NOT_EQUALS
%nonassoc IDENT
%nonassoc ASSIGN
%right LOGICAL_AND
%right LOGICAL_OR
%right LOGICAL_THEN
%nonassoc LOGICAL_NOT
%left INTR SETDIFF UNION
%left INTRTH SETDIFFTH UNIONTH
%left INTRINT SETDIFFINT UNIONINT
%nonassoc IN SUBSETEQ
%nonassoc INTH SUBSETEQTH
%nonassoc ININT SUBSETEQINT
%nonassoc INELEM SUBSETEQELEM
%nonassoc GHOST_DELIMITER
%nonassoc CLOSE_BRACKET OPEN_BRACKET
%nonassoc CLOSE_PAREN OPEN_PAREN
%nonassoc VERTICAL_BAR
%left MATH_MINUS MATH_PLUS
%left MATH_DIV MATH_MOD MATH_MULT
%right MATH_NEG
%left DOT
%left POINTER
%type <Stm.addr> addr
%type <(E.V.id * E.sort)> arg
%type <(E.V.id * E.sort) list> arg_list
%type <(E.V.id * E.sort) list> args
%type <Stm.term> arraylookup
%type <Stm.term> arrayupd
%type <Stm.atom> atom
%type <Stm.expr_t list * Stm.statement_t> atomic_statement
%type <Stm.expr_t list * Stm.statement_t list> atomic_statement_list
%type <(Stm.expr_t list * Stm.statement_t) list> atomic_statements_choice
%type <Stm.expr_t list * Stm.statement_t option> atomic_statements_else_if
%type <Stm.bucket> bucket
%type <Stm.cell> cell
%type <int> choice_keyword
%type <Stm.diseq> disequals
%type <Stm.elem> elem
%type <Stm.eq> equals
%type <Statement.boolean> formula
%type <Stm.statement_t option> ghost_block
%type <Stm.statement_t option> ghost_block_or_nothing
%type <Stm.statement_t option> ghost_block_or_semicolon
%type <Stm.expr_t list * Stm.statement_t> ghost_statement
%type <Stm.expr_t list * Stm.statement_t list> ghost_statement_list
%type <(Stm.expr_t list * Stm.statement_t) list> ghost_statements_choice
%type <Stm.expr_t list * Stm.statement_t option> ghost_statements_else_if
%type <unit> global_decl
%type <unit> global_decl_list
%type <unit> global_declarations
%type <unit> if_ghost_atomic_keyword
%type <int> if_keyword
%type <Stm.boolean option> initial_assumption
%type <Stm.integer> integer
%type <E.var_nature> kind
%type <unit> local_decl
%type <unit> local_decl_list
%type <unit> local_declarations
%type <Stm.lock> lock
%type <Stm.integer option> lock_pos
%type <Stm.mark> mark
%type <Stm.term option> maybe_term
%type <Stm.mem> mem
%type <Stm.pair> pair
%type <Stm.term list> param_list
%type <Stm.term list> params
%type <Stm.path> path
%type <unit> procedure
%type <unit> procedure_list
%type <string> procedure_name
%type <E.sort option> procedure_sort
%type <Stm.statement_t option> program
%type <Stm.set> set
%type <Stm.setelem> setelem
%type <Stm.setint> setint
%type <Stm.setpair> setpair
%type <Stm.setth> setth
%type <Stm.statement_t> statement
%type <Stm.statement_t list> statement_list
%type <Stm.statement_t list> statements_choice
%type <Stm.statement_t option> statements_else_if
%type <(System.t * Expression.V.id list)> system
%type <Stm.term> term
%type <Stm.term list> term_list
%type <Stm.tid> tid
%type <int> while_keyword
%%

system:
  _1 = GLOBAL _2 = global_declarations _3 = initial_assumption _4 = procedure_list
    {    (
      (* ALE: Check if conditional jump positions is correct. *)
      fix_conditional_jumps();

      let proc_tbl    = System.new_proc_table_from_list !procedures in
      let assume_cond = _3 in
      (* Update pos_st hashtbl with information about calls and returns *)
      let _ = Hashtbl.iter (fun _ pc ->
                match Hashtbl.find pos_st pc with
                | (p, Stm.StCall (t,p_name, ps, g, Some info)) ->
                    let _ = check_is_procedure p_name in
                    let proc_info = Hashtbl.find proc_tbl p_name in
                    let _ = check_call_args proc_info p_name ps in
                    (* Check possible assigned variable sort and procedure sort *)
                    let t_proc_info = Hashtbl.find proc_tbl p in
                    let _ = check_call_sort t t_proc_info p_name proc_info in
                    let init_line = Sys.proc_init_line proc_info in
                    let _ = info.Stm.call_pos <- Some init_line in
                    Hashtbl.replace pos_st pc
                      (p, Stm.StCall (t,p_name,ps,g,Some info))
                | _ -> ()
              ) call_points in
      let _ = Hashtbl.iter (fun proc pc ->
                match Hashtbl.find pos_st pc with
                | (p,  Stm.StReturn (t, g, Some info)) ->
                    (* Check return type matches procedure type *)
                    let proc_info = Hashtbl.find proc_tbl p in
                    let _ = check_return_sort t p proc_info in
                    (* Update of return position *)
                    let ret_pos_list = Hashtbl.find_all call_points proc in
                    let (calls, rets) = List.fold_left (fun (cs,rs) pos ->
                                          let (_,st) = Hashtbl.find pos_st pos in
                                            (Stm.get_st_pos st :: cs,
                                             Stm.get_st_next_pos st :: rs)
                                        ) ([],[]) ret_pos_list in
                    let _ = info.Stm.called_from_pos <- calls in
                    let _ = info.Stm.return_pos <- rets in
                    Hashtbl.replace pos_st pc (p, Stm.StReturn (t,g,Some info))
                | _ -> ()
              ) return_points in
      let sys = System.new_system (System.copy_var_table globalVars)
                                  assume_cond
                                  proc_tbl
                                  transitions
                                  []
                                  (Hashtbl.copy pos_st)
                                  labelTbl in
      let _      = current_proc := "" in
      let ts     = !undefTids in
      let _      = undefTids := [] in
      let _      = cond_stm_list := [] in

      if System.is_proc sys Sys.defMainProcedure then
        (* Check whether the last statement in main is a return() *)
        let main_info = Sys.get_proc_by_name sys Sys.defMainProcedure in
        let lst_main = Sys.proc_last_line main_info in
        let (_,st) = Sys.get_statement_at sys lst_main in
        match st with
        | Stm.StReturn(None,_,Some info) ->
            let _ = info.Stm.return_pos <- [(Sys.get_trans_num sys)+1] in
            (sys, ts)
        | Stm.StReturn(Some t,_,_) ->
            begin
              let lVars = Sys.proc_info_get_local main_info in
              let iVars = Sys.proc_info_get_input main_info in
              let t_sort = get_sort_from_tables t iVars lVars in
              Interface.Err.msg "Main procedure returns value" $
                sprintf "Main procedure returns term %s os sort %s \
                         but no value was expected to be returned."
                        (Stm.term_to_str t)
                        (E.sort_to_str t_sort);
              raise(No_valid_main)
            end
        | _ -> begin
                 Interface.Err.msg ("No return at end of \"" ^
                                     Sys.defMainProcedure ^ "\" procedure") $
                   sprintf "The last statement at \"%s\" should be a return, \
                            but instead, statement\n\t %s\n was found."
                            (Sys.defMainProcedure)
                            (Stm.statement_to_str 0 st);
                 raise(No_valid_main)
               end
      else
        begin
          Interface.Err.msg ("No \"" ^ Sys.defMainProcedure ^ "\" \
                            procedure defined")
                  ("A \"" ^ Sys.defMainProcedure ^ "\" procedure could \
                   not be found in the system description.");
          raise(No_main)
        end
    )}

global_declarations:
  
    {    ( (decl_global_var Conf.heap_name E.Mem None E.RealVar) )}
| _1 = global_decl_list
    {    ( (decl_global_var Conf.heap_name E.Mem None E.RealVar) )}

global_decl_list:
  _1 = global_decl
    {    ( () )}
| _1 = global_decl _2 = global_decl_list
    {    ( () )}

global_decl:
  _1 = kind _2 = IDENT _3 = IDENT
    {    (
      let k      = _1 in
      let s      = check_and_get_sort (get_name _2) in
      let v_name = get_name _3 in

      decl_global_var v_name s None k
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = ASSIGN _5 = term
    {    (
      let k      = _1 in
      let s      = check_and_get_sort (get_name _2) in
      let v_name = get_name _3 in
      let t      = _5 in
      let v      = Stm.VarT(Stm.build_var v_name s Stm.GlobalScope ~nature:k) in
      let get_str_expr () = sprintf "%s %s := %s" (E.sort_to_str s)
                                                  (v_name)
                                                  (Stm.term_to_str t) in
      let _        = decl_global_var v_name s
                      (Some (E.Equality (Stm.term_to_expr_term t))) k
      in
        parser_check_compatibility v t get_str_expr
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = ASSIGN _5 = formula
    {    (
      let k      = _1 in
      let s      = check_and_get_sort (get_name _2) in
      let v_name = get_name _3 in
      let b      = Stm.boolean_to_expr_formula _5 in
      let get_str_expr () = sprintf "%s %s := %s" (E.sort_to_str s)
                                                  (v_name)
                                                  (E.formula_to_str b) in
      let cond = b in
      let _ = decl_global_var v_name s (Some (E.Condition cond)) k
      in
        parser_check_var_assign v_name s (E.Bool) get_str_expr
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = MATH_LESS _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) Less _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = MATH_GREATER _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) Greater _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = MATH_LESS_EQ _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) LessEq _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = MATH_GREATER_EQ _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) GreaterEq _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = IN _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) In _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = SUBSETEQ _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) SubsetEq _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = INTH _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) InTh _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = SUBSETEQTH _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) SubsetEqTh _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = ININT _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) InInt _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = SUBSETEQINT _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) SubsetEqInt _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = INELEM _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) InElem _5
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = SUBSETEQELEM _5 = term
    {    (
      global_decl_cond _1 (get_name _2) (get_name _3) SubsetEqElem _5
    )}
| _1 = kind _2 = IDENT _3 = SETPAIRIN _4 = OPEN_PAREN _5 = IDENT _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      global_decl_cond _1 (get_name _2) (get_name _5) InPair _7
    )}
| _1 = kind _2 = IDENT _3 = SETPAIRSUBSETEQ _4 = OPEN_PAREN _5 = IDENT _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      global_decl_cond _1 (get_name _2) (get_name _5) SubsetEqPair _7
    )}

initial_assumption:
  
    {    ( None )}
| _1 = ASSUME _2 = formula
    {    ( Some _2 )}

local_declarations:
  
    {    ( () )}
| _1 = local_decl_list
    {    ( () )}

local_decl_list:
  _1 = local_decl
    {    ( () )}
| _1 = local_decl _2 = local_decl_list
    {    ( () )}

local_decl:
  _1 = kind _2 = IDENT _3 = IDENT
    {    (
      let k      = _1 in
      let v_name = get_name _3 in
      let s      = check_and_get_sort (get_name _2) in
      decl_local_var v_name s None k
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = ASSIGN _5 = term
    {    (
      let conv_term = Stm.term_to_expr_term in
      let k      = _1 in
      let s      = check_and_get_sort (get_name _2) in
      let v_name = get_name _3 in
      let t      = _5 in
      let v      = Stm.VarT (Stm.build_var v_name s (Stm.Scope !current_proc) ~nature:k) in
      let get_str_expr () = sprintf "%s %s := %s" (E.sort_to_str s)
                                                  (v_name)
                                                  (Stm.term_to_str t) in
      let _ = decl_local_var v_name s (Some (E.Equality (conv_term t))) k
      in
        parser_check_compatibility v t get_str_expr
    )}
| _1 = kind _2 = IDENT _3 = IDENT _4 = ASSIGN _5 = formula
    {    (
      let k      = _1 in
      let s      = check_and_get_sort (get_name _2) in
      let v_name = get_name _3 in
      let b      = Stm.boolean_to_expr_formula _5 in
      let get_str_expr () = sprintf "%s %s := %s" (E.sort_to_str s)
                                                  (v_name)
                                                  (E.formula_to_str b) in
      let cond = b in
      let _ = decl_local_var v_name s (Some (E.Condition cond)) k
      in
        parser_check_var_assign v_name s (E.Bool) get_str_expr
    )}

kind:
  
    {    ( E.RealVar )}
| _1 = GHOST
    {    ( E.GhostVar )}

procedure_list:
  _1 = procedure
    {    ( () )}
| _1 = procedure _2 = procedure_list
    {    ( () )}

procedure:
  _1 = PROCEDURE _2 = procedure_name _3 = args _4 = procedure_sort _5 = local_declarations _6 = BEGIN _7 = program _8 = END
    {    (
      let proc_sort = _4 in
      let proc_name  = _2 in
      let args_signature = _3 in
      let proc_input = System.copy_var_table inputVars in
      let proc_local = System.copy_var_table localVars in
      let statements = _7 in
      let (firstLine, lastLine) =
        ( match statements with
            Some (Stm.StSeq xs) -> (Stm.get_fst_st_pos (List.hd xs),
                                    Stm.get_last_st_pos (lastElem xs))
          | _                   -> (0,0)
        ) in
      let proc_info = System.new_proc_info proc_sort
                                           proc_input
                                           proc_local
                                           args_signature
                                           firstLine
                                           lastLine
                                           statements
                                           in

      procedures := (proc_name, proc_info) :: !procedures;
      System.clear_table inputVars;
      System.clear_table localVars;
    )}

procedure_sort:
  
    {    ( None )}
| _1 = COLON _2 = IDENT
    {    (
      let s = check_and_get_sort (get_name _2) in
      Some s
    )}

procedure_name:
  _1 = IDENT
    {  (
    let p_name = get_name _1 in
    current_proc := p_name; p_name
  )}

args:
  _1 = OPEN_PAREN _2 = CLOSE_PAREN
    {    ( [] )}
| _1 = OPEN_PAREN _2 = arg_list _3 = CLOSE_PAREN
    {    ( _2 )}

arg_list:
  _1 = arg
    {    ( [_1] )}
| _1 = arg _2 = COMMA _3 = arg_list
    {    ( _1 :: _3 )}

arg:
  _1 = IDENT _2 = COLON _3 = IDENT
    {    (
      let v_name = get_name _1 in
      let s      = check_and_get_sort (get_name _3) in
      let _      = decl_input_var v_name s None
      in
        (v_name, s)
    )}

atomic_statement_list:
  _1 = atomic_statement
    {    (
      let (assign_list, code) = _1 in
      (assign_list, [code])
    )}
| _1 = atomic_statement _2 = atomic_statement_list
    {    (
      let (assign_body, code) = _1 in
      let (assign_list, code_list) = _2 in
      let st_list = code::code_list in
      let st_str = Stm.statement_to_str 1 (Stm.StSeq st_list) in
      let all_assign = check_no_double_assignment assign_body assign_list st_str
      in
        (all_assign, st_list)
    )}

atomic_statement:
  _1 = ST_SKIP _2 = SEMICOLON
    {    (
      ([], Stm.StSkip (None, None))
    )}
| _1 = ST_ASSERT _2 = formula _3 = SEMICOLON
    {    (
      let cond = _2 in
      let get_str_expr () = sprintf "assert %s" (Stm.boolean_to_str cond) in
      unexpected_statement get_str_expr
    )}
| _1 = ST_AWAIT _2 = formula _3 = SEMICOLON
    {    (
      let cond = _2 in
      ([], Stm.StAwait (cond, None, None))
    )}
| _1 = ST_NONCRITICAL _2 = SEMICOLON
    {    (

      let get_str_expr () = sprintf "noncritical" in
      unexpected_statement get_str_expr
    )}
| _1 = ST_CRITICAL _2 = SEMICOLON
    {    (
      let get_str_expr () = sprintf "critical" in
      unexpected_statement get_str_expr
    )}
| _1 = term _2 = ASSIGN _3 = term _4 = SEMICOLON
    {    (
      let t1 = _1 in
      let t2 = _3 in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str t1)
                                              (Stm.term_to_str t2) in

      let _ = parser_check_compatibility t1 t2 get_str_expr in
      let _ = check_assignment_term t1 get_str_expr in
      let _ = check_assignment_kind t1 (Stm.Term t2) (get_str_expr()) in

      ([Stm.Term t1], Stm.StAssign (t1, Stm.Term t2, None, None))
    )}
| _1 = IDENT _2 = ASSIGN _3 = term _4 = SEMICOLON
    {    (
      let v = get_name _1 in
      let t = _3 in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = inject_sort (Stm.construct_var_from_sort
                               v p_name (E.Unknown) k) in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.term_to_str t) in
      let _ = parser_check_compatibility var t get_str_expr in
      let _   = check_assignment_kind var (Stm.Term t) (get_str_expr())in

      ([Stm.Term var], Stm.StAssign (var, Stm.Term t, None, None))
    )}
| _1 = IDENT _2 = ASSIGN _3 = formula _4 = SEMICOLON
    {    (
      let v = get_name _1 in
      let b = _3 in
      let _ = check_sort_var v (Stm.Scope !current_proc) E.Bool in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = Stm.construct_var_from_sort v p_name E.Bool k in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.boolean_to_str b) in
      let _   = check_assignment_kind var (Stm.Formula b) (get_str_expr()) in
      ([Stm.Term var], Stm.StAssign (var, Stm.Formula b, None, None))
    )}
| _1 = if_ghost_atomic_keyword _2 = formula _3 = ST_THEN _4 = atomic_statement_list _5 = atomic_statements_else_if _6 = ST_ENDIF
    {    (
      let cond = _2 in
      let (then_assign, then_st) = _4 in
      let (else_assign, else_st) = _5 in
      let st = Stm.StIf (cond, Stm.StSeq then_st, else_st, None, None) in
      (* Check no repetition between then_assign and else_assign *)
      let all_assign =
        (* check_no_double_assignment then_assign else_assign st_str *)
        then_assign @ else_assign
      in
        (all_assign, st)
    )}
| _1 = while_keyword _2 = formula _3 = ST_DO _4 = atomic_statement_list _5 = ST_ENDWHILE
    {    (
      let cond = Stm.boolean_to_expr_formula _2 in
      let (_, body_code) = _4 in
      let body = Stm.StSeq body_code in
      let get_str_expr () = sprintf "while (%s) do \n%s\n endwhile"
                                    (E.formula_to_str cond)
                                    (Stm.statement_to_str 1 body)
      in

      unexpected_statement get_str_expr
    )}
| _1 = choice_keyword _2 = atomic_statements_choice _3 = ST_ENDCHOICE
    {    (
      let (_, choice_list) = List.split _2 in
      (* ALE: Eliminate also duplicated variables
         let assign_list = List.flatten assign_lists in *)
      let get_str_expr () = sprintf "choice \n%s\n endchoice"
                              (String.concat " _or_ " $
                                List.map (Stm.statement_to_str 1) choice_list)
      in
      unexpected_statement get_str_expr
    )}

atomic_statements_else_if:
  
    {    ( ([], None) )}
| _1 = ST_ELSE _2 = atomic_statement_list
    {    (
      let (assign_list, body_code) = _2 in
      (assign_list, Some (Stm.StSeq body_code))
    )}

atomic_statements_choice:
  _1 = atomic_statement_list
    {    (
      let (assign_list, body_code) = _1 in
      [(assign_list, Stm.StSeq body_code)]
    )}
| _1 = atomic_statement_list _2 = ST_OR _3 = atomic_statements_choice
    {    (
      let (assign_list, body_code) = _1 in
      (assign_list, Stm.StSeq body_code) :: _3
    )}

ghost_block_or_semicolon:
  _1 = SEMICOLON
    {    ( None )}
| _1 = ghost_block
    {    ( _1 )}

ghost_block_or_nothing:
  
    {    ( None )}
| _1 = ghost_block
    {    ( _1 )}

ghost_block:
  _1 = GHOST_DELIMITER _2 = GHOST_DELIMITER
    {    ( None )}
| _1 = GHOST_DELIMITER _2 = ghost_statement_list _3 = GHOST_DELIMITER
    {    (
      let (_, st_list) = _2 in
      Some (Stm.StSeq st_list)
    )}

ghost_statement_list:
  _1 = ghost_statement
    {    (
      let (assign_list, code) = _1 in
      (assign_list, [code])
    )}
| _1 = ghost_statement _2 = ghost_statement_list
    {    (
      let (assign_body, code) = _1 in
      let (assign_list, code_list) = _2 in
      let st_list = code::code_list in
      let st_str = Stm.statement_to_str 1 (Stm.StSeq st_list) in
      let all_assign = check_no_double_assignment assign_body assign_list st_str
      in
        (all_assign, st_list)
    )}

ghost_statement:
  _1 = ST_SKIP _2 = SEMICOLON
    {    (
      ([], Stm.StSkip (None, None))
    )}
| _1 = ST_ASSERT _2 = formula _3 = SEMICOLON
    {    (
      let cond = Stm.boolean_to_expr_formula _2 in
      let get_str_expr () = sprintf "assert %s" (E.formula_to_str cond) in
      unexpected_statement get_str_expr
    )}
| _1 = ST_AWAIT _2 = formula _3 = SEMICOLON
    {    (
      let cond = Stm.boolean_to_expr_formula _2 in
      let get_str_expr () = sprintf "await %s" (E.formula_to_str cond) in
      unexpected_statement get_str_expr
    )}
| _1 = ST_NONCRITICAL _2 = SEMICOLON
    {    (
      let get_str_expr () = sprintf "noncritical" in
      unexpected_statement get_str_expr
    )}
| _1 = ST_CRITICAL _2 = SEMICOLON
    {    (
      let get_str_expr () = sprintf "critical" in
      unexpected_statement get_str_expr
    )}
| _1 = term _2 = ASSIGN _3 = term _4 = SEMICOLON
    {    (
      let t1 = _1 in
      let t2 = _3 in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str t1)
                                              (Stm.term_to_str t2) in

      let _ = parser_check_compatibility t1 t2 get_str_expr in
      let _ = check_assignment_term t1 get_str_expr in
      let _ = check_ghost_assignment_kind t1 (get_str_expr()) in

      ([Stm.Term t1], Stm.StAssign (t1, Stm.Term t2, None, None))
    )}
| _1 = IDENT _2 = ASSIGN _3 = term _4 = SEMICOLON
    {    (
      let v = get_name _1 in
      let t = _3 in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = inject_sort (Stm.construct_var_from_sort
                               v p_name (E.Unknown) k) in

      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.term_to_str t) in

      let _ = parser_check_compatibility var t get_str_expr in
      let _ = check_ghost_assignment_kind var (get_str_expr())in

      ([Stm.Term var], Stm.StAssign (var, Stm.Term t, None, None))
    )}
| _1 = IDENT _2 = ASSIGN _3 = formula _4 = SEMICOLON
    {    (
      let v = get_name _1 in
      let b = _3 in
      let _ = check_sort_var v (Stm.Scope !current_proc) E.Bool in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = Stm.construct_var_from_sort v p_name E.Bool k in

      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.boolean_to_str b) in
      let _   = check_ghost_assignment_kind var (get_str_expr()) in
      ([Stm.Term var], Stm.StAssign (var, Stm.Formula b, None, None))
    )}
| _1 = if_ghost_atomic_keyword _2 = formula _3 = ST_THEN _4 = ghost_statement_list _5 = ghost_statements_else_if _6 = ST_ENDIF
    {    (
      let cond = _2 in
      let (then_assign, then_st) = _4 in
      let (else_assign, else_st) = _5 in
      let st = Stm.StIf (cond, Stm.StSeq then_st, else_st, None, None) in
      (* No need to search for repeated assignments between both branches
         of an IF statement *)
      let all_assign =
        (* check_no_double_assignment then_assign else_assign st_str *)
        then_assign @ else_assign
      in
        (all_assign, st)
    )}
| _1 = while_keyword _2 = formula _3 = ST_DO _4 = ghost_statement_list _5 = ST_ENDWHILE
    {    (
      let cond = Stm.boolean_to_expr_formula _2 in
      let (_, body_code) = _4 in
      let body = Stm.StSeq body_code in
      let get_str_expr () = sprintf "while (%s) do \n%s\n endwhile"
                                    (E.formula_to_str cond)
                                    (Stm.statement_to_str 1 body)
      in
      unexpected_statement get_str_expr
    )}
| _1 = choice_keyword _2 = ghost_statements_choice _3 = ST_ENDCHOICE
    {    (
      let (_, choice_list) = List.split _2 in
      (* ALE: Eliminates duplicated variables.
         let assign_list = List.flatten assign_lists in *)
      let get_str_expr () = sprintf "choice \n%s\n endchoice"
                              (String.concat " _or_ " $
                                List.map (Stm.statement_to_str 1) choice_list)
      in
      unexpected_statement get_str_expr
    )}

ghost_statements_else_if:
  
    {    ( ([], None) )}
| _1 = ST_ELSE _2 = ghost_statement_list
    {    (
      let (assign_list, body_code) = _2 in
      (assign_list, Some (Stm.StSeq body_code))
    )}

ghost_statements_choice:
  _1 = ghost_statement_list
    {    (
      let (assign_list, body_code) = _1 in
      [(assign_list, Stm.StSeq body_code)]
    )}
| _1 = ghost_statement_list _2 = ST_OR _3 = ghost_statements_choice
    {    (
      let (assign_list, body_code) = _1 in
      (assign_list, Stm.StSeq body_code) :: _3
    )}

program:
  
    {    ( None )}
| _1 = statement_list
    {    ( Some (Stm.StSeq _1) )}

line_label_list:
  
    {    ( () )}
| _1 = line_label _2 = line_label_list
    {    ( () )}

line_label:
  _1 = COLON _2 = IDENT
    {    (
      let label_name = get_name _2 in
        System.add_single_label labelTbl label_name !pos
    )}
| _1 = COLON _2 = IDENT _3 = OPEN_BRACKET
    {    (
      let label_name = get_name _2 in
        System.add_open_label labelTbl label_name !pos
    )}
| _1 = COLON _2 = IDENT _3 = CLOSE_BRACKET
    {    (
      let label_name = get_name _2 in
        System.add_close_label labelTbl label_name (!pos-1)
    )}

if_keyword:
  _1 = line_label_list _2 = ST_IF
    {    ( pos := !pos+1; !pos-1 )}

if_ghost_atomic_keyword:
  _1 = line_label_list _2 = ST_IF
    {    ( )}

while_keyword:
  _1 = line_label_list _2 = ST_WHILE
    {    ( pos := !pos+1; !pos-1 )}

choice_keyword:
  _1 = line_label_list _2 = ST_CHOICE
    {    ( pos := !pos+1; !pos-1 )}

statement_list:
  _1 = statement _2 = line_label_list
    {    ( [_1] )}
| _1 = statement _2 = statement_list
    {    ( (_1 :: _2) )}

statement:
  _1 = line_label_list _2 = ST_SKIP _3 = ghost_block_or_semicolon
    {    (
      let g_code  = _3 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StSkip (g_code, Some st_info) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = ST_ASSERT _3 = formula _4 = ghost_block_or_semicolon
    {    (
      let cond    = _3 in
      let g_code  = _4 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StAssert (cond, g_code, Some st_info) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = ST_AWAIT _3 = formula _4 = ghost_block_or_semicolon
    {    (
      let cond    = _3 in
      let g_code  = _4 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StAwait (cond, g_code, Some st_info) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = ST_NONCRITICAL _3 = ghost_block_or_semicolon
    {    (
      let g_code  = _3 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StNonCrit (g_code, Some st_info) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = ST_CRITICAL _3 = ghost_block_or_semicolon
    {    (
      let g_code  = _3 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StCrit (g_code, Some st_info) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = term _3 = ASSIGN _4 = term _5 = ghost_block_or_semicolon
    {    (
      let t1 = _2 in
      let t2 = _4 in
      let g_code = _5 in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str t1)
                                              (Stm.term_to_str t2) in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StAssign (t1, Stm.Term t2, g_code, Some st_info) in

      let _ = parser_check_compatibility t1 t2 get_str_expr in
      let _ = check_assignment_term t1 get_str_expr in
      let _ = check_assignment_kind t1 (Stm.Term t2) (get_str_expr()) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = IDENT _3 = ASSIGN _4 = term _5 = ghost_block_or_semicolon
    {    (
      let v = get_name _2 in
      let t = _4 in
      let g_code = _5 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = inject_sort (Stm.construct_var_from_sort
                              v p_name (E.Unknown) k) in
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.term_to_str t) in

      let _ = parser_check_compatibility var t get_str_expr in

      let st = Stm.StAssign (var, Stm.Term t, g_code, Some st_info) in

      let _ = check_assignment_kind var (Stm.Term t) (get_str_expr()) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = IDENT _3 = ASSIGN _4 = formula _5 = ghost_block_or_semicolon
    {    (
      let v = get_name _2 in
      let b = _4 in
      let g_code = _5 in
      let _ = check_sort_var v (Stm.Scope !current_proc) E.Bool in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in

      let k = get_var_kind v in
      let var = Stm.construct_var_from_sort v p_name E.Bool k in

      let st = Stm.StAssign (var, Stm.Formula b, g_code, Some st_info) in

      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str var)
                                              (Stm.boolean_to_str b) in
      let _ = check_assignment_kind var (Stm.Formula b) (get_str_expr()) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = term _3 = ASSIGN _4 = CALL _5 = IDENT _6 = OPEN_PAREN _7 = params _8 = CLOSE_PAREN _9 = ghost_block_or_semicolon
    {    (
      let t = _2 in
      let proc_name = get_name _5 in
      let ps = _7 in
      let g_code = _9 in
      let get_str_expr () = sprintf "%s = %s(%s)"
                              (Stm.term_to_str t)
                              (proc_name)
                              (String.concat "," $ List.map Stm.term_to_str ps) in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = 0;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let _ = Hashtbl.add call_points proc_name !pos in
      let st = Stm.StCall (Some t, proc_name, ps, g_code, Some st_info) in

      let _ = check_assignment_term t get_str_expr in
      let _ = check_assignment_kind t (Stm.Term t) (get_str_expr()) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos + 1;
      st
    )}
| _1 = line_label_list _2 = IDENT _3 = ASSIGN _4 = CALL _5 = IDENT _6 = OPEN_PAREN _7 = params _8 = CLOSE_PAREN _9 = ghost_block_or_semicolon
    {    (
      let v = get_name _2 in
      let proc_name = get_name _5 in
      let ps = _7 in
      let g_code = _9 in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = 0;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in

      let p_name = if System.mem_var localVars v ||
                      System.mem_var inputVars v then
                        Stm.Scope !current_proc
                   else
                        Stm.GlobalScope in
      let k = get_var_kind v in
      let var = inject_sort (Stm.construct_var_from_sort
                              v p_name (E.Unknown) k) in
      let get_str_expr () = sprintf "%s = %s(%s)"
                              (Stm.term_to_str var)
                              (proc_name)
                              (String.concat "," $ List.map Stm.term_to_str ps) in
      let _ = Hashtbl.add call_points proc_name !pos in
      let st = Stm.StCall (Some var, proc_name, ps, g_code, Some st_info) in
      let _ = check_assignment_kind var (Stm.Term var) (get_str_expr()) in

      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos + 1;
      st
    )}
| _1 = line_label_list _2 = term _3 = POINTER _4 = LOCK _5 = lock_pos _6 = ghost_block_or_semicolon
    {    (
      let get_str_expr () = sprintf "%s->lock%s" (Stm.term_to_str _2) (lock_pos_to_str _5) in
      let a = parser_check_type check_type_addr _2 E.Addr get_str_expr in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      (* ALE: I'm not verifying whether I am working with a non ghost address *)
      let g_code = _6 in
      let st = Stm.StUnit ((match _5 with
                           | None   -> Stm.UnitLock a
                           | Some i -> Stm.UnitLockAt (a,i)
                           ), g_code, Some st_info) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = line_label_list _2 = term _3 = POINTER _4 = UNLOCK _5 = lock_pos _6 = ghost_block_or_semicolon
    {    (
      let get_str_expr () = sprintf "%s->unlock%s" (Stm.term_to_str _2) (lock_pos_to_str _5) in
      let a = parser_check_type check_type_addr _2 E.Addr get_str_expr in
      let st_info = { Stm.pos             = !pos;
                      Stm.next_pos        = !pos+1;
                      Stm.else_pos        = !pos+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      (* ALE: I'm not verifying whether I am working with a non ghost address *)
      let g_code = _6 in
      let st = Stm.StUnit ((match _5 with
                            | None   -> Stm.UnitUnlock a
                            | Some i -> Stm.UnitUnlockAt (a,i)
                            ), g_code, Some st_info) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos+1;
      st
    )}
| _1 = if_keyword _2 = formula _3 = ST_THEN _4 = statement_list _5 = statements_else_if _6 = ST_ENDIF _7 = ghost_block_or_nothing
    {    (
      let n       = _1 in
      let cond    = _2 in
      let then_st = _4 in
      let else_st = _5 in
      let g_code  = _7 in

      let (next_p, else_p) =
        match (then_st, else_st) with
        | ([], None) -> (n+1, n+1)
        | ([], Some ys) -> (Stm.get_last_st_pos ys + 1, Stm.get_fst_st_pos ys)
        | (xs, None) -> begin
                          let last_xs = lastElem xs in
                          cond_stm_list := n :: (!cond_stm_list);
                          (n+1, (Stm.get_last_st_info last_xs).Stm.else_pos);
                        end
        | (xs, Some ys) -> begin
                             let last_xs = lastElem xs in
                             cond_stm_list := n :: (!cond_stm_list);
                             (match last_xs with
                              | Stm.StIf (_,_,Some _,_,_) -> ()
                              | _ -> (Stm.get_st_info last_xs).Stm.else_pos <-
                                        (Stm.get_last_st_info ys).Stm.next_pos);
                             (n+1, Stm.get_fst_st_pos ys)
                           end in

      let st_info = { Stm.pos             = n;
                      Stm.next_pos        = next_p;
                      Stm.else_pos        = else_p;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in

      let st = Stm.StIf (cond, Stm.StSeq then_st, else_st, g_code, Some st_info) in

      Hashtbl.replace pos_st n (!current_proc, st);
      st
    )}
| _1 = while_keyword _2 = formula _3 = ST_DO _4 = statement_list _5 = ST_ENDWHILE
    {    (
      let n = _1 in
      let cond = _2 in
      let body = Stm.StSeq _4 in
      let end_p = (match _4 with
                     [] -> n+1
                   | xs -> Stm.get_last_st_pos (lastElem xs) + 1
                  ) in
      (* Update jump position for last statement in the body *)
      let _ = match _4 with
                [] -> ()
              | xs -> let lst = lastElem xs in
                      let zs = match lst with
                               | Stm.StSelect (ys,_,_) -> ys
                               | Stm.StIf (_,t,e,_,info) ->
                                  begin
                                    match e with
                                    | Some s -> [t;s]
                                    | None   -> begin
                                                  (match info with
                                                   | None -> ()
                                                   | Some i -> i.Stm.else_pos <- n);
                                                  [t]
                                                end
                                  end
                               | _ -> [lst]
                      in
                        List.iter (fun st ->
                          (Stm.get_last_st_info st).Stm.next_pos <- n
                        ) zs in
      let st_info = { Stm.pos             = n;
                      Stm.next_pos        = n+1;
                      Stm.else_pos        = end_p;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = [];
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StWhile (cond, body, None, Some st_info) in

      Hashtbl.replace pos_st n (!current_proc, st);
      st
    )}
| _1 = choice_keyword _2 = statements_choice _3 = ST_ENDCHOICE
    {    (
      let n = _1 in
      let opt = _2 in
      let end_p = Stm.get_last_st_pos (lastElem opt) + 1 in
      let opt_p = List.map Stm.get_fst_st_pos opt in
      let st_info = { Stm.pos             = n;
                      Stm.next_pos        = n+1;
                      Stm.else_pos        = n+1;
                      Stm.call_pos        = None;
                      Stm.opt_pos         = opt_p;
                      Stm.called_from_pos = [];
                      Stm.return_pos      = []; } in
      let st = Stm.StSelect (opt, None, Some st_info) in

      List.iter (fun x ->
                  (Stm.get_last_st_info x).Stm.next_pos <- end_p) opt;
      Hashtbl.replace pos_st n (!current_proc, st);
      st
    )}
| _1 = line_label_list _2 = OPEN_SET _3 = atomic_statement_list _4 = CLOSE_SET _5 = ghost_block_or_nothing
    {    (
      let (_, st_list) = _3 in
      let g_code       = _5 in
      let st_info      = { Stm.pos              = !pos;
                           Stm.next_pos         = !pos+1;
                           Stm.else_pos         = !pos+1;
                           Stm.call_pos         = None;
                           Stm.opt_pos          = [];
                           Stm.called_from_pos  = [];
                           Stm.return_pos       = []; } in
      let st           = Stm.StAtomic (st_list, g_code, Some st_info) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos + 1;
      st
    )}
| _1 = line_label_list _2 = CALL _3 = IDENT _4 = OPEN_PAREN _5 = params _6 = CLOSE_PAREN _7 = ghost_block_or_semicolon
    {    (
      let proc_name = get_name _3 in
      let ps = _5 in
      let g_code = _7 in
      let st_info = {Stm.pos              = !pos;
                     Stm.next_pos         = !pos+1;
                     Stm.else_pos         = 0;
                     Stm.call_pos         = None;
                     Stm.opt_pos          = [];
                     Stm.called_from_pos  = [];
                     Stm.return_pos       = []; } in
      let _ = Hashtbl.add call_points proc_name !pos in
      let st = Stm.StCall (None, proc_name, ps, g_code, Some st_info) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos + 1;
      st
    )}
| _1 = line_label_list _2 = RETURN _3 = OPEN_PAREN _4 = maybe_term _5 = CLOSE_PAREN _6 = ghost_block_or_semicolon
    {    (
      let t = _4 in
      let g_code = _6 in
      let st_info = {Stm.pos              = !pos;
                     Stm.next_pos         = 0;
                     Stm.else_pos         = !pos+1;
                     Stm.call_pos         = None;
                     Stm.opt_pos          = [];
                     Stm.called_from_pos  = [];
                     Stm.return_pos       = []; } in
      let _ = Hashtbl.add return_points !current_proc !pos in
      let st = Stm.StReturn (t, g_code, Some st_info) in
      Hashtbl.replace pos_st !pos (!current_proc, st);
      pos := !pos + 1;
      st
    )}

lock_pos:
  
    {    ( None )}
| _1 = OPEN_BRACKET _2 = term _3 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "[%s]" (Stm.term_to_str _2) in
      let i = parser_check_type check_type_int _2 E.Int get_str_expr in
        Some i
    )}

maybe_term:
  
    {    ( None )}
| _1 = term
    {    ( Some _1 )}

term_list:
  _1 = term _2 = COMMA _3 = term
    {    ( [_1;_3] )}
| _1 = term _2 = COMMA _3 = term_list
    {    ( _1 :: _3 )}

params:
  
    {    ( [] )}
| _1 = param_list
    {    ( _1 )}

param_list:
  _1 = term
    {    ( [_1] )}
| _1 = term _2 = COMMA _3 = param_list
    {    ( _1 :: _3 )}

statements_else_if:
  
    {    ( None )}
| _1 = ST_ELSE _2 = statement_list
    {    ( Some (Stm.StSeq _2) )}

statements_choice:
  _1 = statement_list
    {    ( [Stm.StSeq _1] )}
| _1 = statement_list _2 = ST_OR _3 = statements_choice
    {    ( ((Stm.StSeq _1) :: _3) )}

formula:
  _1 = OPEN_PAREN _2 = formula _3 = CLOSE_PAREN
    {      ( _2 )}
| _1 = atom
    {      ( F.atom_to_formula _1 )}
| _1 = LOGICAL_TRUE
    {      ( F.True )}
| _1 = LOGICAL_FALSE
    {      ( F.False )}
| _1 = LOGICAL_NOT _2 = formula
    {      ( F.Not _2 )}
| _1 = formula _2 = LOGICAL_AND _3 = formula
    {      ( F.And (_1, _3) )}
| _1 = formula _2 = LOGICAL_OR _3 = formula
    {      ( F.Or (_1, _3) )}
| _1 = formula _2 = LOGICAL_THEN _3 = formula
    {      ( F.Implies (_1, _3) )}
| _1 = formula _2 = EQUALS _3 = formula
    {      ( F.Iff (_1, _3) )}
| _1 = OPEN_PAREN _2 = IDENT _3 = CLOSE_PAREN
    {      (
        let v        = get_name _2 in
        let is_input = System.mem_var inputVars v in
        let is_local = System.mem_var localVars v in
        let k        = get_var_kind v in

        if is_input || is_local then
          let c_proc = if !current_proc <> "" then
                         Stm.Scope !current_proc
                       else
                         Stm.GlobalScope
          in
            F.atom_to_formula (Stm.BoolVar (Stm.build_var v E.Bool c_proc ~nature:k))
        else
            F.atom_to_formula (Stm.BoolVar (Stm.build_var v E.Bool Stm.GlobalScope ~nature:k))
      )}

atom:
  _1 = APPEND _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "append(%s,%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5)
                                                       (Stm.term_to_str _7) in
      let p1   = parser_check_type check_type_path _3 E.Path get_str_expr in
      let p2   = parser_check_type check_type_path _5 E.Path get_str_expr in
      let pres = parser_check_type check_type_path _7 E.Path get_str_expr in
        Stm.Append (p1,p2,pres)
    )}
| _1 = REACH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "reach(%s,%s,%s,%s)" (Stm.term_to_str _3)
                                                         (Stm.term_to_str _5)
                                                         (Stm.term_to_str _7)
                                                         (Stm.term_to_str _9) in
      let h      = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a_from = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr _7 E.Addr get_str_expr in
      let p      = parser_check_type check_type_path _9 E.Path get_str_expr in
        Stm.Reach (h,a_from,a_to,p)
    )}
| _1 = ORDERLIST _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "orderlist(%s,%s,%s)" (Stm.term_to_str _3)
                                                          (Stm.term_to_str _5)
                                                          (Stm.term_to_str _7) in
      let h      = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a_from = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr _7 E.Addr get_str_expr in
        Stm.OrderList (h,a_from,a_to)
    )}
| _1 = SKIPLIST _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = COMMA _11 = term _12 = COMMA _13 = term _14 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "skiplist(%s,%s,%s,%s,%s)"
                                        (Stm.term_to_str _3)
                                        (Stm.term_to_str _5)
                                        (Stm.term_to_str _7)
                                        (Stm.term_to_str _9)
                                        (Stm.term_to_str _11) in
      let h      = parser_check_type check_type_mem      _3 E.Mem get_str_expr in
      let s      = parser_check_type check_type_set      _5 E.Set get_str_expr in
      let l      = parser_check_type check_type_int      _7 E.Int get_str_expr in
      let a_from = parser_check_type check_type_addr     _9 E.Addr get_str_expr in
      let a_to   = parser_check_type check_type_addr    _11 E.Addr get_str_expr in
      let elems  = parser_check_type check_type_setelem _13 E.SetElem get_str_expr in
        Stm.Skiplist (h,s,l,a_from,a_to,elems)
    )}
| _1 = IN _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "in(%s,%s)" (Stm.term_to_str _3)
                                                (Stm.term_to_str _5) in
      let a = parser_check_type check_type_addr _3 E.Addr get_str_expr in
      let r = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Stm.In (a,r)
    )}
| _1 = SUBSETEQ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "subseteq(%s,%s)" (Stm.term_to_str _3)
                                                      (Stm.term_to_str _5) in
      let s = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let r = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Stm.SubsetEq(s,r)
    )}
| _1 = INTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tin(%s, %s" (Stm.term_to_str _3)
                                                 (Stm.term_to_str _5) in
      let th = parser_check_type check_type_tid  _3 E.Tid get_str_expr in
      let s  = parser_check_type check_type_setth _5 E.SetTh get_str_expr in
        Stm.InTh (th,s)
    )}
| _1 = SUBSETEQTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tsubseteq(%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5) in
      let r = parser_check_type check_type_setth _3 E.SetTh get_str_expr in
      let s = parser_check_type check_type_setth _5 E.SetTh get_str_expr in
        Stm.SubsetEqTh(r,s)
    )}
| _1 = ININT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "iin(%s,%s)" (Stm.term_to_str _3)
                                                 (Stm.term_to_str _5) in
      let i = parser_check_type check_type_int _3 E.Int get_str_expr in
      let s = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Stm.InInt (i,s)
    )}
| _1 = SUBSETEQINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "isubseteq(%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5) in
      let r = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Stm.SubsetEqInt(r,s)
    )}
| _1 = INELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "ein(%s,%s)" (Stm.term_to_str _3)
                                                 (Stm.term_to_str _5) in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let s = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Stm.InElem (e,s)
    )}
| _1 = SUBSETEQELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "esubseteq(%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5) in
      let r = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Stm.SubsetEqElem(r,s)
    )}
| _1 = SETPAIRIN _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spin(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Stm.InPair (p,s)
    )}
| _1 = SETPAIRSUBSETEQ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spsubseteq(%s,%s)" (Stm.term_to_str _3)
                                                        (Stm.term_to_str _5) in
      let r = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
      let s = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Stm.SubsetEqPair(r,s)
    )}
| _1 = HASHTBL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = COMMA _11 = term _12 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "hashtbl(%s,%s,%s,%s,%s)"
                                        (Stm.term_to_str _3)
                                        (Stm.term_to_str _5)
                                        (Stm.term_to_str _7)
                                        (Stm.term_to_str _9)
                                        (Stm.term_to_str _11) in
      let h  = parser_check_type check_type_mem        _3 E.Mem get_str_expr in
      let s  = parser_check_type check_type_set        _5 E.Set get_str_expr in
      let se = parser_check_type check_type_setelem    _7 E.SetElem get_str_expr in
      let bb = parser_check_type check_type_bucketarr  _9 E.BucketArray get_str_expr in
      let i  = parser_check_type check_type_int       _11 E.Int get_str_expr in
        Stm.Hashtbl (h,s,se,bb,i)
    )}
| _1 = term _2 = MATH_LESS _3 = term
    {    (
      let get_str_expr () = sprintf "%s < %s" (Stm.term_to_str _1)
                                              (Stm.term_to_str _3) in
      try
        let e1 = parser_check_type check_type_elem _1 E.Elem get_str_expr in
        let e2 = parser_check_type check_type_elem _3 E.Elem get_str_expr in
          Stm.LessElem (e1, e2)
      with
        _ -> let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
             let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
               Stm.Less (i1, i2)
    )}
| _1 = term _2 = MATH_GREATER _3 = term
    {    (
      let get_str_expr () = sprintf "%s > %s" (Stm.term_to_str _1)
                                              (Stm.term_to_str _3) in
      try
        let e1 = parser_check_type check_type_elem _1 E.Elem get_str_expr in
        let e2 = parser_check_type check_type_elem _3 E.Elem get_str_expr in
          Stm.GreaterElem (e1, e2)
      with
        _ -> let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
             let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
               Stm.Greater (i1, i2)
    )}
| _1 = term _2 = MATH_LESS_EQ _3 = term
    {    (
      let get_str_expr () = sprintf "%s <= %s" (Stm.term_to_str _1)
                                               (Stm.term_to_str _3) in
      let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.LessEq (i1, i2)
    )}
| _1 = term _2 = MATH_GREATER_EQ _3 = term
    {    (
      let get_str_expr () = sprintf "%s >= %s" (Stm.term_to_str _1)
                                               (Stm.term_to_str _3) in
      let i1 = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2 = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.GreaterEq (i1, i2)
    )}
| _1 = equals
    {    ( Stm.Eq(_1) )}
| _1 = disequals
    {    ( Stm.InEq(_1) )}

equals:
  _1 = term _2 = EQUALS _3 = term
    {    (
      let get_str_expr () = sprintf "%s = %s" (Stm.term_to_str _1)
                                              (Stm.term_to_str _3) in
      let t1 = _1 in
      let t2 = _3 in

      parser_check_compatibility t1 t2 get_str_expr ;
      (inject_sort t1, inject_sort t2)
    )}

disequals:
  _1 = term _2 = NOT_EQUALS _3 = term
    {    (
      let get_str_expr () = sprintf "%s != %s" (Stm.term_to_str _1)
                                               (Stm.term_to_str _3) in
      let t1= _1 in
      let t2= _3 in

      parser_check_compatibility t1 t2 get_str_expr ;
      (inject_sort t1, inject_sort t2)
    )}

term:
  _1 = ident
    {    ( _1 )}
| _1 = set
    {    ( Stm.SetT(_1) )}
| _1 = elem
    {    ( Stm.ElemT(_1) )}
| _1 = tid
    {    ( Stm.TidT(_1) )}
| _1 = addr
    {    ( Stm.AddrT(_1) )}
| _1 = cell
    {    ( Stm.CellT(_1) )}
| _1 = setth
    {    ( Stm.SetThT(_1) )}
| _1 = setint
    {    ( Stm.SetIntT(_1) )}
| _1 = setelem
    {    ( Stm.SetElemT(_1) )}
| _1 = setpair
    {    ( Stm.SetPairT(_1) )}
| _1 = path
    {    ( Stm.PathT(_1) )}
| _1 = mem
    {    ( Stm.MemT(_1) )}
| _1 = integer
    {    ( Stm.IntT(_1) )}
| _1 = pair
    {    ( Stm.PairT(_1) )}
| _1 = mark
    {    ( Stm.MarkT(_1) )}
| _1 = arraylookup
    {    ( _1 )}
| _1 = arrayupd
    {    ( _1 )}
| _1 = bucket
    {    ( Stm.BucketT(_1) )}
| _1 = lock
    {    ( Stm.LockT(_1) )}
| _1 = OPEN_PAREN _2 = term _3 = CLOSE_PAREN
    {    ( _2 )}

ident:
  _1 = IDENT
    {    (
      let v        = get_name _1 in
      let is_input = System.mem_var inputVars v in
      let is_local = System.mem_var localVars v in
      let k        = get_var_kind v in

      if is_input || is_local then
        let c_proc = if !current_proc <> "" then
                       Stm.Scope !current_proc
                     else
                       Stm.GlobalScope
        in
          inject_sort $ Stm.VarT
                          (Stm.build_var (get_name _1) E.Unknown c_proc ~nature:k)
      else
          inject_sort $ Stm.VarT (Stm.build_var v E.Unknown Stm.GlobalScope ~nature:k)
    )}

set:
  _1 = EMPTYSET
    {    ( Stm.EmptySet )}
| _1 = OPEN_SET _2 = term _3 = CLOSE_SET
    {    (
      let get_str_expr() = sprintf "{ %s }" (Stm.term_to_str _2) in
      let a = parser_check_type check_type_addr _2 E.Addr get_str_expr in
        Stm.Singl(a)
    )}
| _1 = UNION _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "union(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Stm.Union(s1,s2)
    )}
| _1 = INTR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "intr(%s,%s)" (Stm.term_to_str _3)
                                                 (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Stm.Intr(s1,s2)
    )}
| _1 = SETDIFF _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "diff(%s,%s)" (Stm.term_to_str _3)
                                                 (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_set  _3 E.Set get_str_expr in
      let s2 = parser_check_type check_type_set  _5 E.Set get_str_expr in
        Stm.Setdiff(s1,s2)
    )}
| _1 = PATH2SET _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "path2set(%s)" (Stm.term_to_str _3) in
      let p = parser_check_type check_type_path _3 E.Path get_str_expr in
        Stm.PathToSet(p)
    )}
| _1 = ADDR2SET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "addr2set(%s,%s)" (Stm.term_to_str _3)
                                                      (Stm.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
        Stm.AddrToSet(h,a)
    )}
| _1 = ADDR2SET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "addr2set(%s,%s,%s)" (Stm.term_to_str _3)
                                                         (Stm.term_to_str _5)
                                                         (Stm.term_to_str _7) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let l = parser_check_type check_type_int  _7 E.Int get_str_expr in
        Stm.AddrToSetAt(h,a,l)
    )}
| _1 = term _2 = DOT _3 = BREGION
    {    (
      let get_str_expr () = sprintf "%s.bregion" (Stm.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        Stm.BucketRegion(b)
    )}

elem:
  _1 = term _2 = DOT _3 = DATA
    {    (
      let get_str_expr () = sprintf "%s.data" (Stm.term_to_str _1) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
        Stm.CellData(c)
    )}
| _1 = term _2 = POINTER _3 = DATA
    {    (
      let get_str_expr () = sprintf "%s->data" (Stm.term_to_str _1) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
        Stm.PointerData a
    )}
| _1 = HAVOCLISTELEM _2 = OPEN_PAREN _3 = CLOSE_PAREN
    {    (
      Stm.HavocListElem
    )}
| _1 = HAVOCSKIPLISTELEM _2 = OPEN_PAREN _3 = CLOSE_PAREN
    {    (
      Stm.HavocSkiplistElem
    )}
| _1 = LOWEST_ELEM
    {    (
      Stm.LowestElem
    )}
| _1 = HIGHEST_ELEM
    {    (
      Stm.HighestElem
    )}

tid:
  _1 = term _2 = DOT _3 = LOCKID
    {    (

      let get_str_expr () = sprintf "%s.lockid" (Stm.term_to_str _1) in
      try
        let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
          Stm.CellLockId(c)
      with _ ->
        let l = parser_check_type check_type_lock _1 E.Lock get_str_expr in
          Stm.LockId(l)
    )}
| _1 = SHARP
    {    (
      Stm.NoTid
    )}
| _1 = term _2 = POINTER _3 = LOCKID
    {    (
      let get_str_expr () = sprintf "%s->lockid" (Stm.term_to_str _1) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
        Stm.PointerLockid a
    )}
| _1 = ME
    {    (
      Stm.VarTh (Stm.build_var Sys.me_tid E.Tid Stm.GlobalScope)
    )}
| _1 = TIDOF _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "tid_of(%s)" (Stm.term_to_str _3) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
        Stm.PairTid(p)
    )}
| _1 = term _2 = DOT _3 = BTID
    {    (
      let get_str_expr () = sprintf "%s.btid" (Stm.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        Stm.BucketTid(b)
    )}

addr:
  _1 = NULL
    {    ( Stm.Null )}
| _1 = term _2 = DOT _3 = NEXT
    {    (
      let get_str_expr () = sprintf "%s.next" (Stm.term_to_str _1) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
        Stm.Next(c)
    )}
| _1 = term _2 = DOT _3 = NEXTAT _4 = OPEN_BRACKET _5 = term _6 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s.nextat[%s]" (Stm.term_to_str _1)
                                                    (Stm.term_to_str _5) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.NextAt(c,l)
    )}
| _1 = term _2 = DOT _3 = ARR _4 = OPEN_BRACKET _5 = term _6 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s.arr[%s]" (Stm.term_to_str _1)
                                                 (Stm.term_to_str _5) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.ArrAt(c,l)
    )}
| _1 = FIRSTLOCKED _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "firstlocked(%s,%s)" (Stm.term_to_str _3)
                                                         (Stm.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
        Stm.FirstLocked(h,p)
    )}
| _1 = LASTLOCKED _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "lastlocked(%s,%s)" (Stm.term_to_str _3)
                                                        (Stm.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let p = parser_check_type check_type_path _5 E.Path get_str_expr in
        Stm.LastLocked(h,p)
    )}
| _1 = MALLOC _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "malloc(%s,%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5)
                                                       (Stm.term_to_str _7)
      in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let t = parser_check_type check_type_tid _7 E.Tid get_str_expr in

        Stm.Malloc(e,a,t)
    )}
| _1 = MALLOCSL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mallocSL(%s,%s)" (Stm.term_to_str _3)
                                                      (Stm.term_to_str _5)
      in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.MallocSL(e,l)
    )}
| _1 = MALLOCSLK _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mallocSLK(%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5)
      in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.MallocSLK(e,l)
    )}
| _1 = term _2 = POINTER _3 = NEXT
    {    (
      let get_str_expr () = sprintf "%s->next" (Stm.term_to_str _1) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
        Stm.PointerNext a
    )}
| _1 = term _2 = POINTER _3 = NEXTAT _4 = OPEN_BRACKET _5 = term _6 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s->nextat[%s]" (Stm.term_to_str _1)
                                                     (Stm.term_to_str _5) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.PointerNextAt (a,l)
    )}
| _1 = term _2 = POINTER _3 = ARR _4 = OPEN_BRACKET _5 = term _6 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s->arr[%s]" (Stm.term_to_str _1)
                                                   (Stm.term_to_str _5) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
      let l = parser_check_type check_type_int _5 E.Int get_str_expr in
        Stm.PointerArrAt (a,l)
    )}
| _1 = term _2 = DOT _3 = BINIT
    {    (
      let get_str_expr () = sprintf "%s.binit" (Stm.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        Stm.BucketInit(b)
    )}
| _1 = term _2 = DOT _3 = BEND
    {    (
      let get_str_expr () = sprintf "%s.bend" (Stm.term_to_str _1) in
      let b = parser_check_type check_type_bucket _1 E.Bucket get_str_expr in
        Stm.BucketEnd(b)
    )}

cell:
  _1 = ERROR
    {    ( Stm.Error )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkcell(%s,%s,%s)"
                                           (Stm.term_to_str _3)
                                           (Stm.term_to_str _5)
                                           (Stm.term_to_str _7) in
      let d  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let a  = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let th = parser_check_type check_type_tid _7 E.Tid get_str_expr in
        Stm.MkCell(d,a,th)
    )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = OPEN_BRACKET _6 = term_list _7 = CLOSE_BRACKET _8 = COMMA _9 = OPEN_BRACKET _10 = term_list _11 = CLOSE_BRACKET _12 = CLOSE_PAREN
    {    (
      let list_term_to_str ts = String.concat "," (List.map Stm.term_to_str ts) in
      let addrs_str = list_term_to_str _6 in
      let tids_str = list_term_to_str _10 in
      let get_str_expr () = sprintf "mkcell(%s,[%s],[%s])"
                                           (Stm.term_to_str _3)
                                           (addrs_str)
                                           (tids_str) in
      let e  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let addrs = List.map (fun a ->
                    parser_check_type check_type_addr a E.Addr get_str_expr
                  ) _6 in
      let tids = List.map (fun t ->
                   parser_check_type check_type_tid t E.Tid get_str_expr
                 ) _10 in
      if List.length addrs <> List.length tids then
        begin
          Interface.Err.msg "Different argument lengths" $
            sprintf "mkcell is invoked with an unequal number of addresses [%s] \
                     and thread ids [%s]." addrs_str tids_str;
          raise(Different_argument_length(addrs_str,tids_str))
        end
      else
        Stm.MkSLKCell(e,addrs,tids)
    )}
| _1 = MKCELL _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkslcell(%s,%s,%s,%s)"
                                           (Stm.term_to_str _3)
                                           (Stm.term_to_str _5)
                                           (Stm.term_to_str _7)
                                           (Stm.term_to_str _9) in
      let e  = parser_check_type check_type_elem _3 E.Elem get_str_expr in
      let aa = parser_check_type check_type_addrarr _5 E.AddrArray get_str_expr in
      let ta = parser_check_type check_type_tidarr _7 E.TidArray get_str_expr in
      let l  = parser_check_type check_type_int _9 E.Int get_str_expr in
        Stm.MkSLCell(e,aa,ta,l)
    )}
| _1 = term _2 = DOT _3 = LOCK
    {    (
      let get_str_expr () = sprintf "%s.lock" (Stm.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        Stm.CellLock(c)
    )}
| _1 = term _2 = DOT _3 = UNLOCK
    {    (

      let get_str_expr () = sprintf "%s.unlock" (Stm.term_to_str _1) in
      let c = parser_check_type check_type_cell _1 E.Cell get_str_expr in
        Stm.CellUnlock(c)
    )}
| _1 = MEMORY_READ _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "%s [ %s ]" (Stm.term_to_str _3)
                                                (Stm.term_to_str _5) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
        Stm.CellAt(h,a)
    )}

mark:
  _1 = MARK_T
    {    ( Stm.MarkTrue )}
| _1 = MARK_F
    {    ( Stm.MarkFalse )}
| _1 = term _2 = DOT _3 = MARKED
    {    (
      let get_str_expr () = sprintf "%s.marked" (Stm.term_to_str _1) in
      let c = parser_check_type check_type_cell  _1 E.Cell get_str_expr in
        Stm.Marked(c)
    )}
| _1 = term _2 = POINTER _3 = MARKED
    {    (
      let get_str_expr () = sprintf "%s->marked" (Stm.term_to_str _1) in
      let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
        Stm.PointerMarked a
    )}

setth:
  _1 = EMPTYSETTH
    {    ( Stm.EmptySetTh )}
| _1 = SINGLETH _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tsingle(%s)" (Stm.term_to_str _3) in
      let th = parser_check_type check_type_tid  _3 E.Tid get_str_expr in
        Stm.SinglTh(th)
    )}
| _1 = UNIONTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tunion(%s,%s)" (Stm.term_to_str _3)
                                                   (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        Stm.UnionTh(s1,s2)
    )}
| _1 = INTRTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tintr(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        Stm.IntrTh(s1,s2)
    )}
| _1 = SETDIFFTH _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "tdiff(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setth  _3 E.SetTh get_str_expr in
      let s2 = parser_check_type check_type_setth  _5 E.SetTh get_str_expr in
        Stm.SetdiffTh(s1,s2)
    )}

setint:
  _1 = EMPTYSETINT
    {     ( Stm.EmptySetInt )}
| _1 = SINGLEINT _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "isingle(%s)" (Stm.term_to_str _3) in
      let th = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.SinglInt(th)
    )}
| _1 = UNIONINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "iunion(%s,%s)" (Stm.term_to_str _3)
                                                   (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Stm.UnionInt(s1,s2)
    )}
| _1 = INTRINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "iintr(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Stm.IntrInt(s1,s2)
    )}
| _1 = SETDIFFINT _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "idiff(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setint _3 E.SetInt get_str_expr in
      let s2 = parser_check_type check_type_setint _5 E.SetInt get_str_expr in
        Stm.SetdiffInt(s1,s2)
    )}

setelem:
  _1 = EMPTYSETELEM
    {     ( Stm.EmptySetElem )}
| _1 = SINGLEELEM _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "esingle(%s)" (Stm.term_to_str _3) in
      let e = parser_check_type check_type_elem _3 E.Elem get_str_expr in
        Stm.SinglElem(e)
    )}
| _1 = UNIONELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "eunion(%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Stm.UnionElem(s1,s2)
    )}
| _1 = INTRELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "eintr(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Stm.IntrElem(s1,s2)
    )}
| _1 = SETDIFFELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "ediff(%s,%s)" (Stm.term_to_str _3)
                                                  (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setelem _3 E.SetElem get_str_expr in
      let s2 = parser_check_type check_type_setelem _5 E.SetElem get_str_expr in
        Stm.SetdiffElem(s1,s2)
    )}
| _1 = SET2ELEM _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "set2elem(%s,%s)" (Stm.term_to_str _3)
                                                      (Stm.term_to_str _5) in
      let m = parser_check_type check_type_mem _3 E.Mem get_str_expr in
      let s = parser_check_type check_type_set _5 E.Set get_str_expr in
        Stm.SetToElems(s,m)
    )}

setpair:
  _1 = SETPAIREMPTY
    {     ( Stm.EmptySetPair )}
| _1 = SETPAIRSINGLE _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spsingle(%s)" (Stm.term_to_str _3) in
      let p = parser_check_type check_type_pair _3 E.Pair get_str_expr in
        Stm.SinglPair(p)
    )}
| _1 = SETPAIRUNION _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spunion(%s,%s)" (Stm.term_to_str _3)
                                                    (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair  _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair  _5 E.SetPair get_str_expr in
        Stm.UnionPair(s1,s2)
    )}
| _1 = SETPAIRINTR _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spintr(%s,%s)" (Stm.term_to_str _3)
                                                   (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair  _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair  _5 E.SetPair get_str_expr in
        Stm.IntrPair(s1,s2)
    )}
| _1 = SETPAIRDIFF _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr() = sprintf "spdiff(%s,%s)" (Stm.term_to_str _3)
                                                   (Stm.term_to_str _5) in
      let s1 = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
      let s2 = parser_check_type check_type_setpair _5 E.SetPair get_str_expr in
        Stm.SetdiffPair(s1,s2)
    )}

path:
  _1 = EPSILON
    {    ( Stm.Epsilon )}
| _1 = SINGLE_PATH _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "[ %s ]" (Stm.term_to_str _3) in
      let a = parser_check_type check_type_addr _3 E.Addr get_str_expr in
        Stm.SimplePath(a)
    )}
| _1 = GETP _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "getp(%s,%s,%s)" (Stm.term_to_str _3)
                                                     (Stm.term_to_str _5)
                                                     (Stm.term_to_str _7) in
      let h     = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let first = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let last  = parser_check_type check_type_addr _7 E.Addr get_str_expr in
        Stm.GetPath(h,first,last)
  )}

mem:
  _1 = UPDATE _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "update(%s,%s,%s)" (Stm.term_to_str _3)
                                                       (Stm.term_to_str _5)
                                                       (Stm.term_to_str _7) in
      let h = parser_check_type check_type_mem  _3 E.Mem get_str_expr in
      let a = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let c = parser_check_type check_type_cell _7 E.Cell get_str_expr in
        Stm.Update(h,a,c)
    )}

integer:
  _1 = NUMBER
    {    ( Stm.IntVal _1 )}
| _1 = MATH_MINUS _2 = term %prec MATH_NEG
    {    (
      let get_str_expr () = sprintf "-%s" (Stm.term_to_str _2) in
      let i  = parser_check_type check_type_int _2 E.Int get_str_expr in
        Stm.IntNeg i
    )}
| _1 = term _2 = MATH_PLUS _3 = term
    {    (
      let get_str_expr () = sprintf "%s+%s" (Stm.term_to_str _1)
                                            (Stm.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.IntAdd (i1,i2)
    )}
| _1 = term _2 = MATH_MINUS _3 = term
    {    (
      let get_str_expr () = sprintf "%s-%s" (Stm.term_to_str _1)
                                            (Stm.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.IntSub (i1,i2)
    )}
| _1 = term _2 = MATH_MULT _3 = term
    {    (
      let get_str_expr () = sprintf "%s*%s" (Stm.term_to_str _1)
                                            (Stm.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.IntMul (i1,i2)
    )}
| _1 = term _2 = MATH_DIV _3 = term
    {    (
      let get_str_expr () = sprintf "%s/%s" (Stm.term_to_str _1)
                                            (Stm.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.IntDiv (i1,i2)
    )}
| _1 = term _2 = MATH_MOD _3 = term
    {    (
      let get_str_expr () = sprintf "%s %% %s" (Stm.term_to_str _1)
                                               (Stm.term_to_str _3) in
      let i1  = parser_check_type check_type_int _1 E.Int get_str_expr in
      let i2  = parser_check_type check_type_int _3 E.Int get_str_expr in
        Stm.IntMod (i1,i2)
    )}
| _1 = SETINTMIN _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let iSet = _3 in
      let get_str_expr () = sprintf "setIntMin(%s)" (Stm.term_to_str iSet) in
      let s  = parser_check_type check_type_setint iSet E.SetInt get_str_expr
      in
        Stm.IntSetMin (s)
    )}
| _1 = SETINTMAX _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let iSet = _3 in
      let get_str_expr () = sprintf "setIntMax(%s)" (Stm.term_to_str iSet) in
      let s  = parser_check_type check_type_setint iSet E.SetInt get_str_expr
      in
        Stm.IntSetMax (s)
    )}
| _1 = HAVOCLEVEL _2 = OPEN_PAREN _3 = CLOSE_PAREN
    {    (
      Stm.HavocLevel
    )}
| _1 = HASHCODE _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "hashCode(%s)" (Stm.term_to_str _3) in
      let e  = parser_check_type check_type_elem _3 E.Elem get_str_expr
      in
        Stm.HashCode (e)
    )}
| _1 = INTOF _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "int_of(%s)" (Stm.term_to_str _3) in
      let p  = parser_check_type check_type_pair _3 E.Pair get_str_expr
      in
        Stm.PairInt(p)
    )}

pair:
  _1 = OPEN_PAREN _2 = term _3 = COMMA _4 = term _5 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "(%s,%s)" (Stm.term_to_str _2)
                                              (Stm.term_to_str _4) in
      let i  = parser_check_type check_type_int _2 E.Int get_str_expr in
      let t  = parser_check_type check_type_tid _4 E.Tid get_str_expr in
        Stm.IntTidPair(i,t)
    )}
| _1 = SETPAIRMIN _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spmin(%s)" (Stm.term_to_str _3) in
      let s  = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        Stm.SetPairMin(s)
    )}
| _1 = SETPAIRMAX _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "spmax(%s)" (Stm.term_to_str _3) in
      let s  = parser_check_type check_type_setpair _3 E.SetPair get_str_expr in
        Stm.SetPairMax(s)
    )}

arraylookup:
  _1 = term _2 = OPEN_BRACKET _3 = term _4 = CLOSE_BRACKET
    {    (
      let get_str_expr () = sprintf "%s[%s]" (Stm.term_to_str _1)
                                             (Stm.term_to_str _3) in
      let i = parser_check_type check_type_int _3 E.Int get_str_expr in
      try
        let arr = parser_check_type check_type_tidarr _1 E.TidArray get_str_expr in
          Stm.TidT (Stm.TidArrRd (arr,i))
        with _ ->
          try
            let arr = parser_check_type check_type_addrarr _1 E.AddrArray get_str_expr in
              Stm.AddrT (Stm.AddrArrRd (arr,i))
          with _ ->
            try
              let arr = parser_check_type check_type_bucketarr _1 E.BucketArray get_str_expr in
                Stm.BucketT (Stm.BucketArrRd (arr,i))
            with _ ->
              try
                let arr = parser_check_type check_type_lockarr _1 E.LockArray get_str_expr in
                  Stm.LockT (Stm.LockArrRd (arr,i))
              with e ->
                let a = parser_check_type check_type_addr _1 E.Addr get_str_expr in
                  match a with
                  | Stm.PointerNext a -> Stm.AddrT (Stm.PointerArrAt (a,i))
                  | _ -> raise(e)
    )}

arrayupd:
  _1 = ARR_UPDATE _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "arrUpd (%s,%s,%s)" (Stm.term_to_str _3)
                                                        (Stm.term_to_str _5)
                                                        (Stm.term_to_str _7) in
      let i = parser_check_type check_type_int _5 E.Int get_str_expr in
      try
        let ll = parser_check_type check_type_lockarr _3 E.LockArray get_str_expr in
        let l = parser_check_type check_type_lock _7 E.Lock get_str_expr in
          Stm.LockArrayT (Stm.LockArrayUp (ll,i,l))
      with _ ->
        try
          let bb = parser_check_type check_type_bucketarr _3 E.BucketArray get_str_expr in
          let b = parser_check_type check_type_bucket _7 E.Bucket get_str_expr in
            Stm.BucketArrayT (Stm.BucketArrayUp (bb,i,b))
        with _ ->
          try
            let aa = parser_check_type check_type_addrarr _3 E.AddrArray get_str_expr in
            let a = parser_check_type check_type_addr _7 E.Addr get_str_expr in
              Stm.AddrArrayT (Stm.AddrArrayUp (aa,i,a))
          with _ ->
            let at = parser_check_type check_type_tidarr _3 E.TidArray get_str_expr in
            let t = parser_check_type check_type_tid _7 E.Tid get_str_expr in
              Stm.TidArrayT (Stm.TidArrayUp (at,i,t))
    )}

bucket:
  _1 = MKBUCKET _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = COMMA _7 = term _8 = COMMA _9 = term _10 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "mkbucket(%s,%s,%s,%s)"
                                           (Stm.term_to_str _3)
                                           (Stm.term_to_str _5)
                                           (Stm.term_to_str _7)
                                           (Stm.term_to_str _9) in
      let i = parser_check_type check_type_addr _3 E.Addr get_str_expr in
      let e = parser_check_type check_type_addr _5 E.Addr get_str_expr in
      let s = parser_check_type check_type_set _7 E.Set get_str_expr in
      let t = parser_check_type check_type_tid _9 E.Tid get_str_expr in
        Stm.MkBucket(i,e,s,t)
    )}

lock:
  _1 = LOCK _2 = OPEN_PAREN _3 = term _4 = COMMA _5 = term _6 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "lock(%s,%s)"
                                           (Stm.term_to_str _3)
                                           (Stm.term_to_str _5) in
      let l = parser_check_type check_type_lock _3 E.Lock get_str_expr in
      let t = parser_check_type check_type_tid _5 E.Tid get_str_expr in
        Stm.LLock(l,t)
    )}
| _1 = UNLOCK _2 = OPEN_PAREN _3 = term _4 = CLOSE_PAREN
    {    (
      let get_str_expr () = sprintf "unlock(%s)"
                                           (Stm.term_to_str _3) in
      let l = parser_check_type check_type_lock _3 E.Lock get_str_expr in
        Stm.LUnlock(l)
    )}

%%
