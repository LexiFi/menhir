Note: the nonterminal symbol list (from liquidsoap.1.3.4-lang_parser.mly) is renamed liquidsoap_1_3_4_lang_parser_list.
File "liquidsoap.1.3.4-lang_parser.mly", line 205, characters 21-31:
Warning: the token PP_COMMENT is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 203, characters 15-21:
Warning: the token PP_DEF is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 203, characters 22-31:
Warning: the token PP_DEFINE is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 202, characters 53-61:
Warning: the token PP_ENDIF is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 203, characters 7-14:
Warning: the token PP_ENDL is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 202, characters 7-15:
Warning: the token PP_IFDEF is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 202, characters 26-38:
Warning: the token PP_IFENCODER is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 202, characters 16-25:
Warning: the token PP_IFNDEF is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 202, characters 39-52:
Warning: the token PP_IFNENCODER is unused.
File "liquidsoap.1.3.4-lang_parser.mly", line 204, characters 16-26:
Warning: the token PP_INCLUDE is unused.
Grammar has 26 nonterminal symbols, among which 2 start symbols.
Grammar has 75 terminal symbols.
Grammar has 168 productions.
nullable(ty_args) = true
nullable(ty_arg) = false
nullable(ty) = false
nullable(top_level_ogg_item) = false
nullable(s) = true
nullable(program) = false
nullable(opt) = true
nullable(ogg_items) = false
nullable(ogg_item) = false
nullable(liquidsoap_1_3_4_lang_parser_list) = false
nullable(interactive) = false
nullable(inner_list) = true
nullable(if_elsif) = true
nullable(g) = true
nullable(exprs) = false
nullable(expr) = false
nullable(cexprs) = false
nullable(cexpr) = false
nullable(binding) = false
nullable(argty) = false
nullable(argsty) = true
nullable(arglist) = true
nullable(arg) = false
nullable(app_opt) = true
nullable(app_list_elem) = false
nullable(app_list) = true
first(ty_args) = VARLPAR VAR TIMES REF LPAR LBRA INT
first(ty_arg) = VARLPAR VAR TIMES REF LPAR LBRA INT
first(ty) = VARLPAR VAR TIMES REF LPAR LBRA INT
first(top_level_ogg_item) = VORBIS_CBR VORBIS_ABR VORBIS THEORA SPEEX OPUS
first(s) = SEQ
first(program) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF DEF BOOL BEGIN AVI
first(opt) = GETS
first(ogg_items) = VORBIS_CBR VORBIS_ABR VORBIS THEORA SPEEX OPUS FLAC
first(ogg_item) = VORBIS_CBR VORBIS_ABR VORBIS THEORA SPEEX OPUS FLAC
first(liquidsoap_1_3_4_lang_parser_list) = LBRA
first(interactive) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF DEF BOOL BEGIN AVI
first(inner_list) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL BOOL BEGIN AVI
first(if_elsif) = ELSIF ELSE
first(g) = GETS
first(exprs) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL DEF BOOL BEGIN AVI
first(expr) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL BOOL BEGIN AVI
first(cexprs) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL DEF BOOL BEGIN AVI
first(cexpr) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL BOOL BEGIN AVI
first(binding) = VAR DEF
first(argty) = VARLPAR VAR TIMES REF QUESTION LPAR LBRA INT
first(argsty) = VARLPAR VAR TIMES REF QUESTION LPAR LBRA INT
first(arglist) = VAR TILD
first(arg) = VAR TILD
first(app_opt) = LPAR
first(app_list_elem) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL BOOL BEGIN AVI
first(app_list) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL BOOL BEGIN AVI
minimal(ty_args) = (* 0 *)
minimal(ty_arg) = (* 1 *) VAR
minimal(ty) = (* 1 *) VAR
minimal(top_level_ogg_item) = (* 1 *) VORBIS
minimal(s) = (* 0 *)
minimal(program) = (* 1 *) EOF
minimal(opt) = (* 0 *)
minimal(ogg_items) = (* 1 *) FLAC
minimal(ogg_item) = (* 1 *) FLAC
minimal(liquidsoap_1_3_4_lang_parser_list) = (* 2 *) LBRA RBRA
minimal(interactive) = (* 1 *) EOF
minimal(inner_list) = (* 0 *)
minimal(if_elsif) = (* 0 *)
minimal(g) = (* 0 *)
minimal(exprs) = (* 1 *) INT
minimal(expr) = (* 1 *) INT
minimal(cexprs) = (* 1 *) INT
minimal(cexpr) = (* 1 *) INT
minimal(binding) = (* 3 *) VAR GETS INT
minimal(argty) = (* 1 *) VAR
minimal(argsty) = (* 0 *)
minimal(arglist) = (* 0 *)
minimal(arg) = (* 1 *) VAR
minimal(app_opt) = (* 0 *)
minimal(app_list_elem) = (* 1 *) INT
minimal(app_list) = (* 0 *)
follow(ty_args) = RPAR
follow(ty_arg) = RPAR COMMA
follow(ty) = TIMES RPAR RBRA COMMA
follow(top_level_ogg_item) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIMES TIME THEORA THEN STRING SPEEX SHINE SET SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ RPAR REF RCUR RBRA OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF COMMA COLON BOOL BIN3 BIN2 BIN1 BIN0 BEGIN AVI
follow(s) = THEN SEQSEQ RCUR EOF END ELSIF ELSE
follow(program) = #
follow(opt) = RPAR COMMA
follow(ogg_items) = RPAR
follow(ogg_item) = RPAR COMMA
follow(liquidsoap_1_3_4_lang_parser_list) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIMES TIME THEORA THEN STRING SPEEX SHINE SET SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ RPAR REF RCUR RBRA OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF COMMA COLON BOOL BIN3 BIN2 BIN1 BIN0 BEGIN AVI
follow(interactive) = #
follow(inner_list) = RBRA
follow(if_elsif) = END
follow(g) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ REF OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GSTREAMER GET FUN FLOAT FLAC FDKAAC EXTERNAL DEF BOOL BEGIN AVI
follow(exprs) = THEN SEQSEQ RCUR EOF END ELSIF ELSE
follow(expr) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIMES TIME THEORA THEN STRING SPEEX SHINE SET SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ RPAR REF RCUR RBRA OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF COMMA COLON BOOL BIN3 BIN2 BIN1 BIN0 BEGIN AVI
follow(cexprs) = THEN SEQSEQ RCUR EOF END ELSIF ELSE
follow(cexpr) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIMES TIME THEORA THEN STRING SPEEX SHINE SET SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ REF RCUR OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF BOOL BIN3 BIN2 BIN1 BIN0 BEGIN AVI
follow(binding) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIME THEORA THEN STRING SPEEX SHINE SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ REF RCUR OPUS OGG NOT MP3_VBR MP3_ABR MP3 LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF BOOL BEGIN AVI
follow(argty) = RPAR COMMA
follow(argsty) = RPAR
follow(arglist) = RPAR
follow(arg) = RPAR COMMA
follow(app_opt) = WAV VORBIS_CBR VORBIS_ABR VORBIS VARLPAR VARLBRA VAR TIMES TIME THEORA THEN STRING SPEEX SHINE SET SERVER_WRITE SERVER_WAIT SERVER_READLINE SERVER_READCHARS SERVER_READ SEQSEQ SEQ RPAR REF RCUR RBRA OPUS OGG NOT MP3_VBR MP3_ABR MP3 MINUS LPAR LCUR LBRA INTERVAL INT IF GET FUN FLOAT FLAC FDKAAC EXTERNAL EOF END ELSIF ELSE DEF COMMA COLON BOOL BIN3 BIN2 BIN1 BIN0 BEGIN AVI
follow(app_list_elem) = RPAR COMMA
follow(app_list) = RPAR
Built an LR(0) automaton with 383 states.
The grammar is not SLR(1) -- 48 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 383 states.
179 shift/reduce conflicts were silently solved.
130 out of 383 states have a default reduction.
169 out of 383 states are represented.
0 out of 105 symbols keep track of their start position.
0 out of 105 symbols keep track of their end position.
104 out of 170 productions exploit shiftreduce optimization.
0 out of 383 states can peek at an error.
969 functions before inlining, 147 functions after inlining.
