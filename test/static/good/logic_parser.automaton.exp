State 0:
## Known stack suffix:
##
## LR(1) items:
annot' -> . annot [ # ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 2
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPE shift to state 560
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 617
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOOP shift to state 656
-- On LONG shift to state 28
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On LABEL shift to state 31
-- On INVARIANT shift to state 724
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 727
-- On IMPACT shift to state 739
-- On IF shift to state 38
-- On GLOBAL shift to state 745
-- On FREES shift to state 42
-- On FOR shift to state 751
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 889
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 942
-- On ALLOCATES shift to state 71
-- On type_annot shift to state 945
-- On slice_pragma shift to state 946
-- On post_cond shift to state 72
-- On model_annot shift to state 947
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annotations shift to state 948
-- On loop_annot_stack shift to state 949
-- On loop_allocation shift to state 785
-- On logic_def shift to state 950
-- On is_spec shift to state 951
-- On is_acsl_spec shift to state 1043
-- On is_acsl_other shift to state 692
-- On impact_pragma shift to state 1044
-- On grammar_extension_name shift to state 1045
-- On full_identifier_or_typename shift to state 1046
-- On enter_kw_c_mode shift to state 698
-- On deprecated_logic_decl shift to state 1047
-- On decl_list shift to state 1048
-- On decl shift to state 1050
-- On code_annotation shift to state 1052
-- On c_keyword shift to state 701
-- On annotation shift to state 1059
-- On annot shift to state 1061
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 1:
## Known stack suffix:
## WRITES
## LR(1) items:
is_acsl_other -> WRITES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> WRITES

State 2:
## Known stack suffix:
## VOLATILE
## LR(1) items:
decl -> VOLATILE . ne_zones volatile_opt SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_zones shift to state 550
-- On ne_lexpr_list shift to state 559
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 3:
## Known stack suffix:
## VOLATILE
## LR(1) items:
acsl_c_keyword -> VOLATILE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production acsl_c_keyword -> VOLATILE

State 4:
## Known stack suffix:
## VOID
## LR(1) items:
c_keyword -> VOID . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> VOID

State 5:
## Known stack suffix:
## VARIANT
## LR(1) items:
is_acsl_decl_or_code_annot -> VARIANT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> VARIANT

State 6:
## Known stack suffix:
## VALID_READ
## LR(1) items:
lexpr_inner -> VALID_READ . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 89
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 7:
## Known stack suffix:
## LBRACE
## LR(1) items:
opt_label_list -> LBRACE . ne_label_list RBRACE [ LPAR ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_label_list shift to state 74
-- On label_name shift to state 76
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 86
-- On acsl_c_keyword shift to state 87
## Reductions:

State 8:
## Known stack suffix:
## UNSIGNED
## LR(1) items:
c_keyword -> UNSIGNED . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> UNSIGNED

State 9:
## Known stack suffix:
## UNION
## LR(1) items:
c_keyword -> UNION . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> UNION

State 10:
## Known stack suffix:
## TYPENAME
## LR(1) items:
identifier_or_typename -> TYPENAME . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production identifier_or_typename -> TYPENAME

State 11:
## Known stack suffix:
## TYPE
## LR(1) items:
is_acsl_decl_or_code_annot -> TYPE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> TYPE

State 12:
## Known stack suffix:
## TERMINATES
## LR(1) items:
is_acsl_spec -> TERMINATES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> TERMINATES

State 13:
## Known stack suffix:
## STRUCT
## LR(1) items:
c_keyword -> STRUCT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> STRUCT

State 14:
## Known stack suffix:
## STATIC
## LR(1) items:
c_keyword -> STATIC . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> STATIC

State 15:
## Known stack suffix:
## SLICE
## LR(1) items:
is_acsl_decl_or_code_annot -> SLICE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> SLICE

State 16:
## Known stack suffix:
## SIZEOF
## LR(1) items:
c_keyword -> SIZEOF . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> SIZEOF

State 17:
## Known stack suffix:
## SIGNED
## LR(1) items:
c_keyword -> SIGNED . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> SIGNED

State 18:
## Known stack suffix:
## SHORT
## LR(1) items:
c_keyword -> SHORT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> SHORT

State 19:
## Known stack suffix:
## RETURNS
## LR(1) items:
post_cond -> RETURNS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond -> RETURNS

State 20:
## Known stack suffix:
## REQUIRES
## LR(1) items:
is_acsl_spec -> REQUIRES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> REQUIRES

State 21:
## Known stack suffix:
## REAL
## LR(1) items:
is_acsl_other -> REAL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> REAL

State 22:
## Known stack suffix:
## READS
## LR(1) items:
is_acsl_other -> READS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> READS

State 23:
## Known stack suffix:
## PREDICATE
## LR(1) items:
is_acsl_decl_or_code_annot -> PREDICATE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> PREDICATE

State 24:
## Known stack suffix:
## PRAGMA
## LR(1) items:
is_acsl_decl_or_code_annot -> PRAGMA . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> PRAGMA

State 25:
## Known stack suffix:
## MODULE
## LR(1) items:
is_ext_spec -> MODULE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> MODULE

State 26:
## Known stack suffix:
## MODEL
## LR(1) items:
is_acsl_decl_or_code_annot -> MODEL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> MODEL

State 27:
## Known stack suffix:
## LOOP
## LR(1) items:
is_acsl_decl_or_code_annot -> LOOP . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> LOOP

State 28:
## Known stack suffix:
## LONG
## LR(1) items:
c_keyword -> LONG . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> LONG

State 29:
## Known stack suffix:
## LOGIC
## LR(1) items:
keyword -> LOGIC . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production keyword -> LOGIC

State 30:
## Known stack suffix:
## LEMMA
## LR(1) items:
is_acsl_decl_or_code_annot -> LEMMA . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> LEMMA

State 31:
## Known stack suffix:
## LABEL
## LR(1) items:
is_acsl_other -> LABEL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> LABEL

State 32:
## Known stack suffix:
## INVARIANT
## LR(1) items:
is_acsl_decl_or_code_annot -> INVARIANT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> INVARIANT

State 33:
## Known stack suffix:
## INTEGER
## LR(1) items:
is_acsl_other -> INTEGER . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> INTEGER

State 34:
## Known stack suffix:
## INT
## LR(1) items:
c_keyword -> INT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> INT

State 35:
## Known stack suffix:
## INDUCTIVE
## LR(1) items:
is_acsl_decl_or_code_annot -> INDUCTIVE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> INDUCTIVE

State 36:
## Known stack suffix:
## INCLUDE
## LR(1) items:
is_ext_spec -> INCLUDE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> INCLUDE

State 37:
## Known stack suffix:
## IMPACT
## LR(1) items:
is_acsl_decl_or_code_annot -> IMPACT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> IMPACT

State 38:
## Known stack suffix:
## IF
## LR(1) items:
c_keyword -> IF . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> IF

State 39:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier_or_typename -> IDENTIFIER . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production identifier_or_typename -> IDENTIFIER

State 40:
## Known stack suffix:
## GLOBAL
## LR(1) items:
is_acsl_decl_or_code_annot -> GLOBAL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> GLOBAL

State 41:
## Known stack suffix:
## FUNCTION
## LR(1) items:
is_ext_spec -> FUNCTION . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> FUNCTION

State 42:
## Known stack suffix:
## FREES
## LR(1) items:
is_acsl_spec -> FREES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> FREES

State 43:
## Known stack suffix:
## FOR
## LR(1) items:
acsl_c_keyword -> FOR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production acsl_c_keyword -> FOR

State 44:
## Known stack suffix:
## FLOAT
## LR(1) items:
c_keyword -> FLOAT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> FLOAT

State 45:
## Known stack suffix:
## EXT_LET
## LR(1) items:
is_ext_spec -> EXT_LET . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> EXT_LET

State 46:
## Known stack suffix:
## EXT_AT
## LR(1) items:
is_ext_spec -> EXT_AT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> EXT_AT

State 47:
## Known stack suffix:
## EXITS
## LR(1) items:
post_cond -> EXITS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond -> EXITS

State 48:
## Known stack suffix:
## ENUM
## LR(1) items:
c_keyword -> ENUM . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> ENUM

State 49:
## Known stack suffix:
## ENSURES
## LR(1) items:
post_cond -> ENSURES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond -> ENSURES

State 50:
## Known stack suffix:
## ELSE
## LR(1) items:
c_keyword -> ELSE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> ELSE

State 51:
## Known stack suffix:
## DOUBLE
## LR(1) items:
c_keyword -> DOUBLE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> DOUBLE

State 52:
## Known stack suffix:
## DISJOINT
## LR(1) items:
is_acsl_spec -> DISJOINT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> DISJOINT

State 53:
## Known stack suffix:
## DECREASES
## LR(1) items:
is_acsl_spec -> DECREASES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> DECREASES

State 54:
## Known stack suffix:
## CUSTOM
## LR(1) items:
non_logic_keyword -> CUSTOM . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> CUSTOM

State 55:
## Known stack suffix:
## CONTRACT
## LR(1) items:
is_ext_spec -> CONTRACT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_ext_spec -> CONTRACT

State 56:
## Known stack suffix:
## CONTINUES
## LR(1) items:
post_cond -> CONTINUES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond -> CONTINUES

State 57:
## Known stack suffix:
## CONST
## LR(1) items:
c_keyword -> CONST . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> CONST

State 58:
## Known stack suffix:
## COMPLETE
## LR(1) items:
is_acsl_spec -> COMPLETE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> COMPLETE

State 59:
## Known stack suffix:
## CHAR
## LR(1) items:
c_keyword -> CHAR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> CHAR

State 60:
## Known stack suffix:
## CASE
## LR(1) items:
c_keyword -> CASE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> CASE

State 61:
## Known stack suffix:
## BREAKS
## LR(1) items:
post_cond -> BREAKS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond -> BREAKS

State 62:
## Known stack suffix:
## BOOLEAN
## LR(1) items:
c_keyword -> BOOLEAN . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> BOOLEAN

State 63:
## Known stack suffix:
## BOOL
## LR(1) items:
c_keyword -> BOOL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production c_keyword -> BOOL

State 64:
## Known stack suffix:
## BEHAVIORS
## LR(1) items:
is_acsl_other -> BEHAVIORS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_other -> BEHAVIORS

State 65:
## Known stack suffix:
## BEHAVIOR
## LR(1) items:
is_acsl_spec -> BEHAVIOR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> BEHAVIOR

State 66:
## Known stack suffix:
## AXIOMATIC
## LR(1) items:
is_acsl_decl_or_code_annot -> AXIOMATIC . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> AXIOMATIC

State 67:
## Known stack suffix:
## AXIOM
## LR(1) items:
is_acsl_decl_or_code_annot -> AXIOM . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> AXIOM

State 68:
## Known stack suffix:
## ASSUMES
## LR(1) items:
is_acsl_decl_or_code_annot -> ASSUMES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> ASSUMES

State 69:
## Known stack suffix:
## ASSIGNS
## LR(1) items:
is_acsl_spec -> ASSIGNS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> ASSIGNS

State 70:
## Known stack suffix:
## ASSERT
## LR(1) items:
is_acsl_decl_or_code_annot -> ASSERT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_decl_or_code_annot -> ASSERT

State 71:
## Known stack suffix:
## ALLOCATES
## LR(1) items:
is_acsl_spec -> ALLOCATES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> ALLOCATES

State 72:
## Known stack suffix:
## post_cond
## LR(1) items:
is_acsl_spec -> post_cond . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_acsl_spec -> post_cond

State 73:
## Known stack suffix:
## non_logic_keyword
## LR(1) items:
keyword -> non_logic_keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production keyword -> non_logic_keyword

State 74:
## Known stack suffix:
## LBRACE ne_label_list
## LR(1) items:
opt_label_list -> LBRACE ne_label_list . RBRACE [ LPAR ]
## Transitions:
-- On RBRACE shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## LBRACE ne_label_list RBRACE
## LR(1) items:
opt_label_list -> LBRACE ne_label_list RBRACE . [ LPAR ]
## Transitions:
## Reductions:
-- On LPAR
--   reduce production opt_label_list -> LBRACE ne_label_list RBRACE

State 76:
## Known stack suffix:
## label_name
## LR(1) items:
ne_label_list -> label_name . [ RBRACE ]
ne_label_list -> label_name . COMMA ne_label_list [ RBRACE ]
## Transitions:
-- On COMMA shift to state 77
## Reductions:
-- On RBRACE
--   reduce production ne_label_list -> label_name

State 77:
## Known stack suffix:
## label_name COMMA
## LR(1) items:
ne_label_list -> label_name COMMA . ne_label_list [ RBRACE ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_label_list shift to state 78
-- On label_name shift to state 76
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 86
-- On acsl_c_keyword shift to state 87
## Reductions:

State 78:
## Known stack suffix:
## label_name COMMA ne_label_list
## LR(1) items:
ne_label_list -> label_name COMMA ne_label_list . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production ne_label_list -> label_name COMMA ne_label_list

State 79:
## Known stack suffix:
## keyword
## LR(1) items:
any_identifier -> keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production any_identifier -> keyword

State 80:
## Known stack suffix:
## is_ext_spec
## LR(1) items:
non_logic_keyword -> is_ext_spec . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> is_ext_spec

State 81:
## Known stack suffix:
## is_acsl_spec
## LR(1) items:
non_logic_keyword -> is_acsl_spec . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> is_acsl_spec

State 82:
## Known stack suffix:
## is_acsl_other
## LR(1) items:
non_logic_keyword -> is_acsl_other . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> is_acsl_other

State 83:
## Known stack suffix:
## is_acsl_decl_or_code_annot
## LR(1) items:
non_logic_keyword -> is_acsl_decl_or_code_annot . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> is_acsl_decl_or_code_annot

State 84:
## Known stack suffix:
## identifier_or_typename
## LR(1) items:
any_identifier -> identifier_or_typename . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production any_identifier -> identifier_or_typename

State 85:
## Known stack suffix:
## c_keyword
## LR(1) items:
non_logic_keyword -> c_keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> c_keyword

State 86:
## Known stack suffix:
## any_identifier
## LR(1) items:
label_name -> any_identifier . [ RPAR RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAR RBRACE COMMA
--   reduce production label_name -> any_identifier

State 87:
## Known stack suffix:
## acsl_c_keyword
## LR(1) items:
non_logic_keyword -> acsl_c_keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production non_logic_keyword -> acsl_c_keyword

State 88:
## Known stack suffix:
## opt_label_list
## LR(1) items:
opt_label_1 -> opt_label_list . [ LPAR ]
## Transitions:
## Reductions:
-- On LPAR
--   reduce production opt_label_1 -> opt_label_list

State 89:
## Known stack suffix:
## VALID_READ opt_label_1
## LR(1) items:
lexpr_inner -> VALID_READ opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 90
## Reductions:

State 90:
## Known stack suffix:
## VALID_READ opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> VALID_READ opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 548
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 91:
## Known stack suffix:
## VALID_RANGE
## LR(1) items:
lexpr_inner -> VALID_RANGE . opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 92
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 92:
## Known stack suffix:
## VALID_RANGE opt_label_1
## LR(1) items:
lexpr_inner -> VALID_RANGE opt_label_1 . LPAR lexpr COMMA lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 93
## Reductions:

State 93:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> VALID_RANGE opt_label_1 LPAR . lexpr COMMA lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 542
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 94:
## Known stack suffix:
## VALID_INDEX
## LR(1) items:
lexpr_inner -> VALID_INDEX . opt_label_1 LPAR lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 95
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 95:
## Known stack suffix:
## VALID_INDEX opt_label_1
## LR(1) items:
lexpr_inner -> VALID_INDEX opt_label_1 . LPAR lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 96
## Reductions:

State 96:
## Known stack suffix:
## VALID_INDEX opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> VALID_INDEX opt_label_1 LPAR . lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 538
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 97:
## Known stack suffix:
## VALID
## LR(1) items:
lexpr_inner -> VALID . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 98
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 98:
## Known stack suffix:
## VALID opt_label_1
## LR(1) items:
lexpr_inner -> VALID opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 99
## Reductions:

State 99:
## Known stack suffix:
## VALID opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> VALID opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 536
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 100:
## Known stack suffix:
## UNALLOCATED
## LR(1) items:
lexpr_inner -> UNALLOCATED . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> UNALLOCATED

State 101:
## Known stack suffix:
## TYPEOF
## LR(1) items:
lexpr_inner -> TYPEOF . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 102
## Reductions:

State 102:
## Known stack suffix:
## TYPEOF LPAR
## LR(1) items:
lexpr_inner -> TYPEOF LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 534
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 103:
## Known stack suffix:
## TRUE
## LR(1) items:
lexpr_inner -> TRUE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> TRUE

State 104:
## Known stack suffix:
## TILDE
## LR(1) items:
lexpr_inner -> TILDE . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 533
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 105:
## Known stack suffix:
## STRING_LITERAL
## LR(1) items:
string -> STRING_LITERAL . [ WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production string -> STRING_LITERAL

State 106:
## Known stack suffix:
## STATIC
## LR(1) items:
lexpr_inner -> STATIC . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> STATIC

State 107:
## Known stack suffix:
## STAR
## LR(1) items:
lexpr_inner -> STAR . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 532
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 108:
## Known stack suffix:
## SIZEOF
## LR(1) items:
lexpr_inner -> SIZEOF . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> SIZEOF . LPAR logic_type RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 109
## Reductions:

State 109:
## Known stack suffix:
## SIZEOF LPAR
## LR(1) items:
lexpr_inner -> SIZEOF LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> SIZEOF LPAR . logic_type RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 110
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 111
-- On UNION shift to state 119
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 122
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 195
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 198
-- On SHORT shift to state 199
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 216
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 217
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 468
-- On INT shift to state 469
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 470
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 471
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 472
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 473
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 474
-- On BOOL shift to state 475
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On type_spec shift to state 157
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On logic_type shift to state 528
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 530
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 110:
## Known stack suffix:
## VOID
## LR(1) items:
c_keyword -> VOID . [ COLON ]
type_spec -> VOID . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> VOID
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> VOID

State 111:
## Known stack suffix:
## UNSIGNED
## LR(1) items:
c_keyword -> UNSIGNED . [ COLON ]
type_spec -> UNSIGNED . CHAR [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . SHORT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . LONG [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . LONG INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . LONG LONG [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> UNSIGNED . LONG LONG INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On SHORT shift to state 112
-- On LONG shift to state 113
-- On INT shift to state 117
-- On CHAR shift to state 118
## Reductions:
-- On COLON
--   reduce production c_keyword -> UNSIGNED
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> UNSIGNED

State 112:
## Known stack suffix:
## UNSIGNED SHORT
## LR(1) items:
type_spec -> UNSIGNED SHORT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED SHORT

State 113:
## Known stack suffix:
## UNSIGNED LONG
## LR(1) items:
type_spec -> UNSIGNED LONG . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED LONG . INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED LONG . LONG [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED LONG . LONG INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LONG shift to state 114
-- On INT shift to state 116
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED LONG

State 114:
## Known stack suffix:
## UNSIGNED LONG LONG
## LR(1) items:
type_spec -> UNSIGNED LONG LONG . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED LONG LONG . INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On INT shift to state 115
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED LONG LONG

State 115:
## Known stack suffix:
## UNSIGNED LONG LONG INT
## LR(1) items:
type_spec -> UNSIGNED LONG LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED LONG LONG INT

State 116:
## Known stack suffix:
## UNSIGNED LONG INT
## LR(1) items:
type_spec -> UNSIGNED LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED LONG INT

State 117:
## Known stack suffix:
## UNSIGNED INT
## LR(1) items:
type_spec -> UNSIGNED INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED INT

State 118:
## Known stack suffix:
## UNSIGNED CHAR
## LR(1) items:
type_spec -> UNSIGNED CHAR . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED CHAR

State 119:
## Known stack suffix:
## UNION
## LR(1) items:
c_keyword -> UNION . [ COLON ]
type_spec -> UNION . exit_rt_type identifier_or_typename [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On exit_rt_type shift to state 120
## Reductions:
-- On COLON
--   reduce production c_keyword -> UNION
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 120:
## Known stack suffix:
## UNION exit_rt_type
## LR(1) items:
type_spec -> UNION exit_rt_type . identifier_or_typename [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## UNION exit_rt_type identifier_or_typename
## LR(1) items:
type_spec -> UNION exit_rt_type identifier_or_typename . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNION exit_rt_type identifier_or_typename

State 122:
## Known stack suffix:
## TYPENAME
## LR(1) items:
identifier_or_typename -> TYPENAME . [ COLON ]
type_spec -> TYPENAME . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> TYPENAME . LT enter_rt_type ne_logic_type_list GT exit_rt_type [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On LT shift to state 123
## Reductions:
-- On COLON
--   reduce production identifier_or_typename -> TYPENAME
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> TYPENAME

State 123:
## Known stack suffix:
## TYPENAME LT
## LR(1) items:
type_spec -> TYPENAME LT . enter_rt_type ne_logic_type_list GT exit_rt_type [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On enter_rt_type shift to state 124
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_rt_type ->

State 124:
## Known stack suffix:
## TYPENAME LT enter_rt_type
## LR(1) items:
type_spec -> TYPENAME LT enter_rt_type . ne_logic_type_list GT exit_rt_type [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On ne_logic_type_list shift to state 188
-- On logic_type shift to state 191
## Reductions:

State 125:
## Known stack suffix:
## VOID
## LR(1) items:
type_spec -> VOID . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> VOID

State 126:
## Known stack suffix:
## UNSIGNED
## LR(1) items:
type_spec -> UNSIGNED . CHAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . SHORT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . LONG [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . LONG INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . LONG LONG [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> UNSIGNED . LONG LONG INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On SHORT shift to state 112
-- On LONG shift to state 113
-- On INT shift to state 117
-- On CHAR shift to state 118
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> UNSIGNED

State 127:
## Known stack suffix:
## UNION
## LR(1) items:
type_spec -> UNION . exit_rt_type identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On exit_rt_type shift to state 120
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 128:
## Known stack suffix:
## TYPENAME
## LR(1) items:
type_spec -> TYPENAME . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> TYPENAME . LT enter_rt_type ne_logic_type_list GT exit_rt_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LT shift to state 123
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> TYPENAME

State 129:
## Known stack suffix:
## STRUCT
## LR(1) items:
type_spec -> STRUCT . exit_rt_type identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On exit_rt_type shift to state 130
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 130:
## Known stack suffix:
## STRUCT exit_rt_type
## LR(1) items:
type_spec -> STRUCT exit_rt_type . identifier_or_typename [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 131
## Reductions:

State 131:
## Known stack suffix:
## STRUCT exit_rt_type identifier_or_typename
## LR(1) items:
type_spec -> STRUCT exit_rt_type identifier_or_typename . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> STRUCT exit_rt_type identifier_or_typename

State 132:
## Known stack suffix:
## SIGNED
## LR(1) items:
type_spec -> SIGNED . CHAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . SHORT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . LONG [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . LONG INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . LONG LONG [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED . LONG LONG INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On SHORT shift to state 133
-- On LONG shift to state 134
-- On INT shift to state 138
-- On CHAR shift to state 139
## Reductions:

State 133:
## Known stack suffix:
## SIGNED SHORT
## LR(1) items:
type_spec -> SIGNED SHORT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED SHORT

State 134:
## Known stack suffix:
## SIGNED LONG
## LR(1) items:
type_spec -> SIGNED LONG . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED LONG . INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED LONG . LONG [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED LONG . LONG INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LONG shift to state 135
-- On INT shift to state 137
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED LONG

State 135:
## Known stack suffix:
## SIGNED LONG LONG
## LR(1) items:
type_spec -> SIGNED LONG LONG . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> SIGNED LONG LONG . INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On INT shift to state 136
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED LONG LONG

State 136:
## Known stack suffix:
## SIGNED LONG LONG INT
## LR(1) items:
type_spec -> SIGNED LONG LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED LONG LONG INT

State 137:
## Known stack suffix:
## SIGNED LONG INT
## LR(1) items:
type_spec -> SIGNED LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED LONG INT

State 138:
## Known stack suffix:
## SIGNED INT
## LR(1) items:
type_spec -> SIGNED INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED INT

State 139:
## Known stack suffix:
## SIGNED CHAR
## LR(1) items:
type_spec -> SIGNED CHAR . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SIGNED CHAR

State 140:
## Known stack suffix:
## SHORT
## LR(1) items:
type_spec -> SHORT . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> SHORT

State 141:
## Known stack suffix:
## REAL
## LR(1) items:
type_spec -> REAL . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> REAL

State 142:
## Known stack suffix:
## LONG
## LR(1) items:
type_spec -> LONG . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> LONG . INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> LONG . LONG [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> LONG . LONG INT [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> LONG . DOUBLE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LONG shift to state 143
-- On INT shift to state 145
-- On DOUBLE shift to state 146
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> LONG

State 143:
## Known stack suffix:
## LONG LONG
## LR(1) items:
type_spec -> LONG LONG . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
type_spec -> LONG LONG . INT [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On INT shift to state 144
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> LONG LONG

State 144:
## Known stack suffix:
## LONG LONG INT
## LR(1) items:
type_spec -> LONG LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> LONG LONG INT

State 145:
## Known stack suffix:
## LONG INT
## LR(1) items:
type_spec -> LONG INT . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> LONG INT

State 146:
## Known stack suffix:
## LONG DOUBLE
## LR(1) items:
type_spec -> LONG DOUBLE . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> LONG DOUBLE

State 147:
## Known stack suffix:
## INTEGER
## LR(1) items:
type_spec -> INTEGER . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> INTEGER

State 148:
## Known stack suffix:
## INT
## LR(1) items:
type_spec -> INT . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> INT

State 149:
## Known stack suffix:
## FLOAT
## LR(1) items:
type_spec -> FLOAT . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> FLOAT

State 150:
## Known stack suffix:
## ENUM
## LR(1) items:
type_spec -> ENUM . exit_rt_type identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On exit_rt_type shift to state 151
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 151:
## Known stack suffix:
## ENUM exit_rt_type
## LR(1) items:
type_spec -> ENUM exit_rt_type . identifier_or_typename [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## ENUM exit_rt_type identifier_or_typename
## LR(1) items:
type_spec -> ENUM exit_rt_type identifier_or_typename . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> ENUM exit_rt_type identifier_or_typename

State 153:
## Known stack suffix:
## DOUBLE
## LR(1) items:
type_spec -> DOUBLE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> DOUBLE

State 154:
## Known stack suffix:
## CHAR
## LR(1) items:
type_spec -> CHAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> CHAR

State 155:
## Known stack suffix:
## BOOLEAN
## LR(1) items:
type_spec -> BOOLEAN . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> BOOLEAN

State 156:
## Known stack suffix:
## BOOL
## LR(1) items:
type_spec -> BOOL . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> BOOL

State 157:
## Known stack suffix:
## type_spec
## LR(1) items:
logic_type -> type_spec . abs_spec_option [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 158
-- On LSQUARE shift to state 159
-- On LPAR shift to state 166
-- On tabs shift to state 167
-- On stars shift to state 168
-- On abs_spec_option shift to state 186
-- On abs_spec_bis shift to state 182
-- On abs_spec shift to state 187
## Reductions:
-- On WRITES WITH SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec_option ->

State 158:
## Known stack suffix:
## STAR
## LR(1) items:
stars -> STAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production stars -> STAR

State 159:
## Known stack suffix:
## LSQUARE
## LR(1) items:
tabs -> LSQUARE . constant_option RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
tabs -> LSQUARE . constant_option RSQUARE tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On constant_option shift to state 162
-- On constant shift to state 165
## Reductions:
-- On RSQUARE
--   reduce production constant_option ->

State 160:
## Known stack suffix:
## CONSTANT10
## LR(1) items:
constant -> CONSTANT10 . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production constant -> CONSTANT10

State 161:
## Known stack suffix:
## CONSTANT
## LR(1) items:
constant -> CONSTANT . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production constant -> CONSTANT

State 162:
## Known stack suffix:
## LSQUARE constant_option
## LR(1) items:
tabs -> LSQUARE constant_option . RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
tabs -> LSQUARE constant_option . RSQUARE tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RSQUARE shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## LSQUARE constant_option RSQUARE
## LR(1) items:
tabs -> LSQUARE constant_option RSQUARE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
tabs -> LSQUARE constant_option RSQUARE . tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LSQUARE shift to state 159
-- On tabs shift to state 164
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production tabs -> LSQUARE constant_option RSQUARE

State 164:
## Known stack suffix:
## LSQUARE constant_option RSQUARE tabs
## LR(1) items:
tabs -> LSQUARE constant_option RSQUARE tabs . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production tabs -> LSQUARE constant_option RSQUARE tabs

State 165:
## Known stack suffix:
## constant
## LR(1) items:
constant_option -> constant . [ RSQUARE ]
## Transitions:
## Reductions:
-- On RSQUARE
--   reduce production constant_option -> constant

State 166:
## Known stack suffix:
## LPAR
## LR(1) items:
abs_spec_bis -> LPAR . abs_spec RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 158
-- On LSQUARE shift to state 159
-- On LPAR shift to state 166
-- On tabs shift to state 167
-- On stars shift to state 168
-- On abs_spec_bis shift to state 182
-- On abs_spec shift to state 184
## Reductions:

State 167:
## Known stack suffix:
## tabs
## LR(1) items:
abs_spec -> tabs . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> tabs

State 168:
## Known stack suffix:
## stars
## LR(1) items:
abs_spec -> stars . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec -> stars . tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec -> stars . abs_spec_bis [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec -> stars . abs_spec_bis tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
stars -> stars . STAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 169
-- On LSQUARE shift to state 159
-- On LPAR shift to state 166
-- On tabs shift to state 170
-- On abs_spec_bis shift to state 171
## Reductions:
-- On WRITES WITH SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> stars

State 169:
## Known stack suffix:
## stars STAR
## LR(1) items:
stars -> stars STAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production stars -> stars STAR

State 170:
## Known stack suffix:
## stars tabs
## LR(1) items:
abs_spec -> stars tabs . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> stars tabs

State 171:
## Known stack suffix:
## stars abs_spec_bis
## LR(1) items:
abs_spec -> stars abs_spec_bis . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec -> stars abs_spec_bis . tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec_bis -> abs_spec_bis . LPAR abs_param_type_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LSQUARE shift to state 159
-- On LPAR shift to state 172
-- On tabs shift to state 181
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> stars abs_spec_bis

State 172:
## Known stack suffix:
## abs_spec_bis LPAR
## LR(1) items:
abs_spec_bis -> abs_spec_bis LPAR . abs_param_type_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 173
-- On abs_param_type_list shift to state 174
-- On abs_param_list shift to state 176
-- On abs_param shift to state 180
## Reductions:
-- On RPAR
--   reduce production abs_param_type_list ->

State 173:
## Known stack suffix:
## logic_type
## LR(1) items:
abs_param -> logic_type . [ RPAR COMMA ]
## Transitions:
## Reductions:
-- On RPAR COMMA
--   reduce production abs_param -> logic_type

State 174:
## Known stack suffix:
## abs_spec_bis LPAR abs_param_type_list
## LR(1) items:
abs_spec_bis -> abs_spec_bis LPAR abs_param_type_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## abs_spec_bis LPAR abs_param_type_list RPAR
## LR(1) items:
abs_spec_bis -> abs_spec_bis LPAR abs_param_type_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec_bis -> abs_spec_bis LPAR abs_param_type_list RPAR

State 176:
## Known stack suffix:
## abs_param_list
## LR(1) items:
abs_param_list -> abs_param_list . COMMA abs_param [ RPAR COMMA ]
abs_param_type_list -> abs_param_list . [ RPAR ]
abs_param_type_list -> abs_param_list . COMMA DOTDOTDOT [ RPAR ]
## Transitions:
-- On COMMA shift to state 177
## Reductions:
-- On RPAR
--   reduce production abs_param_type_list -> abs_param_list

State 177:
## Known stack suffix:
## abs_param_list COMMA
## LR(1) items:
abs_param_list -> abs_param_list COMMA . abs_param [ RPAR COMMA ]
abs_param_type_list -> abs_param_list COMMA . DOTDOTDOT [ RPAR ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On DOTDOTDOT shift to state 178
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 173
-- On abs_param shift to state 179
## Reductions:

State 178:
## Known stack suffix:
## abs_param_list COMMA DOTDOTDOT
## LR(1) items:
abs_param_type_list -> abs_param_list COMMA DOTDOTDOT . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_param_type_list -> abs_param_list COMMA DOTDOTDOT

State 179:
## Known stack suffix:
## abs_param_list COMMA abs_param
## LR(1) items:
abs_param_list -> abs_param_list COMMA abs_param . [ RPAR COMMA ]
## Transitions:
## Reductions:
-- On RPAR COMMA
--   reduce production abs_param_list -> abs_param_list COMMA abs_param

State 180:
## Known stack suffix:
## abs_param
## LR(1) items:
abs_param_list -> abs_param . [ RPAR COMMA ]
## Transitions:
## Reductions:
-- On RPAR COMMA
--   reduce production abs_param_list -> abs_param

State 181:
## Known stack suffix:
## stars abs_spec_bis tabs
## LR(1) items:
abs_spec -> stars abs_spec_bis tabs . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> stars abs_spec_bis tabs

State 182:
## Known stack suffix:
## abs_spec_bis
## LR(1) items:
abs_spec -> abs_spec_bis . tabs [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec -> abs_spec_bis . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
abs_spec_bis -> abs_spec_bis . LPAR abs_param_type_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LSQUARE shift to state 159
-- On LPAR shift to state 172
-- On tabs shift to state 183
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> abs_spec_bis

State 183:
## Known stack suffix:
## abs_spec_bis tabs
## LR(1) items:
abs_spec -> abs_spec_bis tabs . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec -> abs_spec_bis tabs

State 184:
## Known stack suffix:
## LPAR abs_spec
## LR(1) items:
abs_spec_bis -> LPAR abs_spec . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## LPAR abs_spec RPAR
## LR(1) items:
abs_spec_bis -> LPAR abs_spec RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec_bis -> LPAR abs_spec RPAR

State 186:
## Known stack suffix:
## type_spec abs_spec_option
## LR(1) items:
logic_type -> type_spec abs_spec_option . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production logic_type -> type_spec abs_spec_option

State 187:
## Known stack suffix:
## abs_spec
## LR(1) items:
abs_spec_option -> abs_spec . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production abs_spec_option -> abs_spec

State 188:
## Known stack suffix:
## TYPENAME LT enter_rt_type ne_logic_type_list
## LR(1) items:
type_spec -> TYPENAME LT enter_rt_type ne_logic_type_list . GT exit_rt_type [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On GT shift to state 189
## Reductions:

State 189:
## Known stack suffix:
## TYPENAME LT enter_rt_type ne_logic_type_list GT
## LR(1) items:
type_spec -> TYPENAME LT enter_rt_type ne_logic_type_list GT . exit_rt_type [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On exit_rt_type shift to state 190
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production exit_rt_type ->

State 190:
## Known stack suffix:
## TYPENAME LT enter_rt_type ne_logic_type_list GT exit_rt_type
## LR(1) items:
type_spec -> TYPENAME LT enter_rt_type ne_logic_type_list GT exit_rt_type . [ WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES CONST COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production type_spec -> TYPENAME LT enter_rt_type ne_logic_type_list GT exit_rt_type

State 191:
## Known stack suffix:
## logic_type
## LR(1) items:
ne_logic_type_list -> logic_type . [ GT ]
ne_logic_type_list -> logic_type . COMMA enter_rt_type ne_logic_type_list [ GT ]
## Transitions:
-- On COMMA shift to state 192
## Reductions:
-- On GT
--   reduce production ne_logic_type_list -> logic_type

State 192:
## Known stack suffix:
## logic_type COMMA
## LR(1) items:
ne_logic_type_list -> logic_type COMMA . enter_rt_type ne_logic_type_list [ GT ]
## Transitions:
-- On enter_rt_type shift to state 193
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_rt_type ->

State 193:
## Known stack suffix:
## logic_type COMMA enter_rt_type
## LR(1) items:
ne_logic_type_list -> logic_type COMMA enter_rt_type . ne_logic_type_list [ GT ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On ne_logic_type_list shift to state 194
-- On logic_type shift to state 191
## Reductions:

State 194:
## Known stack suffix:
## logic_type COMMA enter_rt_type ne_logic_type_list
## LR(1) items:
ne_logic_type_list -> logic_type COMMA enter_rt_type ne_logic_type_list . [ GT ]
## Transitions:
## Reductions:
-- On GT
--   reduce production ne_logic_type_list -> logic_type COMMA enter_rt_type ne_logic_type_list

State 195:
## Known stack suffix:
## STRUCT
## LR(1) items:
c_keyword -> STRUCT . [ COLON ]
type_spec -> STRUCT . exit_rt_type identifier_or_typename [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On exit_rt_type shift to state 130
## Reductions:
-- On COLON
--   reduce production c_keyword -> STRUCT
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 196:
## Known stack suffix:
## STATIC
## LR(1) items:
c_keyword -> STATIC . [ COLON ]
lexpr_inner -> STATIC . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> STATIC
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> STATIC

State 197:
## Known stack suffix:
## SIZEOF
## LR(1) items:
c_keyword -> SIZEOF . [ COLON ]
lexpr_inner -> SIZEOF . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> SIZEOF . LPAR logic_type RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 109
## Reductions:
-- On COLON
--   reduce production c_keyword -> SIZEOF

State 198:
## Known stack suffix:
## SIGNED
## LR(1) items:
c_keyword -> SIGNED . [ COLON ]
type_spec -> SIGNED . CHAR [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . SHORT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . LONG [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . LONG INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . LONG LONG [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> SIGNED . LONG LONG INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On SHORT shift to state 133
-- On LONG shift to state 134
-- On INT shift to state 138
-- On CHAR shift to state 139
## Reductions:
-- On COLON
--   reduce production c_keyword -> SIGNED

State 199:
## Known stack suffix:
## SHORT
## LR(1) items:
c_keyword -> SHORT . [ COLON ]
type_spec -> SHORT . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> SHORT
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> SHORT

State 200:
## Known stack suffix:
## SEPARATED
## LR(1) items:
lexpr_inner -> SEPARATED . LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 201
## Reductions:

State 201:
## Known stack suffix:
## SEPARATED LPAR
## LR(1) items:
lexpr_inner -> SEPARATED LPAR . ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 526
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 202:
## Known stack suffix:
## RESULT
## LR(1) items:
lexpr_inner -> RESULT . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> RESULT

State 203:
## Known stack suffix:
## REGISTER
## LR(1) items:
lexpr_inner -> REGISTER . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> REGISTER

State 204:
## Known stack suffix:
## PLUS
## LR(1) items:
lexpr_inner -> PLUS . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 525
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 205:
## Known stack suffix:
## OLD
## LR(1) items:
lexpr_inner -> OLD . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 206
## Reductions:

State 206:
## Known stack suffix:
## OLD LPAR
## LR(1) items:
lexpr_inner -> OLD LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 523
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 207:
## Known stack suffix:
## OFFSET
## LR(1) items:
lexpr_inner -> OFFSET . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 208
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 208:
## Known stack suffix:
## OFFSET opt_label_1
## LR(1) items:
lexpr_inner -> OFFSET opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 209
## Reductions:

State 209:
## Known stack suffix:
## OFFSET opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> OFFSET opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 521
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 210:
## Known stack suffix:
## NULL
## LR(1) items:
lexpr_inner -> NULL . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> NULL

State 211:
## Known stack suffix:
## NOT
## LR(1) items:
lexpr_end_rel -> NOT . lexpr_binder [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_inner -> NOT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LET shift to state 218
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FALSE shift to state 265
-- On EXISTS shift to state 266
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 519
-- On lexpr_binder shift to state 520
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 212:
## Known stack suffix:
## NOT
## LR(1) items:
lexpr_inner -> NOT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 519
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 213:
## Known stack suffix:
## MINUS
## LR(1) items:
lexpr_inner -> MINUS . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 518
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 214:
## Known stack suffix:
## LPAR
## LR(1) items:
lexpr_inner -> LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LPAR . range RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LPAR . cast_logic_type RPAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 215
-- On VOID shift to state 110
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 111
-- On UNION shift to state 119
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 122
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 195
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 198
-- On SHORT shift to state 199
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 216
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 217
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 468
-- On INT shift to state 469
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 470
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 471
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 472
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 484
-- On COMPLETE shift to state 58
-- On CHAR shift to state 473
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 474
-- On BOOL shift to state 475
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On type_spec_cv shift to state 485
-- On type_spec shift to state 507
-- On string shift to state 298
-- On range shift to state 509
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_option shift to state 311
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 511
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On cv shift to state 513
-- On constant shift to state 336
-- On cast_logic_type shift to state 515
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option ->

State 215:
## Known stack suffix:
## VOLATILE
## LR(1) items:
acsl_c_keyword -> VOLATILE . [ COLON ]
cv -> VOLATILE . [ VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production acsl_c_keyword -> VOLATILE
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production cv -> VOLATILE

State 216:
## Known stack suffix:
## REAL
## LR(1) items:
is_acsl_other -> REAL . [ COLON ]
type_spec -> REAL . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production is_acsl_other -> REAL
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> REAL

State 217:
## Known stack suffix:
## LONG
## LR(1) items:
c_keyword -> LONG . [ COLON ]
type_spec -> LONG . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> LONG . INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> LONG . LONG [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> LONG . LONG INT [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
type_spec -> LONG . DOUBLE [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On LONG shift to state 143
-- On INT shift to state 145
-- On DOUBLE shift to state 146
## Reductions:
-- On COLON
--   reduce production c_keyword -> LONG
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> LONG

State 218:
## Known stack suffix:
## LET
## LR(1) items:
lexpr_binder -> LET . bounded_var EQUAL lexpr SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 219
-- On IDENTIFIER shift to state 220
-- On identifier shift to state 221
-- On bounded_var shift to state 222
## Reductions:

State 219:
## Known stack suffix:
## TYPENAME
## LR(1) items:
bounded_var -> TYPENAME . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production bounded_var -> TYPENAME

State 220:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production identifier -> IDENTIFIER

State 221:
## Known stack suffix:
## identifier
## LR(1) items:
bounded_var -> identifier . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production bounded_var -> identifier

State 222:
## Known stack suffix:
## LET bounded_var
## LR(1) items:
lexpr_binder -> LET bounded_var . EQUAL lexpr SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On EQUAL shift to state 223
## Reductions:

State 223:
## Known stack suffix:
## LET bounded_var EQUAL
## LR(1) items:
lexpr_binder -> LET bounded_var EQUAL . lexpr SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 481
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 224:
## Known stack suffix:
## LBRACE
## LR(1) items:
lexpr_inner -> LBRACE . lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE . lexpr PIPE binders RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE . lexpr PIPE binders SEMICOLON lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE . field_init RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE . array_init RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE . lexpr WITH update RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LSQUARE shift to state 225
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DOT shift to state 430
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 432
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On field_path_elt shift to state 447
-- On field_init_elt shift to state 450
-- On field_init shift to state 453
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On array_path_elt shift to state 455
-- On array_init_elt shift to state 458
-- On array_init shift to state 461
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 225:
## Known stack suffix:
## LSQUARE
## LR(1) items:
array_path_elt -> LSQUARE . lexpr RSQUARE [ LSQUARE EQUAL DOT ]
array_path_elt -> LSQUARE . range RSQUARE [ LSQUARE EQUAL DOT ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On range shift to state 426
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_option shift to state 311
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 428
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option ->

State 226:
## Known stack suffix:
## LAMBDA
## LR(1) items:
lexpr_binder -> LAMBDA . binders SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 227
-- On decl_spec shift to state 242
-- On binders_reentrance shift to state 243
-- On binders shift to state 247
## Reductions:

State 227:
## Known stack suffix:
## type_spec
## LR(1) items:
decl_spec -> type_spec . var_spec [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On STAR shift to state 158
-- On LPAR shift to state 228
-- On IDENTIFIER shift to state 220
-- On var_spec_bis shift to state 229
-- On var_spec shift to state 241
-- On stars shift to state 238
-- On identifier shift to state 240
## Reductions:

State 228:
## Known stack suffix:
## LPAR
## LR(1) items:
var_spec_bis -> LPAR . var_spec RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On STAR shift to state 158
-- On LPAR shift to state 228
-- On IDENTIFIER shift to state 220
-- On var_spec_bis shift to state 229
-- On var_spec shift to state 236
-- On stars shift to state 238
-- On identifier shift to state 240
## Reductions:

State 229:
## Known stack suffix:
## var_spec_bis
## LR(1) items:
var_spec -> var_spec_bis . [ SEMICOLON RPAR RBRACE COMMA ]
var_spec_bis -> var_spec_bis . LSQUARE constant_option RSQUARE [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
var_spec_bis -> var_spec_bis . LPAR abs_param_type_list RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On LSQUARE shift to state 230
-- On LPAR shift to state 233
## Reductions:
-- On SEMICOLON RPAR RBRACE COMMA
--   reduce production var_spec -> var_spec_bis

State 230:
## Known stack suffix:
## var_spec_bis LSQUARE
## LR(1) items:
var_spec_bis -> var_spec_bis LSQUARE . constant_option RSQUARE [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On constant_option shift to state 231
-- On constant shift to state 165
## Reductions:
-- On RSQUARE
--   reduce production constant_option ->

State 231:
## Known stack suffix:
## var_spec_bis LSQUARE constant_option
## LR(1) items:
var_spec_bis -> var_spec_bis LSQUARE constant_option . RSQUARE [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On RSQUARE shift to state 232
## Reductions:

State 232:
## Known stack suffix:
## var_spec_bis LSQUARE constant_option RSQUARE
## LR(1) items:
var_spec_bis -> var_spec_bis LSQUARE constant_option RSQUARE . [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA
--   reduce production var_spec_bis -> var_spec_bis LSQUARE constant_option RSQUARE

State 233:
## Known stack suffix:
## var_spec_bis LPAR
## LR(1) items:
var_spec_bis -> var_spec_bis LPAR . abs_param_type_list RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 173
-- On abs_param_type_list shift to state 234
-- On abs_param_list shift to state 176
-- On abs_param shift to state 180
## Reductions:
-- On RPAR
--   reduce production abs_param_type_list ->

State 234:
## Known stack suffix:
## var_spec_bis LPAR abs_param_type_list
## LR(1) items:
var_spec_bis -> var_spec_bis LPAR abs_param_type_list . RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On RPAR shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## var_spec_bis LPAR abs_param_type_list RPAR
## LR(1) items:
var_spec_bis -> var_spec_bis LPAR abs_param_type_list RPAR . [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA
--   reduce production var_spec_bis -> var_spec_bis LPAR abs_param_type_list RPAR

State 236:
## Known stack suffix:
## LPAR var_spec
## LR(1) items:
var_spec_bis -> LPAR var_spec . RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On RPAR shift to state 237
## Reductions:

State 237:
## Known stack suffix:
## LPAR var_spec RPAR
## LR(1) items:
var_spec_bis -> LPAR var_spec RPAR . [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA
--   reduce production var_spec_bis -> LPAR var_spec RPAR

State 238:
## Known stack suffix:
## stars
## LR(1) items:
stars -> stars . STAR [ STAR LPAR IDENTIFIER ]
var_spec -> stars . var_spec_bis [ SEMICOLON RPAR RBRACE COMMA ]
## Transitions:
-- On STAR shift to state 169
-- On LPAR shift to state 228
-- On IDENTIFIER shift to state 220
-- On var_spec_bis shift to state 239
-- On identifier shift to state 240
## Reductions:

State 239:
## Known stack suffix:
## stars var_spec_bis
## LR(1) items:
var_spec -> stars var_spec_bis . [ SEMICOLON RPAR RBRACE COMMA ]
var_spec_bis -> var_spec_bis . LSQUARE constant_option RSQUARE [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
var_spec_bis -> var_spec_bis . LPAR abs_param_type_list RPAR [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
-- On LSQUARE shift to state 230
-- On LPAR shift to state 233
## Reductions:
-- On SEMICOLON RPAR RBRACE COMMA
--   reduce production var_spec -> stars var_spec_bis

State 240:
## Known stack suffix:
## identifier
## LR(1) items:
var_spec_bis -> identifier . [ SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE LSQUARE LPAR COMMA
--   reduce production var_spec_bis -> identifier

State 241:
## Known stack suffix:
## type_spec var_spec
## LR(1) items:
decl_spec -> type_spec var_spec . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production decl_spec -> type_spec var_spec

State 242:
## Known stack suffix:
## decl_spec
## LR(1) items:
binders_reentrance -> decl_spec . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production binders_reentrance -> decl_spec

State 243:
## Known stack suffix:
## binders_reentrance
## LR(1) items:
binders -> binders_reentrance . [ SEMICOLON RBRACE ]
binders_reentrance -> binders_reentrance . COMMA decl_spec [ SEMICOLON RBRACE COMMA ]
binders_reentrance -> binders_reentrance . COMMA var_spec [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On COMMA shift to state 244
## Reductions:
-- On SEMICOLON RBRACE
--   reduce production binders -> binders_reentrance

State 244:
## Known stack suffix:
## binders_reentrance COMMA
## LR(1) items:
binders_reentrance -> binders_reentrance COMMA . decl_spec [ SEMICOLON RBRACE COMMA ]
binders_reentrance -> binders_reentrance COMMA . var_spec [ SEMICOLON RBRACE COMMA ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On STAR shift to state 158
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LPAR shift to state 228
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On IDENTIFIER shift to state 220
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On var_spec_bis shift to state 229
-- On var_spec shift to state 245
-- On type_spec shift to state 227
-- On stars shift to state 238
-- On identifier shift to state 240
-- On decl_spec shift to state 246
## Reductions:

State 245:
## Known stack suffix:
## binders_reentrance COMMA var_spec
## LR(1) items:
binders_reentrance -> binders_reentrance COMMA var_spec . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production binders_reentrance -> binders_reentrance COMMA var_spec

State 246:
## Known stack suffix:
## binders_reentrance COMMA decl_spec
## LR(1) items:
binders_reentrance -> binders_reentrance COMMA decl_spec . [ SEMICOLON RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RBRACE COMMA
--   reduce production binders_reentrance -> binders_reentrance COMMA decl_spec

State 247:
## Known stack suffix:
## LAMBDA binders
## LR(1) items:
lexpr_binder -> LAMBDA binders . SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## LAMBDA binders SEMICOLON
## LR(1) items:
lexpr_binder -> LAMBDA binders SEMICOLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 425
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 249:
## Known stack suffix:
## INTER
## LR(1) items:
lexpr_inner -> INTER . LPAR lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## INTER LPAR
## LR(1) items:
lexpr_inner -> INTER LPAR . lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 408
-- On lexpr_rel shift to state 301
-- On lexpr_list shift to state 423
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On RPAR
--   reduce production lexpr_list ->

State 251:
## Known stack suffix:
## INITIALIZED
## LR(1) items:
lexpr_inner -> INITIALIZED . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 252
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 252:
## Known stack suffix:
## INITIALIZED opt_label_1
## LR(1) items:
lexpr_inner -> INITIALIZED opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 253
## Reductions:

State 253:
## Known stack suffix:
## INITIALIZED opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> INITIALIZED opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 421
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 254:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
identifier_or_typename -> IDENTIFIER . [ COLON ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LPAR LE LBRACE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production identifier -> IDENTIFIER
-- On COLON
--   reduce production identifier_or_typename -> IDENTIFIER

State 255:
## Known stack suffix:
## FRESH
## LR(1) items:
lexpr_inner -> FRESH . opt_label_2 LPAR lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 256
-- On opt_label_2 shift to state 257
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 256:
## Known stack suffix:
## opt_label_list
## LR(1) items:
opt_label_2 -> opt_label_list . [ LPAR ]
## Transitions:
## Reductions:
-- On LPAR
--   reduce production opt_label_2 -> opt_label_list

State 257:
## Known stack suffix:
## FRESH opt_label_2
## LR(1) items:
lexpr_inner -> FRESH opt_label_2 . LPAR lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## FRESH opt_label_2 LPAR
## LR(1) items:
lexpr_inner -> FRESH opt_label_2 LPAR . lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 417
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 259:
## Known stack suffix:
## FREEABLE
## LR(1) items:
lexpr_inner -> FREEABLE . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 260
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 260:
## Known stack suffix:
## FREEABLE opt_label_1
## LR(1) items:
lexpr_inner -> FREEABLE opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## FREEABLE opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> FREEABLE opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 415
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 262:
## Known stack suffix:
## FORALL
## LR(1) items:
lexpr_binder -> FORALL . binders SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 227
-- On decl_spec shift to state 242
-- On binders_reentrance shift to state 243
-- On binders shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## FORALL binders
## LR(1) items:
lexpr_binder -> FORALL binders . SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 264
## Reductions:

State 264:
## Known stack suffix:
## FORALL binders SEMICOLON
## LR(1) items:
lexpr_binder -> FORALL binders SEMICOLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 414
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 265:
## Known stack suffix:
## FALSE
## LR(1) items:
lexpr_inner -> FALSE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> FALSE

State 266:
## Known stack suffix:
## EXISTS
## LR(1) items:
lexpr_binder -> EXISTS . binders SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 227
-- On decl_spec shift to state 242
-- On binders_reentrance shift to state 243
-- On binders shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## EXISTS binders
## LR(1) items:
lexpr_binder -> EXISTS binders . SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 268
## Reductions:

State 268:
## Known stack suffix:
## EXISTS binders SEMICOLON
## LR(1) items:
lexpr_binder -> EXISTS binders SEMICOLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 413
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 269:
## Known stack suffix:
## EMPTY
## LR(1) items:
lexpr_inner -> EMPTY . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> EMPTY

State 270:
## Known stack suffix:
## DYNAMIC
## LR(1) items:
lexpr_inner -> DYNAMIC . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> DYNAMIC

State 271:
## Known stack suffix:
## DANGLING
## LR(1) items:
lexpr_inner -> DANGLING . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 272
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 272:
## Known stack suffix:
## DANGLING opt_label_1
## LR(1) items:
lexpr_inner -> DANGLING opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 273
## Reductions:

State 273:
## Known stack suffix:
## DANGLING opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> DANGLING opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 411
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 274:
## Known stack suffix:
## BSUNION
## LR(1) items:
lexpr_inner -> BSUNION . LPAR lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 275
## Reductions:

State 275:
## Known stack suffix:
## BSUNION LPAR
## LR(1) items:
lexpr_inner -> BSUNION LPAR . lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 408
-- On lexpr_rel shift to state 301
-- On lexpr_list shift to state 409
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On RPAR
--   reduce production lexpr_list ->

State 276:
## Known stack suffix:
## BSTYPE
## LR(1) items:
lexpr_inner -> BSTYPE . LPAR type_spec RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> BSTYPE . LPAR type_spec stars RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 277
## Reductions:

State 277:
## Known stack suffix:
## BSTYPE LPAR
## LR(1) items:
lexpr_inner -> BSTYPE LPAR . type_spec RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> BSTYPE LPAR . type_spec stars RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## BSTYPE LPAR type_spec
## LR(1) items:
lexpr_inner -> BSTYPE LPAR type_spec . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> BSTYPE LPAR type_spec . stars RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 158
-- On RPAR shift to state 279
-- On stars shift to state 280
## Reductions:

State 279:
## Known stack suffix:
## BSTYPE LPAR type_spec RPAR
## LR(1) items:
lexpr_inner -> BSTYPE LPAR type_spec RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> BSTYPE LPAR type_spec RPAR

State 280:
## Known stack suffix:
## BSTYPE LPAR type_spec stars
## LR(1) items:
lexpr_inner -> BSTYPE LPAR type_spec stars . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
stars -> stars . STAR [ STAR RPAR ]
## Transitions:
-- On STAR shift to state 169
-- On RPAR shift to state 281
## Reductions:

State 281:
## Known stack suffix:
## BSTYPE LPAR type_spec stars RPAR
## LR(1) items:
lexpr_inner -> BSTYPE LPAR type_spec stars RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> BSTYPE LPAR type_spec stars RPAR

State 282:
## Known stack suffix:
## BLOCK_LENGTH
## LR(1) items:
lexpr_inner -> BLOCK_LENGTH . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 283
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 283:
## Known stack suffix:
## BLOCK_LENGTH opt_label_1
## LR(1) items:
lexpr_inner -> BLOCK_LENGTH opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## BLOCK_LENGTH opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> BLOCK_LENGTH opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 406
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 285:
## Known stack suffix:
## BASE_ADDR
## LR(1) items:
lexpr_inner -> BASE_ADDR . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 286
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 286:
## Known stack suffix:
## BASE_ADDR opt_label_1
## LR(1) items:
lexpr_inner -> BASE_ADDR opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 287
## Reductions:

State 287:
## Known stack suffix:
## BASE_ADDR opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> BASE_ADDR opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 404
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 288:
## Known stack suffix:
## AUTOMATIC
## LR(1) items:
lexpr_inner -> AUTOMATIC . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> AUTOMATIC

State 289:
## Known stack suffix:
## AT
## LR(1) items:
lexpr_inner -> AT . LPAR lexpr COMMA label_name RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 290
## Reductions:

State 290:
## Known stack suffix:
## AT LPAR
## LR(1) items:
lexpr_inner -> AT LPAR . lexpr COMMA label_name RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 400
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 291:
## Known stack suffix:
## AMP
## LR(1) items:
lexpr_inner -> AMP . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 399
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 292:
## Known stack suffix:
## ALLOCATION
## LR(1) items:
lexpr_inner -> ALLOCATION . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 293
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 293:
## Known stack suffix:
## ALLOCATION opt_label_1
## LR(1) items:
lexpr_inner -> ALLOCATION opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 294
## Reductions:

State 294:
## Known stack suffix:
## ALLOCATION opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> ALLOCATION opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 397
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 295:
## Known stack suffix:
## ALLOCABLE
## LR(1) items:
lexpr_inner -> ALLOCABLE . opt_label_1 LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LBRACE shift to state 7
-- On opt_label_list shift to state 88
-- On opt_label_1 shift to state 296
## Reductions:
-- On LPAR
--   reduce production opt_label_list ->

State 296:
## Known stack suffix:
## ALLOCABLE opt_label_1
## LR(1) items:
lexpr_inner -> ALLOCABLE opt_label_1 . LPAR lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## ALLOCABLE opt_label_1 LPAR
## LR(1) items:
lexpr_inner -> ALLOCABLE opt_label_1 LPAR . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 395
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 298:
## Known stack suffix:
## string
## LR(1) items:
lexpr -> string . COLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_inner -> string . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
string -> string . STRING_LITERAL [ WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STRING_LITERAL shift to state 299
-- On COLON shift to state 300
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> string

State 299:
## Known stack suffix:
## string STRING_LITERAL
## LR(1) items:
string -> string STRING_LITERAL . [ WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 COLON BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production string -> string STRING_LITERAL

State 300:
## Known stack suffix:
## string COLON
## LR(1) items:
lexpr -> string COLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 394
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 301:
## Known stack suffix:
## lexpr_rel
## LR(1) items:
lexpr -> lexpr_rel . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr -> lexpr_rel

State 302:
## Known stack suffix:
## lexpr_inner
## LR(1) items:
lexpr_end_rel -> lexpr_inner . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_rel -> lexpr_inner . rel_list [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PLUS shift to state 372
-- On PERCENT shift to state 374
-- On NE shift to state 376
-- On MINUS shift to state 377
-- On LTLT shift to state 379
-- On LTCOLON shift to state 306
-- On LT shift to state 381
-- On LSQUARE shift to state 308
-- On LE shift to state 382
-- On GTGT shift to state 383
-- On GT shift to state 385
-- On GE shift to state 386
-- On EQUAL shift to state 387
-- On EQ shift to state 388
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
-- On relation shift to state 389
-- On rel_list shift to state 393
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_end_rel -> lexpr_inner

State 303:
## Known stack suffix:
## lexpr_inner STAR
## LR(1) items:
lexpr_inner -> lexpr_inner STAR . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 305
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 304:
## Known stack suffix:
## string
## LR(1) items:
lexpr_inner -> string . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
string -> string . STRING_LITERAL [ WRITES WITH STRING_LITERAL STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STRING_LITERAL shift to state 299
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> string

State 305:
## Known stack suffix:
## lexpr_inner STAR lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner STAR lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner STAR lexpr_inner

State 306:
## Known stack suffix:
## lexpr_inner LTCOLON
## LR(1) items:
lexpr_inner -> lexpr_inner LTCOLON . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 307
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 307:
## Known stack suffix:
## lexpr_inner LTCOLON lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner LTCOLON lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner LTCOLON lexpr_inner

State 308:
## Known stack suffix:
## lexpr_inner LSQUARE
## LR(1) items:
lexpr_inner -> lexpr_inner LSQUARE . range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner LSQUARE . lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On range shift to state 309
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_option shift to state 311
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 361
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option ->

State 309:
## Known stack suffix:
## lexpr_inner LSQUARE range
## LR(1) items:
lexpr_inner -> lexpr_inner LSQUARE range . RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RSQUARE shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## lexpr_inner LSQUARE range RSQUARE
## LR(1) items:
lexpr_inner -> lexpr_inner LSQUARE range RSQUARE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner LSQUARE range RSQUARE

State 311:
## Known stack suffix:
## lexpr_option
## LR(1) items:
range -> lexpr_option . DOTDOT lexpr_option [ RSQUARE RPAR ]
## Transitions:
-- On DOTDOT shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## lexpr_option DOTDOT
## LR(1) items:
range -> lexpr_option DOTDOT . lexpr_option [ RSQUARE RPAR ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_option shift to state 313
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 316
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On RSQUARE RPAR
--   reduce production lexpr_option ->

State 313:
## Known stack suffix:
## lexpr_option DOTDOT lexpr_option
## LR(1) items:
range -> lexpr_option DOTDOT lexpr_option . [ RSQUARE RPAR ]
## Transitions:
## Reductions:
-- On RSQUARE RPAR
--   reduce production range -> lexpr_option DOTDOT lexpr_option

State 314:
## Known stack suffix:
## lexpr_end_rel
## LR(1) items:
lexpr_rel -> lexpr_end_rel . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_rel -> lexpr_end_rel

State 315:
## Known stack suffix:
## lexpr_binder
## LR(1) items:
lexpr_end_rel -> lexpr_binder . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_end_rel -> lexpr_binder

State 316:
## Known stack suffix:
## lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RSQUARE RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_option -> lexpr . [ RSQUARE RPAR ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On RSQUARE RPAR
--   reduce production lexpr_option -> lexpr

State 317:
## Known stack suffix:
## lexpr QUESTION
## LR(1) items:
lexpr -> lexpr QUESTION . lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 318
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 318:
## Known stack suffix:
## lexpr QUESTION lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COLON2 BIMPLIES BIFF AND AMP ]
lexpr -> lexpr QUESTION lexpr . COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COLON2 shift to state 359
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 319:
## Known stack suffix:
## lexpr PIPE
## LR(1) items:
lexpr -> lexpr PIPE . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 320
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 320:
## Known stack suffix:
## lexpr PIPE lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr PIPE lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS AND ALLOCATES
--   reduce production lexpr -> lexpr PIPE lexpr

State 321:
## Known stack suffix:
## lexpr HAT
## LR(1) items:
lexpr -> lexpr HAT . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 322
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 322:
## Known stack suffix:
## lexpr HAT lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr HAT lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND ALLOCATES
--   reduce production lexpr -> lexpr HAT lexpr

State 323:
## Known stack suffix:
## lexpr AMP
## LR(1) items:
lexpr -> lexpr AMP . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 324
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 324:
## Known stack suffix:
## lexpr AMP lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr AMP lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr -> lexpr AMP lexpr

State 325:
## Known stack suffix:
## identifier
## LR(1) items:
lexpr_inner -> identifier . LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier . LBRACE ne_label_args RBRACE LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier . LBRACE ne_label_args RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 326
-- On LBRACE shift to state 350
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> identifier

State 326:
## Known stack suffix:
## identifier LPAR
## LR(1) items:
lexpr_inner -> identifier LPAR . ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 327
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 327:
## Known stack suffix:
## identifier LPAR ne_lexpr_list
## LR(1) items:
lexpr_inner -> identifier LPAR ne_lexpr_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## identifier LPAR ne_lexpr_list RPAR
## LR(1) items:
lexpr_inner -> identifier LPAR ne_lexpr_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> identifier LPAR ne_lexpr_list RPAR

State 329:
## Known stack suffix:
## lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
ne_lexpr_list -> lexpr . [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
ne_lexpr_list -> lexpr . COMMA ne_lexpr_list [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 348
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_lexpr_list -> lexpr

State 330:
## Known stack suffix:
## lexpr OR
## LR(1) items:
lexpr -> lexpr OR . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 331
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 331:
## Known stack suffix:
## lexpr OR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr OR lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On PIPE shift to state 319
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION OR IMPLIES IFF IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> lexpr OR lexpr

State 332:
## Known stack suffix:
## lexpr HATHAT
## LR(1) items:
lexpr -> lexpr HATHAT . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 333
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 333:
## Known stack suffix:
## lexpr HATHAT lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr HATHAT lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On PIPE shift to state 319
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION OR IMPLIES IFF IDENTIFIER HATHAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> lexpr HATHAT lexpr

State 334:
## Known stack suffix:
## lexpr BIMPLIES
## LR(1) items:
lexpr -> lexpr BIMPLIES . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 335
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 335:
## Known stack suffix:
## lexpr BIMPLIES lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr BIMPLIES lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIFF BEHAVIOR ASSUMES ASSIGNS AND ALLOCATES
--   reduce production lexpr -> lexpr BIMPLIES lexpr

State 336:
## Known stack suffix:
## constant
## LR(1) items:
lexpr_inner -> constant . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> constant

State 337:
## Known stack suffix:
## any_identifier
## LR(1) items:
lexpr -> any_identifier . COLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On COLON shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## any_identifier COLON
## LR(1) items:
lexpr -> any_identifier COLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 339
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 339:
## Known stack suffix:
## any_identifier COLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> any_identifier COLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> any_identifier COLON lexpr

State 340:
## Known stack suffix:
## lexpr IMPLIES
## LR(1) items:
lexpr -> lexpr IMPLIES . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 341
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 341:
## Known stack suffix:
## lexpr IMPLIES lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr IMPLIES lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION IFF IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> lexpr IMPLIES lexpr

State 342:
## Known stack suffix:
## lexpr BIFF
## LR(1) items:
lexpr -> lexpr BIFF . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 343
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 343:
## Known stack suffix:
## lexpr BIFF lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr BIFF lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIFF BEHAVIOR ASSUMES ASSIGNS AND ALLOCATES
--   reduce production lexpr -> lexpr BIFF lexpr

State 344:
## Known stack suffix:
## lexpr AND
## LR(1) items:
lexpr -> lexpr AND . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 345
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 345:
## Known stack suffix:
## lexpr AND lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr AND lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On PIPE shift to state 319
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION OR IMPLIES IFF IDENTIFIER HATHAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS AND ALLOCATES
--   reduce production lexpr -> lexpr AND lexpr

State 346:
## Known stack suffix:
## lexpr IFF
## LR(1) items:
lexpr -> lexpr IFF . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 347
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 347:
## Known stack suffix:
## lexpr IFF lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr IFF lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION IFF IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> lexpr IFF lexpr

State 348:
## Known stack suffix:
## lexpr COMMA
## LR(1) items:
ne_lexpr_list -> lexpr COMMA . ne_lexpr_list [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 349
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 349:
## Known stack suffix:
## lexpr COMMA ne_lexpr_list
## LR(1) items:
ne_lexpr_list -> lexpr COMMA ne_lexpr_list . [ WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES SEMICOLON RPAR RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_lexpr_list -> lexpr COMMA ne_lexpr_list

State 350:
## Known stack suffix:
## identifier LBRACE
## LR(1) items:
lexpr_inner -> identifier LBRACE . ne_label_args RBRACE LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier LBRACE . ne_label_args RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On ne_label_args shift to state 351
-- On identifier_or_typename shift to state 356
## Reductions:

State 351:
## Known stack suffix:
## identifier LBRACE ne_label_args
## LR(1) items:
lexpr_inner -> identifier LBRACE ne_label_args . RBRACE LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier LBRACE ne_label_args . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RBRACE shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## identifier LBRACE ne_label_args RBRACE
## LR(1) items:
lexpr_inner -> identifier LBRACE ne_label_args RBRACE . LPAR ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> identifier LBRACE ne_label_args RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LPAR shift to state 353
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> identifier LBRACE ne_label_args RBRACE

State 353:
## Known stack suffix:
## identifier LBRACE ne_label_args RBRACE LPAR
## LR(1) items:
lexpr_inner -> identifier LBRACE ne_label_args RBRACE LPAR . ne_lexpr_list RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 354
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 354:
## Known stack suffix:
## identifier LBRACE ne_label_args RBRACE LPAR ne_lexpr_list
## LR(1) items:
lexpr_inner -> identifier LBRACE ne_label_args RBRACE LPAR ne_lexpr_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 355
## Reductions:

State 355:
## Known stack suffix:
## identifier LBRACE ne_label_args RBRACE LPAR ne_lexpr_list RPAR
## LR(1) items:
lexpr_inner -> identifier LBRACE ne_label_args RBRACE LPAR ne_lexpr_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> identifier LBRACE ne_label_args RBRACE LPAR ne_lexpr_list RPAR

State 356:
## Known stack suffix:
## identifier_or_typename
## LR(1) items:
ne_label_args -> identifier_or_typename . [ RBRACE ]
ne_label_args -> identifier_or_typename . COMMA ne_label_args [ RBRACE ]
## Transitions:
-- On COMMA shift to state 357
## Reductions:
-- On RBRACE
--   reduce production ne_label_args -> identifier_or_typename

State 357:
## Known stack suffix:
## identifier_or_typename COMMA
## LR(1) items:
ne_label_args -> identifier_or_typename COMMA . ne_label_args [ RBRACE ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On ne_label_args shift to state 358
-- On identifier_or_typename shift to state 356
## Reductions:

State 358:
## Known stack suffix:
## identifier_or_typename COMMA ne_label_args
## LR(1) items:
ne_label_args -> identifier_or_typename COMMA ne_label_args . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production ne_label_args -> identifier_or_typename COMMA ne_label_args

State 359:
## Known stack suffix:
## lexpr QUESTION lexpr COLON2
## LR(1) items:
lexpr -> lexpr QUESTION lexpr COLON2 . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 360
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 360:
## Known stack suffix:
## lexpr QUESTION lexpr COLON2 lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr QUESTION lexpr COLON2 lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> lexpr QUESTION lexpr COLON2 lexpr

State 361:
## Known stack suffix:
## lexpr_inner LSQUARE lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr_inner -> lexpr_inner LSQUARE lexpr . RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_option -> lexpr . [ DOTDOT ]
## Transitions:
-- On RSQUARE shift to state 362
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option -> lexpr

State 362:
## Known stack suffix:
## lexpr_inner LSQUARE lexpr RSQUARE
## LR(1) items:
lexpr_inner -> lexpr_inner LSQUARE lexpr RSQUARE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner LSQUARE lexpr RSQUARE

State 363:
## Known stack suffix:
## lexpr_inner DOT
## LR(1) items:
lexpr_inner -> lexpr_inner DOT . identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 364
## Reductions:

State 364:
## Known stack suffix:
## lexpr_inner DOT identifier_or_typename
## LR(1) items:
lexpr_inner -> lexpr_inner DOT identifier_or_typename . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner DOT identifier_or_typename

State 365:
## Known stack suffix:
## lexpr_inner COLONGT
## LR(1) items:
lexpr_inner -> lexpr_inner COLONGT . logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner COLONGT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VOID shift to state 125
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 128
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRUCT shift to state 129
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On REAL shift to state 141
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LONG shift to state 142
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FLOAT shift to state 149
-- On FALSE shift to state 265
-- On ENUM shift to state 150
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 153
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CHAR shift to state 154
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On type_spec shift to state 157
-- On string shift to state 304
-- On logic_type shift to state 366
-- On lexpr_inner shift to state 367
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 366:
## Known stack suffix:
## lexpr_inner COLONGT logic_type
## LR(1) items:
lexpr_inner -> lexpr_inner COLONGT logic_type . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner COLONGT logic_type

State 367:
## Known stack suffix:
## lexpr_inner COLONGT lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner COLONGT lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner COLONGT lexpr_inner

State 368:
## Known stack suffix:
## lexpr_inner ARROW
## LR(1) items:
lexpr_inner -> lexpr_inner ARROW . identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 369
## Reductions:

State 369:
## Known stack suffix:
## lexpr_inner ARROW identifier_or_typename
## LR(1) items:
lexpr_inner -> lexpr_inner ARROW identifier_or_typename . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner ARROW identifier_or_typename

State 370:
## Known stack suffix:
## lexpr_inner SLASH
## LR(1) items:
lexpr_inner -> lexpr_inner SLASH . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 371
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 371:
## Known stack suffix:
## lexpr_inner SLASH lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner SLASH lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner SLASH lexpr_inner

State 372:
## Known stack suffix:
## lexpr_inner PLUS
## LR(1) items:
lexpr_inner -> lexpr_inner PLUS . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 373
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 373:
## Known stack suffix:
## lexpr_inner PLUS lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner PLUS lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PERCENT shift to state 374
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner PLUS lexpr_inner

State 374:
## Known stack suffix:
## lexpr_inner PERCENT
## LR(1) items:
lexpr_inner -> lexpr_inner PERCENT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 375
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 375:
## Known stack suffix:
## lexpr_inner PERCENT lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner PERCENT lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner PERCENT lexpr_inner

State 376:
## Known stack suffix:
## NE
## LR(1) items:
relation -> NE . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> NE

State 377:
## Known stack suffix:
## lexpr_inner MINUS
## LR(1) items:
lexpr_inner -> lexpr_inner MINUS . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 378
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 378:
## Known stack suffix:
## lexpr_inner MINUS lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner MINUS lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PERCENT shift to state 374
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner MINUS lexpr_inner

State 379:
## Known stack suffix:
## lexpr_inner LTLT
## LR(1) items:
lexpr_inner -> lexpr_inner LTLT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 380
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 380:
## Known stack suffix:
## lexpr_inner LTLT lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner LTLT lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PLUS shift to state 372
-- On PERCENT shift to state 374
-- On MINUS shift to state 377
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR NE LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner LTLT lexpr_inner

State 381:
## Known stack suffix:
## LT
## LR(1) items:
relation -> LT . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> LT

State 382:
## Known stack suffix:
## LE
## LR(1) items:
relation -> LE . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> LE

State 383:
## Known stack suffix:
## lexpr_inner GTGT
## LR(1) items:
lexpr_inner -> lexpr_inner GTGT . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 384
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 384:
## Known stack suffix:
## lexpr_inner GTGT lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner GTGT lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PLUS shift to state 372
-- On PERCENT shift to state 374
-- On MINUS shift to state 377
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR NE LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> lexpr_inner GTGT lexpr_inner

State 385:
## Known stack suffix:
## GT
## LR(1) items:
relation -> GT . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> GT

State 386:
## Known stack suffix:
## GE
## LR(1) items:
relation -> GE . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> GE

State 387:
## Known stack suffix:
## EQUAL
## LR(1) items:
relation -> EQUAL . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> EQUAL

State 388:
## Known stack suffix:
## EQ
## LR(1) items:
relation -> EQ . [ VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE ]
## Transitions:
## Reductions:
-- On VALID_READ VALID_RANGE VALID_INDEX VALID UNALLOCATED TYPEOF TRUE TILDE STRING_LITERAL STATIC STAR SIZEOF SEPARATED RESULT REGISTER PLUS OLD OFFSET NULL NOT MINUS LPAR LET LBRACE LAMBDA INTER INITIALIZED IDENTIFIER FRESH FREEABLE FORALL FALSE EXISTS EMPTY DYNAMIC DANGLING CONSTANT10 CONSTANT BSUNION BSTYPE BLOCK_LENGTH BASE_ADDR AUTOMATIC AT AMP ALLOCATION ALLOCABLE
--   reduce production relation -> EQ

State 389:
## Known stack suffix:
## relation
## LR(1) items:
rel_list -> relation . lexpr_end_rel [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
rel_list -> relation . lexpr_inner rel_list [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LET shift to state 218
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FALSE shift to state 265
-- On EXISTS shift to state 266
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 390
-- On lexpr_end_rel shift to state 392
-- On lexpr_binder shift to state 315
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 390:
## Known stack suffix:
## relation lexpr_inner
## LR(1) items:
lexpr_end_rel -> lexpr_inner . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
rel_list -> relation lexpr_inner . rel_list [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On STAR shift to state 303
-- On SLASH shift to state 370
-- On PLUS shift to state 372
-- On PERCENT shift to state 374
-- On NE shift to state 376
-- On MINUS shift to state 377
-- On LTLT shift to state 379
-- On LTCOLON shift to state 306
-- On LT shift to state 381
-- On LSQUARE shift to state 308
-- On LE shift to state 382
-- On GTGT shift to state 383
-- On GT shift to state 385
-- On GE shift to state 386
-- On EQUAL shift to state 387
-- On EQ shift to state 388
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
-- On relation shift to state 389
-- On rel_list shift to state 391
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_end_rel -> lexpr_inner

State 391:
## Known stack suffix:
## relation lexpr_inner rel_list
## LR(1) items:
rel_list -> relation lexpr_inner rel_list . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production rel_list -> relation lexpr_inner rel_list

State 392:
## Known stack suffix:
## relation lexpr_end_rel
## LR(1) items:
rel_list -> relation lexpr_end_rel . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production rel_list -> relation lexpr_end_rel

State 393:
## Known stack suffix:
## lexpr_inner rel_list
## LR(1) items:
lexpr_rel -> lexpr_inner rel_list . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_rel -> lexpr_inner rel_list

State 394:
## Known stack suffix:
## string COLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> string COLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr -> string COLON lexpr

State 395:
## Known stack suffix:
## ALLOCABLE opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> ALLOCABLE opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 396
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 396:
## Known stack suffix:
## ALLOCABLE opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> ALLOCABLE opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> ALLOCABLE opt_label_1 LPAR lexpr RPAR

State 397:
## Known stack suffix:
## ALLOCATION opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> ALLOCATION opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 398
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 398:
## Known stack suffix:
## ALLOCATION opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> ALLOCATION opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> ALLOCATION opt_label_1 LPAR lexpr RPAR

State 399:
## Known stack suffix:
## AMP lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> AMP lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> AMP lexpr_inner

State 400:
## Known stack suffix:
## AT LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr_inner -> AT LPAR lexpr . COMMA label_name RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 401
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 401:
## Known stack suffix:
## AT LPAR lexpr COMMA
## LR(1) items:
lexpr_inner -> AT LPAR lexpr COMMA . label_name RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On label_name shift to state 402
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 86
-- On acsl_c_keyword shift to state 87
## Reductions:

State 402:
## Known stack suffix:
## AT LPAR lexpr COMMA label_name
## LR(1) items:
lexpr_inner -> AT LPAR lexpr COMMA label_name . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 403
## Reductions:

State 403:
## Known stack suffix:
## AT LPAR lexpr COMMA label_name RPAR
## LR(1) items:
lexpr_inner -> AT LPAR lexpr COMMA label_name RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> AT LPAR lexpr COMMA label_name RPAR

State 404:
## Known stack suffix:
## BASE_ADDR opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> BASE_ADDR opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 405
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 405:
## Known stack suffix:
## BASE_ADDR opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> BASE_ADDR opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> BASE_ADDR opt_label_1 LPAR lexpr RPAR

State 406:
## Known stack suffix:
## BLOCK_LENGTH opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> BLOCK_LENGTH opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 407
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 407:
## Known stack suffix:
## BLOCK_LENGTH opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> BLOCK_LENGTH opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> BLOCK_LENGTH opt_label_1 LPAR lexpr RPAR

State 408:
## Known stack suffix:
## ne_lexpr_list
## LR(1) items:
lexpr_list -> ne_lexpr_list . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production lexpr_list -> ne_lexpr_list

State 409:
## Known stack suffix:
## BSUNION LPAR lexpr_list
## LR(1) items:
lexpr_inner -> BSUNION LPAR lexpr_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 410
## Reductions:

State 410:
## Known stack suffix:
## BSUNION LPAR lexpr_list RPAR
## LR(1) items:
lexpr_inner -> BSUNION LPAR lexpr_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> BSUNION LPAR lexpr_list RPAR

State 411:
## Known stack suffix:
## DANGLING opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> DANGLING opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 412
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 412:
## Known stack suffix:
## DANGLING opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> DANGLING opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> DANGLING opt_label_1 LPAR lexpr RPAR

State 413:
## Known stack suffix:
## EXISTS binders SEMICOLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_binder -> EXISTS binders SEMICOLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr_binder -> EXISTS binders SEMICOLON lexpr

State 414:
## Known stack suffix:
## FORALL binders SEMICOLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_binder -> FORALL binders SEMICOLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr_binder -> FORALL binders SEMICOLON lexpr

State 415:
## Known stack suffix:
## FREEABLE opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> FREEABLE opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 416
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 416:
## Known stack suffix:
## FREEABLE opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> FREEABLE opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> FREEABLE opt_label_1 LPAR lexpr RPAR

State 417:
## Known stack suffix:
## FRESH opt_label_2 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr_inner -> FRESH opt_label_2 LPAR lexpr . COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 418
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 418:
## Known stack suffix:
## FRESH opt_label_2 LPAR lexpr COMMA
## LR(1) items:
lexpr_inner -> FRESH opt_label_2 LPAR lexpr COMMA . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 419
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 419:
## Known stack suffix:
## FRESH opt_label_2 LPAR lexpr COMMA lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> FRESH opt_label_2 LPAR lexpr COMMA lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 420
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 420:
## Known stack suffix:
## FRESH opt_label_2 LPAR lexpr COMMA lexpr RPAR
## LR(1) items:
lexpr_inner -> FRESH opt_label_2 LPAR lexpr COMMA lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> FRESH opt_label_2 LPAR lexpr COMMA lexpr RPAR

State 421:
## Known stack suffix:
## INITIALIZED opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> INITIALIZED opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 422
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 422:
## Known stack suffix:
## INITIALIZED opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> INITIALIZED opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> INITIALIZED opt_label_1 LPAR lexpr RPAR

State 423:
## Known stack suffix:
## INTER LPAR lexpr_list
## LR(1) items:
lexpr_inner -> INTER LPAR lexpr_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## INTER LPAR lexpr_list RPAR
## LR(1) items:
lexpr_inner -> INTER LPAR lexpr_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> INTER LPAR lexpr_list RPAR

State 425:
## Known stack suffix:
## LAMBDA binders SEMICOLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_binder -> LAMBDA binders SEMICOLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr_binder -> LAMBDA binders SEMICOLON lexpr

State 426:
## Known stack suffix:
## LSQUARE range
## LR(1) items:
array_path_elt -> LSQUARE range . RSQUARE [ LSQUARE EQUAL DOT ]
## Transitions:
-- On RSQUARE shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## LSQUARE range RSQUARE
## LR(1) items:
array_path_elt -> LSQUARE range RSQUARE . [ LSQUARE EQUAL DOT ]
## Transitions:
## Reductions:
-- On LSQUARE EQUAL DOT
--   reduce production array_path_elt -> LSQUARE range RSQUARE

State 428:
## Known stack suffix:
## LSQUARE lexpr
## LR(1) items:
array_path_elt -> LSQUARE lexpr . RSQUARE [ LSQUARE EQUAL DOT ]
lexpr -> lexpr . IMPLIES lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RSQUARE QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr_option -> lexpr . [ DOTDOT ]
## Transitions:
-- On RSQUARE shift to state 429
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option -> lexpr

State 429:
## Known stack suffix:
## LSQUARE lexpr RSQUARE
## LR(1) items:
array_path_elt -> LSQUARE lexpr RSQUARE . [ LSQUARE EQUAL DOT ]
## Transitions:
## Reductions:
-- On LSQUARE EQUAL DOT
--   reduce production array_path_elt -> LSQUARE lexpr RSQUARE

State 430:
## Known stack suffix:
## DOT
## LR(1) items:
field_path_elt -> DOT . identifier_or_typename [ LSQUARE EQUAL DOT ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 431
## Reductions:

State 431:
## Known stack suffix:
## DOT identifier_or_typename
## LR(1) items:
field_path_elt -> DOT identifier_or_typename . [ LSQUARE EQUAL DOT ]
## Transitions:
## Reductions:
-- On LSQUARE EQUAL DOT
--   reduce production field_path_elt -> DOT identifier_or_typename

State 432:
## Known stack suffix:
## LBRACE lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> LBRACE lexpr . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE lexpr . PIPE binders RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE lexpr . PIPE binders SEMICOLON lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE lexpr . WITH update RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WITH shift to state 433
-- On RBRACE shift to state 466
-- On QUESTION shift to state 317
-- On PIPE shift to state 467
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 433:
## Known stack suffix:
## LBRACE lexpr WITH
## LR(1) items:
lexpr_inner -> LBRACE lexpr WITH . update RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LSQUARE shift to state 225
-- On DOT shift to state 430
-- On update_elt shift to state 434
-- On update shift to state 464
-- On path_elt shift to state 437
-- On path shift to state 441
-- On field_path_elt shift to state 439
-- On array_path_elt shift to state 440
## Reductions:

State 434:
## Known stack suffix:
## update_elt
## LR(1) items:
update -> update_elt . [ RBRACE ]
update -> update_elt . COMMA update [ RBRACE ]
## Transitions:
-- On COMMA shift to state 435
## Reductions:
-- On RBRACE
--   reduce production update -> update_elt

State 435:
## Known stack suffix:
## update_elt COMMA
## LR(1) items:
update -> update_elt COMMA . update [ RBRACE ]
## Transitions:
-- On LSQUARE shift to state 225
-- On DOT shift to state 430
-- On update_elt shift to state 434
-- On update shift to state 436
-- On path_elt shift to state 437
-- On path shift to state 441
-- On field_path_elt shift to state 439
-- On array_path_elt shift to state 440
## Reductions:

State 436:
## Known stack suffix:
## update_elt COMMA update
## LR(1) items:
update -> update_elt COMMA update . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production update -> update_elt COMMA update

State 437:
## Known stack suffix:
## path_elt
## LR(1) items:
path -> path_elt . [ EQUAL ]
path -> path_elt . path [ EQUAL ]
## Transitions:
-- On LSQUARE shift to state 225
-- On DOT shift to state 430
-- On path_elt shift to state 437
-- On path shift to state 438
-- On field_path_elt shift to state 439
-- On array_path_elt shift to state 440
## Reductions:
-- On EQUAL
--   reduce production path -> path_elt

State 438:
## Known stack suffix:
## path_elt path
## LR(1) items:
path -> path_elt path . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production path -> path_elt path

State 439:
## Known stack suffix:
## field_path_elt
## LR(1) items:
path_elt -> field_path_elt . [ LSQUARE EQUAL DOT ]
## Transitions:
## Reductions:
-- On LSQUARE EQUAL DOT
--   reduce production path_elt -> field_path_elt

State 440:
## Known stack suffix:
## array_path_elt
## LR(1) items:
path_elt -> array_path_elt . [ LSQUARE EQUAL DOT ]
## Transitions:
## Reductions:
-- On LSQUARE EQUAL DOT
--   reduce production path_elt -> array_path_elt

State 441:
## Known stack suffix:
## path
## LR(1) items:
update_elt -> path . EQUAL lexpr [ RBRACE COMMA ]
update_elt -> path . EQUAL LBRACE WITH update RBRACE [ RBRACE COMMA ]
## Transitions:
-- On EQUAL shift to state 442
## Reductions:

State 442:
## Known stack suffix:
## path EQUAL
## LR(1) items:
update_elt -> path EQUAL . lexpr [ RBRACE COMMA ]
update_elt -> path EQUAL . LBRACE WITH update RBRACE [ RBRACE COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 443
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 463
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 443:
## Known stack suffix:
## path EQUAL LBRACE
## LR(1) items:
lexpr_inner -> LBRACE . lexpr RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
lexpr_inner -> LBRACE . lexpr PIPE binders RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
lexpr_inner -> LBRACE . lexpr PIPE binders SEMICOLON lexpr RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
lexpr_inner -> LBRACE . field_init RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
lexpr_inner -> LBRACE . array_init RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
lexpr_inner -> LBRACE . lexpr WITH update RBRACE [ STAR SLASH RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF HATHAT HAT GTGT GT GE EQUAL EQ DOT COMMA COLONGT BIMPLIES BIFF ARROW AND AMP ]
update_elt -> path EQUAL LBRACE . WITH update RBRACE [ RBRACE COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On WITH shift to state 444
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LSQUARE shift to state 225
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DOT shift to state 430
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 432
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On field_path_elt shift to state 447
-- On field_init_elt shift to state 450
-- On field_init shift to state 453
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On array_path_elt shift to state 455
-- On array_init_elt shift to state 458
-- On array_init shift to state 461
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 444:
## Known stack suffix:
## path EQUAL LBRACE WITH
## LR(1) items:
update_elt -> path EQUAL LBRACE WITH . update RBRACE [ RBRACE COMMA ]
## Transitions:
-- On LSQUARE shift to state 225
-- On DOT shift to state 430
-- On update_elt shift to state 434
-- On update shift to state 445
-- On path_elt shift to state 437
-- On path shift to state 441
-- On field_path_elt shift to state 439
-- On array_path_elt shift to state 440
## Reductions:

State 445:
## Known stack suffix:
## path EQUAL LBRACE WITH update
## LR(1) items:
update_elt -> path EQUAL LBRACE WITH update . RBRACE [ RBRACE COMMA ]
## Transitions:
-- On RBRACE shift to state 446
## Reductions:

State 446:
## Known stack suffix:
## path EQUAL LBRACE WITH update RBRACE
## LR(1) items:
update_elt -> path EQUAL LBRACE WITH update RBRACE . [ RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RBRACE COMMA
--   reduce production update_elt -> path EQUAL LBRACE WITH update RBRACE

State 447:
## Known stack suffix:
## field_path_elt
## LR(1) items:
field_init_elt -> field_path_elt . EQUAL lexpr [ RBRACE COMMA ]
## Transitions:
-- On EQUAL shift to state 448
## Reductions:

State 448:
## Known stack suffix:
## field_path_elt EQUAL
## LR(1) items:
field_init_elt -> field_path_elt EQUAL . lexpr [ RBRACE COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 449
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 449:
## Known stack suffix:
## field_path_elt EQUAL lexpr
## LR(1) items:
field_init_elt -> field_path_elt EQUAL lexpr . [ RBRACE COMMA ]
lexpr -> lexpr . IMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On RBRACE COMMA
--   reduce production field_init_elt -> field_path_elt EQUAL lexpr

State 450:
## Known stack suffix:
## field_init_elt
## LR(1) items:
field_init -> field_init_elt . [ RBRACE ]
field_init -> field_init_elt . COMMA field_init [ RBRACE ]
## Transitions:
-- On COMMA shift to state 451
## Reductions:
-- On RBRACE
--   reduce production field_init -> field_init_elt

State 451:
## Known stack suffix:
## field_init_elt COMMA
## LR(1) items:
field_init -> field_init_elt COMMA . field_init [ RBRACE ]
## Transitions:
-- On DOT shift to state 430
-- On field_path_elt shift to state 447
-- On field_init_elt shift to state 450
-- On field_init shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## field_init_elt COMMA field_init
## LR(1) items:
field_init -> field_init_elt COMMA field_init . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production field_init -> field_init_elt COMMA field_init

State 453:
## Known stack suffix:
## LBRACE field_init
## LR(1) items:
lexpr_inner -> LBRACE field_init . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RBRACE shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## LBRACE field_init RBRACE
## LR(1) items:
lexpr_inner -> LBRACE field_init RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE field_init RBRACE

State 455:
## Known stack suffix:
## array_path_elt
## LR(1) items:
array_init_elt -> array_path_elt . EQUAL lexpr [ RBRACE COMMA ]
## Transitions:
-- On EQUAL shift to state 456
## Reductions:

State 456:
## Known stack suffix:
## array_path_elt EQUAL
## LR(1) items:
array_init_elt -> array_path_elt EQUAL . lexpr [ RBRACE COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 457
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 457:
## Known stack suffix:
## array_path_elt EQUAL lexpr
## LR(1) items:
array_init_elt -> array_path_elt EQUAL lexpr . [ RBRACE COMMA ]
lexpr -> lexpr . IMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On RBRACE COMMA
--   reduce production array_init_elt -> array_path_elt EQUAL lexpr

State 458:
## Known stack suffix:
## array_init_elt
## LR(1) items:
array_init -> array_init_elt . [ RBRACE ]
array_init -> array_init_elt . COMMA array_init [ RBRACE ]
## Transitions:
-- On COMMA shift to state 459
## Reductions:
-- On RBRACE
--   reduce production array_init -> array_init_elt

State 459:
## Known stack suffix:
## array_init_elt COMMA
## LR(1) items:
array_init -> array_init_elt COMMA . array_init [ RBRACE ]
## Transitions:
-- On LSQUARE shift to state 225
-- On array_path_elt shift to state 455
-- On array_init_elt shift to state 458
-- On array_init shift to state 460
## Reductions:

State 460:
## Known stack suffix:
## array_init_elt COMMA array_init
## LR(1) items:
array_init -> array_init_elt COMMA array_init . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production array_init -> array_init_elt COMMA array_init

State 461:
## Known stack suffix:
## LBRACE array_init
## LR(1) items:
lexpr_inner -> LBRACE array_init . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RBRACE shift to state 462
## Reductions:

State 462:
## Known stack suffix:
## LBRACE array_init RBRACE
## LR(1) items:
lexpr_inner -> LBRACE array_init RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE array_init RBRACE

State 463:
## Known stack suffix:
## path EQUAL lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
update_elt -> path EQUAL lexpr . [ RBRACE COMMA ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On RBRACE COMMA
--   reduce production update_elt -> path EQUAL lexpr

State 464:
## Known stack suffix:
## LBRACE lexpr WITH update
## LR(1) items:
lexpr_inner -> LBRACE lexpr WITH update . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RBRACE shift to state 465
## Reductions:

State 465:
## Known stack suffix:
## LBRACE lexpr WITH update RBRACE
## LR(1) items:
lexpr_inner -> LBRACE lexpr WITH update RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE lexpr WITH update RBRACE

State 466:
## Known stack suffix:
## LBRACE lexpr RBRACE
## LR(1) items:
lexpr_inner -> LBRACE lexpr RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE lexpr RBRACE

State 467:
## Known stack suffix:
## LBRACE lexpr PIPE
## LR(1) items:
lexpr -> lexpr PIPE . lexpr [ WITH RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> LBRACE lexpr PIPE . binders RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE lexpr PIPE . binders SEMICOLON lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 110
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 111
-- On UNION shift to state 119
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 122
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 195
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 198
-- On SHORT shift to state 199
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 216
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 217
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 468
-- On INT shift to state 469
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 470
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 471
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 472
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 473
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 474
-- On BOOL shift to state 475
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On type_spec shift to state 227
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 320
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On decl_spec shift to state 242
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On binders_reentrance shift to state 243
-- On binders shift to state 476
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 468:
## Known stack suffix:
## INTEGER
## LR(1) items:
is_acsl_other -> INTEGER . [ COLON ]
type_spec -> INTEGER . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production is_acsl_other -> INTEGER
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> INTEGER

State 469:
## Known stack suffix:
## INT
## LR(1) items:
c_keyword -> INT . [ COLON ]
type_spec -> INT . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> INT
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> INT

State 470:
## Known stack suffix:
## FLOAT
## LR(1) items:
c_keyword -> FLOAT . [ COLON ]
type_spec -> FLOAT . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> FLOAT
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> FLOAT

State 471:
## Known stack suffix:
## ENUM
## LR(1) items:
c_keyword -> ENUM . [ COLON ]
type_spec -> ENUM . exit_rt_type identifier_or_typename [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
-- On exit_rt_type shift to state 151
## Reductions:
-- On COLON
--   reduce production c_keyword -> ENUM
-- On TYPENAME IDENTIFIER
--   reduce production exit_rt_type ->

State 472:
## Known stack suffix:
## DOUBLE
## LR(1) items:
c_keyword -> DOUBLE . [ COLON ]
type_spec -> DOUBLE . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> DOUBLE
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> DOUBLE

State 473:
## Known stack suffix:
## CHAR
## LR(1) items:
c_keyword -> CHAR . [ COLON ]
type_spec -> CHAR . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> CHAR
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> CHAR

State 474:
## Known stack suffix:
## BOOLEAN
## LR(1) items:
c_keyword -> BOOLEAN . [ COLON ]
type_spec -> BOOLEAN . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> BOOLEAN
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> BOOLEAN

State 475:
## Known stack suffix:
## BOOL
## LR(1) items:
c_keyword -> BOOL . [ COLON ]
type_spec -> BOOL . [ VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> BOOL
-- On VOLATILE STAR RPAR LSQUARE LPAR IDENTIFIER CONST
--   reduce production type_spec -> BOOL

State 476:
## Known stack suffix:
## LBRACE lexpr PIPE binders
## LR(1) items:
lexpr_inner -> LBRACE lexpr PIPE binders . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LBRACE lexpr PIPE binders . SEMICOLON lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 477
-- On RBRACE shift to state 480
## Reductions:

State 477:
## Known stack suffix:
## LBRACE lexpr PIPE binders SEMICOLON
## LR(1) items:
lexpr_inner -> LBRACE lexpr PIPE binders SEMICOLON . lexpr RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 478
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 478:
## Known stack suffix:
## LBRACE lexpr PIPE binders SEMICOLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RBRACE QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> LBRACE lexpr PIPE binders SEMICOLON lexpr . RBRACE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RBRACE shift to state 479
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 479:
## Known stack suffix:
## LBRACE lexpr PIPE binders SEMICOLON lexpr RBRACE
## LR(1) items:
lexpr_inner -> LBRACE lexpr PIPE binders SEMICOLON lexpr RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE lexpr PIPE binders SEMICOLON lexpr RBRACE

State 480:
## Known stack suffix:
## LBRACE lexpr PIPE binders RBRACE
## LR(1) items:
lexpr_inner -> LBRACE lexpr PIPE binders RBRACE . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LBRACE lexpr PIPE binders RBRACE

State 481:
## Known stack suffix:
## LET bounded_var EQUAL lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ SEMICOLON QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_binder -> LET bounded_var EQUAL lexpr . SEMICOLON lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 482
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 482:
## Known stack suffix:
## LET bounded_var EQUAL lexpr SEMICOLON
## LR(1) items:
lexpr_binder -> LET bounded_var EQUAL lexpr SEMICOLON . lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 483
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 483:
## Known stack suffix:
## LET bounded_var EQUAL lexpr SEMICOLON lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr_binder -> LET bounded_var EQUAL lexpr SEMICOLON lexpr . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE IDENTIFIER FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production lexpr_binder -> LET bounded_var EQUAL lexpr SEMICOLON lexpr

State 484:
## Known stack suffix:
## CONST
## LR(1) items:
c_keyword -> CONST . [ COLON ]
cv -> CONST . [ VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production c_keyword -> CONST
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production cv -> CONST

State 485:
## Known stack suffix:
## type_spec_cv
## LR(1) items:
cast_logic_type -> type_spec_cv . abs_spec_cv_option [ RPAR ]
## Transitions:
-- On STAR shift to state 486
-- On LSQUARE shift to state 159
-- On LPAR shift to state 490
-- On tabs shift to state 491
-- On stars_cv shift to state 492
-- On abs_spec_cv_option shift to state 505
-- On abs_spec_cv shift to state 506
-- On abs_spec_bis_cv shift to state 503
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv_option ->

State 486:
## Known stack suffix:
## STAR
## LR(1) items:
stars_cv -> STAR . [ STAR RPAR LSQUARE LPAR ]
stars_cv -> STAR . cv [ STAR RPAR LSQUARE LPAR ]
## Transitions:
-- On VOLATILE shift to state 487
-- On CONST shift to state 488
-- On cv shift to state 489
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production stars_cv -> STAR

State 487:
## Known stack suffix:
## VOLATILE
## LR(1) items:
cv -> VOLATILE . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production cv -> VOLATILE

State 488:
## Known stack suffix:
## CONST
## LR(1) items:
cv -> CONST . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production cv -> CONST

State 489:
## Known stack suffix:
## STAR cv
## LR(1) items:
stars_cv -> STAR cv . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production stars_cv -> STAR cv

State 490:
## Known stack suffix:
## LPAR
## LR(1) items:
abs_spec_bis_cv -> LPAR . abs_spec_cv RPAR [ RPAR LSQUARE LPAR ]
## Transitions:
-- On STAR shift to state 486
-- On LSQUARE shift to state 159
-- On LPAR shift to state 490
-- On tabs shift to state 491
-- On stars_cv shift to state 492
-- On abs_spec_cv shift to state 501
-- On abs_spec_bis_cv shift to state 503
## Reductions:

State 491:
## Known stack suffix:
## tabs
## LR(1) items:
abs_spec_cv -> tabs . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> tabs

State 492:
## Known stack suffix:
## stars_cv
## LR(1) items:
abs_spec_cv -> stars_cv . [ RPAR ]
abs_spec_cv -> stars_cv . tabs [ RPAR ]
abs_spec_cv -> stars_cv . abs_spec_bis_cv [ RPAR ]
abs_spec_cv -> stars_cv . abs_spec_bis_cv tabs [ RPAR ]
stars_cv -> stars_cv . STAR [ STAR RPAR LSQUARE LPAR ]
stars_cv -> stars_cv . STAR cv [ STAR RPAR LSQUARE LPAR ]
## Transitions:
-- On STAR shift to state 493
-- On LSQUARE shift to state 159
-- On LPAR shift to state 490
-- On tabs shift to state 495
-- On abs_spec_bis_cv shift to state 496
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> stars_cv

State 493:
## Known stack suffix:
## stars_cv STAR
## LR(1) items:
stars_cv -> stars_cv STAR . [ STAR RPAR LSQUARE LPAR ]
stars_cv -> stars_cv STAR . cv [ STAR RPAR LSQUARE LPAR ]
## Transitions:
-- On VOLATILE shift to state 487
-- On CONST shift to state 488
-- On cv shift to state 494
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production stars_cv -> stars_cv STAR

State 494:
## Known stack suffix:
## stars_cv STAR cv
## LR(1) items:
stars_cv -> stars_cv STAR cv . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production stars_cv -> stars_cv STAR cv

State 495:
## Known stack suffix:
## stars_cv tabs
## LR(1) items:
abs_spec_cv -> stars_cv tabs . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> stars_cv tabs

State 496:
## Known stack suffix:
## stars_cv abs_spec_bis_cv
## LR(1) items:
abs_spec_bis_cv -> abs_spec_bis_cv . LPAR abs_param_type_list RPAR [ RPAR LSQUARE LPAR ]
abs_spec_cv -> stars_cv abs_spec_bis_cv . [ RPAR ]
abs_spec_cv -> stars_cv abs_spec_bis_cv . tabs [ RPAR ]
## Transitions:
-- On LSQUARE shift to state 159
-- On LPAR shift to state 497
-- On tabs shift to state 500
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> stars_cv abs_spec_bis_cv

State 497:
## Known stack suffix:
## abs_spec_bis_cv LPAR
## LR(1) items:
abs_spec_bis_cv -> abs_spec_bis_cv LPAR . abs_param_type_list RPAR [ RPAR LSQUARE LPAR ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 173
-- On abs_param_type_list shift to state 498
-- On abs_param_list shift to state 176
-- On abs_param shift to state 180
## Reductions:
-- On RPAR
--   reduce production abs_param_type_list ->

State 498:
## Known stack suffix:
## abs_spec_bis_cv LPAR abs_param_type_list
## LR(1) items:
abs_spec_bis_cv -> abs_spec_bis_cv LPAR abs_param_type_list . RPAR [ RPAR LSQUARE LPAR ]
## Transitions:
-- On RPAR shift to state 499
## Reductions:

State 499:
## Known stack suffix:
## abs_spec_bis_cv LPAR abs_param_type_list RPAR
## LR(1) items:
abs_spec_bis_cv -> abs_spec_bis_cv LPAR abs_param_type_list RPAR . [ RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On RPAR LSQUARE LPAR
--   reduce production abs_spec_bis_cv -> abs_spec_bis_cv LPAR abs_param_type_list RPAR

State 500:
## Known stack suffix:
## stars_cv abs_spec_bis_cv tabs
## LR(1) items:
abs_spec_cv -> stars_cv abs_spec_bis_cv tabs . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> stars_cv abs_spec_bis_cv tabs

State 501:
## Known stack suffix:
## LPAR abs_spec_cv
## LR(1) items:
abs_spec_bis_cv -> LPAR abs_spec_cv . RPAR [ RPAR LSQUARE LPAR ]
## Transitions:
-- On RPAR shift to state 502
## Reductions:

State 502:
## Known stack suffix:
## LPAR abs_spec_cv RPAR
## LR(1) items:
abs_spec_bis_cv -> LPAR abs_spec_cv RPAR . [ RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On RPAR LSQUARE LPAR
--   reduce production abs_spec_bis_cv -> LPAR abs_spec_cv RPAR

State 503:
## Known stack suffix:
## abs_spec_bis_cv
## LR(1) items:
abs_spec_bis_cv -> abs_spec_bis_cv . LPAR abs_param_type_list RPAR [ RPAR LSQUARE LPAR ]
abs_spec_cv -> abs_spec_bis_cv . tabs [ RPAR ]
abs_spec_cv -> abs_spec_bis_cv . [ RPAR ]
## Transitions:
-- On LSQUARE shift to state 159
-- On LPAR shift to state 497
-- On tabs shift to state 504
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> abs_spec_bis_cv

State 504:
## Known stack suffix:
## abs_spec_bis_cv tabs
## LR(1) items:
abs_spec_cv -> abs_spec_bis_cv tabs . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv -> abs_spec_bis_cv tabs

State 505:
## Known stack suffix:
## type_spec_cv abs_spec_cv_option
## LR(1) items:
cast_logic_type -> type_spec_cv abs_spec_cv_option . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production cast_logic_type -> type_spec_cv abs_spec_cv_option

State 506:
## Known stack suffix:
## abs_spec_cv
## LR(1) items:
abs_spec_cv_option -> abs_spec_cv . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production abs_spec_cv_option -> abs_spec_cv

State 507:
## Known stack suffix:
## type_spec
## LR(1) items:
type_spec_cv -> type_spec . [ STAR RPAR LSQUARE LPAR ]
type_spec_cv -> type_spec . cv [ STAR RPAR LSQUARE LPAR ]
## Transitions:
-- On VOLATILE shift to state 487
-- On CONST shift to state 488
-- On cv shift to state 508
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production type_spec_cv -> type_spec

State 508:
## Known stack suffix:
## type_spec cv
## LR(1) items:
type_spec_cv -> type_spec cv . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production type_spec_cv -> type_spec cv

State 509:
## Known stack suffix:
## LPAR range
## LR(1) items:
lexpr_inner -> LPAR range . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## LPAR range RPAR
## LR(1) items:
lexpr_inner -> LPAR range RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LPAR range RPAR

State 511:
## Known stack suffix:
## LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT DOTDOT BIMPLIES BIFF AND AMP ]
lexpr_inner -> LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_option -> lexpr . [ DOTDOT ]
## Transitions:
-- On RPAR shift to state 512
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On DOTDOT
--   reduce production lexpr_option -> lexpr

State 512:
## Known stack suffix:
## LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> LPAR lexpr RPAR

State 513:
## Known stack suffix:
## cv
## LR(1) items:
type_spec_cv -> cv . type_spec [ STAR RPAR LSQUARE LPAR ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 514
## Reductions:

State 514:
## Known stack suffix:
## cv type_spec
## LR(1) items:
type_spec_cv -> cv type_spec . [ STAR RPAR LSQUARE LPAR ]
## Transitions:
## Reductions:
-- On STAR RPAR LSQUARE LPAR
--   reduce production type_spec_cv -> cv type_spec

State 515:
## Known stack suffix:
## LPAR cast_logic_type
## LR(1) items:
lexpr_inner -> LPAR cast_logic_type . RPAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 516
## Reductions:

State 516:
## Known stack suffix:
## LPAR cast_logic_type RPAR
## LR(1) items:
lexpr_inner -> LPAR cast_logic_type RPAR . lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 106
-- On STAR shift to state 107
-- On SIZEOF shift to state 108
-- On SEPARATED shift to state 200
-- On RESULT shift to state 202
-- On REGISTER shift to state 203
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 212
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LBRACE shift to state 224
-- On INTER shift to state 249
-- On INITIALIZED shift to state 251
-- On IDENTIFIER shift to state 220
-- On FRESH shift to state 255
-- On FREEABLE shift to state 259
-- On FALSE shift to state 265
-- On EMPTY shift to state 269
-- On DYNAMIC shift to state 270
-- On DANGLING shift to state 271
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BLOCK_LENGTH shift to state 282
-- On BASE_ADDR shift to state 285
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCABLE shift to state 295
-- On string shift to state 304
-- On lexpr_inner shift to state 517
-- On identifier shift to state 325
-- On constant shift to state 336
## Reductions:

State 517:
## Known stack suffix:
## LPAR cast_logic_type RPAR lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> LPAR cast_logic_type RPAR lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> LPAR cast_logic_type RPAR lexpr_inner

State 518:
## Known stack suffix:
## MINUS lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> MINUS lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> MINUS lexpr_inner

State 519:
## Known stack suffix:
## NOT lexpr_inner
## LR(1) items:
lexpr_inner -> NOT lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> NOT lexpr_inner

State 520:
## Known stack suffix:
## NOT lexpr_binder
## LR(1) items:
lexpr_end_rel -> NOT lexpr_binder . [ WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FROM FREES FOR EXITS EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_end_rel -> NOT lexpr_binder

State 521:
## Known stack suffix:
## OFFSET opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> OFFSET opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 522
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 522:
## Known stack suffix:
## OFFSET opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> OFFSET opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> OFFSET opt_label_1 LPAR lexpr RPAR

State 523:
## Known stack suffix:
## OLD LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> OLD LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 524
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 524:
## Known stack suffix:
## OLD LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> OLD LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> OLD LPAR lexpr RPAR

State 525:
## Known stack suffix:
## PLUS lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> PLUS lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> PLUS lexpr_inner

State 526:
## Known stack suffix:
## SEPARATED LPAR ne_lexpr_list
## LR(1) items:
lexpr_inner -> SEPARATED LPAR ne_lexpr_list . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 527
## Reductions:

State 527:
## Known stack suffix:
## SEPARATED LPAR ne_lexpr_list RPAR
## LR(1) items:
lexpr_inner -> SEPARATED LPAR ne_lexpr_list RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> SEPARATED LPAR ne_lexpr_list RPAR

State 528:
## Known stack suffix:
## SIZEOF LPAR logic_type
## LR(1) items:
lexpr_inner -> SIZEOF LPAR logic_type . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 529
## Reductions:

State 529:
## Known stack suffix:
## SIZEOF LPAR logic_type RPAR
## LR(1) items:
lexpr_inner -> SIZEOF LPAR logic_type RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> SIZEOF LPAR logic_type RPAR

State 530:
## Known stack suffix:
## SIZEOF LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> SIZEOF LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 531
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 531:
## Known stack suffix:
## SIZEOF LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> SIZEOF LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> SIZEOF LPAR lexpr RPAR

State 532:
## Known stack suffix:
## STAR lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> STAR lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> STAR lexpr_inner

State 533:
## Known stack suffix:
## TILDE lexpr_inner
## LR(1) items:
lexpr_inner -> lexpr_inner . PLUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . MINUS lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . STAR lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . SLASH lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . PERCENT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . ARROW identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . DOT identifier_or_typename [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE range RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LSQUARE lexpr RSQUARE [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> TILDE lexpr_inner . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . GTGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTLT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . LTCOLON lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT logic_type [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
lexpr_inner -> lexpr_inner . COLONGT lexpr_inner [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On LTCOLON shift to state 306
-- On LSQUARE shift to state 308
-- On DOT shift to state 363
-- On COLONGT shift to state 365
-- On ARROW shift to state 368
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LT LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES
--   reduce production lexpr_inner -> TILDE lexpr_inner

State 534:
## Known stack suffix:
## TYPEOF LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> TYPEOF LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 535
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 535:
## Known stack suffix:
## TYPEOF LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> TYPEOF LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> TYPEOF LPAR lexpr RPAR

State 536:
## Known stack suffix:
## VALID opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 537
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 537:
## Known stack suffix:
## VALID opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> VALID opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> VALID opt_label_1 LPAR lexpr RPAR

State 538:
## Known stack suffix:
## VALID_INDEX opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_INDEX opt_label_1 LPAR lexpr . COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 539
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 539:
## Known stack suffix:
## VALID_INDEX opt_label_1 LPAR lexpr COMMA
## LR(1) items:
lexpr_inner -> VALID_INDEX opt_label_1 LPAR lexpr COMMA . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 540
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 540:
## Known stack suffix:
## VALID_INDEX opt_label_1 LPAR lexpr COMMA lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_INDEX opt_label_1 LPAR lexpr COMMA lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 541
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 541:
## Known stack suffix:
## VALID_INDEX opt_label_1 LPAR lexpr COMMA lexpr RPAR
## LR(1) items:
lexpr_inner -> VALID_INDEX opt_label_1 LPAR lexpr COMMA lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> VALID_INDEX opt_label_1 LPAR lexpr COMMA lexpr RPAR

State 542:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr . COMMA lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 543
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 543:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr COMMA
## LR(1) items:
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA . lexpr COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 544
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 544:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ QUESTION PIPE OR IMPLIES IFF HATHAT HAT COMMA BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr . COMMA lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On COMMA shift to state 545
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 545:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA
## LR(1) items:
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA . lexpr RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 546
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 546:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 547
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 547:
## Known stack suffix:
## VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr RPAR
## LR(1) items:
lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> VALID_RANGE opt_label_1 LPAR lexpr COMMA lexpr COMMA lexpr RPAR

State 548:
## Known stack suffix:
## VALID_READ opt_label_1 LPAR lexpr
## LR(1) items:
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT BIMPLIES BIFF AND AMP ]
lexpr_inner -> VALID_READ opt_label_1 LPAR lexpr . RPAR [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
-- On RPAR shift to state 549
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:

State 549:
## Known stack suffix:
## VALID_READ opt_label_1 LPAR lexpr RPAR
## LR(1) items:
lexpr_inner -> VALID_READ opt_label_1 LPAR lexpr RPAR . [ WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES WITH STAR SLASH SEMICOLON RSQUARE RPAR RETURNS REQUIRES READS RBRACE QUESTION PLUS PIPE PERCENT OR NE MINUS LTLT LTCOLON LT LSQUARE LE IMPLIES IFF IDENTIFIER HATHAT HAT GTGT GT GE FROM FREES FOR EXITS EQUAL EQ EOF ENSURES DOTDOT DOT DISJOINT DECREASES CONTINUES COMPLETE COMMA COLONGT COLON2 BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS ARROW AND AMP ALLOCATES
--   reduce production lexpr_inner -> VALID_READ opt_label_1 LPAR lexpr RPAR

State 550:
## Known stack suffix:
## VOLATILE ne_zones
## LR(1) items:
decl -> VOLATILE ne_zones . volatile_opt SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 551
-- On READS shift to state 553
-- On volatile_opt shift to state 557
## Reductions:
-- On SEMICOLON
--   reduce production volatile_opt ->

State 551:
## Known stack suffix:
## WRITES
## LR(1) items:
volatile_opt -> WRITES . any_identifier volatile_opt [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 552
-- On acsl_c_keyword shift to state 87
## Reductions:

State 552:
## Known stack suffix:
## WRITES any_identifier
## LR(1) items:
volatile_opt -> WRITES any_identifier . volatile_opt [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 551
-- On READS shift to state 553
-- On volatile_opt shift to state 556
## Reductions:
-- On SEMICOLON
--   reduce production volatile_opt ->

State 553:
## Known stack suffix:
## READS
## LR(1) items:
volatile_opt -> READS . any_identifier volatile_opt [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 554
-- On acsl_c_keyword shift to state 87
## Reductions:

State 554:
## Known stack suffix:
## READS any_identifier
## LR(1) items:
volatile_opt -> READS any_identifier . volatile_opt [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 551
-- On READS shift to state 553
-- On volatile_opt shift to state 555
## Reductions:
-- On SEMICOLON
--   reduce production volatile_opt ->

State 555:
## Known stack suffix:
## READS any_identifier volatile_opt
## LR(1) items:
volatile_opt -> READS any_identifier volatile_opt . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production volatile_opt -> READS any_identifier volatile_opt

State 556:
## Known stack suffix:
## WRITES any_identifier volatile_opt
## LR(1) items:
volatile_opt -> WRITES any_identifier volatile_opt . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production volatile_opt -> WRITES any_identifier volatile_opt

State 557:
## Known stack suffix:
## VOLATILE ne_zones volatile_opt
## LR(1) items:
decl -> VOLATILE ne_zones volatile_opt . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 558
## Reductions:

State 558:
## Known stack suffix:
## VOLATILE ne_zones volatile_opt SEMICOLON
## LR(1) items:
decl -> VOLATILE ne_zones volatile_opt SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> VOLATILE ne_zones volatile_opt SEMICOLON

State 559:
## Known stack suffix:
## ne_lexpr_list
## LR(1) items:
ne_zones -> ne_lexpr_list . [ WRITES SEMICOLON RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES SEMICOLON RETURNS REQUIRES READS IDENTIFIER FROM FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_zones -> ne_lexpr_list

State 560:
## Known stack suffix:
## TYPE
## LR(1) items:
deprecated_logic_decl -> TYPE . poly_id_type SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> TYPE . poly_id_type_add_typename EQUAL typedef SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
type_annot -> TYPE . INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On INVARIANT shift to state 561
-- On poly_id_type_add_typename shift to state 580
-- On poly_id_type shift to state 608
-- On full_identifier shift to state 610
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 561:
## Known stack suffix:
## TYPE INVARIANT
## LR(1) items:
type_annot -> TYPE INVARIANT . any_identifier LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 562
-- On acsl_c_keyword shift to state 87
## Reductions:

State 562:
## Known stack suffix:
## TYPE INVARIANT any_identifier
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier . LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 563
## Reductions:

State 563:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR . full_parameter RPAR EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_parameter shift to state 564
-- On enter_kw_c_mode shift to state 572
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 564:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR full_parameter
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter . RPAR EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On RPAR shift to state 565
## Reductions:

State 565:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR full_parameter RPAR
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter RPAR . EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On EQUAL shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL . full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 567
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 567:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 568
## Reductions:

State 568:
## Known stack suffix:
## TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON
## LR(1) items:
type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production type_annot -> TYPE INVARIANT any_identifier LPAR full_parameter RPAR EQUAL full_lexpr SEMICOLON

State 569:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_lexpr -> enter_kw_c_mode . lexpr exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 570
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 570:
## Known stack suffix:
## enter_kw_c_mode lexpr
## LR(1) items:
full_lexpr -> enter_kw_c_mode lexpr . exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
lexpr -> lexpr . IMPLIES lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . IFF lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . OR lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AND lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HATHAT lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . AMP lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . PIPE lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . HAT lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIMPLIES lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . BIFF lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ SEMICOLON RETURNS REQUIRES QUESTION PIPE OR IMPLIES IFF IDENTIFIER HATHAT HAT FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BIMPLIES BIFF BEHAVIOR ASSUMES ASSIGNS AND AMP ALLOCATES ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
-- On exit_kw_c_mode shift to state 571
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production exit_kw_c_mode ->

State 571:
## Known stack suffix:
## enter_kw_c_mode lexpr exit_kw_c_mode
## LR(1) items:
full_lexpr -> enter_kw_c_mode lexpr exit_kw_c_mode . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES FOR EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production full_lexpr -> enter_kw_c_mode lexpr exit_kw_c_mode

State 572:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_parameter -> enter_kw_c_mode . parameter exit_kw_c_mode [ SEMICOLON RPAR RBRACE ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On IDENTIFIER shift to state 220
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 573
-- On parameter shift to state 575
-- On identifier shift to state 577
-- On id_as_typename shift to state 578
## Reductions:

State 573:
## Known stack suffix:
## type_spec
## LR(1) items:
parameter -> type_spec . var_spec [ SEMICOLON RPAR RBRACE COMMA ]
## Transitions:
-- On STAR shift to state 158
-- On LPAR shift to state 228
-- On IDENTIFIER shift to state 220
-- On var_spec_bis shift to state 229
-- On var_spec shift to state 574
-- On stars shift to state 238
-- On identifier shift to state 240
## Reductions:

State 574:
## Known stack suffix:
## type_spec var_spec
## LR(1) items:
parameter -> type_spec var_spec . [ SEMICOLON RPAR RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE COMMA
--   reduce production parameter -> type_spec var_spec

State 575:
## Known stack suffix:
## enter_kw_c_mode parameter
## LR(1) items:
full_parameter -> enter_kw_c_mode parameter . exit_kw_c_mode [ SEMICOLON RPAR RBRACE ]
## Transitions:
-- On exit_kw_c_mode shift to state 576
## Reductions:
-- On SEMICOLON RPAR RBRACE
--   reduce production exit_kw_c_mode ->

State 576:
## Known stack suffix:
## enter_kw_c_mode parameter exit_kw_c_mode
## LR(1) items:
full_parameter -> enter_kw_c_mode parameter exit_kw_c_mode . [ SEMICOLON RPAR RBRACE ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE
--   reduce production full_parameter -> enter_kw_c_mode parameter exit_kw_c_mode

State 577:
## Known stack suffix:
## identifier
## LR(1) items:
id_as_typename -> identifier . [ STAR LPAR IDENTIFIER ]
## Transitions:
## Reductions:
-- On STAR LPAR IDENTIFIER
--   reduce production id_as_typename -> identifier

State 578:
## Known stack suffix:
## id_as_typename
## LR(1) items:
parameter -> id_as_typename . var_spec [ SEMICOLON RPAR RBRACE COMMA ]
## Transitions:
-- On STAR shift to state 158
-- On LPAR shift to state 228
-- On IDENTIFIER shift to state 220
-- On var_spec_bis shift to state 229
-- On var_spec shift to state 579
-- On stars shift to state 238
-- On identifier shift to state 240
## Reductions:

State 579:
## Known stack suffix:
## id_as_typename var_spec
## LR(1) items:
parameter -> id_as_typename var_spec . [ SEMICOLON RPAR RBRACE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR RBRACE COMMA
--   reduce production parameter -> id_as_typename var_spec

State 580:
## Known stack suffix:
## TYPE poly_id_type_add_typename
## LR(1) items:
logic_def -> TYPE poly_id_type_add_typename . EQUAL typedef SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On EQUAL shift to state 581
## Reductions:

State 581:
## Known stack suffix:
## TYPE poly_id_type_add_typename EQUAL
## LR(1) items:
logic_def -> TYPE poly_id_type_add_typename EQUAL . typedef SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On PIPE shift to state 582
-- On typedef shift to state 601
-- On ne_datacons_list shift to state 603
-- On full_logic_type shift to state 604
-- On full_identifier shift to state 583
-- On enter_kw_c_mode shift to state 605
-- On datacons shift to state 606
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 582:
## Known stack suffix:
## PIPE
## LR(1) items:
ne_datacons_list -> PIPE . datacons datacons_list [ SEMICOLON ]
## Transitions:
-- On full_identifier shift to state 583
-- On enter_kw_c_mode shift to state 593
-- On datacons shift to state 596
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 583:
## Known stack suffix:
## full_identifier
## LR(1) items:
datacons -> full_identifier . [ SEMICOLON PIPE ]
datacons -> full_identifier . LPAR ne_type_list RPAR [ SEMICOLON PIPE ]
## Transitions:
-- On LPAR shift to state 584
## Reductions:
-- On SEMICOLON PIPE
--   reduce production datacons -> full_identifier

State 584:
## Known stack suffix:
## full_identifier LPAR
## LR(1) items:
datacons -> full_identifier LPAR . ne_type_list RPAR [ SEMICOLON PIPE ]
## Transitions:
-- On ne_type_list shift to state 585
-- On full_logic_type shift to state 587
-- On enter_kw_c_mode shift to state 590
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 585:
## Known stack suffix:
## full_identifier LPAR ne_type_list
## LR(1) items:
datacons -> full_identifier LPAR ne_type_list . RPAR [ SEMICOLON PIPE ]
## Transitions:
-- On RPAR shift to state 586
## Reductions:

State 586:
## Known stack suffix:
## full_identifier LPAR ne_type_list RPAR
## LR(1) items:
datacons -> full_identifier LPAR ne_type_list RPAR . [ SEMICOLON PIPE ]
## Transitions:
## Reductions:
-- On SEMICOLON PIPE
--   reduce production datacons -> full_identifier LPAR ne_type_list RPAR

State 587:
## Known stack suffix:
## full_logic_type
## LR(1) items:
ne_type_list -> full_logic_type . [ RPAR ]
ne_type_list -> full_logic_type . COMMA ne_type_list [ RPAR ]
## Transitions:
-- On COMMA shift to state 588
## Reductions:
-- On RPAR
--   reduce production ne_type_list -> full_logic_type

State 588:
## Known stack suffix:
## full_logic_type COMMA
## LR(1) items:
ne_type_list -> full_logic_type COMMA . ne_type_list [ RPAR ]
## Transitions:
-- On ne_type_list shift to state 589
-- On full_logic_type shift to state 587
-- On enter_kw_c_mode shift to state 590
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 589:
## Known stack suffix:
## full_logic_type COMMA ne_type_list
## LR(1) items:
ne_type_list -> full_logic_type COMMA ne_type_list . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production ne_type_list -> full_logic_type COMMA ne_type_list

State 590:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_logic_type -> enter_kw_c_mode . logic_type exit_kw_c_mode [ RPAR COMMA ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 591
## Reductions:

State 591:
## Known stack suffix:
## enter_kw_c_mode logic_type
## LR(1) items:
full_logic_type -> enter_kw_c_mode logic_type . exit_kw_c_mode [ SEMICOLON RPAR COMMA ]
## Transitions:
-- On exit_kw_c_mode shift to state 592
## Reductions:
-- On SEMICOLON RPAR COMMA
--   reduce production exit_kw_c_mode ->

State 592:
## Known stack suffix:
## enter_kw_c_mode logic_type exit_kw_c_mode
## LR(1) items:
full_logic_type -> enter_kw_c_mode logic_type exit_kw_c_mode . [ SEMICOLON RPAR COMMA ]
## Transitions:
## Reductions:
-- On SEMICOLON RPAR COMMA
--   reduce production full_logic_type -> enter_kw_c_mode logic_type exit_kw_c_mode

State 593:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_identifier -> enter_kw_c_mode . identifier exit_kw_c_mode [ SEMICOLON READS PIPE LT LPAR LBRACE GT EQUAL COMMA COLON ]
## Transitions:
-- On IDENTIFIER shift to state 220
-- On identifier shift to state 594
## Reductions:

State 594:
## Known stack suffix:
## enter_kw_c_mode identifier
## LR(1) items:
full_identifier -> enter_kw_c_mode identifier . exit_kw_c_mode [ SEMICOLON READS PIPE LT LPAR LBRACE GT EQUAL COMMA COLON ]
## Transitions:
-- On exit_kw_c_mode shift to state 595
## Reductions:
-- On SEMICOLON READS PIPE LT LPAR LBRACE GT EQUAL COMMA COLON
--   reduce production exit_kw_c_mode ->

State 595:
## Known stack suffix:
## enter_kw_c_mode identifier exit_kw_c_mode
## LR(1) items:
full_identifier -> enter_kw_c_mode identifier exit_kw_c_mode . [ SEMICOLON READS PIPE LT LPAR LBRACE GT EQUAL COMMA COLON ]
## Transitions:
## Reductions:
-- On SEMICOLON READS PIPE LT LPAR LBRACE GT EQUAL COMMA COLON
--   reduce production full_identifier -> enter_kw_c_mode identifier exit_kw_c_mode

State 596:
## Known stack suffix:
## PIPE datacons
## LR(1) items:
ne_datacons_list -> PIPE datacons . datacons_list [ SEMICOLON ]
## Transitions:
-- On PIPE shift to state 597
-- On datacons_list shift to state 600
## Reductions:
-- On SEMICOLON
--   reduce production datacons_list ->

State 597:
## Known stack suffix:
## PIPE
## LR(1) items:
datacons_list -> PIPE . datacons datacons_list [ SEMICOLON ]
## Transitions:
-- On full_identifier shift to state 583
-- On enter_kw_c_mode shift to state 593
-- On datacons shift to state 598
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 598:
## Known stack suffix:
## PIPE datacons
## LR(1) items:
datacons_list -> PIPE datacons . datacons_list [ SEMICOLON ]
## Transitions:
-- On PIPE shift to state 597
-- On datacons_list shift to state 599
## Reductions:
-- On SEMICOLON
--   reduce production datacons_list ->

State 599:
## Known stack suffix:
## PIPE datacons datacons_list
## LR(1) items:
datacons_list -> PIPE datacons datacons_list . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production datacons_list -> PIPE datacons datacons_list

State 600:
## Known stack suffix:
## PIPE datacons datacons_list
## LR(1) items:
ne_datacons_list -> PIPE datacons datacons_list . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production ne_datacons_list -> PIPE datacons datacons_list

State 601:
## Known stack suffix:
## TYPE poly_id_type_add_typename EQUAL typedef
## LR(1) items:
logic_def -> TYPE poly_id_type_add_typename EQUAL typedef . SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 602
## Reductions:

State 602:
## Known stack suffix:
## TYPE poly_id_type_add_typename EQUAL typedef SEMICOLON
## LR(1) items:
logic_def -> TYPE poly_id_type_add_typename EQUAL typedef SEMICOLON . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> TYPE poly_id_type_add_typename EQUAL typedef SEMICOLON

State 603:
## Known stack suffix:
## ne_datacons_list
## LR(1) items:
typedef -> ne_datacons_list . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production typedef -> ne_datacons_list

State 604:
## Known stack suffix:
## full_logic_type
## LR(1) items:
typedef -> full_logic_type . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production typedef -> full_logic_type

State 605:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_identifier -> enter_kw_c_mode . identifier exit_kw_c_mode [ SEMICOLON PIPE LPAR ]
full_logic_type -> enter_kw_c_mode . logic_type exit_kw_c_mode [ SEMICOLON ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On IDENTIFIER shift to state 220
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 591
-- On identifier shift to state 594
## Reductions:

State 606:
## Known stack suffix:
## datacons
## LR(1) items:
ne_datacons_list -> datacons . datacons_list [ SEMICOLON ]
## Transitions:
-- On PIPE shift to state 597
-- On datacons_list shift to state 607
## Reductions:
-- On SEMICOLON
--   reduce production datacons_list ->

State 607:
## Known stack suffix:
## datacons datacons_list
## LR(1) items:
ne_datacons_list -> datacons datacons_list . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production ne_datacons_list -> datacons datacons_list

State 608:
## Known stack suffix:
## TYPE poly_id_type
## LR(1) items:
deprecated_logic_decl -> TYPE poly_id_type . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
poly_id_type_add_typename -> poly_id_type . [ EQUAL ]
## Transitions:
-- On SEMICOLON shift to state 609
## Reductions:
-- On EQUAL
--   reduce production poly_id_type_add_typename -> poly_id_type

State 609:
## Known stack suffix:
## TYPE poly_id_type SEMICOLON
## LR(1) items:
deprecated_logic_decl -> TYPE poly_id_type SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production deprecated_logic_decl -> TYPE poly_id_type SEMICOLON

State 610:
## Known stack suffix:
## full_identifier
## LR(1) items:
poly_id_type -> full_identifier . [ SEMICOLON EQUAL ]
poly_id_type -> full_identifier . LT ne_tvar_list GT [ SEMICOLON EQUAL ]
## Transitions:
-- On LT shift to state 611
## Reductions:
-- On SEMICOLON EQUAL
--   reduce production poly_id_type -> full_identifier

State 611:
## Known stack suffix:
## full_identifier LT
## LR(1) items:
poly_id_type -> full_identifier LT . ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On ne_tvar_list shift to state 612
-- On full_identifier shift to state 614
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 612:
## Known stack suffix:
## full_identifier LT ne_tvar_list
## LR(1) items:
poly_id_type -> full_identifier LT ne_tvar_list . GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On GT shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## full_identifier LT ne_tvar_list GT
## LR(1) items:
poly_id_type -> full_identifier LT ne_tvar_list GT . [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
## Reductions:
-- On SEMICOLON READS LPAR EQUAL COLON
--   reduce production poly_id_type -> full_identifier LT ne_tvar_list GT

State 614:
## Known stack suffix:
## full_identifier
## LR(1) items:
ne_tvar_list -> full_identifier . [ GT ]
ne_tvar_list -> full_identifier . COMMA ne_tvar_list [ GT ]
## Transitions:
-- On COMMA shift to state 615
## Reductions:
-- On GT
--   reduce production ne_tvar_list -> full_identifier

State 615:
## Known stack suffix:
## full_identifier COMMA
## LR(1) items:
ne_tvar_list -> full_identifier COMMA . ne_tvar_list [ GT ]
## Transitions:
-- On ne_tvar_list shift to state 616
-- On full_identifier shift to state 614
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 616:
## Known stack suffix:
## full_identifier COMMA ne_tvar_list
## LR(1) items:
ne_tvar_list -> full_identifier COMMA ne_tvar_list . [ GT ]
## Transitions:
## Reductions:
-- On GT
--   reduce production ne_tvar_list -> full_identifier COMMA ne_tvar_list

State 617:
## Known stack suffix:
## SLICE
## LR(1) items:
slice_pragma -> SLICE . PRAGMA any_identifier full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
slice_pragma -> SLICE . PRAGMA any_identifier SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On PRAGMA shift to state 618
## Reductions:

State 618:
## Known stack suffix:
## SLICE PRAGMA
## LR(1) items:
slice_pragma -> SLICE PRAGMA . any_identifier full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
slice_pragma -> SLICE PRAGMA . any_identifier SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 619
-- On acsl_c_keyword shift to state 87
## Reductions:

State 619:
## Known stack suffix:
## SLICE PRAGMA any_identifier
## LR(1) items:
slice_pragma -> SLICE PRAGMA any_identifier . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
slice_pragma -> SLICE PRAGMA any_identifier . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 620
-- On full_lexpr shift to state 621
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 620:
## Known stack suffix:
## SLICE PRAGMA any_identifier SEMICOLON
## LR(1) items:
slice_pragma -> SLICE PRAGMA any_identifier SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production slice_pragma -> SLICE PRAGMA any_identifier SEMICOLON

State 621:
## Known stack suffix:
## SLICE PRAGMA any_identifier full_lexpr
## LR(1) items:
slice_pragma -> SLICE PRAGMA any_identifier full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 622
## Reductions:

State 622:
## Known stack suffix:
## SLICE PRAGMA any_identifier full_lexpr SEMICOLON
## LR(1) items:
slice_pragma -> SLICE PRAGMA any_identifier full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production slice_pragma -> SLICE PRAGMA any_identifier full_lexpr SEMICOLON

State 623:
## Known stack suffix:
## PREDICATE
## LR(1) items:
deprecated_logic_decl -> PREDICATE . poly_id opt_parameters SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> PREDICATE . poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 625
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 624:
## Known stack suffix:
## poly_id_type
## LR(1) items:
poly_id -> poly_id_type . [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
## Reductions:
-- On SEMICOLON READS LPAR EQUAL COLON
--   reduce production poly_id -> poly_id_type

State 625:
## Known stack suffix:
## PREDICATE poly_id
## LR(1) items:
deprecated_logic_decl -> PREDICATE poly_id . opt_parameters SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> PREDICATE poly_id . opt_parameters EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 626
-- On parameters shift to state 635
-- On opt_parameters shift to state 636
## Reductions:
-- On SEMICOLON EQUAL
--   reduce production opt_parameters ->

State 626:
## Known stack suffix:
## LPAR
## LR(1) items:
parameters -> LPAR . full_parameters RPAR [ SEMICOLON READS LBRACE EQUAL ]
## Transitions:
-- On full_parameters shift to state 627
-- On enter_kw_c_mode shift to state 629
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 627:
## Known stack suffix:
## LPAR full_parameters
## LR(1) items:
parameters -> LPAR full_parameters . RPAR [ SEMICOLON READS LBRACE EQUAL ]
## Transitions:
-- On RPAR shift to state 628
## Reductions:

State 628:
## Known stack suffix:
## LPAR full_parameters RPAR
## LR(1) items:
parameters -> LPAR full_parameters RPAR . [ SEMICOLON READS LBRACE EQUAL ]
## Transitions:
## Reductions:
-- On SEMICOLON READS LBRACE EQUAL
--   reduce production parameters -> LPAR full_parameters RPAR

State 629:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_parameters -> enter_kw_c_mode . ne_parameters exit_kw_c_mode [ RPAR ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On IDENTIFIER shift to state 220
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 573
-- On parameter shift to state 630
-- On ne_parameters shift to state 633
-- On identifier shift to state 577
-- On id_as_typename shift to state 578
## Reductions:

State 630:
## Known stack suffix:
## parameter
## LR(1) items:
ne_parameters -> parameter . [ RPAR ]
ne_parameters -> parameter . COMMA ne_parameters [ RPAR ]
## Transitions:
-- On COMMA shift to state 631
## Reductions:
-- On RPAR
--   reduce production ne_parameters -> parameter

State 631:
## Known stack suffix:
## parameter COMMA
## LR(1) items:
ne_parameters -> parameter COMMA . ne_parameters [ RPAR ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On IDENTIFIER shift to state 220
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 573
-- On parameter shift to state 630
-- On ne_parameters shift to state 632
-- On identifier shift to state 577
-- On id_as_typename shift to state 578
## Reductions:

State 632:
## Known stack suffix:
## parameter COMMA ne_parameters
## LR(1) items:
ne_parameters -> parameter COMMA ne_parameters . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production ne_parameters -> parameter COMMA ne_parameters

State 633:
## Known stack suffix:
## enter_kw_c_mode ne_parameters
## LR(1) items:
full_parameters -> enter_kw_c_mode ne_parameters . exit_kw_c_mode [ RPAR ]
## Transitions:
-- On exit_kw_c_mode shift to state 634
## Reductions:
-- On RPAR
--   reduce production exit_kw_c_mode ->

State 634:
## Known stack suffix:
## enter_kw_c_mode ne_parameters exit_kw_c_mode
## LR(1) items:
full_parameters -> enter_kw_c_mode ne_parameters exit_kw_c_mode . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production full_parameters -> enter_kw_c_mode ne_parameters exit_kw_c_mode

State 635:
## Known stack suffix:
## parameters
## LR(1) items:
opt_parameters -> parameters . [ SEMICOLON READS EQUAL ]
## Transitions:
## Reductions:
-- On SEMICOLON READS EQUAL
--   reduce production opt_parameters -> parameters

State 636:
## Known stack suffix:
## PREDICATE poly_id opt_parameters
## LR(1) items:
deprecated_logic_decl -> PREDICATE poly_id opt_parameters . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> PREDICATE poly_id opt_parameters . EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 637
-- On EQUAL shift to state 638
## Reductions:

State 637:
## Known stack suffix:
## PREDICATE poly_id opt_parameters SEMICOLON
## LR(1) items:
deprecated_logic_decl -> PREDICATE poly_id opt_parameters SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production deprecated_logic_decl -> PREDICATE poly_id opt_parameters SEMICOLON

State 638:
## Known stack suffix:
## PREDICATE poly_id opt_parameters EQUAL
## LR(1) items:
logic_def -> PREDICATE poly_id opt_parameters EQUAL . full_lexpr SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 639
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 639:
## Known stack suffix:
## PREDICATE poly_id opt_parameters EQUAL full_lexpr
## LR(1) items:
logic_def -> PREDICATE poly_id opt_parameters EQUAL full_lexpr . SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 640
## Reductions:

State 640:
## Known stack suffix:
## PREDICATE poly_id opt_parameters EQUAL full_lexpr SEMICOLON
## LR(1) items:
logic_def -> PREDICATE poly_id opt_parameters EQUAL full_lexpr SEMICOLON . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> PREDICATE poly_id opt_parameters EQUAL full_lexpr SEMICOLON

State 641:
## Known stack suffix:
## full_identifier
## LR(1) items:
poly_id -> full_identifier . LBRACE ne_label_list RBRACE [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id -> full_identifier . LBRACE ne_label_list RBRACE LT ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id_type -> full_identifier . [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id_type -> full_identifier . LT ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On LT shift to state 611
-- On LBRACE shift to state 642
## Reductions:
-- On SEMICOLON READS LPAR EQUAL COLON
--   reduce production poly_id_type -> full_identifier

State 642:
## Known stack suffix:
## full_identifier LBRACE
## LR(1) items:
poly_id -> full_identifier LBRACE . ne_label_list RBRACE [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id -> full_identifier LBRACE . ne_label_list RBRACE LT ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_label_list shift to state 643
-- On label_name shift to state 76
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 86
-- On acsl_c_keyword shift to state 87
## Reductions:

State 643:
## Known stack suffix:
## full_identifier LBRACE ne_label_list
## LR(1) items:
poly_id -> full_identifier LBRACE ne_label_list . RBRACE [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id -> full_identifier LBRACE ne_label_list . RBRACE LT ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On RBRACE shift to state 644
## Reductions:

State 644:
## Known stack suffix:
## full_identifier LBRACE ne_label_list RBRACE
## LR(1) items:
poly_id -> full_identifier LBRACE ne_label_list RBRACE . [ SEMICOLON READS LPAR EQUAL COLON ]
poly_id -> full_identifier LBRACE ne_label_list RBRACE . LT ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On LT shift to state 645
## Reductions:
-- On SEMICOLON READS LPAR EQUAL COLON
--   reduce production poly_id -> full_identifier LBRACE ne_label_list RBRACE

State 645:
## Known stack suffix:
## full_identifier LBRACE ne_label_list RBRACE LT
## LR(1) items:
poly_id -> full_identifier LBRACE ne_label_list RBRACE LT . ne_tvar_list GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On ne_tvar_list shift to state 646
-- On full_identifier shift to state 614
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 646:
## Known stack suffix:
## full_identifier LBRACE ne_label_list RBRACE LT ne_tvar_list
## LR(1) items:
poly_id -> full_identifier LBRACE ne_label_list RBRACE LT ne_tvar_list . GT [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
-- On GT shift to state 647
## Reductions:

State 647:
## Known stack suffix:
## full_identifier LBRACE ne_label_list RBRACE LT ne_tvar_list GT
## LR(1) items:
poly_id -> full_identifier LBRACE ne_label_list RBRACE LT ne_tvar_list GT . [ SEMICOLON READS LPAR EQUAL COLON ]
## Transitions:
## Reductions:
-- On SEMICOLON READS LPAR EQUAL COLON
--   reduce production poly_id -> full_identifier LBRACE ne_label_list RBRACE LT ne_tvar_list GT

State 648:
## Known stack suffix:
## MODEL
## LR(1) items:
model_annot -> MODEL . type_spec LBRACE full_parameter opt_semicolon RBRACE SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 649
## Reductions:

State 649:
## Known stack suffix:
## MODEL type_spec
## LR(1) items:
model_annot -> MODEL type_spec . LBRACE full_parameter opt_semicolon RBRACE SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LBRACE shift to state 650
## Reductions:

State 650:
## Known stack suffix:
## MODEL type_spec LBRACE
## LR(1) items:
model_annot -> MODEL type_spec LBRACE . full_parameter opt_semicolon RBRACE SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_parameter shift to state 651
-- On enter_kw_c_mode shift to state 572
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 651:
## Known stack suffix:
## MODEL type_spec LBRACE full_parameter
## LR(1) items:
model_annot -> MODEL type_spec LBRACE full_parameter . opt_semicolon RBRACE SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 652
-- On opt_semicolon shift to state 653
## Reductions:
-- On RBRACE
--   reduce production opt_semicolon ->

State 652:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
opt_semicolon -> SEMICOLON . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production opt_semicolon -> SEMICOLON

State 653:
## Known stack suffix:
## MODEL type_spec LBRACE full_parameter opt_semicolon
## LR(1) items:
model_annot -> MODEL type_spec LBRACE full_parameter opt_semicolon . RBRACE SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On RBRACE shift to state 654
## Reductions:

State 654:
## Known stack suffix:
## MODEL type_spec LBRACE full_parameter opt_semicolon RBRACE
## LR(1) items:
model_annot -> MODEL type_spec LBRACE full_parameter opt_semicolon RBRACE . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 655
## Reductions:

State 655:
## Known stack suffix:
## MODEL type_spec LBRACE full_parameter opt_semicolon RBRACE SEMICOLON
## LR(1) items:
model_annot -> MODEL type_spec LBRACE full_parameter opt_semicolon RBRACE SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production model_annot -> MODEL type_spec LBRACE full_parameter opt_semicolon RBRACE SEMICOLON

State 656:
## Known stack suffix:
## LOOP
## LR(1) items:
loop_allocation -> LOOP . allocation SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
loop_effects -> LOOP . ASSIGNS full_assigns SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
loop_grammar_extension -> LOOP . grammar_extension SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
loop_invariant -> LOOP . INVARIANT full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
loop_pragma -> LOOP . PRAGMA any_identifier full_ne_lexpr_list SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
loop_variant -> LOOP . VARIANT variant SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On VARIANT shift to state 657
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PRAGMA shift to state 663
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INVARIANT shift to state 670
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On ENUM shift to state 48
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 680
-- On ALLOCATES shift to state 690
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 695
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 702
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 657:
## Known stack suffix:
## LOOP VARIANT
## LR(1) items:
loop_variant -> LOOP VARIANT . variant SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On variant shift to state 658
-- On full_lexpr shift to state 660
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 658:
## Known stack suffix:
## LOOP VARIANT variant
## LR(1) items:
loop_variant -> LOOP VARIANT variant . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 659
## Reductions:

State 659:
## Known stack suffix:
## LOOP VARIANT variant SEMICOLON
## LR(1) items:
loop_variant -> LOOP VARIANT variant SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_variant -> LOOP VARIANT variant SEMICOLON

State 660:
## Known stack suffix:
## full_lexpr
## LR(1) items:
variant -> full_lexpr . FOR any_identifier [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
variant -> full_lexpr . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On FOR shift to state 661
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production variant -> full_lexpr

State 661:
## Known stack suffix:
## full_lexpr FOR
## LR(1) items:
variant -> full_lexpr FOR . any_identifier [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 662
-- On acsl_c_keyword shift to state 87
## Reductions:

State 662:
## Known stack suffix:
## full_lexpr FOR any_identifier
## LR(1) items:
variant -> full_lexpr FOR any_identifier . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production variant -> full_lexpr FOR any_identifier

State 663:
## Known stack suffix:
## LOOP PRAGMA
## LR(1) items:
loop_pragma -> LOOP PRAGMA . any_identifier full_ne_lexpr_list SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 664
-- On acsl_c_keyword shift to state 87
## Reductions:

State 664:
## Known stack suffix:
## LOOP PRAGMA any_identifier
## LR(1) items:
loop_pragma -> LOOP PRAGMA any_identifier . full_ne_lexpr_list SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_ne_lexpr_list shift to state 665
-- On enter_kw_c_mode shift to state 667
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 665:
## Known stack suffix:
## LOOP PRAGMA any_identifier full_ne_lexpr_list
## LR(1) items:
loop_pragma -> LOOP PRAGMA any_identifier full_ne_lexpr_list . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 666
## Reductions:

State 666:
## Known stack suffix:
## LOOP PRAGMA any_identifier full_ne_lexpr_list SEMICOLON
## LR(1) items:
loop_pragma -> LOOP PRAGMA any_identifier full_ne_lexpr_list SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_pragma -> LOOP PRAGMA any_identifier full_ne_lexpr_list SEMICOLON

State 667:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_ne_lexpr_list -> enter_kw_c_mode . ne_lexpr_list exit_kw_c_mode [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_lexpr_list shift to state 668
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 668:
## Known stack suffix:
## enter_kw_c_mode ne_lexpr_list
## LR(1) items:
full_ne_lexpr_list -> enter_kw_c_mode ne_lexpr_list . exit_kw_c_mode [ SEMICOLON ]
## Transitions:
-- On exit_kw_c_mode shift to state 669
## Reductions:
-- On SEMICOLON
--   reduce production exit_kw_c_mode ->

State 669:
## Known stack suffix:
## enter_kw_c_mode ne_lexpr_list exit_kw_c_mode
## LR(1) items:
full_ne_lexpr_list -> enter_kw_c_mode ne_lexpr_list exit_kw_c_mode . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production full_ne_lexpr_list -> enter_kw_c_mode ne_lexpr_list exit_kw_c_mode

State 670:
## Known stack suffix:
## LOOP INVARIANT
## LR(1) items:
loop_invariant -> LOOP INVARIANT . full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 671
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 671:
## Known stack suffix:
## LOOP INVARIANT full_lexpr
## LR(1) items:
loop_invariant -> LOOP INVARIANT full_lexpr . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 672
## Reductions:

State 672:
## Known stack suffix:
## LOOP INVARIANT full_lexpr SEMICOLON
## LR(1) items:
loop_invariant -> LOOP INVARIANT full_lexpr SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_invariant -> LOOP INVARIANT full_lexpr SEMICOLON

State 673:
## Known stack suffix:
## FREES
## LR(1) items:
allocation -> FREES . full_zones [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On full_zones shift to state 674
-- On enter_kw_c_mode shift to state 675
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 674:
## Known stack suffix:
## FREES full_zones
## LR(1) items:
allocation -> FREES full_zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production allocation -> FREES full_zones

State 675:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_zones -> enter_kw_c_mode . zones exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOTHING shift to state 676
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On zones shift to state 677
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_zones shift to state 679
-- On ne_lexpr_list shift to state 559
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 676:
## Known stack suffix:
## NOTHING
## LR(1) items:
zones -> NOTHING . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production zones -> NOTHING

State 677:
## Known stack suffix:
## enter_kw_c_mode zones
## LR(1) items:
full_zones -> enter_kw_c_mode zones . exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On exit_kw_c_mode shift to state 678
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production exit_kw_c_mode ->

State 678:
## Known stack suffix:
## enter_kw_c_mode zones exit_kw_c_mode
## LR(1) items:
full_zones -> enter_kw_c_mode zones exit_kw_c_mode . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production full_zones -> enter_kw_c_mode zones exit_kw_c_mode

State 679:
## Known stack suffix:
## ne_zones
## LR(1) items:
zones -> ne_zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production zones -> ne_zones

State 680:
## Known stack suffix:
## LOOP ASSIGNS
## LR(1) items:
loop_effects -> LOOP ASSIGNS . full_assigns SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_assigns shift to state 681
-- On enter_kw_c_mode shift to state 683
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 681:
## Known stack suffix:
## LOOP ASSIGNS full_assigns
## LR(1) items:
loop_effects -> LOOP ASSIGNS full_assigns . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 682
## Reductions:

State 682:
## Known stack suffix:
## LOOP ASSIGNS full_assigns SEMICOLON
## LR(1) items:
loop_effects -> LOOP ASSIGNS full_assigns SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_effects -> LOOP ASSIGNS full_assigns SEMICOLON

State 683:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_assigns -> enter_kw_c_mode . assigns exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOTHING shift to state 676
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On zones shift to state 684
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_zones shift to state 685
-- On ne_lexpr_list shift to state 559
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On assigns shift to state 688
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 684:
## Known stack suffix:
## zones
## LR(1) items:
assigns -> zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production assigns -> zones

State 685:
## Known stack suffix:
## ne_zones
## LR(1) items:
assigns -> ne_zones . FROM zones [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
zones -> ne_zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On FROM shift to state 686
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production zones -> ne_zones

State 686:
## Known stack suffix:
## ne_zones FROM
## LR(1) items:
assigns -> ne_zones FROM . zones [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOTHING shift to state 676
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On zones shift to state 687
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_zones shift to state 679
-- On ne_lexpr_list shift to state 559
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 687:
## Known stack suffix:
## ne_zones FROM zones
## LR(1) items:
assigns -> ne_zones FROM zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production assigns -> ne_zones FROM zones

State 688:
## Known stack suffix:
## enter_kw_c_mode assigns
## LR(1) items:
full_assigns -> enter_kw_c_mode assigns . exit_kw_c_mode [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On exit_kw_c_mode shift to state 689
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production exit_kw_c_mode ->

State 689:
## Known stack suffix:
## enter_kw_c_mode assigns exit_kw_c_mode
## LR(1) items:
full_assigns -> enter_kw_c_mode assigns exit_kw_c_mode . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production full_assigns -> enter_kw_c_mode assigns exit_kw_c_mode

State 690:
## Known stack suffix:
## ALLOCATES
## LR(1) items:
allocation -> ALLOCATES . full_zones [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On full_zones shift to state 691
-- On enter_kw_c_mode shift to state 675
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 691:
## Known stack suffix:
## ALLOCATES full_zones
## LR(1) items:
allocation -> ALLOCATES full_zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production allocation -> ALLOCATES full_zones

State 692:
## Known stack suffix:
## is_acsl_other
## LR(1) items:
grammar_extension_name -> is_acsl_other . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production grammar_extension_name -> is_acsl_other

State 693:
## Known stack suffix:
## grammar_extension_name
## LR(1) items:
grammar_extension -> grammar_extension_name . full_zones [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On full_zones shift to state 694
-- On enter_kw_c_mode shift to state 675
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 694:
## Known stack suffix:
## grammar_extension_name full_zones
## LR(1) items:
grammar_extension -> grammar_extension_name full_zones . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production grammar_extension -> grammar_extension_name full_zones

State 695:
## Known stack suffix:
## LOOP grammar_extension
## LR(1) items:
loop_grammar_extension -> LOOP grammar_extension . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 696
## Reductions:

State 696:
## Known stack suffix:
## LOOP grammar_extension SEMICOLON
## LR(1) items:
loop_grammar_extension -> LOOP grammar_extension SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_grammar_extension -> LOOP grammar_extension SEMICOLON

State 697:
## Known stack suffix:
## full_identifier_or_typename
## LR(1) items:
grammar_extension_name -> full_identifier_or_typename . [ WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production grammar_extension_name -> full_identifier_or_typename

State 698:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_identifier_or_typename -> enter_kw_c_mode . identifier_or_typename exit_kw_c_mode [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
-- On TYPENAME shift to state 10
-- On IDENTIFIER shift to state 39
-- On identifier_or_typename shift to state 699
## Reductions:

State 699:
## Known stack suffix:
## enter_kw_c_mode identifier_or_typename
## LR(1) items:
full_identifier_or_typename -> enter_kw_c_mode identifier_or_typename . exit_kw_c_mode [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
-- On exit_kw_c_mode shift to state 700
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production exit_kw_c_mode ->

State 700:
## Known stack suffix:
## enter_kw_c_mode identifier_or_typename exit_kw_c_mode
## LR(1) items:
full_identifier_or_typename -> enter_kw_c_mode identifier_or_typename exit_kw_c_mode . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production full_identifier_or_typename -> enter_kw_c_mode identifier_or_typename exit_kw_c_mode

State 701:
## Known stack suffix:
## c_keyword
## LR(1) items:
grammar_extension_name -> c_keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production grammar_extension_name -> c_keyword

State 702:
## Known stack suffix:
## LOOP allocation
## LR(1) items:
loop_allocation -> LOOP allocation . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 703
## Reductions:

State 703:
## Known stack suffix:
## LOOP allocation SEMICOLON
## LR(1) items:
loop_allocation -> LOOP allocation SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOOP LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_allocation -> LOOP allocation SEMICOLON

State 704:
## Known stack suffix:
## LOGIC
## LR(1) items:
deprecated_logic_decl -> LOGIC . full_logic_rt_type poly_id opt_parameters SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> LOGIC . full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_logic_rt_type shift to state 705
-- On enter_kw_c_mode shift to state 712
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 705:
## Known stack suffix:
## LOGIC full_logic_rt_type
## LR(1) items:
deprecated_logic_decl -> LOGIC full_logic_rt_type . poly_id opt_parameters SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type . poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 706
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 706:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id
## LR(1) items:
deprecated_logic_decl -> LOGIC full_logic_rt_type poly_id . opt_parameters SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type poly_id . opt_parameters EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 626
-- On parameters shift to state 635
-- On opt_parameters shift to state 707
## Reductions:
-- On SEMICOLON EQUAL
--   reduce production opt_parameters ->

State 707:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters
## LR(1) items:
deprecated_logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters . EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 708
-- On EQUAL shift to state 709
## Reductions:

State 708:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters SEMICOLON
## LR(1) items:
deprecated_logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production deprecated_logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters SEMICOLON

State 709:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters EQUAL
## LR(1) items:
logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters EQUAL . full_lexpr SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 710
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 710:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr
## LR(1) items:
logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr . SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 711
## Reductions:

State 711:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr SEMICOLON
## LR(1) items:
logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr SEMICOLON . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr SEMICOLON

State 712:
## Known stack suffix:
## enter_kw_c_mode
## LR(1) items:
full_logic_rt_type -> enter_kw_c_mode . logic_rt_type exit_kw_c_mode [ IDENTIFIER ]
## Transitions:
-- On IDENTIFIER shift to state 220
-- On logic_rt_type shift to state 713
-- On identifier shift to state 577
-- On id_as_typename shift to state 715
-- On begin_rt_type shift to state 716
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production begin_rt_type ->

State 713:
## Known stack suffix:
## enter_kw_c_mode logic_rt_type
## LR(1) items:
full_logic_rt_type -> enter_kw_c_mode logic_rt_type . exit_kw_c_mode [ IDENTIFIER ]
## Transitions:
-- On exit_kw_c_mode shift to state 714
## Reductions:
-- On IDENTIFIER
--   reduce production exit_kw_c_mode ->

State 714:
## Known stack suffix:
## enter_kw_c_mode logic_rt_type exit_kw_c_mode
## LR(1) items:
full_logic_rt_type -> enter_kw_c_mode logic_rt_type exit_kw_c_mode . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production full_logic_rt_type -> enter_kw_c_mode logic_rt_type exit_kw_c_mode

State 715:
## Known stack suffix:
## id_as_typename
## LR(1) items:
logic_rt_type -> id_as_typename . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production logic_rt_type -> id_as_typename

State 716:
## Known stack suffix:
## begin_rt_type
## LR(1) items:
logic_rt_type -> begin_rt_type . logic_type end_rt_type [ IDENTIFIER ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 157
-- On logic_type shift to state 717
## Reductions:

State 717:
## Known stack suffix:
## begin_rt_type logic_type
## LR(1) items:
logic_rt_type -> begin_rt_type logic_type . end_rt_type [ IDENTIFIER ]
## Transitions:
-- On end_rt_type shift to state 718
## Reductions:
-- On IDENTIFIER
--   reduce production end_rt_type ->

State 718:
## Known stack suffix:
## begin_rt_type logic_type end_rt_type
## LR(1) items:
logic_rt_type -> begin_rt_type logic_type end_rt_type . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production logic_rt_type -> begin_rt_type logic_type end_rt_type

State 719:
## Known stack suffix:
## LEMMA
## LR(1) items:
logic_def -> LEMMA . poly_id COLON full_lexpr SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 720
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 720:
## Known stack suffix:
## LEMMA poly_id
## LR(1) items:
logic_def -> LEMMA poly_id . COLON full_lexpr SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 721
## Reductions:

State 721:
## Known stack suffix:
## LEMMA poly_id COLON
## LR(1) items:
logic_def -> LEMMA poly_id COLON . full_lexpr SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 722
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 722:
## Known stack suffix:
## LEMMA poly_id COLON full_lexpr
## LR(1) items:
logic_def -> LEMMA poly_id COLON full_lexpr . SEMICOLON [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 723
## Reductions:

State 723:
## Known stack suffix:
## LEMMA poly_id COLON full_lexpr SEMICOLON
## LR(1) items:
logic_def -> LEMMA poly_id COLON full_lexpr SEMICOLON . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> LEMMA poly_id COLON full_lexpr SEMICOLON

State 724:
## Known stack suffix:
## INVARIANT
## LR(1) items:
code_annotation -> INVARIANT . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On full_lexpr shift to state 725
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 725:
## Known stack suffix:
## INVARIANT full_lexpr
## LR(1) items:
code_annotation -> INVARIANT full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 726
## Reductions:

State 726:
## Known stack suffix:
## INVARIANT full_lexpr SEMICOLON
## LR(1) items:
code_annotation -> INVARIANT full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> INVARIANT full_lexpr SEMICOLON

State 727:
## Known stack suffix:
## INDUCTIVE
## LR(1) items:
logic_def -> INDUCTIVE . poly_id parameters LBRACE indcases RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 728
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 728:
## Known stack suffix:
## INDUCTIVE poly_id
## LR(1) items:
logic_def -> INDUCTIVE poly_id . parameters LBRACE indcases RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 626
-- On parameters shift to state 729
## Reductions:

State 729:
## Known stack suffix:
## INDUCTIVE poly_id parameters
## LR(1) items:
logic_def -> INDUCTIVE poly_id parameters . LBRACE indcases RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LBRACE shift to state 730
## Reductions:

State 730:
## Known stack suffix:
## INDUCTIVE poly_id parameters LBRACE
## LR(1) items:
logic_def -> INDUCTIVE poly_id parameters LBRACE . indcases RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On CASE shift to state 731
-- On indcases shift to state 737
## Reductions:
-- On RBRACE
--   reduce production indcases ->

State 731:
## Known stack suffix:
## CASE
## LR(1) items:
indcases -> CASE . poly_id COLON full_lexpr SEMICOLON indcases [ RBRACE ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 732
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 732:
## Known stack suffix:
## CASE poly_id
## LR(1) items:
indcases -> CASE poly_id . COLON full_lexpr SEMICOLON indcases [ RBRACE ]
## Transitions:
-- On COLON shift to state 733
## Reductions:

State 733:
## Known stack suffix:
## CASE poly_id COLON
## LR(1) items:
indcases -> CASE poly_id COLON . full_lexpr SEMICOLON indcases [ RBRACE ]
## Transitions:
-- On full_lexpr shift to state 734
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 734:
## Known stack suffix:
## CASE poly_id COLON full_lexpr
## LR(1) items:
indcases -> CASE poly_id COLON full_lexpr . SEMICOLON indcases [ RBRACE ]
## Transitions:
-- On SEMICOLON shift to state 735
## Reductions:

State 735:
## Known stack suffix:
## CASE poly_id COLON full_lexpr SEMICOLON
## LR(1) items:
indcases -> CASE poly_id COLON full_lexpr SEMICOLON . indcases [ RBRACE ]
## Transitions:
-- On CASE shift to state 731
-- On indcases shift to state 736
## Reductions:
-- On RBRACE
--   reduce production indcases ->

State 736:
## Known stack suffix:
## CASE poly_id COLON full_lexpr SEMICOLON indcases
## LR(1) items:
indcases -> CASE poly_id COLON full_lexpr SEMICOLON indcases . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production indcases -> CASE poly_id COLON full_lexpr SEMICOLON indcases

State 737:
## Known stack suffix:
## INDUCTIVE poly_id parameters LBRACE indcases
## LR(1) items:
logic_def -> INDUCTIVE poly_id parameters LBRACE indcases . RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On RBRACE shift to state 738
## Reductions:

State 738:
## Known stack suffix:
## INDUCTIVE poly_id parameters LBRACE indcases RBRACE
## LR(1) items:
logic_def -> INDUCTIVE poly_id parameters LBRACE indcases RBRACE . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> INDUCTIVE poly_id parameters LBRACE indcases RBRACE

State 739:
## Known stack suffix:
## IMPACT
## LR(1) items:
impact_pragma -> IMPACT . PRAGMA any_identifier full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
impact_pragma -> IMPACT . PRAGMA any_identifier SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On PRAGMA shift to state 740
## Reductions:

State 740:
## Known stack suffix:
## IMPACT PRAGMA
## LR(1) items:
impact_pragma -> IMPACT PRAGMA . any_identifier full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
impact_pragma -> IMPACT PRAGMA . any_identifier SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 741
-- On acsl_c_keyword shift to state 87
## Reductions:

State 741:
## Known stack suffix:
## IMPACT PRAGMA any_identifier
## LR(1) items:
impact_pragma -> IMPACT PRAGMA any_identifier . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
impact_pragma -> IMPACT PRAGMA any_identifier . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 742
-- On full_lexpr shift to state 743
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 742:
## Known stack suffix:
## IMPACT PRAGMA any_identifier SEMICOLON
## LR(1) items:
impact_pragma -> IMPACT PRAGMA any_identifier SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production impact_pragma -> IMPACT PRAGMA any_identifier SEMICOLON

State 743:
## Known stack suffix:
## IMPACT PRAGMA any_identifier full_lexpr
## LR(1) items:
impact_pragma -> IMPACT PRAGMA any_identifier full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 744
## Reductions:

State 744:
## Known stack suffix:
## IMPACT PRAGMA any_identifier full_lexpr SEMICOLON
## LR(1) items:
impact_pragma -> IMPACT PRAGMA any_identifier full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production impact_pragma -> IMPACT PRAGMA any_identifier full_lexpr SEMICOLON

State 745:
## Known stack suffix:
## GLOBAL
## LR(1) items:
decl -> GLOBAL . INVARIANT any_identifier COLON full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On INVARIANT shift to state 746
## Reductions:

State 746:
## Known stack suffix:
## GLOBAL INVARIANT
## LR(1) items:
decl -> GLOBAL INVARIANT . any_identifier COLON full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 747
-- On acsl_c_keyword shift to state 87
## Reductions:

State 747:
## Known stack suffix:
## GLOBAL INVARIANT any_identifier
## LR(1) items:
decl -> GLOBAL INVARIANT any_identifier . COLON full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 748
## Reductions:

State 748:
## Known stack suffix:
## GLOBAL INVARIANT any_identifier COLON
## LR(1) items:
decl -> GLOBAL INVARIANT any_identifier COLON . full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 749
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 749:
## Known stack suffix:
## GLOBAL INVARIANT any_identifier COLON full_lexpr
## LR(1) items:
decl -> GLOBAL INVARIANT any_identifier COLON full_lexpr . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 750
## Reductions:

State 750:
## Known stack suffix:
## GLOBAL INVARIANT any_identifier COLON full_lexpr SEMICOLON
## LR(1) items:
decl -> GLOBAL INVARIANT any_identifier COLON full_lexpr SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> GLOBAL INVARIANT any_identifier COLON full_lexpr SEMICOLON

State 751:
## Known stack suffix:
## FOR
## LR(1) items:
annotation -> FOR . ne_behavior_name_list COLON contract [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
code_annotation -> FOR . ne_behavior_name_list COLON ASSERT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
code_annotation -> FOR . ne_behavior_name_list COLON INVARIANT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
loop_annot_stack -> FOR . ne_behavior_name_list COLON loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_behavior_name_list shift to state 752
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name shift to state 792
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:

State 752:
## Known stack suffix:
## FOR ne_behavior_name_list
## LR(1) items:
annotation -> FOR ne_behavior_name_list . COLON contract [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
code_annotation -> FOR ne_behavior_name_list . COLON ASSERT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
code_annotation -> FOR ne_behavior_name_list . COLON INVARIANT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
loop_annot_stack -> FOR ne_behavior_name_list . COLON loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 753
## Reductions:

State 753:
## Known stack suffix:
## FOR ne_behavior_name_list COLON
## LR(1) items:
annotation -> FOR ne_behavior_name_list COLON . contract [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
code_annotation -> FOR ne_behavior_name_list COLON . ASSERT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
code_annotation -> FOR ne_behavior_name_list COLON . INVARIANT full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
loop_annot_stack -> FOR ne_behavior_name_list COLON . loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On REQUIRES shift to state 754
-- On LOOP shift to state 656
-- On INVARIANT shift to state 772
-- On FOR shift to state 775
-- On ASSERT shift to state 796
-- On requires shift to state 799
-- On ne_requires shift to state 758
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 791
-- On loop_allocation shift to state 785
-- On contract shift to state 888
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production requires ->

State 754:
## Known stack suffix:
## REQUIRES
## LR(1) items:
ne_requires -> REQUIRES . full_lexpr SEMICOLON requires [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
ne_requires -> REQUIRES . full_lexpr clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On full_lexpr shift to state 755
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 755:
## Known stack suffix:
## REQUIRES full_lexpr
## LR(1) items:
ne_requires -> REQUIRES full_lexpr . SEMICOLON requires [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
ne_requires -> REQUIRES full_lexpr . clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 756
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 771
## Reductions:

State 756:
## Known stack suffix:
## REQUIRES full_lexpr SEMICOLON
## LR(1) items:
ne_requires -> REQUIRES full_lexpr SEMICOLON . requires [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On REQUIRES shift to state 754
-- On requires shift to state 757
-- On ne_requires shift to state 758
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production requires ->

State 757:
## Known stack suffix:
## REQUIRES full_lexpr SEMICOLON requires
## LR(1) items:
ne_requires -> REQUIRES full_lexpr SEMICOLON requires . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_requires -> REQUIRES full_lexpr SEMICOLON requires

State 758:
## Known stack suffix:
## ne_requires
## LR(1) items:
requires -> ne_requires . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production requires -> ne_requires

State 759:
## Known stack suffix:
## REQUIRES
## LR(1) items:
clause_kw -> REQUIRES . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> REQUIRES

State 760:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
clause_kw -> IDENTIFIER . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> IDENTIFIER

State 761:
## Known stack suffix:
## FREES
## LR(1) items:
clause_kw -> FREES . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> FREES

State 762:
## Known stack suffix:
## EOF
## LR(1) items:
clause_kw -> EOF . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> EOF

State 763:
## Known stack suffix:
## DISJOINT
## LR(1) items:
clause_kw -> DISJOINT . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> DISJOINT

State 764:
## Known stack suffix:
## DECREASES
## LR(1) items:
clause_kw -> DECREASES . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> DECREASES

State 765:
## Known stack suffix:
## COMPLETE
## LR(1) items:
clause_kw -> COMPLETE . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> COMPLETE

State 766:
## Known stack suffix:
## BEHAVIOR
## LR(1) items:
clause_kw -> BEHAVIOR . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> BEHAVIOR

State 767:
## Known stack suffix:
## ASSUMES
## LR(1) items:
clause_kw -> ASSUMES . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> ASSUMES

State 768:
## Known stack suffix:
## ASSIGNS
## LR(1) items:
clause_kw -> ASSIGNS . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> ASSIGNS

State 769:
## Known stack suffix:
## ALLOCATES
## LR(1) items:
clause_kw -> ALLOCATES . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> ALLOCATES

State 770:
## Known stack suffix:
## post_cond
## LR(1) items:
clause_kw -> post_cond . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production clause_kw -> post_cond

State 771:
## Known stack suffix:
## REQUIRES full_lexpr clause_kw
## LR(1) items:
ne_requires -> REQUIRES full_lexpr clause_kw . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_requires -> REQUIRES full_lexpr clause_kw

State 772:
## Known stack suffix:
## FOR ne_behavior_name_list COLON INVARIANT
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON INVARIANT . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On full_lexpr shift to state 773
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 773:
## Known stack suffix:
## FOR ne_behavior_name_list COLON INVARIANT full_lexpr
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON INVARIANT full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 774
## Reductions:

State 774:
## Known stack suffix:
## FOR ne_behavior_name_list COLON INVARIANT full_lexpr SEMICOLON
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON INVARIANT full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> FOR ne_behavior_name_list COLON INVARIANT full_lexpr SEMICOLON

State 775:
## Known stack suffix:
## FOR
## LR(1) items:
loop_annot_stack -> FOR . ne_behavior_name_list COLON loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_behavior_name_list shift to state 776
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name shift to state 792
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:

State 776:
## Known stack suffix:
## FOR ne_behavior_name_list
## LR(1) items:
loop_annot_stack -> FOR ne_behavior_name_list . COLON loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 777
## Reductions:

State 777:
## Known stack suffix:
## FOR ne_behavior_name_list COLON
## LR(1) items:
loop_annot_stack -> FOR ne_behavior_name_list COLON . loop_annot_stack [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 791
-- On loop_allocation shift to state 785
## Reductions:

State 778:
## Known stack suffix:
## loop_variant
## LR(1) items:
loop_annot_stack -> loop_variant . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 790
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 779:
## Known stack suffix:
## loop_pragma
## LR(1) items:
loop_annot_stack -> loop_pragma . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 789
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 780:
## Known stack suffix:
## loop_invariant
## LR(1) items:
loop_annot_stack -> loop_invariant . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 788
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 781:
## Known stack suffix:
## loop_grammar_extension
## LR(1) items:
loop_annot_stack -> loop_grammar_extension . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 787
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 782:
## Known stack suffix:
## loop_effects
## LR(1) items:
loop_annot_stack -> loop_effects . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 784
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 783:
## Known stack suffix:
## loop_annot_stack
## LR(1) items:
loop_annot_opt -> loop_annot_stack . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt -> loop_annot_stack

State 784:
## Known stack suffix:
## loop_effects loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_effects loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_effects loop_annot_opt

State 785:
## Known stack suffix:
## loop_allocation
## LR(1) items:
loop_annot_stack -> loop_allocation . loop_annot_opt [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LOOP shift to state 656
-- On FOR shift to state 775
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annot_stack shift to state 783
-- On loop_annot_opt shift to state 786
-- On loop_allocation shift to state 785
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_opt ->

State 786:
## Known stack suffix:
## loop_allocation loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_allocation loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_allocation loop_annot_opt

State 787:
## Known stack suffix:
## loop_grammar_extension loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_grammar_extension loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_grammar_extension loop_annot_opt

State 788:
## Known stack suffix:
## loop_invariant loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_invariant loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_invariant loop_annot_opt

State 789:
## Known stack suffix:
## loop_pragma loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_pragma loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_pragma loop_annot_opt

State 790:
## Known stack suffix:
## loop_variant loop_annot_opt
## LR(1) items:
loop_annot_stack -> loop_variant loop_annot_opt . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> loop_variant loop_annot_opt

State 791:
## Known stack suffix:
## FOR ne_behavior_name_list COLON loop_annot_stack
## LR(1) items:
loop_annot_stack -> FOR ne_behavior_name_list COLON loop_annot_stack . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annot_stack -> FOR ne_behavior_name_list COLON loop_annot_stack

State 792:
## Known stack suffix:
## behavior_name
## LR(1) items:
ne_behavior_name_list -> behavior_name . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
ne_behavior_name_list -> behavior_name . COMMA ne_behavior_name_list [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On COMMA shift to state 793
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_behavior_name_list -> behavior_name

State 793:
## Known stack suffix:
## behavior_name COMMA
## LR(1) items:
ne_behavior_name_list -> behavior_name COMMA . ne_behavior_name_list [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_behavior_name_list shift to state 794
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name shift to state 792
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:

State 794:
## Known stack suffix:
## behavior_name COMMA ne_behavior_name_list
## LR(1) items:
ne_behavior_name_list -> behavior_name COMMA ne_behavior_name_list . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production ne_behavior_name_list -> behavior_name COMMA ne_behavior_name_list

State 795:
## Known stack suffix:
## any_identifier
## LR(1) items:
behavior_name -> any_identifier . [ SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On SEMICOLON RETURNS REQUIRES IDENTIFIER FREES EXITS EOF ENSURES DISJOINT DECREASES CONTINUES COMPLETE COMMA COLON BREAKS BEHAVIOR ASSUMES ASSIGNS ALLOCATES
--   reduce production behavior_name -> any_identifier

State 796:
## Known stack suffix:
## FOR ne_behavior_name_list COLON ASSERT
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON ASSERT . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On full_lexpr shift to state 797
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 797:
## Known stack suffix:
## FOR ne_behavior_name_list COLON ASSERT full_lexpr
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON ASSERT full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 798
## Reductions:

State 798:
## Known stack suffix:
## FOR ne_behavior_name_list COLON ASSERT full_lexpr SEMICOLON
## LR(1) items:
code_annotation -> FOR ne_behavior_name_list COLON ASSERT full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> FOR ne_behavior_name_list COLON ASSERT full_lexpr SEMICOLON

State 799:
## Known stack suffix:
## requires
## LR(1) items:
contract -> requires . terminates decreases simple_clauses behaviors complete_or_disjoint [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . ne_terminates REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates ne_decreases REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates ne_decreases TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases ne_simple_clauses REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases ne_simple_clauses TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases ne_simple_clauses DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses ne_behaviors TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses ne_behaviors DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires . terminates decreases simple_clauses behaviors ne_complete_or_disjoint post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On TERMINATES shift to state 800
-- On terminates shift to state 804
-- On ne_terminates shift to state 886
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production terminates ->

State 800:
## Known stack suffix:
## TERMINATES
## LR(1) items:
ne_terminates -> TERMINATES . full_lexpr SEMICOLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_terminates -> TERMINATES . full_lexpr clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On full_lexpr shift to state 801
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 801:
## Known stack suffix:
## TERMINATES full_lexpr
## LR(1) items:
ne_terminates -> TERMINATES full_lexpr . SEMICOLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_terminates -> TERMINATES full_lexpr . clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 802
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 803
## Reductions:

State 802:
## Known stack suffix:
## TERMINATES full_lexpr SEMICOLON
## LR(1) items:
ne_terminates -> TERMINATES full_lexpr SEMICOLON . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_terminates -> TERMINATES full_lexpr SEMICOLON

State 803:
## Known stack suffix:
## TERMINATES full_lexpr clause_kw
## LR(1) items:
ne_terminates -> TERMINATES full_lexpr clause_kw . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_terminates -> TERMINATES full_lexpr clause_kw

State 804:
## Known stack suffix:
## requires terminates
## LR(1) items:
contract -> requires terminates . decreases simple_clauses behaviors complete_or_disjoint [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . ne_decreases REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . ne_decreases TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases ne_simple_clauses REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases ne_simple_clauses TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases ne_simple_clauses DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses ne_behaviors TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses ne_behaviors DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates . decreases simple_clauses behaviors ne_complete_or_disjoint post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On DECREASES shift to state 805
-- On ne_decreases shift to state 809
-- On decreases shift to state 812
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production decreases ->

State 805:
## Known stack suffix:
## DECREASES
## LR(1) items:
ne_decreases -> DECREASES . variant SEMICOLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_decreases -> DECREASES . variant clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On variant shift to state 806
-- On full_lexpr shift to state 660
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 806:
## Known stack suffix:
## DECREASES variant
## LR(1) items:
ne_decreases -> DECREASES variant . SEMICOLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_decreases -> DECREASES variant . clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 807
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 808
## Reductions:

State 807:
## Known stack suffix:
## DECREASES variant SEMICOLON
## LR(1) items:
ne_decreases -> DECREASES variant SEMICOLON . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_decreases -> DECREASES variant SEMICOLON

State 808:
## Known stack suffix:
## DECREASES variant clause_kw
## LR(1) items:
ne_decreases -> DECREASES variant clause_kw . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_decreases -> DECREASES variant clause_kw

State 809:
## Known stack suffix:
## requires terminates ne_decreases
## LR(1) items:
contract -> requires terminates ne_decreases . REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates ne_decreases . TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
decreases -> ne_decreases . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On TERMINATES shift to state 810
-- On REQUIRES shift to state 811
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production decreases -> ne_decreases

State 810:
## Known stack suffix:
## requires terminates ne_decreases TERMINATES
## LR(1) items:
contract -> requires terminates ne_decreases TERMINATES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates ne_decreases TERMINATES

State 811:
## Known stack suffix:
## requires terminates ne_decreases REQUIRES
## LR(1) items:
contract -> requires terminates ne_decreases REQUIRES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates ne_decreases REQUIRES

State 812:
## Known stack suffix:
## requires terminates decreases
## LR(1) items:
contract -> requires terminates decreases . simple_clauses behaviors complete_or_disjoint [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . ne_simple_clauses REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . ne_simple_clauses TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . ne_simple_clauses DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses ne_behaviors TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses ne_behaviors DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases . simple_clauses behaviors ne_complete_or_disjoint post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 833
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 882
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production simple_clauses ->

State 813:
## Known stack suffix:
## ASSIGNS
## LR(1) items:
ne_simple_clauses -> ASSIGNS . full_assigns SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> ASSIGNS . full_assigns clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On full_assigns shift to state 814
-- On enter_kw_c_mode shift to state 683
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOTHING NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 814:
## Known stack suffix:
## ASSIGNS full_assigns
## LR(1) items:
ne_simple_clauses -> ASSIGNS full_assigns . SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> ASSIGNS full_assigns . clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On SEMICOLON shift to state 815
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 832
## Reductions:

State 815:
## Known stack suffix:
## ASSIGNS full_assigns SEMICOLON
## LR(1) items:
ne_simple_clauses -> ASSIGNS full_assigns SEMICOLON . simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 816
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 822
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production simple_clauses ->

State 816:
## Known stack suffix:
## ASSIGNS full_assigns SEMICOLON simple_clauses
## LR(1) items:
ne_simple_clauses -> ASSIGNS full_assigns SEMICOLON simple_clauses . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> ASSIGNS full_assigns SEMICOLON simple_clauses

State 817:
## Known stack suffix:
## post_cond_kind
## LR(1) items:
ne_simple_clauses -> post_cond_kind . full_lexpr SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> post_cond_kind . full_lexpr clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On full_lexpr shift to state 818
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 818:
## Known stack suffix:
## post_cond_kind full_lexpr
## LR(1) items:
ne_simple_clauses -> post_cond_kind full_lexpr . SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> post_cond_kind full_lexpr . clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On SEMICOLON shift to state 819
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 831
## Reductions:

State 819:
## Known stack suffix:
## post_cond_kind full_lexpr SEMICOLON
## LR(1) items:
ne_simple_clauses -> post_cond_kind full_lexpr SEMICOLON . simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 820
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 822
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production simple_clauses ->

State 820:
## Known stack suffix:
## post_cond_kind full_lexpr SEMICOLON simple_clauses
## LR(1) items:
ne_simple_clauses -> post_cond_kind full_lexpr SEMICOLON simple_clauses . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> post_cond_kind full_lexpr SEMICOLON simple_clauses

State 821:
## Known stack suffix:
## post_cond
## LR(1) items:
post_cond_kind -> post_cond . [ WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production post_cond_kind -> post_cond

State 822:
## Known stack suffix:
## ne_simple_clauses
## LR(1) items:
simple_clauses -> ne_simple_clauses . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production simple_clauses -> ne_simple_clauses

State 823:
## Known stack suffix:
## grammar_extension
## LR(1) items:
ne_simple_clauses -> grammar_extension . SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> grammar_extension . clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On SEMICOLON shift to state 824
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 830
## Reductions:

State 824:
## Known stack suffix:
## grammar_extension SEMICOLON
## LR(1) items:
ne_simple_clauses -> grammar_extension SEMICOLON . simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 825
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 822
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production simple_clauses ->

State 825:
## Known stack suffix:
## grammar_extension SEMICOLON simple_clauses
## LR(1) items:
ne_simple_clauses -> grammar_extension SEMICOLON simple_clauses . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> grammar_extension SEMICOLON simple_clauses

State 826:
## Known stack suffix:
## allocation
## LR(1) items:
ne_simple_clauses -> allocation . SEMICOLON simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
ne_simple_clauses -> allocation . clause_kw [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On SEMICOLON shift to state 827
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 829
## Reductions:

State 827:
## Known stack suffix:
## allocation SEMICOLON
## LR(1) items:
ne_simple_clauses -> allocation SEMICOLON . simple_clauses [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 828
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 822
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production simple_clauses ->

State 828:
## Known stack suffix:
## allocation SEMICOLON simple_clauses
## LR(1) items:
ne_simple_clauses -> allocation SEMICOLON simple_clauses . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> allocation SEMICOLON simple_clauses

State 829:
## Known stack suffix:
## allocation clause_kw
## LR(1) items:
ne_simple_clauses -> allocation clause_kw . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> allocation clause_kw

State 830:
## Known stack suffix:
## grammar_extension clause_kw
## LR(1) items:
ne_simple_clauses -> grammar_extension clause_kw . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> grammar_extension clause_kw

State 831:
## Known stack suffix:
## post_cond_kind full_lexpr clause_kw
## LR(1) items:
ne_simple_clauses -> post_cond_kind full_lexpr clause_kw . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> post_cond_kind full_lexpr clause_kw

State 832:
## Known stack suffix:
## ASSIGNS full_assigns clause_kw
## LR(1) items:
ne_simple_clauses -> ASSIGNS full_assigns clause_kw . [ VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ASSUMES
--   reduce production ne_simple_clauses -> ASSIGNS full_assigns clause_kw

State 833:
## Known stack suffix:
## requires terminates decreases simple_clauses
## LR(1) items:
contract -> requires terminates decreases simple_clauses . behaviors complete_or_disjoint [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . ne_behaviors TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . ne_behaviors DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses . behaviors ne_complete_or_disjoint post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On BEHAVIOR shift to state 834
-- On ne_behaviors shift to state 853
-- On behaviors shift to state 856
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE AXIOMATIC AXIOM
--   reduce production behaviors ->

State 834:
## Known stack suffix:
## BEHAVIOR
## LR(1) items:
ne_behaviors -> BEHAVIOR . behavior_name COLON behavior_body behaviors [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name shift to state 835
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:

State 835:
## Known stack suffix:
## BEHAVIOR behavior_name
## LR(1) items:
ne_behaviors -> BEHAVIOR behavior_name . COLON behavior_body behaviors [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 836
## Reductions:

State 836:
## Known stack suffix:
## BEHAVIOR behavior_name COLON
## LR(1) items:
ne_behaviors -> BEHAVIOR behavior_name COLON . behavior_body behaviors [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
-- On ASSUMES shift to state 837
-- On behavior_body shift to state 842
-- On assumes shift to state 845
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production assumes ->

State 837:
## Known stack suffix:
## ASSUMES
## LR(1) items:
assumes -> ASSUMES . full_lexpr SEMICOLON assumes [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
assumes -> ASSUMES . full_lexpr clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On full_lexpr shift to state 838
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 838:
## Known stack suffix:
## ASSUMES full_lexpr
## LR(1) items:
assumes -> ASSUMES full_lexpr . SEMICOLON assumes [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
assumes -> ASSUMES full_lexpr . clause_kw [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 839
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 841
## Reductions:

State 839:
## Known stack suffix:
## ASSUMES full_lexpr SEMICOLON
## LR(1) items:
assumes -> ASSUMES full_lexpr SEMICOLON . assumes [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On ASSUMES shift to state 837
-- On assumes shift to state 840
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production assumes ->

State 840:
## Known stack suffix:
## ASSUMES full_lexpr SEMICOLON assumes
## LR(1) items:
assumes -> ASSUMES full_lexpr SEMICOLON assumes . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production assumes -> ASSUMES full_lexpr SEMICOLON assumes

State 841:
## Known stack suffix:
## ASSUMES full_lexpr clause_kw
## LR(1) items:
assumes -> ASSUMES full_lexpr clause_kw . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production assumes -> ASSUMES full_lexpr clause_kw

State 842:
## Known stack suffix:
## BEHAVIOR behavior_name COLON behavior_body
## LR(1) items:
ne_behaviors -> BEHAVIOR behavior_name COLON behavior_body . behaviors [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
-- On BEHAVIOR shift to state 834
-- On ne_behaviors shift to state 843
-- On behaviors shift to state 844
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM
--   reduce production behaviors ->

State 843:
## Known stack suffix:
## ne_behaviors
## LR(1) items:
behaviors -> ne_behaviors . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM
--   reduce production behaviors -> ne_behaviors

State 844:
## Known stack suffix:
## BEHAVIOR behavior_name COLON behavior_body behaviors
## LR(1) items:
ne_behaviors -> BEHAVIOR behavior_name COLON behavior_body behaviors . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE AXIOMATIC AXIOM
--   reduce production ne_behaviors -> BEHAVIOR behavior_name COLON behavior_body behaviors

State 845:
## Known stack suffix:
## assumes
## LR(1) items:
behavior_body -> assumes . requires simple_clauses [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes . ne_requires ASSUMES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes . requires ne_simple_clauses ASSUMES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes . requires ne_simple_clauses REQUIRES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
-- On REQUIRES shift to state 754
-- On requires shift to state 846
-- On ne_requires shift to state 851
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production requires ->

State 846:
## Known stack suffix:
## assumes requires
## LR(1) items:
behavior_body -> assumes requires . simple_clauses [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes requires . ne_simple_clauses ASSUMES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes requires . ne_simple_clauses REQUIRES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOID shift to state 4
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REAL shift to state 21
-- On READS shift to state 22
-- On LONG shift to state 28
-- On LABEL shift to state 31
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On IF shift to state 38
-- On FREES shift to state 673
-- On FLOAT shift to state 44
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On ASSIGNS shift to state 813
-- On ALLOCATES shift to state 690
-- On simple_clauses shift to state 847
-- On post_cond_kind shift to state 817
-- On post_cond shift to state 821
-- On ne_simple_clauses shift to state 848
-- On is_acsl_other shift to state 692
-- On grammar_extension_name shift to state 693
-- On grammar_extension shift to state 823
-- On full_identifier_or_typename shift to state 697
-- On enter_kw_c_mode shift to state 698
-- On c_keyword shift to state 701
-- On allocation shift to state 826
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production simple_clauses ->

State 847:
## Known stack suffix:
## assumes requires simple_clauses
## LR(1) items:
behavior_body -> assumes requires simple_clauses . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production behavior_body -> assumes requires simple_clauses

State 848:
## Known stack suffix:
## assumes requires ne_simple_clauses
## LR(1) items:
behavior_body -> assumes requires ne_simple_clauses . ASSUMES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
behavior_body -> assumes requires ne_simple_clauses . REQUIRES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
simple_clauses -> ne_simple_clauses . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
-- On REQUIRES shift to state 849
-- On ASSUMES shift to state 850
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production simple_clauses -> ne_simple_clauses

State 849:
## Known stack suffix:
## assumes requires ne_simple_clauses REQUIRES
## LR(1) items:
behavior_body -> assumes requires ne_simple_clauses REQUIRES . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production behavior_body -> assumes requires ne_simple_clauses REQUIRES

State 850:
## Known stack suffix:
## assumes requires ne_simple_clauses ASSUMES
## LR(1) items:
behavior_body -> assumes requires ne_simple_clauses ASSUMES . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production behavior_body -> assumes requires ne_simple_clauses ASSUMES

State 851:
## Known stack suffix:
## assumes ne_requires
## LR(1) items:
behavior_body -> assumes ne_requires . ASSUMES [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
requires -> ne_requires . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On ASSUMES shift to state 852
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production requires -> ne_requires

State 852:
## Known stack suffix:
## assumes ne_requires ASSUMES
## LR(1) items:
behavior_body -> assumes ne_requires ASSUMES . [ VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT DECREASES CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production behavior_body -> assumes ne_requires ASSUMES

State 853:
## Known stack suffix:
## requires terminates decreases simple_clauses ne_behaviors
## LR(1) items:
behaviors -> ne_behaviors . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses ne_behaviors . TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses ne_behaviors . DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On TERMINATES shift to state 854
-- On DECREASES shift to state 855
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE AXIOMATIC AXIOM
--   reduce production behaviors -> ne_behaviors

State 854:
## Known stack suffix:
## requires terminates decreases simple_clauses ne_behaviors TERMINATES
## LR(1) items:
contract -> requires terminates decreases simple_clauses ne_behaviors TERMINATES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses ne_behaviors TERMINATES

State 855:
## Known stack suffix:
## requires terminates decreases simple_clauses ne_behaviors DECREASES
## LR(1) items:
contract -> requires terminates decreases simple_clauses ne_behaviors DECREASES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses ne_behaviors DECREASES

State 856:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors . complete_or_disjoint [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors . ne_complete_or_disjoint post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On DISJOINT shift to state 857
-- On COMPLETE shift to state 863
-- On ne_complete_or_disjoint shift to state 872
-- On complete_or_disjoint shift to state 881
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production complete_or_disjoint ->

State 857:
## Known stack suffix:
## DISJOINT
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT . BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_complete_or_disjoint -> DISJOINT . BEHAVIORS ne_behavior_name_list clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On BEHAVIORS shift to state 858
## Reductions:

State 858:
## Known stack suffix:
## DISJOINT BEHAVIORS
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT BEHAVIORS . behavior_name_list SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_complete_or_disjoint -> DISJOINT BEHAVIORS . ne_behavior_name_list clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_behavior_name_list shift to state 859
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name_list shift to state 861
-- On behavior_name shift to state 792
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On SEMICOLON
--   reduce production behavior_name_list ->

State 859:
## Known stack suffix:
## DISJOINT BEHAVIORS ne_behavior_name_list
## LR(1) items:
behavior_name_list -> ne_behavior_name_list . [ SEMICOLON ]
ne_complete_or_disjoint -> DISJOINT BEHAVIORS ne_behavior_name_list . clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 860
## Reductions:
-- On SEMICOLON
--   reduce production behavior_name_list -> ne_behavior_name_list

State 860:
## Known stack suffix:
## DISJOINT BEHAVIORS ne_behavior_name_list clause_kw
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT BEHAVIORS ne_behavior_name_list clause_kw . [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_complete_or_disjoint -> DISJOINT BEHAVIORS ne_behavior_name_list clause_kw

State 861:
## Known stack suffix:
## DISJOINT BEHAVIORS behavior_name_list
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT BEHAVIORS behavior_name_list . SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 862
## Reductions:

State 862:
## Known stack suffix:
## DISJOINT BEHAVIORS behavior_name_list SEMICOLON
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT BEHAVIORS behavior_name_list SEMICOLON . complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On DISJOINT shift to state 857
-- On COMPLETE shift to state 863
-- On ne_complete_or_disjoint shift to state 869
-- On complete_or_disjoint shift to state 871
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production complete_or_disjoint ->

State 863:
## Known stack suffix:
## COMPLETE
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE . BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_complete_or_disjoint -> COMPLETE . BEHAVIORS ne_behavior_name_list clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On BEHAVIORS shift to state 864
## Reductions:

State 864:
## Known stack suffix:
## COMPLETE BEHAVIORS
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE BEHAVIORS . behavior_name_list SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
ne_complete_or_disjoint -> COMPLETE BEHAVIORS . ne_behavior_name_list clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_behavior_name_list shift to state 865
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On behavior_name_list shift to state 867
-- On behavior_name shift to state 792
-- On any_identifier shift to state 795
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On SEMICOLON
--   reduce production behavior_name_list ->

State 865:
## Known stack suffix:
## COMPLETE BEHAVIORS ne_behavior_name_list
## LR(1) items:
behavior_name_list -> ne_behavior_name_list . [ SEMICOLON ]
ne_complete_or_disjoint -> COMPLETE BEHAVIORS ne_behavior_name_list . clause_kw [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 759
-- On IDENTIFIER shift to state 760
-- On FREES shift to state 761
-- On EXITS shift to state 47
-- On EOF shift to state 762
-- On ENSURES shift to state 49
-- On DISJOINT shift to state 763
-- On DECREASES shift to state 764
-- On CONTINUES shift to state 56
-- On COMPLETE shift to state 765
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 766
-- On ASSUMES shift to state 767
-- On ASSIGNS shift to state 768
-- On ALLOCATES shift to state 769
-- On post_cond shift to state 770
-- On clause_kw shift to state 866
## Reductions:
-- On SEMICOLON
--   reduce production behavior_name_list -> ne_behavior_name_list

State 866:
## Known stack suffix:
## COMPLETE BEHAVIORS ne_behavior_name_list clause_kw
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE BEHAVIORS ne_behavior_name_list clause_kw . [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_complete_or_disjoint -> COMPLETE BEHAVIORS ne_behavior_name_list clause_kw

State 867:
## Known stack suffix:
## COMPLETE BEHAVIORS behavior_name_list
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE BEHAVIORS behavior_name_list . SEMICOLON complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On SEMICOLON shift to state 868
## Reductions:

State 868:
## Known stack suffix:
## COMPLETE BEHAVIORS behavior_name_list SEMICOLON
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE BEHAVIORS behavior_name_list SEMICOLON . complete_or_disjoint [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On DISJOINT shift to state 857
-- On COMPLETE shift to state 863
-- On ne_complete_or_disjoint shift to state 869
-- On complete_or_disjoint shift to state 870
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production complete_or_disjoint ->

State 869:
## Known stack suffix:
## ne_complete_or_disjoint
## LR(1) items:
complete_or_disjoint -> ne_complete_or_disjoint . [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production complete_or_disjoint -> ne_complete_or_disjoint

State 870:
## Known stack suffix:
## COMPLETE BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint
## LR(1) items:
ne_complete_or_disjoint -> COMPLETE BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint . [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_complete_or_disjoint -> COMPLETE BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint

State 871:
## Known stack suffix:
## DISJOINT BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint
## LR(1) items:
ne_complete_or_disjoint -> DISJOINT BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint . [ VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE TERMINATES RETURNS REQUIRES PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION FREES EXT_LET EXT_AT EXITS EOF ENSURES DECREASES CONTRACT CONTINUES BREAKS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ne_complete_or_disjoint -> DISJOINT BEHAVIORS behavior_name_list SEMICOLON complete_or_disjoint

State 872:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint
## LR(1) items:
complete_or_disjoint -> ne_complete_or_disjoint . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . BEHAVIOR [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . ASSIGNS [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . ALLOCATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . FREES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint . post_cond_kind [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On TERMINATES shift to state 873
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 874
-- On FREES shift to state 875
-- On EXITS shift to state 47
-- On ENSURES shift to state 49
-- On DECREASES shift to state 876
-- On CONTINUES shift to state 56
-- On BREAKS shift to state 61
-- On BEHAVIOR shift to state 877
-- On ASSIGNS shift to state 878
-- On ALLOCATES shift to state 879
-- On post_cond_kind shift to state 880
-- On post_cond shift to state 821
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production complete_or_disjoint -> ne_complete_or_disjoint

State 873:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint TERMINATES
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint TERMINATES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint TERMINATES

State 874:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint REQUIRES
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint REQUIRES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint REQUIRES

State 875:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint FREES
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint FREES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint FREES

State 876:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint DECREASES
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint DECREASES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint DECREASES

State 877:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint BEHAVIOR

State 878:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ASSIGNS
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ASSIGNS . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ASSIGNS

State 879:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ALLOCATES
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ALLOCATES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint ALLOCATES

State 880:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint post_cond_kind
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint post_cond_kind . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors ne_complete_or_disjoint post_cond_kind

State 881:
## Known stack suffix:
## requires terminates decreases simple_clauses behaviors complete_or_disjoint
## LR(1) items:
contract -> requires terminates decreases simple_clauses behaviors complete_or_disjoint . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases simple_clauses behaviors complete_or_disjoint

State 882:
## Known stack suffix:
## requires terminates decreases ne_simple_clauses
## LR(1) items:
contract -> requires terminates decreases ne_simple_clauses . REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases ne_simple_clauses . TERMINATES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
contract -> requires terminates decreases ne_simple_clauses . DECREASES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
simple_clauses -> ne_simple_clauses . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM ]
## Transitions:
-- On TERMINATES shift to state 883
-- On REQUIRES shift to state 884
-- On DECREASES shift to state 885
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF DISJOINT CONTRACT COMPLETE BEHAVIOR AXIOMATIC AXIOM
--   reduce production simple_clauses -> ne_simple_clauses

State 883:
## Known stack suffix:
## requires terminates decreases ne_simple_clauses TERMINATES
## LR(1) items:
contract -> requires terminates decreases ne_simple_clauses TERMINATES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases ne_simple_clauses TERMINATES

State 884:
## Known stack suffix:
## requires terminates decreases ne_simple_clauses REQUIRES
## LR(1) items:
contract -> requires terminates decreases ne_simple_clauses REQUIRES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases ne_simple_clauses REQUIRES

State 885:
## Known stack suffix:
## requires terminates decreases ne_simple_clauses DECREASES
## LR(1) items:
contract -> requires terminates decreases ne_simple_clauses DECREASES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires terminates decreases ne_simple_clauses DECREASES

State 886:
## Known stack suffix:
## requires ne_terminates
## LR(1) items:
contract -> requires ne_terminates . REQUIRES [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
terminates -> ne_terminates . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On REQUIRES shift to state 887
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production terminates -> ne_terminates

State 887:
## Known stack suffix:
## requires ne_terminates REQUIRES
## LR(1) items:
contract -> requires ne_terminates REQUIRES . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production contract -> requires ne_terminates REQUIRES

State 888:
## Known stack suffix:
## FOR ne_behavior_name_list COLON contract
## LR(1) items:
annotation -> FOR ne_behavior_name_list COLON contract . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production annotation -> FOR ne_behavior_name_list COLON contract

State 889:
## Known stack suffix:
## CUSTOM
## LR(1) items:
annot -> CUSTOM . any_identifier COLON custom_tree EOF [ # ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 890
-- On acsl_c_keyword shift to state 87
## Reductions:

State 890:
## Known stack suffix:
## CUSTOM any_identifier
## LR(1) items:
annot -> CUSTOM any_identifier . COLON custom_tree EOF [ # ]
## Transitions:
-- On COLON shift to state 891
## Reductions:

State 891:
## Known stack suffix:
## CUSTOM any_identifier COLON
## LR(1) items:
annot -> CUSTOM any_identifier COLON . custom_tree EOF [ # ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 892
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 894
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 896
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 897
-- On custom_tree shift to state 898
-- On c_keyword shift to state 85
-- On any_identifier_non_logic shift to state 900
-- On acsl_c_keyword shift to state 87
## Reductions:

State 892:
## Known stack suffix:
## TYPE
## LR(1) items:
custom_tree -> TYPE . type_spec [ RPAR EOF COMMA ]
is_acsl_decl_or_code_annot -> TYPE . [ RPAR LPAR EOF COMMA ]
## Transitions:
-- On VOID shift to state 125
-- On UNSIGNED shift to state 126
-- On UNION shift to state 127
-- On TYPENAME shift to state 128
-- On STRUCT shift to state 129
-- On SIGNED shift to state 132
-- On SHORT shift to state 140
-- On REAL shift to state 141
-- On LONG shift to state 142
-- On INTEGER shift to state 147
-- On INT shift to state 148
-- On FLOAT shift to state 149
-- On ENUM shift to state 150
-- On DOUBLE shift to state 153
-- On CHAR shift to state 154
-- On BOOLEAN shift to state 155
-- On BOOL shift to state 156
-- On type_spec shift to state 893
## Reductions:
-- On RPAR LPAR EOF COMMA
--   reduce production is_acsl_decl_or_code_annot -> TYPE

State 893:
## Known stack suffix:
## TYPE type_spec
## LR(1) items:
custom_tree -> TYPE type_spec . [ RPAR EOF COMMA ]
## Transitions:
## Reductions:
-- On RPAR EOF COMMA
--   reduce production custom_tree -> TYPE type_spec

State 894:
## Known stack suffix:
## LOGIC
## LR(1) items:
custom_tree -> LOGIC . lexpr [ RPAR EOF COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 895
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 895:
## Known stack suffix:
## LOGIC lexpr
## LR(1) items:
custom_tree -> LOGIC lexpr . [ RPAR EOF COMMA ]
lexpr -> lexpr . IMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . IFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . OR lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AND lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HATHAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . AMP lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . PIPE lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . HAT lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIMPLIES lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . BIFF lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
lexpr -> lexpr . QUESTION lexpr COLON2 lexpr [ RPAR QUESTION PIPE OR IMPLIES IFF HATHAT HAT EOF COMMA BIMPLIES BIFF AND AMP ]
## Transitions:
-- On QUESTION shift to state 317
-- On PIPE shift to state 319
-- On OR shift to state 330
-- On IMPLIES shift to state 340
-- On IFF shift to state 346
-- On HATHAT shift to state 332
-- On HAT shift to state 321
-- On BIMPLIES shift to state 334
-- On BIFF shift to state 342
-- On AND shift to state 344
-- On AMP shift to state 323
## Reductions:
-- On RPAR EOF COMMA
--   reduce production custom_tree -> LOGIC lexpr

State 896:
## Known stack suffix:
## non_logic_keyword
## LR(1) items:
any_identifier_non_logic -> non_logic_keyword . [ RPAR LPAR EOF COMMA ]
## Transitions:
## Reductions:
-- On RPAR LPAR EOF COMMA
--   reduce production any_identifier_non_logic -> non_logic_keyword

State 897:
## Known stack suffix:
## identifier_or_typename
## LR(1) items:
any_identifier_non_logic -> identifier_or_typename . [ RPAR LPAR EOF COMMA ]
## Transitions:
## Reductions:
-- On RPAR LPAR EOF COMMA
--   reduce production any_identifier_non_logic -> identifier_or_typename

State 898:
## Known stack suffix:
## CUSTOM any_identifier COLON custom_tree
## LR(1) items:
annot -> CUSTOM any_identifier COLON custom_tree . EOF [ # ]
## Transitions:
-- On EOF shift to state 899
## Reductions:

State 899:
## Known stack suffix:
## CUSTOM any_identifier COLON custom_tree EOF
## LR(1) items:
annot -> CUSTOM any_identifier COLON custom_tree EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production annot -> CUSTOM any_identifier COLON custom_tree EOF

State 900:
## Known stack suffix:
## any_identifier_non_logic
## LR(1) items:
custom_tree -> any_identifier_non_logic . [ RPAR EOF COMMA ]
custom_tree -> any_identifier_non_logic . LPAR custom_tree_list RPAR [ RPAR EOF COMMA ]
## Transitions:
-- On LPAR shift to state 901
## Reductions:
-- On RPAR EOF COMMA
--   reduce production custom_tree -> any_identifier_non_logic

State 901:
## Known stack suffix:
## any_identifier_non_logic LPAR
## LR(1) items:
custom_tree -> any_identifier_non_logic LPAR . custom_tree_list RPAR [ RPAR EOF COMMA ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 892
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 894
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 896
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 897
-- On custom_tree_list shift to state 902
-- On custom_tree shift to state 904
-- On c_keyword shift to state 85
-- On any_identifier_non_logic shift to state 900
-- On acsl_c_keyword shift to state 87
## Reductions:

State 902:
## Known stack suffix:
## any_identifier_non_logic LPAR custom_tree_list
## LR(1) items:
custom_tree -> any_identifier_non_logic LPAR custom_tree_list . RPAR [ RPAR EOF COMMA ]
## Transitions:
-- On RPAR shift to state 903
## Reductions:

State 903:
## Known stack suffix:
## any_identifier_non_logic LPAR custom_tree_list RPAR
## LR(1) items:
custom_tree -> any_identifier_non_logic LPAR custom_tree_list RPAR . [ RPAR EOF COMMA ]
## Transitions:
## Reductions:
-- On RPAR EOF COMMA
--   reduce production custom_tree -> any_identifier_non_logic LPAR custom_tree_list RPAR

State 904:
## Known stack suffix:
## custom_tree
## LR(1) items:
custom_tree_list -> custom_tree . [ RPAR ]
custom_tree_list -> custom_tree . COMMA custom_tree_list [ RPAR ]
## Transitions:
-- On COMMA shift to state 905
## Reductions:
-- On RPAR
--   reduce production custom_tree_list -> custom_tree

State 905:
## Known stack suffix:
## custom_tree COMMA
## LR(1) items:
custom_tree_list -> custom_tree COMMA . custom_tree_list [ RPAR ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 892
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 894
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 896
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 897
-- On custom_tree_list shift to state 906
-- On custom_tree shift to state 904
-- On c_keyword shift to state 85
-- On any_identifier_non_logic shift to state 900
-- On acsl_c_keyword shift to state 87
## Reductions:

State 906:
## Known stack suffix:
## custom_tree COMMA custom_tree_list
## LR(1) items:
custom_tree_list -> custom_tree COMMA custom_tree_list . [ RPAR ]
## Transitions:
## Reductions:
-- On RPAR
--   reduce production custom_tree_list -> custom_tree COMMA custom_tree_list

State 907:
## Known stack suffix:
## AXIOMATIC
## LR(1) items:
logic_def -> AXIOMATIC . any_identifier LBRACE logic_decls RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 908
-- On acsl_c_keyword shift to state 87
## Reductions:

State 908:
## Known stack suffix:
## AXIOMATIC any_identifier
## LR(1) items:
logic_def -> AXIOMATIC any_identifier . LBRACE logic_decls RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On LBRACE shift to state 909
## Reductions:

State 909:
## Known stack suffix:
## AXIOMATIC any_identifier LBRACE
## LR(1) items:
logic_def -> AXIOMATIC any_identifier LBRACE . logic_decls RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On TYPE shift to state 910
-- On PREDICATE shift to state 913
-- On LOGIC shift to state 920
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 926
-- On logic_def shift to state 931
-- On logic_decls shift to state 932
-- On logic_decl_loc shift to state 934
-- On logic_decl shift to state 936
## Reductions:
-- On RBRACE
--   reduce production logic_decls ->

State 910:
## Known stack suffix:
## TYPE
## LR(1) items:
logic_decl -> TYPE . poly_id_type SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> TYPE . poly_id_type_add_typename EQUAL typedef SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type_add_typename shift to state 580
-- On poly_id_type shift to state 911
-- On full_identifier shift to state 610
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 911:
## Known stack suffix:
## TYPE poly_id_type
## LR(1) items:
logic_decl -> TYPE poly_id_type . SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
poly_id_type_add_typename -> poly_id_type . [ EQUAL ]
## Transitions:
-- On SEMICOLON shift to state 912
## Reductions:
-- On EQUAL
--   reduce production poly_id_type_add_typename -> poly_id_type

State 912:
## Known stack suffix:
## TYPE poly_id_type SEMICOLON
## LR(1) items:
logic_decl -> TYPE poly_id_type SEMICOLON . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl -> TYPE poly_id_type SEMICOLON

State 913:
## Known stack suffix:
## PREDICATE
## LR(1) items:
logic_decl -> PREDICATE . poly_id opt_parameters reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> PREDICATE . poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 914
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 914:
## Known stack suffix:
## PREDICATE poly_id
## LR(1) items:
logic_decl -> PREDICATE poly_id . opt_parameters reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> PREDICATE poly_id . opt_parameters EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 626
-- On parameters shift to state 635
-- On opt_parameters shift to state 915
## Reductions:
-- On SEMICOLON READS EQUAL
--   reduce production opt_parameters ->

State 915:
## Known stack suffix:
## PREDICATE poly_id opt_parameters
## LR(1) items:
logic_decl -> PREDICATE poly_id opt_parameters . reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> PREDICATE poly_id opt_parameters . EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On READS shift to state 916
-- On EQUAL shift to state 638
-- On reads_clause shift to state 918
## Reductions:
-- On SEMICOLON
--   reduce production reads_clause ->

State 916:
## Known stack suffix:
## READS
## LR(1) items:
reads_clause -> READS . zones [ SEMICOLON ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 6
-- On VALID_RANGE shift to state 91
-- On VALID_INDEX shift to state 94
-- On VALID shift to state 97
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 100
-- On TYPEOF shift to state 101
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 103
-- On TILDE shift to state 104
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 105
-- On STATIC shift to state 196
-- On STAR shift to state 107
-- On SLICE shift to state 15
-- On SIZEOF shift to state 197
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 200
-- On RETURNS shift to state 19
-- On RESULT shift to state 202
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 203
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 204
-- On OLD shift to state 205
-- On OFFSET shift to state 207
-- On NULL shift to state 210
-- On NOTHING shift to state 676
-- On NOT shift to state 211
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 213
-- On LPAR shift to state 214
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 218
-- On LEMMA shift to state 30
-- On LBRACE shift to state 224
-- On LAMBDA shift to state 226
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 249
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 251
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 254
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FRESH shift to state 255
-- On FREES shift to state 42
-- On FREEABLE shift to state 259
-- On FORALL shift to state 262
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 265
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 266
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 269
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 270
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 271
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 160
-- On CONSTANT shift to state 161
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 274
-- On BSTYPE shift to state 276
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 282
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 285
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 288
-- On AT shift to state 289
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On AMP shift to state 291
-- On ALLOCATION shift to state 292
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 295
-- On zones shift to state 917
-- On string shift to state 298
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On ne_zones shift to state 679
-- On ne_lexpr_list shift to state 559
-- On lexpr_rel shift to state 301
-- On lexpr_inner shift to state 302
-- On lexpr_end_rel shift to state 314
-- On lexpr_binder shift to state 315
-- On lexpr shift to state 329
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On identifier shift to state 325
-- On constant shift to state 336
-- On c_keyword shift to state 85
-- On any_identifier shift to state 337
-- On acsl_c_keyword shift to state 87
## Reductions:

State 917:
## Known stack suffix:
## READS zones
## LR(1) items:
reads_clause -> READS zones . [ SEMICOLON ]
## Transitions:
## Reductions:
-- On SEMICOLON
--   reduce production reads_clause -> READS zones

State 918:
## Known stack suffix:
## PREDICATE poly_id opt_parameters reads_clause
## LR(1) items:
logic_decl -> PREDICATE poly_id opt_parameters reads_clause . SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 919
## Reductions:

State 919:
## Known stack suffix:
## PREDICATE poly_id opt_parameters reads_clause SEMICOLON
## LR(1) items:
logic_decl -> PREDICATE poly_id opt_parameters reads_clause SEMICOLON . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl -> PREDICATE poly_id opt_parameters reads_clause SEMICOLON

State 920:
## Known stack suffix:
## LOGIC
## LR(1) items:
logic_decl -> LOGIC . full_logic_rt_type poly_id opt_parameters reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> LOGIC . full_logic_rt_type poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On full_logic_rt_type shift to state 921
-- On enter_kw_c_mode shift to state 712
## Reductions:
-- On VOID UNSIGNED UNION TYPENAME STRUCT SIGNED SHORT REAL LONG INTEGER INT IDENTIFIER FLOAT ENUM DOUBLE CHAR BOOLEAN BOOL
--   reduce production enter_kw_c_mode ->

State 921:
## Known stack suffix:
## LOGIC full_logic_rt_type
## LR(1) items:
logic_decl -> LOGIC full_logic_rt_type . poly_id opt_parameters reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type . poly_id opt_parameters EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 922
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 922:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id
## LR(1) items:
logic_decl -> LOGIC full_logic_rt_type poly_id . opt_parameters reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type poly_id . opt_parameters EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On LPAR shift to state 626
-- On parameters shift to state 635
-- On opt_parameters shift to state 923
## Reductions:
-- On SEMICOLON READS EQUAL
--   reduce production opt_parameters ->

State 923:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters
## LR(1) items:
logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters . reads_clause SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
logic_def -> LOGIC full_logic_rt_type poly_id opt_parameters . EQUAL full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On READS shift to state 916
-- On EQUAL shift to state 709
-- On reads_clause shift to state 924
## Reductions:
-- On SEMICOLON
--   reduce production reads_clause ->

State 924:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters reads_clause
## LR(1) items:
logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters reads_clause . SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 925
## Reductions:

State 925:
## Known stack suffix:
## LOGIC full_logic_rt_type poly_id opt_parameters reads_clause SEMICOLON
## LR(1) items:
logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters reads_clause SEMICOLON . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl -> LOGIC full_logic_rt_type poly_id opt_parameters reads_clause SEMICOLON

State 926:
## Known stack suffix:
## AXIOM
## LR(1) items:
logic_decl -> AXIOM . poly_id COLON full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 927
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 927:
## Known stack suffix:
## AXIOM poly_id
## LR(1) items:
logic_decl -> AXIOM poly_id . COLON full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 928
## Reductions:

State 928:
## Known stack suffix:
## AXIOM poly_id COLON
## LR(1) items:
logic_decl -> AXIOM poly_id COLON . full_lexpr SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 929
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 929:
## Known stack suffix:
## AXIOM poly_id COLON full_lexpr
## LR(1) items:
logic_decl -> AXIOM poly_id COLON full_lexpr . SEMICOLON [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 930
## Reductions:

State 930:
## Known stack suffix:
## AXIOM poly_id COLON full_lexpr SEMICOLON
## LR(1) items:
logic_decl -> AXIOM poly_id COLON full_lexpr SEMICOLON . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl -> AXIOM poly_id COLON full_lexpr SEMICOLON

State 931:
## Known stack suffix:
## logic_def
## LR(1) items:
logic_decl -> logic_def . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl -> logic_def

State 932:
## Known stack suffix:
## AXIOMATIC any_identifier LBRACE logic_decls
## LR(1) items:
logic_def -> AXIOMATIC any_identifier LBRACE logic_decls . RBRACE [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On RBRACE shift to state 933
## Reductions:

State 933:
## Known stack suffix:
## AXIOMATIC any_identifier LBRACE logic_decls RBRACE
## LR(1) items:
logic_def -> AXIOMATIC any_identifier LBRACE logic_decls RBRACE . [ VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE RBRACE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production logic_def -> AXIOMATIC any_identifier LBRACE logic_decls RBRACE

State 934:
## Known stack suffix:
## logic_decl_loc
## LR(1) items:
logic_decls -> logic_decl_loc . logic_decls [ RBRACE ]
## Transitions:
-- On TYPE shift to state 910
-- On PREDICATE shift to state 913
-- On LOGIC shift to state 920
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 926
-- On logic_def shift to state 931
-- On logic_decls shift to state 935
-- On logic_decl_loc shift to state 934
-- On logic_decl shift to state 936
## Reductions:
-- On RBRACE
--   reduce production logic_decls ->

State 935:
## Known stack suffix:
## logic_decl_loc logic_decls
## LR(1) items:
logic_decls -> logic_decl_loc logic_decls . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production logic_decls -> logic_decl_loc logic_decls

State 936:
## Known stack suffix:
## logic_decl
## LR(1) items:
logic_decl_loc -> logic_decl . [ TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On TYPE RBRACE PREDICATE LOGIC LEMMA INDUCTIVE AXIOMATIC AXIOM
--   reduce production logic_decl_loc -> logic_decl

State 937:
## Known stack suffix:
## AXIOM
## LR(1) items:
deprecated_logic_decl -> AXIOM . poly_id COLON full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On poly_id_type shift to state 624
-- On poly_id shift to state 938
-- On full_identifier shift to state 641
-- On enter_kw_c_mode shift to state 593
## Reductions:
-- On IDENTIFIER
--   reduce production enter_kw_c_mode ->

State 938:
## Known stack suffix:
## AXIOM poly_id
## LR(1) items:
deprecated_logic_decl -> AXIOM poly_id . COLON full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 939
## Reductions:

State 939:
## Known stack suffix:
## AXIOM poly_id COLON
## LR(1) items:
deprecated_logic_decl -> AXIOM poly_id COLON . full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 940
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 940:
## Known stack suffix:
## AXIOM poly_id COLON full_lexpr
## LR(1) items:
deprecated_logic_decl -> AXIOM poly_id COLON full_lexpr . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 941
## Reductions:

State 941:
## Known stack suffix:
## AXIOM poly_id COLON full_lexpr SEMICOLON
## LR(1) items:
deprecated_logic_decl -> AXIOM poly_id COLON full_lexpr SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production deprecated_logic_decl -> AXIOM poly_id COLON full_lexpr SEMICOLON

State 942:
## Known stack suffix:
## ASSERT
## LR(1) items:
code_annotation -> ASSERT . full_lexpr SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On full_lexpr shift to state 943
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 943:
## Known stack suffix:
## ASSERT full_lexpr
## LR(1) items:
code_annotation -> ASSERT full_lexpr . SEMICOLON [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
-- On SEMICOLON shift to state 944
## Reductions:

State 944:
## Known stack suffix:
## ASSERT full_lexpr SEMICOLON
## LR(1) items:
code_annotation -> ASSERT full_lexpr SEMICOLON . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> ASSERT full_lexpr SEMICOLON

State 945:
## Known stack suffix:
## type_annot
## LR(1) items:
decl -> type_annot . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> type_annot

State 946:
## Known stack suffix:
## slice_pragma
## LR(1) items:
code_annotation -> slice_pragma . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> slice_pragma

State 947:
## Known stack suffix:
## model_annot
## LR(1) items:
decl -> model_annot . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> model_annot

State 948:
## Known stack suffix:
## loop_annotations
## LR(1) items:
annotation -> loop_annotations . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production annotation -> loop_annotations

State 949:
## Known stack suffix:
## loop_annot_stack
## LR(1) items:
loop_annotations -> loop_annot_stack . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production loop_annotations -> loop_annot_stack

State 950:
## Known stack suffix:
## logic_def
## LR(1) items:
decl -> logic_def . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> logic_def

State 951:
## Known stack suffix:
## is_spec
## LR(1) items:
annot -> is_spec . any EOF [ # ]
## Transitions:
-- On WRITES shift to state 1
-- On WITH shift to state 952
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 953
-- On VALID_RANGE shift to state 954
-- On VALID_INDEX shift to state 955
-- On VALID shift to state 956
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 957
-- On TYPEOF shift to state 958
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 959
-- On TILDE shift to state 960
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 961
-- On STATIC shift to state 14
-- On STAR shift to state 962
-- On SLICE shift to state 15
-- On SLASH shift to state 963
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 964
-- On SEMICOLON shift to state 965
-- On RSQUARE shift to state 966
-- On RPAR shift to state 967
-- On RETURNS shift to state 19
-- On RESULT shift to state 968
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 969
-- On REAL shift to state 21
-- On READS shift to state 22
-- On RBRACE shift to state 970
-- On QUESTION shift to state 971
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 972
-- On PIPE shift to state 973
-- On PERCENT shift to state 974
-- On OR shift to state 975
-- On OLD shift to state 976
-- On OFFSET shift to state 977
-- On NULL shift to state 978
-- On NOTHING shift to state 979
-- On NOT shift to state 980
-- On NE shift to state 981
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 982
-- On LTLT shift to state 983
-- On LTCOLON shift to state 984
-- On LT shift to state 985
-- On LSQUARE shift to state 986
-- On LPAR shift to state 987
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 988
-- On LEMMA shift to state 30
-- On LE shift to state 989
-- On LBRACE shift to state 990
-- On LAMBDA shift to state 991
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 992
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 993
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPLIES shift to state 994
-- On IMPACT shift to state 37
-- On IFF shift to state 995
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On HATHAT shift to state 996
-- On HAT shift to state 997
-- On GTGT shift to state 998
-- On GT shift to state 999
-- On GLOBAL shift to state 40
-- On GHOST shift to state 1000
-- On GE shift to state 1001
-- On FUNCTION shift to state 41
-- On FROM shift to state 1002
-- On FRESH shift to state 1003
-- On FREES shift to state 42
-- On FREEABLE shift to state 1004
-- On FORALL shift to state 1005
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 1006
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 1007
-- On EQUAL shift to state 1008
-- On EQ shift to state 1009
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 1010
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 1011
-- On DOUBLE shift to state 51
-- On DOTDOTDOT shift to state 1012
-- On DOTDOT shift to state 1013
-- On DOT shift to state 1014
-- On DOLLAR shift to state 1015
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 1016
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 1017
-- On CONSTANT shift to state 1018
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On COMMA shift to state 1019
-- On COLONGT shift to state 1020
-- On COLONCOLON shift to state 1021
-- On COLON2 shift to state 1022
-- On COLON shift to state 1023
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 1024
-- On BSTYPE shift to state 1025
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 1026
-- On BIMPLIES shift to state 1027
-- On BIFF shift to state 1028
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 1029
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 1030
-- On AT shift to state 1031
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ARROW shift to state 1032
-- On AND shift to state 1033
-- On AMP shift to state 1034
-- On ALLOCATION shift to state 1035
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 1036
-- On wildcard shift to state 1037
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On bs_keyword shift to state 1038
-- On any_identifier shift to state 1039
-- On any shift to state 1041
-- On acsl_c_keyword shift to state 87
## Reductions:

State 952:
## Known stack suffix:
## WITH
## LR(1) items:
bs_keyword -> WITH . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> WITH

State 953:
## Known stack suffix:
## VALID_READ
## LR(1) items:
bs_keyword -> VALID_READ . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> VALID_READ

State 954:
## Known stack suffix:
## VALID_RANGE
## LR(1) items:
bs_keyword -> VALID_RANGE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> VALID_RANGE

State 955:
## Known stack suffix:
## VALID_INDEX
## LR(1) items:
bs_keyword -> VALID_INDEX . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> VALID_INDEX

State 956:
## Known stack suffix:
## VALID
## LR(1) items:
bs_keyword -> VALID . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> VALID

State 957:
## Known stack suffix:
## UNALLOCATED
## LR(1) items:
bs_keyword -> UNALLOCATED . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> UNALLOCATED

State 958:
## Known stack suffix:
## TYPEOF
## LR(1) items:
bs_keyword -> TYPEOF . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> TYPEOF

State 959:
## Known stack suffix:
## TRUE
## LR(1) items:
bs_keyword -> TRUE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> TRUE

State 960:
## Known stack suffix:
## TILDE
## LR(1) items:
wildcard -> TILDE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> TILDE

State 961:
## Known stack suffix:
## STRING_LITERAL
## LR(1) items:
wildcard -> STRING_LITERAL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> STRING_LITERAL

State 962:
## Known stack suffix:
## STAR
## LR(1) items:
wildcard -> STAR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> STAR

State 963:
## Known stack suffix:
## SLASH
## LR(1) items:
wildcard -> SLASH . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> SLASH

State 964:
## Known stack suffix:
## SEPARATED
## LR(1) items:
bs_keyword -> SEPARATED . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> SEPARATED

State 965:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
wildcard -> SEMICOLON . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> SEMICOLON

State 966:
## Known stack suffix:
## RSQUARE
## LR(1) items:
wildcard -> RSQUARE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> RSQUARE

State 967:
## Known stack suffix:
## RPAR
## LR(1) items:
wildcard -> RPAR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> RPAR

State 968:
## Known stack suffix:
## RESULT
## LR(1) items:
bs_keyword -> RESULT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> RESULT

State 969:
## Known stack suffix:
## REGISTER
## LR(1) items:
bs_keyword -> REGISTER . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> REGISTER

State 970:
## Known stack suffix:
## RBRACE
## LR(1) items:
wildcard -> RBRACE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> RBRACE

State 971:
## Known stack suffix:
## QUESTION
## LR(1) items:
wildcard -> QUESTION . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> QUESTION

State 972:
## Known stack suffix:
## PLUS
## LR(1) items:
wildcard -> PLUS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> PLUS

State 973:
## Known stack suffix:
## PIPE
## LR(1) items:
wildcard -> PIPE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> PIPE

State 974:
## Known stack suffix:
## PERCENT
## LR(1) items:
wildcard -> PERCENT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> PERCENT

State 975:
## Known stack suffix:
## OR
## LR(1) items:
wildcard -> OR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> OR

State 976:
## Known stack suffix:
## OLD
## LR(1) items:
bs_keyword -> OLD . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> OLD

State 977:
## Known stack suffix:
## OFFSET
## LR(1) items:
bs_keyword -> OFFSET . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> OFFSET

State 978:
## Known stack suffix:
## NULL
## LR(1) items:
bs_keyword -> NULL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> NULL

State 979:
## Known stack suffix:
## NOTHING
## LR(1) items:
bs_keyword -> NOTHING . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> NOTHING

State 980:
## Known stack suffix:
## NOT
## LR(1) items:
wildcard -> NOT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> NOT

State 981:
## Known stack suffix:
## NE
## LR(1) items:
wildcard -> NE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> NE

State 982:
## Known stack suffix:
## MINUS
## LR(1) items:
wildcard -> MINUS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> MINUS

State 983:
## Known stack suffix:
## LTLT
## LR(1) items:
wildcard -> LTLT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LTLT

State 984:
## Known stack suffix:
## LTCOLON
## LR(1) items:
wildcard -> LTCOLON . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LTCOLON

State 985:
## Known stack suffix:
## LT
## LR(1) items:
wildcard -> LT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LT

State 986:
## Known stack suffix:
## LSQUARE
## LR(1) items:
wildcard -> LSQUARE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LSQUARE

State 987:
## Known stack suffix:
## LPAR
## LR(1) items:
wildcard -> LPAR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LPAR

State 988:
## Known stack suffix:
## LET
## LR(1) items:
bs_keyword -> LET . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> LET

State 989:
## Known stack suffix:
## LE
## LR(1) items:
wildcard -> LE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LE

State 990:
## Known stack suffix:
## LBRACE
## LR(1) items:
wildcard -> LBRACE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> LBRACE

State 991:
## Known stack suffix:
## LAMBDA
## LR(1) items:
bs_keyword -> LAMBDA . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> LAMBDA

State 992:
## Known stack suffix:
## INTER
## LR(1) items:
bs_keyword -> INTER . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> INTER

State 993:
## Known stack suffix:
## INITIALIZED
## LR(1) items:
bs_keyword -> INITIALIZED . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> INITIALIZED

State 994:
## Known stack suffix:
## IMPLIES
## LR(1) items:
wildcard -> IMPLIES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> IMPLIES

State 995:
## Known stack suffix:
## IFF
## LR(1) items:
wildcard -> IFF . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> IFF

State 996:
## Known stack suffix:
## HATHAT
## LR(1) items:
wildcard -> HATHAT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> HATHAT

State 997:
## Known stack suffix:
## HAT
## LR(1) items:
wildcard -> HAT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> HAT

State 998:
## Known stack suffix:
## GTGT
## LR(1) items:
wildcard -> GTGT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> GTGT

State 999:
## Known stack suffix:
## GT
## LR(1) items:
wildcard -> GT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> GT

State 1000:
## Known stack suffix:
## GHOST
## LR(1) items:
wildcard -> GHOST . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> GHOST

State 1001:
## Known stack suffix:
## GE
## LR(1) items:
wildcard -> GE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> GE

State 1002:
## Known stack suffix:
## FROM
## LR(1) items:
bs_keyword -> FROM . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> FROM

State 1003:
## Known stack suffix:
## FRESH
## LR(1) items:
bs_keyword -> FRESH . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> FRESH

State 1004:
## Known stack suffix:
## FREEABLE
## LR(1) items:
bs_keyword -> FREEABLE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> FREEABLE

State 1005:
## Known stack suffix:
## FORALL
## LR(1) items:
bs_keyword -> FORALL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> FORALL

State 1006:
## Known stack suffix:
## FALSE
## LR(1) items:
bs_keyword -> FALSE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> FALSE

State 1007:
## Known stack suffix:
## EXISTS
## LR(1) items:
wildcard -> EXISTS . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> EXISTS

State 1008:
## Known stack suffix:
## EQUAL
## LR(1) items:
wildcard -> EQUAL . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> EQUAL

State 1009:
## Known stack suffix:
## EQ
## LR(1) items:
wildcard -> EQ . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> EQ

State 1010:
## Known stack suffix:
## EMPTY
## LR(1) items:
bs_keyword -> EMPTY . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> EMPTY

State 1011:
## Known stack suffix:
## DYNAMIC
## LR(1) items:
bs_keyword -> DYNAMIC . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> DYNAMIC

State 1012:
## Known stack suffix:
## DOTDOTDOT
## LR(1) items:
wildcard -> DOTDOTDOT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> DOTDOTDOT

State 1013:
## Known stack suffix:
## DOTDOT
## LR(1) items:
wildcard -> DOTDOT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> DOTDOT

State 1014:
## Known stack suffix:
## DOT
## LR(1) items:
wildcard -> DOT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> DOT

State 1015:
## Known stack suffix:
## DOLLAR
## LR(1) items:
wildcard -> DOLLAR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> DOLLAR

State 1016:
## Known stack suffix:
## DANGLING
## LR(1) items:
bs_keyword -> DANGLING . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> DANGLING

State 1017:
## Known stack suffix:
## CONSTANT10
## LR(1) items:
wildcard -> CONSTANT10 . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> CONSTANT10

State 1018:
## Known stack suffix:
## CONSTANT
## LR(1) items:
wildcard -> CONSTANT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> CONSTANT

State 1019:
## Known stack suffix:
## COMMA
## LR(1) items:
wildcard -> COMMA . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> COMMA

State 1020:
## Known stack suffix:
## COLONGT
## LR(1) items:
wildcard -> COLONGT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> COLONGT

State 1021:
## Known stack suffix:
## COLONCOLON
## LR(1) items:
wildcard -> COLONCOLON . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> COLONCOLON

State 1022:
## Known stack suffix:
## COLON2
## LR(1) items:
wildcard -> COLON2 . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> COLON2

State 1023:
## Known stack suffix:
## COLON
## LR(1) items:
wildcard -> COLON . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> COLON

State 1024:
## Known stack suffix:
## BSUNION
## LR(1) items:
bs_keyword -> BSUNION . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> BSUNION

State 1025:
## Known stack suffix:
## BSTYPE
## LR(1) items:
bs_keyword -> BSTYPE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> BSTYPE

State 1026:
## Known stack suffix:
## BLOCK_LENGTH
## LR(1) items:
bs_keyword -> BLOCK_LENGTH . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> BLOCK_LENGTH

State 1027:
## Known stack suffix:
## BIMPLIES
## LR(1) items:
wildcard -> BIMPLIES . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> BIMPLIES

State 1028:
## Known stack suffix:
## BIFF
## LR(1) items:
wildcard -> BIFF . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> BIFF

State 1029:
## Known stack suffix:
## BASE_ADDR
## LR(1) items:
bs_keyword -> BASE_ADDR . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> BASE_ADDR

State 1030:
## Known stack suffix:
## AUTOMATIC
## LR(1) items:
bs_keyword -> AUTOMATIC . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> AUTOMATIC

State 1031:
## Known stack suffix:
## AT
## LR(1) items:
bs_keyword -> AT . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> AT

State 1032:
## Known stack suffix:
## ARROW
## LR(1) items:
wildcard -> ARROW . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> ARROW

State 1033:
## Known stack suffix:
## AND
## LR(1) items:
wildcard -> AND . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> AND

State 1034:
## Known stack suffix:
## AMP
## LR(1) items:
wildcard -> AMP . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> AMP

State 1035:
## Known stack suffix:
## ALLOCATION
## LR(1) items:
bs_keyword -> ALLOCATION . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> ALLOCATION

State 1036:
## Known stack suffix:
## ALLOCABLE
## LR(1) items:
bs_keyword -> ALLOCABLE . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production bs_keyword -> ALLOCABLE

State 1037:
## Known stack suffix:
## wildcard
## LR(1) items:
any -> wildcard . [ EOF ]
any -> wildcard . any [ EOF ]
## Transitions:
-- On WRITES shift to state 1
-- On WITH shift to state 952
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On VALID_READ shift to state 953
-- On VALID_RANGE shift to state 954
-- On VALID_INDEX shift to state 955
-- On VALID shift to state 956
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On UNALLOCATED shift to state 957
-- On TYPEOF shift to state 958
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TRUE shift to state 959
-- On TILDE shift to state 960
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STRING_LITERAL shift to state 961
-- On STATIC shift to state 14
-- On STAR shift to state 962
-- On SLICE shift to state 15
-- On SLASH shift to state 963
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On SEPARATED shift to state 964
-- On SEMICOLON shift to state 965
-- On RSQUARE shift to state 966
-- On RPAR shift to state 967
-- On RETURNS shift to state 19
-- On RESULT shift to state 968
-- On REQUIRES shift to state 20
-- On REGISTER shift to state 969
-- On REAL shift to state 21
-- On READS shift to state 22
-- On RBRACE shift to state 970
-- On QUESTION shift to state 971
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On PLUS shift to state 972
-- On PIPE shift to state 973
-- On PERCENT shift to state 974
-- On OR shift to state 975
-- On OLD shift to state 976
-- On OFFSET shift to state 977
-- On NULL shift to state 978
-- On NOTHING shift to state 979
-- On NOT shift to state 980
-- On NE shift to state 981
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On MINUS shift to state 982
-- On LTLT shift to state 983
-- On LTCOLON shift to state 984
-- On LT shift to state 985
-- On LSQUARE shift to state 986
-- On LPAR shift to state 987
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LET shift to state 988
-- On LEMMA shift to state 30
-- On LE shift to state 989
-- On LBRACE shift to state 990
-- On LAMBDA shift to state 991
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTER shift to state 992
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INITIALIZED shift to state 993
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPLIES shift to state 994
-- On IMPACT shift to state 37
-- On IFF shift to state 995
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On HATHAT shift to state 996
-- On HAT shift to state 997
-- On GTGT shift to state 998
-- On GT shift to state 999
-- On GLOBAL shift to state 40
-- On GHOST shift to state 1000
-- On GE shift to state 1001
-- On FUNCTION shift to state 41
-- On FROM shift to state 1002
-- On FRESH shift to state 1003
-- On FREES shift to state 42
-- On FREEABLE shift to state 1004
-- On FORALL shift to state 1005
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On FALSE shift to state 1006
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On EXISTS shift to state 1007
-- On EQUAL shift to state 1008
-- On EQ shift to state 1009
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On EMPTY shift to state 1010
-- On ELSE shift to state 50
-- On DYNAMIC shift to state 1011
-- On DOUBLE shift to state 51
-- On DOTDOTDOT shift to state 1012
-- On DOTDOT shift to state 1013
-- On DOT shift to state 1014
-- On DOLLAR shift to state 1015
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On DANGLING shift to state 1016
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 1017
-- On CONSTANT shift to state 1018
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On COMMA shift to state 1019
-- On COLONGT shift to state 1020
-- On COLONCOLON shift to state 1021
-- On COLON2 shift to state 1022
-- On COLON shift to state 1023
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BSUNION shift to state 1024
-- On BSTYPE shift to state 1025
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BLOCK_LENGTH shift to state 1026
-- On BIMPLIES shift to state 1027
-- On BIFF shift to state 1028
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On BASE_ADDR shift to state 1029
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On AUTOMATIC shift to state 1030
-- On AT shift to state 1031
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ARROW shift to state 1032
-- On AND shift to state 1033
-- On AMP shift to state 1034
-- On ALLOCATION shift to state 1035
-- On ALLOCATES shift to state 71
-- On ALLOCABLE shift to state 1036
-- On wildcard shift to state 1037
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On bs_keyword shift to state 1038
-- On any_identifier shift to state 1039
-- On any shift to state 1040
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On EOF
--   reduce production any -> wildcard

State 1038:
## Known stack suffix:
## bs_keyword
## LR(1) items:
wildcard -> bs_keyword . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> bs_keyword

State 1039:
## Known stack suffix:
## any_identifier
## LR(1) items:
wildcard -> any_identifier . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ EOF ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production wildcard -> any_identifier

State 1040:
## Known stack suffix:
## wildcard any
## LR(1) items:
any -> wildcard any . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production any -> wildcard any

State 1041:
## Known stack suffix:
## is_spec any
## LR(1) items:
annot -> is_spec any . EOF [ # ]
## Transitions:
-- On EOF shift to state 1042
## Reductions:

State 1042:
## Known stack suffix:
## is_spec any EOF
## LR(1) items:
annot -> is_spec any EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production annot -> is_spec any EOF

State 1043:
## Known stack suffix:
## is_acsl_spec
## LR(1) items:
is_spec -> is_acsl_spec . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_spec -> is_acsl_spec

State 1044:
## Known stack suffix:
## impact_pragma
## LR(1) items:
code_annotation -> impact_pragma . [ VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE SLICE PREDICATE MODULE MODEL LOGIC LEMMA INVARIANT INDUCTIVE INCLUDE IMPACT GLOBAL FUNCTION FOR EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ASSERT
--   reduce production code_annotation -> impact_pragma

State 1045:
## Known stack suffix:
## grammar_extension_name
## LR(1) items:
is_spec -> grammar_extension_name . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production is_spec -> grammar_extension_name

State 1046:
## Known stack suffix:
## full_identifier_or_typename
## LR(1) items:
annotation -> full_identifier_or_typename . [ EOF ]
grammar_extension_name -> full_identifier_or_typename . [ WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production annotation -> full_identifier_or_typename
-- On WRITES WITH VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SLASH SIZEOF SIGNED SHORT SEPARATED SEMICOLON RSQUARE RPAR RETURNS RESULT REQUIRES REGISTER REAL READS RBRACE QUESTION PREDICATE PRAGMA PLUS PIPE PERCENT OR OLD OFFSET NULL NOTHING NOT NE MODULE MODEL MINUS LTLT LTCOLON LT LSQUARE LPAR LOOP LONG LOGIC LET LEMMA LE LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPLIES IMPACT IFF IF IDENTIFIER HATHAT HAT GTGT GT GLOBAL GHOST GE FUNCTION FROM FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS EQUAL EQ ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DOTDOTDOT DOTDOT DOT DOLLAR DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE COMMA COLONGT COLONCOLON COLON2 COLON CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BIMPLIES BIFF BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT ARROW AND AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production grammar_extension_name -> full_identifier_or_typename

State 1047:
## Known stack suffix:
## deprecated_logic_decl
## LR(1) items:
decl -> deprecated_logic_decl . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production decl -> deprecated_logic_decl

State 1048:
## Known stack suffix:
## decl_list
## LR(1) items:
annot -> decl_list . EOF [ # ]
## Transitions:
-- On EOF shift to state 1049
## Reductions:

State 1049:
## Known stack suffix:
## decl_list EOF
## LR(1) items:
annot -> decl_list EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production annot -> decl_list EOF

State 1050:
## Known stack suffix:
## decl
## LR(1) items:
decl_list -> decl . [ EOF ]
decl_list -> decl . decl_list [ EOF ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On GLOBAL shift to state 745
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On deprecated_logic_decl shift to state 1047
-- On decl_list shift to state 1051
-- On decl shift to state 1050
## Reductions:
-- On EOF
--   reduce production decl_list -> decl

State 1051:
## Known stack suffix:
## decl decl_list
## LR(1) items:
decl_list -> decl decl_list . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production decl_list -> decl decl_list

State 1052:
## Known stack suffix:
## code_annotation
## LR(1) items:
annotation -> code_annotation . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
annotation -> code_annotation . beg_code_annotation [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SLICE shift to state 1053
-- On INVARIANT shift to state 1054
-- On IMPACT shift to state 1055
-- On FOR shift to state 1056
-- On ASSERT shift to state 1057
-- On beg_code_annotation shift to state 1058
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production annotation -> code_annotation

State 1053:
## Known stack suffix:
## SLICE
## LR(1) items:
beg_code_annotation -> SLICE . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production beg_code_annotation -> SLICE

State 1054:
## Known stack suffix:
## INVARIANT
## LR(1) items:
beg_code_annotation -> INVARIANT . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production beg_code_annotation -> INVARIANT

State 1055:
## Known stack suffix:
## IMPACT
## LR(1) items:
beg_code_annotation -> IMPACT . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production beg_code_annotation -> IMPACT

State 1056:
## Known stack suffix:
## FOR
## LR(1) items:
beg_code_annotation -> FOR . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production beg_code_annotation -> FOR

State 1057:
## Known stack suffix:
## ASSERT
## LR(1) items:
beg_code_annotation -> ASSERT . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production beg_code_annotation -> ASSERT

State 1058:
## Known stack suffix:
## code_annotation beg_code_annotation
## LR(1) items:
annotation -> code_annotation beg_code_annotation . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production annotation -> code_annotation beg_code_annotation

State 1059:
## Known stack suffix:
## annotation
## LR(1) items:
annot -> annotation . EOF [ # ]
## Transitions:
-- On EOF shift to state 1060
## Reductions:

State 1060:
## Known stack suffix:
## annotation EOF
## LR(1) items:
annot -> annotation EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production annot -> annotation EOF

State 1061:
## Known stack suffix:
## annot
## LR(1) items:
annot' -> annot . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept annot

State 1062:
## Known stack suffix:
##
## LR(1) items:
ext_spec' -> . ext_spec [ # ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On INCLUDE shift to state 1063
-- On GLOBAL shift to state 745
-- On EXT_LET shift to state 1066
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On ext_spec shift to state 1071
-- On ext_global_clauses_opt shift to state 1072
-- On ext_global_clauses shift to state 1115
-- On ext_global_clause shift to state 1116
-- On deprecated_logic_decl shift to state 1047
-- On decl shift to state 1114
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_global_clauses_opt ->

State 1063:
## Known stack suffix:
## INCLUDE
## LR(1) items:
ext_global_clause -> INCLUDE . string SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On STRING_LITERAL shift to state 105
-- On string shift to state 1064
## Reductions:

State 1064:
## Known stack suffix:
## INCLUDE string
## LR(1) items:
ext_global_clause -> INCLUDE string . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
string -> string . STRING_LITERAL [ STRING_LITERAL SEMICOLON ]
## Transitions:
-- On STRING_LITERAL shift to state 299
-- On SEMICOLON shift to state 1065
## Reductions:

State 1065:
## Known stack suffix:
## INCLUDE string SEMICOLON
## LR(1) items:
ext_global_clause -> INCLUDE string SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_global_clause -> INCLUDE string SEMICOLON

State 1066:
## Known stack suffix:
## EXT_LET
## LR(1) items:
ext_global_clause -> EXT_LET . any_identifier EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 1067
-- On acsl_c_keyword shift to state 87
## Reductions:

State 1067:
## Known stack suffix:
## EXT_LET any_identifier
## LR(1) items:
ext_global_clause -> EXT_LET any_identifier . EQUAL full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On EQUAL shift to state 1068
## Reductions:

State 1068:
## Known stack suffix:
## EXT_LET any_identifier EQUAL
## LR(1) items:
ext_global_clause -> EXT_LET any_identifier EQUAL . full_lexpr SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On full_lexpr shift to state 1069
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 1069:
## Known stack suffix:
## EXT_LET any_identifier EQUAL full_lexpr
## LR(1) items:
ext_global_clause -> EXT_LET any_identifier EQUAL full_lexpr . SEMICOLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On SEMICOLON shift to state 1070
## Reductions:

State 1070:
## Known stack suffix:
## EXT_LET any_identifier EQUAL full_lexpr SEMICOLON
## LR(1) items:
ext_global_clause -> EXT_LET any_identifier EQUAL full_lexpr SEMICOLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_global_clause -> EXT_LET any_identifier EQUAL full_lexpr SEMICOLON

State 1071:
## Known stack suffix:
## ext_spec
## LR(1) items:
ext_spec' -> ext_spec . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept ext_spec

State 1072:
## Known stack suffix:
## ext_global_clauses_opt
## LR(1) items:
ext_spec -> ext_global_clauses_opt . ext_module_specs_opt ext_global_specs_opt EOF [ # ]
## Transitions:
-- On FUNCTION shift to state 1073
-- On ext_module_specs_opt shift to state 1077
-- On ext_module_specs shift to state 1123
-- On ext_module_spec shift to state 1084
-- On ext_function_markup shift to state 1086
## Reductions:
-- On MODULE EOF
--   reduce production ext_module_specs_opt ->

State 1073:
## Known stack suffix:
## FUNCTION
## LR(1) items:
ext_function_markup -> FUNCTION . ext_identifier COLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On ext_identifier shift to state 1074
-- On c_keyword shift to state 85
-- On any_identifier shift to state 1076
-- On acsl_c_keyword shift to state 87
## Reductions:

State 1074:
## Known stack suffix:
## FUNCTION ext_identifier
## LR(1) items:
ext_function_markup -> FUNCTION ext_identifier . COLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 1075
## Reductions:

State 1075:
## Known stack suffix:
## FUNCTION ext_identifier COLON
## LR(1) items:
ext_function_markup -> FUNCTION ext_identifier COLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_function_markup -> FUNCTION ext_identifier COLON

State 1076:
## Known stack suffix:
## any_identifier
## LR(1) items:
ext_identifier -> any_identifier . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production ext_identifier -> any_identifier

State 1077:
## Known stack suffix:
## ext_global_clauses_opt ext_module_specs_opt
## LR(1) items:
ext_spec -> ext_global_clauses_opt ext_module_specs_opt . ext_global_specs_opt EOF [ # ]
## Transitions:
-- On MODULE shift to state 1078
-- On ext_module_markup shift to state 1081
-- On ext_global_specs_opt shift to state 1118
-- On ext_global_specs shift to state 1120
-- On ext_global_spec shift to state 1121
## Reductions:
-- On EOF
--   reduce production ext_global_specs_opt ->

State 1078:
## Known stack suffix:
## MODULE
## LR(1) items:
ext_module_markup -> MODULE . ext_identifier COLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EOF AXIOMATIC AXIOM ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On ext_identifier shift to state 1079
-- On c_keyword shift to state 85
-- On any_identifier shift to state 1076
-- On acsl_c_keyword shift to state 87
## Reductions:

State 1079:
## Known stack suffix:
## MODULE ext_identifier
## LR(1) items:
ext_module_markup -> MODULE ext_identifier . COLON [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EOF AXIOMATIC AXIOM ]
## Transitions:
-- On COLON shift to state 1080
## Reductions:

State 1080:
## Known stack suffix:
## MODULE ext_identifier COLON
## LR(1) items:
ext_module_markup -> MODULE ext_identifier COLON . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EOF AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EOF AXIOMATIC AXIOM
--   reduce production ext_module_markup -> MODULE ext_identifier COLON

State 1081:
## Known stack suffix:
## ext_module_markup
## LR(1) items:
ext_global_spec -> ext_module_markup . ext_global_clauses_opt ext_module_specs [ MODULE EOF ]
ext_global_spec -> ext_module_markup . [ MODULE EOF ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On INCLUDE shift to state 1063
-- On GLOBAL shift to state 745
-- On EXT_LET shift to state 1066
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On ext_global_clauses_opt shift to state 1082
-- On ext_global_clauses shift to state 1115
-- On ext_global_clause shift to state 1116
-- On deprecated_logic_decl shift to state 1047
-- On decl shift to state 1114
## Reductions:
-- On FUNCTION
--   reduce production ext_global_clauses_opt ->
-- On MODULE EOF
--   reduce production ext_global_spec -> ext_module_markup

State 1082:
## Known stack suffix:
## ext_module_markup ext_global_clauses_opt
## LR(1) items:
ext_global_spec -> ext_module_markup ext_global_clauses_opt . ext_module_specs [ MODULE EOF ]
## Transitions:
-- On FUNCTION shift to state 1073
-- On ext_module_specs shift to state 1083
-- On ext_module_spec shift to state 1084
-- On ext_function_markup shift to state 1086
## Reductions:

State 1083:
## Known stack suffix:
## ext_module_markup ext_global_clauses_opt ext_module_specs
## LR(1) items:
ext_global_spec -> ext_module_markup ext_global_clauses_opt ext_module_specs . [ MODULE EOF ]
## Transitions:
## Reductions:
-- On MODULE EOF
--   reduce production ext_global_spec -> ext_module_markup ext_global_clauses_opt ext_module_specs

State 1084:
## Known stack suffix:
## ext_module_spec
## LR(1) items:
ext_module_specs -> ext_module_spec . [ MODULE EOF ]
ext_module_specs -> ext_module_spec . ext_module_specs [ MODULE EOF ]
## Transitions:
-- On FUNCTION shift to state 1073
-- On ext_module_specs shift to state 1085
-- On ext_module_spec shift to state 1084
-- On ext_function_markup shift to state 1086
## Reductions:
-- On MODULE EOF
--   reduce production ext_module_specs -> ext_module_spec

State 1085:
## Known stack suffix:
## ext_module_spec ext_module_specs
## LR(1) items:
ext_module_specs -> ext_module_spec ext_module_specs . [ MODULE EOF ]
## Transitions:
## Reductions:
-- On MODULE EOF
--   reduce production ext_module_specs -> ext_module_spec ext_module_specs

State 1086:
## Known stack suffix:
## ext_function_markup
## LR(1) items:
ext_module_spec -> ext_function_markup . ext_function_specs_opt [ MODULE FUNCTION EOF ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On INCLUDE shift to state 1063
-- On GLOBAL shift to state 745
-- On EXT_LET shift to state 1066
-- On EXT_AT shift to state 1087
-- On CONTRACT shift to state 1095
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On ext_global_clause shift to state 1099
-- On ext_function_specs_opt shift to state 1100
-- On ext_function_specs shift to state 1101
-- On ext_function_spec shift to state 1102
-- On ext_contract_markup shift to state 1104
-- On ext_at_stmt_markup shift to state 1106
-- On ext_at_loop_markup shift to state 1112
-- On deprecated_logic_decl shift to state 1047
-- On decl shift to state 1114
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs_opt ->

State 1087:
## Known stack suffix:
## EXT_AT
## LR(1) items:
ext_at_loop_markup -> EXT_AT . LOOP CONSTANT10 COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
ext_at_stmt_markup -> EXT_AT . CONSTANT10 COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
ext_at_stmt_markup -> EXT_AT . any_identifier COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 1088
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONSTANT10 shift to state 1091
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On c_keyword shift to state 85
-- On any_identifier shift to state 1093
-- On acsl_c_keyword shift to state 87
## Reductions:

State 1088:
## Known stack suffix:
## EXT_AT LOOP
## LR(1) items:
ext_at_loop_markup -> EXT_AT LOOP . CONSTANT10 COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
is_acsl_decl_or_code_annot -> LOOP . [ COLON ]
## Transitions:
-- On CONSTANT10 shift to state 1089
## Reductions:
-- On COLON
--   reduce production is_acsl_decl_or_code_annot -> LOOP

State 1089:
## Known stack suffix:
## EXT_AT LOOP CONSTANT10
## LR(1) items:
ext_at_loop_markup -> EXT_AT LOOP CONSTANT10 . COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
-- On COLON shift to state 1090
## Reductions:

State 1090:
## Known stack suffix:
## EXT_AT LOOP CONSTANT10 COLON
## LR(1) items:
ext_at_loop_markup -> EXT_AT LOOP CONSTANT10 COLON . [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
## Reductions:
-- On TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT
--   reduce production ext_at_loop_markup -> EXT_AT LOOP CONSTANT10 COLON

State 1091:
## Known stack suffix:
## EXT_AT CONSTANT10
## LR(1) items:
ext_at_stmt_markup -> EXT_AT CONSTANT10 . COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
-- On COLON shift to state 1092
## Reductions:

State 1092:
## Known stack suffix:
## EXT_AT CONSTANT10 COLON
## LR(1) items:
ext_at_stmt_markup -> EXT_AT CONSTANT10 COLON . [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
## Reductions:
-- On TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT
--   reduce production ext_at_stmt_markup -> EXT_AT CONSTANT10 COLON

State 1093:
## Known stack suffix:
## EXT_AT any_identifier
## LR(1) items:
ext_at_stmt_markup -> EXT_AT any_identifier . COLON [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
-- On COLON shift to state 1094
## Reductions:

State 1094:
## Known stack suffix:
## EXT_AT any_identifier COLON
## LR(1) items:
ext_at_stmt_markup -> EXT_AT any_identifier COLON . [ TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT ]
## Transitions:
## Reductions:
-- On TYPENAME SLICE MODULE LOOP INVARIANT IMPACT IDENTIFIER FUNCTION FOR EOF CONTRACT ASSERT
--   reduce production ext_at_stmt_markup -> EXT_AT any_identifier COLON

State 1095:
## Known stack suffix:
## CONTRACT
## LR(1) items:
ext_contract_markup -> CONTRACT . ext_identifier_opt COLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On WRITES shift to state 1
-- On VOLATILE shift to state 3
-- On VOID shift to state 4
-- On VARIANT shift to state 5
-- On UNSIGNED shift to state 8
-- On UNION shift to state 9
-- On TYPENAME shift to state 10
-- On TYPE shift to state 11
-- On TERMINATES shift to state 12
-- On STRUCT shift to state 13
-- On STATIC shift to state 14
-- On SLICE shift to state 15
-- On SIZEOF shift to state 16
-- On SIGNED shift to state 17
-- On SHORT shift to state 18
-- On RETURNS shift to state 19
-- On REQUIRES shift to state 20
-- On REAL shift to state 21
-- On READS shift to state 22
-- On PREDICATE shift to state 23
-- On PRAGMA shift to state 24
-- On MODULE shift to state 25
-- On MODEL shift to state 26
-- On LOOP shift to state 27
-- On LONG shift to state 28
-- On LOGIC shift to state 29
-- On LEMMA shift to state 30
-- On LABEL shift to state 31
-- On INVARIANT shift to state 32
-- On INTEGER shift to state 33
-- On INT shift to state 34
-- On INDUCTIVE shift to state 35
-- On INCLUDE shift to state 36
-- On IMPACT shift to state 37
-- On IF shift to state 38
-- On IDENTIFIER shift to state 39
-- On GLOBAL shift to state 40
-- On FUNCTION shift to state 41
-- On FREES shift to state 42
-- On FOR shift to state 43
-- On FLOAT shift to state 44
-- On EXT_LET shift to state 45
-- On EXT_AT shift to state 46
-- On EXITS shift to state 47
-- On ENUM shift to state 48
-- On ENSURES shift to state 49
-- On ELSE shift to state 50
-- On DOUBLE shift to state 51
-- On DISJOINT shift to state 52
-- On DECREASES shift to state 53
-- On CUSTOM shift to state 54
-- On CONTRACT shift to state 55
-- On CONTINUES shift to state 56
-- On CONST shift to state 57
-- On COMPLETE shift to state 58
-- On CHAR shift to state 59
-- On CASE shift to state 60
-- On BREAKS shift to state 61
-- On BOOLEAN shift to state 62
-- On BOOL shift to state 63
-- On BEHAVIORS shift to state 64
-- On BEHAVIOR shift to state 65
-- On AXIOMATIC shift to state 66
-- On AXIOM shift to state 67
-- On ASSUMES shift to state 68
-- On ASSIGNS shift to state 69
-- On ASSERT shift to state 70
-- On ALLOCATES shift to state 71
-- On post_cond shift to state 72
-- On non_logic_keyword shift to state 73
-- On keyword shift to state 79
-- On is_ext_spec shift to state 80
-- On is_acsl_spec shift to state 81
-- On is_acsl_other shift to state 82
-- On is_acsl_decl_or_code_annot shift to state 83
-- On identifier_or_typename shift to state 84
-- On ext_identifier_opt shift to state 1096
-- On ext_identifier shift to state 1098
-- On c_keyword shift to state 85
-- On any_identifier shift to state 1076
-- On acsl_c_keyword shift to state 87
## Reductions:
-- On COLON
--   reduce production ext_identifier_opt ->

State 1096:
## Known stack suffix:
## CONTRACT ext_identifier_opt
## LR(1) items:
ext_contract_markup -> CONTRACT ext_identifier_opt . COLON [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
-- On COLON shift to state 1097
## Reductions:

State 1097:
## Known stack suffix:
## CONTRACT ext_identifier_opt COLON
## LR(1) items:
ext_contract_markup -> CONTRACT ext_identifier_opt COLON . [ WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES ]
## Transitions:
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REQUIRES REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production ext_contract_markup -> CONTRACT ext_identifier_opt COLON

State 1098:
## Known stack suffix:
## ext_identifier
## LR(1) items:
ext_identifier_opt -> ext_identifier . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production ext_identifier_opt -> ext_identifier

State 1099:
## Known stack suffix:
## ext_global_clause
## LR(1) items:
ext_function_spec -> ext_global_clause . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_function_spec -> ext_global_clause

State 1100:
## Known stack suffix:
## ext_function_markup ext_function_specs_opt
## LR(1) items:
ext_module_spec -> ext_function_markup ext_function_specs_opt . [ MODULE FUNCTION EOF ]
## Transitions:
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_module_spec -> ext_function_markup ext_function_specs_opt

State 1101:
## Known stack suffix:
## ext_function_specs
## LR(1) items:
ext_function_specs_opt -> ext_function_specs . [ MODULE FUNCTION EOF ]
## Transitions:
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs_opt -> ext_function_specs

State 1102:
## Known stack suffix:
## ext_function_spec
## LR(1) items:
ext_function_specs -> ext_function_spec . [ MODULE FUNCTION EOF ]
ext_function_specs -> ext_function_spec . ext_function_specs [ MODULE FUNCTION EOF ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On INCLUDE shift to state 1063
-- On GLOBAL shift to state 745
-- On EXT_LET shift to state 1066
-- On EXT_AT shift to state 1087
-- On CONTRACT shift to state 1095
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On ext_global_clause shift to state 1099
-- On ext_function_specs shift to state 1103
-- On ext_function_spec shift to state 1102
-- On ext_contract_markup shift to state 1104
-- On ext_at_stmt_markup shift to state 1106
-- On ext_at_loop_markup shift to state 1112
-- On deprecated_logic_decl shift to state 1047
-- On decl shift to state 1114
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs -> ext_function_spec

State 1103:
## Known stack suffix:
## ext_function_spec ext_function_specs
## LR(1) items:
ext_function_specs -> ext_function_spec ext_function_specs . [ MODULE FUNCTION EOF ]
## Transitions:
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs -> ext_function_spec ext_function_specs

State 1104:
## Known stack suffix:
## ext_contract_markup
## LR(1) items:
ext_function_spec -> ext_contract_markup . contract [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On REQUIRES shift to state 754
-- On requires shift to state 799
-- On ne_requires shift to state 758
-- On contract shift to state 1105
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production requires ->

State 1105:
## Known stack suffix:
## ext_contract_markup contract
## LR(1) items:
ext_function_spec -> ext_contract_markup contract . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_function_spec -> ext_contract_markup contract

State 1106:
## Known stack suffix:
## ext_at_stmt_markup
## LR(1) items:
ext_function_spec -> ext_at_stmt_markup . ext_stmt_loop_spec [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
ext_function_specs -> ext_at_stmt_markup . [ MODULE FUNCTION EOF ]
## Transitions:
-- On SLICE shift to state 617
-- On LOOP shift to state 656
-- On INVARIANT shift to state 724
-- On IMPACT shift to state 739
-- On FOR shift to state 751
-- On CONTRACT shift to state 1095
-- On ASSERT shift to state 942
-- On slice_pragma shift to state 946
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annotations shift to state 948
-- On loop_annot_stack shift to state 949
-- On loop_allocation shift to state 785
-- On impact_pragma shift to state 1044
-- On full_identifier_or_typename shift to state 1107
-- On ext_stmt_loop_spec shift to state 1108
-- On ext_contract_markup shift to state 1109
-- On enter_kw_c_mode shift to state 698
-- On code_annotation shift to state 1052
-- On annotation shift to state 1111
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs -> ext_at_stmt_markup

State 1107:
## Known stack suffix:
## full_identifier_or_typename
## LR(1) items:
annotation -> full_identifier_or_typename . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production annotation -> full_identifier_or_typename

State 1108:
## Known stack suffix:
## ext_at_stmt_markup ext_stmt_loop_spec
## LR(1) items:
ext_function_spec -> ext_at_stmt_markup ext_stmt_loop_spec . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_function_spec -> ext_at_stmt_markup ext_stmt_loop_spec

State 1109:
## Known stack suffix:
## ext_contract_markup
## LR(1) items:
ext_stmt_loop_spec -> ext_contract_markup . contract [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
-- On REQUIRES shift to state 754
-- On requires shift to state 799
-- On ne_requires shift to state 758
-- On contract shift to state 1110
## Reductions:
-- On WRITES VOLATILE VOID UNSIGNED UNION TYPENAME TYPE TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS PREDICATE MODULE MODEL LONG LOGIC LEMMA LABEL INTEGER INT INDUCTIVE INCLUDE IF IDENTIFIER GLOBAL FUNCTION FREES FLOAT EXT_LET EXT_AT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTRACT CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR AXIOMATIC AXIOM ASSIGNS ALLOCATES
--   reduce production requires ->

State 1110:
## Known stack suffix:
## ext_contract_markup contract
## LR(1) items:
ext_stmt_loop_spec -> ext_contract_markup contract . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_stmt_loop_spec -> ext_contract_markup contract

State 1111:
## Known stack suffix:
## annotation
## LR(1) items:
ext_stmt_loop_spec -> annotation . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_stmt_loop_spec -> annotation

State 1112:
## Known stack suffix:
## ext_at_loop_markup
## LR(1) items:
ext_function_spec -> ext_at_loop_markup . ext_stmt_loop_spec [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
ext_function_specs -> ext_at_loop_markup . [ MODULE FUNCTION EOF ]
## Transitions:
-- On SLICE shift to state 617
-- On LOOP shift to state 656
-- On INVARIANT shift to state 724
-- On IMPACT shift to state 739
-- On FOR shift to state 751
-- On CONTRACT shift to state 1095
-- On ASSERT shift to state 942
-- On slice_pragma shift to state 946
-- On loop_variant shift to state 778
-- On loop_pragma shift to state 779
-- On loop_invariant shift to state 780
-- On loop_grammar_extension shift to state 781
-- On loop_effects shift to state 782
-- On loop_annotations shift to state 948
-- On loop_annot_stack shift to state 949
-- On loop_allocation shift to state 785
-- On impact_pragma shift to state 1044
-- On full_identifier_or_typename shift to state 1107
-- On ext_stmt_loop_spec shift to state 1113
-- On ext_contract_markup shift to state 1109
-- On enter_kw_c_mode shift to state 698
-- On code_annotation shift to state 1052
-- On annotation shift to state 1111
## Reductions:
-- On TYPENAME IDENTIFIER
--   reduce production enter_kw_c_mode ->
-- On MODULE FUNCTION EOF
--   reduce production ext_function_specs -> ext_at_loop_markup

State 1113:
## Known stack suffix:
## ext_at_loop_markup ext_stmt_loop_spec
## LR(1) items:
ext_function_spec -> ext_at_loop_markup ext_stmt_loop_spec . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_function_spec -> ext_at_loop_markup ext_stmt_loop_spec

State 1114:
## Known stack suffix:
## decl
## LR(1) items:
ext_global_clause -> decl . [ VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM ]
## Transitions:
## Reductions:
-- On VOLATILE TYPE PREDICATE MODULE MODEL LOGIC LEMMA INDUCTIVE INCLUDE GLOBAL FUNCTION EXT_LET EXT_AT EOF CONTRACT AXIOMATIC AXIOM
--   reduce production ext_global_clause -> decl

State 1115:
## Known stack suffix:
## ext_global_clauses
## LR(1) items:
ext_global_clauses_opt -> ext_global_clauses . [ MODULE FUNCTION EOF ]
## Transitions:
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_global_clauses_opt -> ext_global_clauses

State 1116:
## Known stack suffix:
## ext_global_clause
## LR(1) items:
ext_global_clauses -> ext_global_clause . [ MODULE FUNCTION EOF ]
ext_global_clauses -> ext_global_clause . ext_global_clauses [ MODULE FUNCTION EOF ]
## Transitions:
-- On VOLATILE shift to state 2
-- On TYPE shift to state 560
-- On PREDICATE shift to state 623
-- On MODEL shift to state 648
-- On LOGIC shift to state 704
-- On LEMMA shift to state 719
-- On INDUCTIVE shift to state 727
-- On INCLUDE shift to state 1063
-- On GLOBAL shift to state 745
-- On EXT_LET shift to state 1066
-- On AXIOMATIC shift to state 907
-- On AXIOM shift to state 937
-- On type_annot shift to state 945
-- On model_annot shift to state 947
-- On logic_def shift to state 950
-- On ext_global_clauses shift to state 1117
-- On ext_global_clause shift to state 1116
-- On deprecated_logic_decl shift to state 1047
-- On decl shift to state 1114
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_global_clauses -> ext_global_clause

State 1117:
## Known stack suffix:
## ext_global_clause ext_global_clauses
## LR(1) items:
ext_global_clauses -> ext_global_clause ext_global_clauses . [ MODULE FUNCTION EOF ]
## Transitions:
## Reductions:
-- On MODULE FUNCTION EOF
--   reduce production ext_global_clauses -> ext_global_clause ext_global_clauses

State 1118:
## Known stack suffix:
## ext_global_clauses_opt ext_module_specs_opt ext_global_specs_opt
## LR(1) items:
ext_spec -> ext_global_clauses_opt ext_module_specs_opt ext_global_specs_opt . EOF [ # ]
## Transitions:
-- On EOF shift to state 1119
## Reductions:

State 1119:
## Known stack suffix:
## ext_global_clauses_opt ext_module_specs_opt ext_global_specs_opt EOF
## LR(1) items:
ext_spec -> ext_global_clauses_opt ext_module_specs_opt ext_global_specs_opt EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production ext_spec -> ext_global_clauses_opt ext_module_specs_opt ext_global_specs_opt EOF

State 1120:
## Known stack suffix:
## ext_global_specs
## LR(1) items:
ext_global_specs_opt -> ext_global_specs . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production ext_global_specs_opt -> ext_global_specs

State 1121:
## Known stack suffix:
## ext_global_spec
## LR(1) items:
ext_global_specs -> ext_global_spec . [ EOF ]
ext_global_specs -> ext_global_spec . ext_global_specs [ EOF ]
## Transitions:
-- On MODULE shift to state 1078
-- On ext_module_markup shift to state 1081
-- On ext_global_specs shift to state 1122
-- On ext_global_spec shift to state 1121
## Reductions:
-- On EOF
--   reduce production ext_global_specs -> ext_global_spec

State 1122:
## Known stack suffix:
## ext_global_spec ext_global_specs
## LR(1) items:
ext_global_specs -> ext_global_spec ext_global_specs . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production ext_global_specs -> ext_global_spec ext_global_specs

State 1123:
## Known stack suffix:
## ext_module_specs
## LR(1) items:
ext_module_specs_opt -> ext_module_specs . [ MODULE EOF ]
## Transitions:
## Reductions:
-- On MODULE EOF
--   reduce production ext_module_specs_opt -> ext_module_specs

State 1124:
## Known stack suffix:
##
## LR(1) items:
lexpr_eof' -> . lexpr_eof [ # ]
## Transitions:
-- On lexpr_eof shift to state 1125
-- On full_lexpr shift to state 1126
-- On enter_kw_c_mode shift to state 569
## Reductions:
-- On WRITES VOLATILE VOID VARIANT VALID_READ VALID_RANGE VALID_INDEX VALID UNSIGNED UNION UNALLOCATED TYPEOF TYPENAME TYPE TRUE TILDE TERMINATES STRUCT STRING_LITERAL STATIC STAR SLICE SIZEOF SIGNED SHORT SEPARATED RETURNS RESULT REQUIRES REGISTER REAL READS PREDICATE PRAGMA PLUS OLD OFFSET NULL NOT MODULE MODEL MINUS LPAR LOOP LONG LOGIC LET LEMMA LBRACE LAMBDA LABEL INVARIANT INTER INTEGER INT INITIALIZED INDUCTIVE INCLUDE IMPACT IF IDENTIFIER GLOBAL FUNCTION FRESH FREES FREEABLE FORALL FOR FLOAT FALSE EXT_LET EXT_AT EXITS EXISTS ENUM ENSURES EMPTY ELSE DYNAMIC DOUBLE DISJOINT DECREASES DANGLING CUSTOM CONTRACT CONTINUES CONSTANT10 CONSTANT CONST COMPLETE CHAR CASE BSUNION BSTYPE BREAKS BOOLEAN BOOL BLOCK_LENGTH BEHAVIORS BEHAVIOR BASE_ADDR AXIOMATIC AXIOM AUTOMATIC AT ASSUMES ASSIGNS ASSERT AMP ALLOCATION ALLOCATES ALLOCABLE
--   reduce production enter_kw_c_mode ->

State 1125:
## Known stack suffix:
## lexpr_eof
## LR(1) items:
lexpr_eof' -> lexpr_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept lexpr_eof

State 1126:
## Known stack suffix:
## full_lexpr
## LR(1) items:
lexpr_eof -> full_lexpr . EOF [ # ]
## Transitions:
-- On EOF shift to state 1127
## Reductions:

State 1127:
## Known stack suffix:
## full_lexpr EOF
## LR(1) items:
lexpr_eof -> full_lexpr EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production lexpr_eof -> full_lexpr EOF

State 1128:
## Known stack suffix:
##
## LR(1) items:
spec' -> . spec [ # ]
## Transitions:
-- On REQUIRES shift to state 754
-- On spec shift to state 1129
-- On requires shift to state 799
-- On ne_requires shift to state 758
-- On contract shift to state 1130
## Reductions:
-- On WRITES VOID UNSIGNED UNION TYPENAME TERMINATES STRUCT STATIC SIZEOF SIGNED SHORT RETURNS REAL READS LONG LABEL INTEGER INT IF IDENTIFIER FREES FLOAT EXITS EOF ENUM ENSURES ELSE DOUBLE DISJOINT DECREASES CONTINUES CONST COMPLETE CHAR CASE BREAKS BOOLEAN BOOL BEHAVIORS BEHAVIOR ASSIGNS ALLOCATES
--   reduce production requires ->

State 1129:
## Known stack suffix:
## spec
## LR(1) items:
spec' -> spec . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept spec

State 1130:
## Known stack suffix:
## contract
## LR(1) items:
spec -> contract . EOF [ # ]
## Transitions:
-- On EOF shift to state 1131
## Reductions:

State 1131:
## Known stack suffix:
## contract EOF
## LR(1) items:
spec -> contract EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production spec -> contract EOF

