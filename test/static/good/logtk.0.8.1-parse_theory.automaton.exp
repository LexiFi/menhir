State 0:
parse_statement' -> . parse_statement [ # ]
-- On THEORY shift to state 1
-- On RAW shift to state 154
-- On LEMMA shift to state 172
-- On INCLUDE shift to state 182
-- On AXIOM shift to state 185
-- On theory shift to state 190
-- On statement shift to state 191
-- On parse_statement shift to state 193
-- On lemma shift to state 194
-- On include_ shift to state 195
-- On clause shift to state 196
-- On axiom shift to state 197

State 1:
theory -> THEORY . datalog_atom IS premises DOT [ EOI ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 11

State 2:
datalog_atom -> LOWER_WORD . [ IS IF DOT AND_ALSO ]
datalog_atom -> LOWER_WORD . LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN [ IS IF DOT AND_ALSO ]
-- On LEFT_PAREN shift to state 3
-- On IS reduce production datalog_atom -> LOWER_WORD
-- On IF reduce production datalog_atom -> LOWER_WORD
-- On DOT reduce production datalog_atom -> LOWER_WORD
-- On AND_ALSO reduce production datalog_atom -> LOWER_WORD

State 3:
datalog_atom -> LOWER_WORD LEFT_PAREN . separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN [ IS IF DOT AND_ALSO ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,atomic_word) shift to state 6
-- On atomic_word shift to state 8

State 4:
atomic_word -> SINGLE_QUOTED . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_word -> SINGLE_QUOTED
-- On VLINE reduce production atomic_word -> SINGLE_QUOTED
-- On RIGHT_PAREN reduce production atomic_word -> SINGLE_QUOTED
-- On RIGHT_BRACKET reduce production atomic_word -> SINGLE_QUOTED
-- On NOT_EQUAL reduce production atomic_word -> SINGLE_QUOTED
-- On NOTVLINE reduce production atomic_word -> SINGLE_QUOTED
-- On NOTAND reduce production atomic_word -> SINGLE_QUOTED
-- On LEFT_PAREN reduce production atomic_word -> SINGLE_QUOTED
-- On LEFT_IMPLY reduce production atomic_word -> SINGLE_QUOTED
-- On IMPLY reduce production atomic_word -> SINGLE_QUOTED
-- On IF reduce production atomic_word -> SINGLE_QUOTED
-- On EQUIV reduce production atomic_word -> SINGLE_QUOTED
-- On EQUAL reduce production atomic_word -> SINGLE_QUOTED
-- On DOT reduce production atomic_word -> SINGLE_QUOTED
-- On COMMA reduce production atomic_word -> SINGLE_QUOTED
-- On AND_ALSO reduce production atomic_word -> SINGLE_QUOTED
-- On AND reduce production atomic_word -> SINGLE_QUOTED

State 5:
atomic_word -> LOWER_WORD . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_word -> LOWER_WORD
-- On VLINE reduce production atomic_word -> LOWER_WORD
-- On RIGHT_PAREN reduce production atomic_word -> LOWER_WORD
-- On RIGHT_BRACKET reduce production atomic_word -> LOWER_WORD
-- On NOT_EQUAL reduce production atomic_word -> LOWER_WORD
-- On NOTVLINE reduce production atomic_word -> LOWER_WORD
-- On NOTAND reduce production atomic_word -> LOWER_WORD
-- On LEFT_PAREN reduce production atomic_word -> LOWER_WORD
-- On LEFT_IMPLY reduce production atomic_word -> LOWER_WORD
-- On IMPLY reduce production atomic_word -> LOWER_WORD
-- On IF reduce production atomic_word -> LOWER_WORD
-- On EQUIV reduce production atomic_word -> LOWER_WORD
-- On EQUAL reduce production atomic_word -> LOWER_WORD
-- On DOT reduce production atomic_word -> LOWER_WORD
-- On COMMA reduce production atomic_word -> LOWER_WORD
-- On AND_ALSO reduce production atomic_word -> LOWER_WORD
-- On AND reduce production atomic_word -> LOWER_WORD

State 6:
datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) . RIGHT_PAREN [ IS IF DOT AND_ALSO ]
-- On RIGHT_PAREN shift to state 7

State 7:
datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN . [ IS IF DOT AND_ALSO ]
-- On IS reduce production datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN
-- On IF reduce production datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN
-- On DOT reduce production datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN
-- On AND_ALSO reduce production datalog_atom -> LOWER_WORD LEFT_PAREN separated_nonempty_list(COMMA,atomic_word) RIGHT_PAREN

State 8:
separated_nonempty_list(COMMA,atomic_word) -> atomic_word . [ RIGHT_PAREN ]
separated_nonempty_list(COMMA,atomic_word) -> atomic_word . COMMA separated_nonempty_list(COMMA,atomic_word) [ RIGHT_PAREN ]
-- On COMMA shift to state 9
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,atomic_word) -> atomic_word

State 9:
separated_nonempty_list(COMMA,atomic_word) -> atomic_word COMMA . separated_nonempty_list(COMMA,atomic_word) [ RIGHT_PAREN ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,atomic_word) shift to state 10
-- On atomic_word shift to state 8

State 10:
separated_nonempty_list(COMMA,atomic_word) -> atomic_word COMMA separated_nonempty_list(COMMA,atomic_word) . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,atomic_word) -> atomic_word COMMA separated_nonempty_list(COMMA,atomic_word)

State 11:
theory -> THEORY datalog_atom . IS premises DOT [ EOI ]
-- On IS shift to state 12

State 12:
theory -> THEORY datalog_atom IS . premises DOT [ EOI ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 146
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 13:
variable -> UPPER_WORD . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
variable -> UPPER_WORD . COLUMN tff_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On COLUMN shift to state 14
-- On XOR reduce production variable -> UPPER_WORD
-- On VLINE reduce production variable -> UPPER_WORD
-- On RIGHT_PAREN reduce production variable -> UPPER_WORD
-- On RIGHT_BRACKET reduce production variable -> UPPER_WORD
-- On NOT_EQUAL reduce production variable -> UPPER_WORD
-- On NOTVLINE reduce production variable -> UPPER_WORD
-- On NOTAND reduce production variable -> UPPER_WORD
-- On LEFT_IMPLY reduce production variable -> UPPER_WORD
-- On IMPLY reduce production variable -> UPPER_WORD
-- On IF reduce production variable -> UPPER_WORD
-- On EQUIV reduce production variable -> UPPER_WORD
-- On EQUAL reduce production variable -> UPPER_WORD
-- On DOT reduce production variable -> UPPER_WORD
-- On COMMA reduce production variable -> UPPER_WORD
-- On AND_ALSO reduce production variable -> UPPER_WORD
-- On AND reduce production variable -> UPPER_WORD

State 14:
variable -> UPPER_WORD COLUMN . tff_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 18
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_type shift to state 42
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 25

State 15:
tff_ty_var -> UPPER_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production tff_ty_var -> UPPER_WORD
-- On VLINE reduce production tff_ty_var -> UPPER_WORD
-- On STAR reduce production tff_ty_var -> UPPER_WORD
-- On RIGHT_PAREN reduce production tff_ty_var -> UPPER_WORD
-- On RIGHT_BRACKET reduce production tff_ty_var -> UPPER_WORD
-- On NOT_EQUAL reduce production tff_ty_var -> UPPER_WORD
-- On NOTVLINE reduce production tff_ty_var -> UPPER_WORD
-- On NOTAND reduce production tff_ty_var -> UPPER_WORD
-- On LEFT_IMPLY reduce production tff_ty_var -> UPPER_WORD
-- On IMPLY reduce production tff_ty_var -> UPPER_WORD
-- On IF reduce production tff_ty_var -> UPPER_WORD
-- On EQUIV reduce production tff_ty_var -> UPPER_WORD
-- On EQUAL reduce production tff_ty_var -> UPPER_WORD
-- On DOT reduce production tff_ty_var -> UPPER_WORD
-- On COMMA reduce production tff_ty_var -> UPPER_WORD
-- On ARROW reduce production tff_ty_var -> UPPER_WORD
-- On AND_ALSO reduce production tff_ty_var -> UPPER_WORD
-- On AND reduce production tff_ty_var -> UPPER_WORD

State 16:
tff_atom_type -> TYPE_TY . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production tff_atom_type -> TYPE_TY
-- On VLINE reduce production tff_atom_type -> TYPE_TY
-- On STAR reduce production tff_atom_type -> TYPE_TY
-- On RIGHT_PAREN reduce production tff_atom_type -> TYPE_TY
-- On RIGHT_BRACKET reduce production tff_atom_type -> TYPE_TY
-- On NOT_EQUAL reduce production tff_atom_type -> TYPE_TY
-- On NOTVLINE reduce production tff_atom_type -> TYPE_TY
-- On NOTAND reduce production tff_atom_type -> TYPE_TY
-- On LEFT_IMPLY reduce production tff_atom_type -> TYPE_TY
-- On IMPLY reduce production tff_atom_type -> TYPE_TY
-- On IF reduce production tff_atom_type -> TYPE_TY
-- On EQUIV reduce production tff_atom_type -> TYPE_TY
-- On EQUAL reduce production tff_atom_type -> TYPE_TY
-- On DOT reduce production tff_atom_type -> TYPE_TY
-- On COMMA reduce production tff_atom_type -> TYPE_TY
-- On ARROW reduce production tff_atom_type -> TYPE_TY
-- On AND_ALSO reduce production tff_atom_type -> TYPE_TY
-- On AND reduce production tff_atom_type -> TYPE_TY

State 17:
type_const -> LOWER_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production type_const -> LOWER_WORD
-- On VLINE reduce production type_const -> LOWER_WORD
-- On STAR reduce production type_const -> LOWER_WORD
-- On RIGHT_PAREN reduce production type_const -> LOWER_WORD
-- On RIGHT_BRACKET reduce production type_const -> LOWER_WORD
-- On NOT_EQUAL reduce production type_const -> LOWER_WORD
-- On NOTVLINE reduce production type_const -> LOWER_WORD
-- On NOTAND reduce production type_const -> LOWER_WORD
-- On LEFT_PAREN reduce production type_const -> LOWER_WORD
-- On LEFT_IMPLY reduce production type_const -> LOWER_WORD
-- On IMPLY reduce production type_const -> LOWER_WORD
-- On IF reduce production type_const -> LOWER_WORD
-- On EQUIV reduce production type_const -> LOWER_WORD
-- On EQUAL reduce production type_const -> LOWER_WORD
-- On DOT reduce production type_const -> LOWER_WORD
-- On COMMA reduce production type_const -> LOWER_WORD
-- On ARROW reduce production type_const -> LOWER_WORD
-- On AND_ALSO reduce production type_const -> LOWER_WORD
-- On AND reduce production type_const -> LOWER_WORD

State 18:
tff_atom_type -> LEFT_PAREN . tff_type RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
tff_type -> LEFT_PAREN . tff_ty_args RIGHT_PAREN ARROW tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 18
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_type shift to state 28
-- On tff_ty_var shift to state 24
-- On tff_ty_args shift to state 34
-- On tff_atom_type shift to state 38

State 19:
type_const -> DOLLAR_WORD . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production type_const -> DOLLAR_WORD
-- On VLINE reduce production type_const -> DOLLAR_WORD
-- On STAR reduce production type_const -> DOLLAR_WORD
-- On RIGHT_PAREN reduce production type_const -> DOLLAR_WORD
-- On RIGHT_BRACKET reduce production type_const -> DOLLAR_WORD
-- On NOT_EQUAL reduce production type_const -> DOLLAR_WORD
-- On NOTVLINE reduce production type_const -> DOLLAR_WORD
-- On NOTAND reduce production type_const -> DOLLAR_WORD
-- On LEFT_PAREN reduce production type_const -> DOLLAR_WORD
-- On LEFT_IMPLY reduce production type_const -> DOLLAR_WORD
-- On IMPLY reduce production type_const -> DOLLAR_WORD
-- On IF reduce production type_const -> DOLLAR_WORD
-- On EQUIV reduce production type_const -> DOLLAR_WORD
-- On EQUAL reduce production type_const -> DOLLAR_WORD
-- On DOT reduce production type_const -> DOLLAR_WORD
-- On COMMA reduce production type_const -> DOLLAR_WORD
-- On ARROW reduce production type_const -> DOLLAR_WORD
-- On AND_ALSO reduce production type_const -> DOLLAR_WORD
-- On AND reduce production type_const -> DOLLAR_WORD

State 20:
tff_atom_type -> type_const . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
tff_atom_type -> type_const . LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On LEFT_PAREN shift to state 21
-- On XOR reduce production tff_atom_type -> type_const
-- On VLINE reduce production tff_atom_type -> type_const
-- On STAR reduce production tff_atom_type -> type_const
-- On RIGHT_PAREN reduce production tff_atom_type -> type_const
-- On RIGHT_BRACKET reduce production tff_atom_type -> type_const
-- On NOT_EQUAL reduce production tff_atom_type -> type_const
-- On NOTVLINE reduce production tff_atom_type -> type_const
-- On NOTAND reduce production tff_atom_type -> type_const
-- On LEFT_IMPLY reduce production tff_atom_type -> type_const
-- On IMPLY reduce production tff_atom_type -> type_const
-- On IF reduce production tff_atom_type -> type_const
-- On EQUIV reduce production tff_atom_type -> type_const
-- On EQUAL reduce production tff_atom_type -> type_const
-- On DOT reduce production tff_atom_type -> type_const
-- On COMMA reduce production tff_atom_type -> type_const
-- On ARROW reduce production tff_atom_type -> type_const
-- On AND_ALSO reduce production tff_atom_type -> type_const
-- On AND reduce production tff_atom_type -> type_const

State 21:
tff_atom_type -> type_const LEFT_PAREN . separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 18
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_type shift to state 22
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 25
-- On separated_nonempty_list(COMMA,tff_type) shift to state 32

State 22:
separated_nonempty_list(COMMA,tff_type) -> tff_type . [ RIGHT_PAREN ]
separated_nonempty_list(COMMA,tff_type) -> tff_type . COMMA separated_nonempty_list(COMMA,tff_type) [ RIGHT_PAREN ]
-- On COMMA shift to state 23
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,tff_type) -> tff_type

State 23:
separated_nonempty_list(COMMA,tff_type) -> tff_type COMMA . separated_nonempty_list(COMMA,tff_type) [ RIGHT_PAREN ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 18
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_type shift to state 22
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 25
-- On separated_nonempty_list(COMMA,tff_type) shift to state 31

State 24:
tff_atom_type -> tff_ty_var . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production tff_atom_type -> tff_ty_var
-- On VLINE reduce production tff_atom_type -> tff_ty_var
-- On STAR reduce production tff_atom_type -> tff_ty_var
-- On RIGHT_PAREN reduce production tff_atom_type -> tff_ty_var
-- On RIGHT_BRACKET reduce production tff_atom_type -> tff_ty_var
-- On NOT_EQUAL reduce production tff_atom_type -> tff_ty_var
-- On NOTVLINE reduce production tff_atom_type -> tff_ty_var
-- On NOTAND reduce production tff_atom_type -> tff_ty_var
-- On LEFT_IMPLY reduce production tff_atom_type -> tff_ty_var
-- On IMPLY reduce production tff_atom_type -> tff_ty_var
-- On IF reduce production tff_atom_type -> tff_ty_var
-- On EQUIV reduce production tff_atom_type -> tff_ty_var
-- On EQUAL reduce production tff_atom_type -> tff_ty_var
-- On DOT reduce production tff_atom_type -> tff_ty_var
-- On COMMA reduce production tff_atom_type -> tff_ty_var
-- On ARROW reduce production tff_atom_type -> tff_ty_var
-- On AND_ALSO reduce production tff_atom_type -> tff_ty_var
-- On AND reduce production tff_atom_type -> tff_ty_var

State 25:
tff_type -> tff_atom_type . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
tff_type -> tff_atom_type . ARROW tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On ARROW shift to state 26
-- On XOR reduce production tff_type -> tff_atom_type
-- On VLINE reduce production tff_type -> tff_atom_type
-- On RIGHT_PAREN reduce production tff_type -> tff_atom_type
-- On RIGHT_BRACKET reduce production tff_type -> tff_atom_type
-- On NOT_EQUAL reduce production tff_type -> tff_atom_type
-- On NOTVLINE reduce production tff_type -> tff_atom_type
-- On NOTAND reduce production tff_type -> tff_atom_type
-- On LEFT_IMPLY reduce production tff_type -> tff_atom_type
-- On IMPLY reduce production tff_type -> tff_atom_type
-- On IF reduce production tff_type -> tff_atom_type
-- On EQUIV reduce production tff_type -> tff_atom_type
-- On EQUAL reduce production tff_type -> tff_atom_type
-- On DOT reduce production tff_type -> tff_atom_type
-- On COMMA reduce production tff_type -> tff_atom_type
-- On AND_ALSO reduce production tff_type -> tff_atom_type
-- On AND reduce production tff_type -> tff_atom_type

State 26:
tff_type -> tff_atom_type ARROW . tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 27
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 30

State 27:
tff_atom_type -> LEFT_PAREN . tff_type RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 18
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_type shift to state 28
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 25

State 28:
tff_atom_type -> LEFT_PAREN tff_type . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 29

State 29:
tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On VLINE reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On STAR reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On RIGHT_PAREN reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On RIGHT_BRACKET reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On NOT_EQUAL reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On NOTVLINE reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On NOTAND reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On LEFT_IMPLY reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On IMPLY reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On IF reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On EQUIV reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On EQUAL reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On DOT reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On COMMA reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On ARROW reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On AND_ALSO reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN
-- On AND reduce production tff_atom_type -> LEFT_PAREN tff_type RIGHT_PAREN

State 30:
tff_type -> tff_atom_type ARROW tff_atom_type . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On VLINE reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On RIGHT_PAREN reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On RIGHT_BRACKET reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On NOT_EQUAL reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On NOTVLINE reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On NOTAND reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On LEFT_IMPLY reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On IMPLY reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On IF reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On EQUIV reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On EQUAL reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On DOT reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On COMMA reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On AND_ALSO reduce production tff_type -> tff_atom_type ARROW tff_atom_type
-- On AND reduce production tff_type -> tff_atom_type ARROW tff_atom_type

State 31:
separated_nonempty_list(COMMA,tff_type) -> tff_type COMMA separated_nonempty_list(COMMA,tff_type) . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,tff_type) -> tff_type COMMA separated_nonempty_list(COMMA,tff_type)

State 32:
tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) . RIGHT_PAREN [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 33

State 33:
tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN . [ XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND ]
-- On XOR reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On VLINE reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On STAR reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On RIGHT_PAREN reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On RIGHT_BRACKET reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On NOT_EQUAL reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On NOTVLINE reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On NOTAND reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On LEFT_IMPLY reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On IMPLY reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On IF reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On EQUIV reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On EQUAL reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On DOT reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On COMMA reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On ARROW reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On AND_ALSO reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN
-- On AND reduce production tff_atom_type -> type_const LEFT_PAREN separated_nonempty_list(COMMA,tff_type) RIGHT_PAREN

State 34:
tff_type -> LEFT_PAREN tff_ty_args . RIGHT_PAREN ARROW tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 35

State 35:
tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN . ARROW tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On ARROW shift to state 36

State 36:
tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW . tff_atom_type [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 27
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_ty_var shift to state 24
-- On tff_atom_type shift to state 37

State 37:
tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On VLINE reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On RIGHT_PAREN reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On RIGHT_BRACKET reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On NOT_EQUAL reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On NOTVLINE reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On NOTAND reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On LEFT_IMPLY reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On IMPLY reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On IF reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On EQUIV reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On EQUAL reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On DOT reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On COMMA reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On AND_ALSO reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type
-- On AND reduce production tff_type -> LEFT_PAREN tff_ty_args RIGHT_PAREN ARROW tff_atom_type

State 38:
tff_ty_args -> tff_atom_type . [ RIGHT_PAREN ]
tff_ty_args -> tff_atom_type . STAR tff_ty_args [ RIGHT_PAREN ]
tff_type -> tff_atom_type . [ RIGHT_PAREN ]
tff_type -> tff_atom_type . ARROW tff_atom_type [ RIGHT_PAREN ]
-- On STAR shift to state 39
-- On ARROW shift to state 26
-- On RIGHT_PAREN reduce production tff_ty_args -> tff_atom_type
-- On RIGHT_PAREN reduce production tff_type -> tff_atom_type
** Conflict on RIGHT_PAREN

State 39:
tff_ty_args -> tff_atom_type STAR . tff_ty_args [ RIGHT_PAREN ]
-- On UPPER_WORD shift to state 15
-- On TYPE_TY shift to state 16
-- On LOWER_WORD shift to state 17
-- On LEFT_PAREN shift to state 27
-- On DOLLAR_WORD shift to state 19
-- On type_const shift to state 20
-- On tff_ty_var shift to state 24
-- On tff_ty_args shift to state 40
-- On tff_atom_type shift to state 41

State 40:
tff_ty_args -> tff_atom_type STAR tff_ty_args . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production tff_ty_args -> tff_atom_type STAR tff_ty_args

State 41:
tff_ty_args -> tff_atom_type . [ RIGHT_PAREN ]
tff_ty_args -> tff_atom_type . STAR tff_ty_args [ RIGHT_PAREN ]
-- On STAR shift to state 39
-- On RIGHT_PAREN reduce production tff_ty_args -> tff_atom_type

State 42:
variable -> UPPER_WORD COLUMN tff_type . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production variable -> UPPER_WORD COLUMN tff_type
-- On VLINE reduce production variable -> UPPER_WORD COLUMN tff_type
-- On RIGHT_PAREN reduce production variable -> UPPER_WORD COLUMN tff_type
-- On RIGHT_BRACKET reduce production variable -> UPPER_WORD COLUMN tff_type
-- On NOT_EQUAL reduce production variable -> UPPER_WORD COLUMN tff_type
-- On NOTVLINE reduce production variable -> UPPER_WORD COLUMN tff_type
-- On NOTAND reduce production variable -> UPPER_WORD COLUMN tff_type
-- On LEFT_IMPLY reduce production variable -> UPPER_WORD COLUMN tff_type
-- On IMPLY reduce production variable -> UPPER_WORD COLUMN tff_type
-- On IF reduce production variable -> UPPER_WORD COLUMN tff_type
-- On EQUIV reduce production variable -> UPPER_WORD COLUMN tff_type
-- On EQUAL reduce production variable -> UPPER_WORD COLUMN tff_type
-- On DOT reduce production variable -> UPPER_WORD COLUMN tff_type
-- On COMMA reduce production variable -> UPPER_WORD COLUMN tff_type
-- On AND_ALSO reduce production variable -> UPPER_WORD COLUMN tff_type
-- On AND reduce production variable -> UPPER_WORD COLUMN tff_type

State 43:
atomic_formula -> TRUE . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_formula -> TRUE
-- On VLINE reduce production atomic_formula -> TRUE
-- On RIGHT_PAREN reduce production atomic_formula -> TRUE
-- On RIGHT_BRACKET reduce production atomic_formula -> TRUE
-- On NOTVLINE reduce production atomic_formula -> TRUE
-- On NOTAND reduce production atomic_formula -> TRUE
-- On LEFT_IMPLY reduce production atomic_formula -> TRUE
-- On IMPLY reduce production atomic_formula -> TRUE
-- On IF reduce production atomic_formula -> TRUE
-- On EQUIV reduce production atomic_formula -> TRUE
-- On DOT reduce production atomic_formula -> TRUE
-- On COMMA reduce production atomic_formula -> TRUE
-- On AND_ALSO reduce production atomic_formula -> TRUE
-- On AND reduce production atomic_formula -> TRUE

State 44:
premise -> THEORY . datalog_atom [ DOT AND_ALSO ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 45

State 45:
premise -> THEORY datalog_atom . [ DOT AND_ALSO ]
-- On DOT reduce production premise -> THEORY datalog_atom
-- On AND_ALSO reduce production premise -> THEORY datalog_atom

State 46:
defined_atom -> REAL . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_atom -> REAL
-- On VLINE reduce production defined_atom -> REAL
-- On RIGHT_PAREN reduce production defined_atom -> REAL
-- On RIGHT_BRACKET reduce production defined_atom -> REAL
-- On NOT_EQUAL reduce production defined_atom -> REAL
-- On NOTVLINE reduce production defined_atom -> REAL
-- On NOTAND reduce production defined_atom -> REAL
-- On LEFT_IMPLY reduce production defined_atom -> REAL
-- On IMPLY reduce production defined_atom -> REAL
-- On IF reduce production defined_atom -> REAL
-- On EQUIV reduce production defined_atom -> REAL
-- On EQUAL reduce production defined_atom -> REAL
-- On DOT reduce production defined_atom -> REAL
-- On COMMA reduce production defined_atom -> REAL
-- On AND_ALSO reduce production defined_atom -> REAL
-- On AND reduce production defined_atom -> REAL

State 47:
defined_atom -> RATIONAL . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_atom -> RATIONAL
-- On VLINE reduce production defined_atom -> RATIONAL
-- On RIGHT_PAREN reduce production defined_atom -> RATIONAL
-- On RIGHT_BRACKET reduce production defined_atom -> RATIONAL
-- On NOT_EQUAL reduce production defined_atom -> RATIONAL
-- On NOTVLINE reduce production defined_atom -> RATIONAL
-- On NOTAND reduce production defined_atom -> RATIONAL
-- On LEFT_IMPLY reduce production defined_atom -> RATIONAL
-- On IMPLY reduce production defined_atom -> RATIONAL
-- On IF reduce production defined_atom -> RATIONAL
-- On EQUIV reduce production defined_atom -> RATIONAL
-- On EQUAL reduce production defined_atom -> RATIONAL
-- On DOT reduce production defined_atom -> RATIONAL
-- On COMMA reduce production defined_atom -> RATIONAL
-- On AND_ALSO reduce production defined_atom -> RATIONAL
-- On AND reduce production defined_atom -> RATIONAL

State 48:
fof_unary_formula -> NOT . fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 129
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 49:
fof_unitary_formula -> LEFT_PAREN . fof_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 111
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 50:
defined_atom -> INTEGER . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_atom -> INTEGER
-- On VLINE reduce production defined_atom -> INTEGER
-- On RIGHT_PAREN reduce production defined_atom -> INTEGER
-- On RIGHT_BRACKET reduce production defined_atom -> INTEGER
-- On NOT_EQUAL reduce production defined_atom -> INTEGER
-- On NOTVLINE reduce production defined_atom -> INTEGER
-- On NOTAND reduce production defined_atom -> INTEGER
-- On LEFT_IMPLY reduce production defined_atom -> INTEGER
-- On IMPLY reduce production defined_atom -> INTEGER
-- On IF reduce production defined_atom -> INTEGER
-- On EQUIV reduce production defined_atom -> INTEGER
-- On EQUAL reduce production defined_atom -> INTEGER
-- On DOT reduce production defined_atom -> INTEGER
-- On COMMA reduce production defined_atom -> INTEGER
-- On AND_ALSO reduce production defined_atom -> INTEGER
-- On AND reduce production defined_atom -> INTEGER

State 51:
fof_quantified_formula -> FORALL . LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On LEFT_BRACKET shift to state 52

State 52:
fof_quantified_formula -> FORALL LEFT_BRACKET . variables RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On variables shift to state 53
-- On variable shift to state 105
-- On separated_nonempty_list(COMMA,variable) shift to state 108

State 53:
fof_quantified_formula -> FORALL LEFT_BRACKET variables . RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On RIGHT_BRACKET shift to state 54

State 54:
fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET . COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On COLUMN shift to state 55

State 55:
fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN . fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 109
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 56:
atomic_formula -> FALSE . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_formula -> FALSE
-- On VLINE reduce production atomic_formula -> FALSE
-- On RIGHT_PAREN reduce production atomic_formula -> FALSE
-- On RIGHT_BRACKET reduce production atomic_formula -> FALSE
-- On NOTVLINE reduce production atomic_formula -> FALSE
-- On NOTAND reduce production atomic_formula -> FALSE
-- On LEFT_IMPLY reduce production atomic_formula -> FALSE
-- On IMPLY reduce production atomic_formula -> FALSE
-- On IF reduce production atomic_formula -> FALSE
-- On EQUIV reduce production atomic_formula -> FALSE
-- On DOT reduce production atomic_formula -> FALSE
-- On COMMA reduce production atomic_formula -> FALSE
-- On AND_ALSO reduce production atomic_formula -> FALSE
-- On AND reduce production atomic_formula -> FALSE

State 57:
fof_quantified_formula -> EXISTS . LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On LEFT_BRACKET shift to state 58

State 58:
fof_quantified_formula -> EXISTS LEFT_BRACKET . variables RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On variables shift to state 59
-- On variable shift to state 105
-- On separated_nonempty_list(COMMA,variable) shift to state 108

State 59:
fof_quantified_formula -> EXISTS LEFT_BRACKET variables . RIGHT_BRACKET COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On RIGHT_BRACKET shift to state 60

State 60:
fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET . COLUMN fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On COLUMN shift to state 61

State 61:
fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN . fof_unitary_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 101
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 62:
atomic_defined_word -> DOLLAR_WORD . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_defined_word -> DOLLAR_WORD
-- On VLINE reduce production atomic_defined_word -> DOLLAR_WORD
-- On RIGHT_PAREN reduce production atomic_defined_word -> DOLLAR_WORD
-- On RIGHT_BRACKET reduce production atomic_defined_word -> DOLLAR_WORD
-- On NOT_EQUAL reduce production atomic_defined_word -> DOLLAR_WORD
-- On NOTVLINE reduce production atomic_defined_word -> DOLLAR_WORD
-- On NOTAND reduce production atomic_defined_word -> DOLLAR_WORD
-- On LEFT_PAREN reduce production atomic_defined_word -> DOLLAR_WORD
-- On LEFT_IMPLY reduce production atomic_defined_word -> DOLLAR_WORD
-- On IMPLY reduce production atomic_defined_word -> DOLLAR_WORD
-- On IF reduce production atomic_defined_word -> DOLLAR_WORD
-- On EQUIV reduce production atomic_defined_word -> DOLLAR_WORD
-- On EQUAL reduce production atomic_defined_word -> DOLLAR_WORD
-- On DOT reduce production atomic_defined_word -> DOLLAR_WORD
-- On COMMA reduce production atomic_defined_word -> DOLLAR_WORD
-- On AND_ALSO reduce production atomic_defined_word -> DOLLAR_WORD
-- On AND reduce production atomic_defined_word -> DOLLAR_WORD

State 63:
atomic_system_word -> DOLLAR_DOLLAR_WORD . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On VLINE reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On RIGHT_PAREN reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On RIGHT_BRACKET reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On NOT_EQUAL reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On NOTVLINE reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On NOTAND reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On LEFT_PAREN reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On LEFT_IMPLY reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On IMPLY reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On IF reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On EQUIV reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On EQUAL reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On DOT reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On COMMA reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On AND_ALSO reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD
-- On AND reduce production atomic_system_word -> DOLLAR_DOLLAR_WORD

State 64:
defined_atom -> DISTINCT_OBJECT . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_atom -> DISTINCT_OBJECT
-- On VLINE reduce production defined_atom -> DISTINCT_OBJECT
-- On RIGHT_PAREN reduce production defined_atom -> DISTINCT_OBJECT
-- On RIGHT_BRACKET reduce production defined_atom -> DISTINCT_OBJECT
-- On NOT_EQUAL reduce production defined_atom -> DISTINCT_OBJECT
-- On NOTVLINE reduce production defined_atom -> DISTINCT_OBJECT
-- On NOTAND reduce production defined_atom -> DISTINCT_OBJECT
-- On LEFT_IMPLY reduce production defined_atom -> DISTINCT_OBJECT
-- On IMPLY reduce production defined_atom -> DISTINCT_OBJECT
-- On IF reduce production defined_atom -> DISTINCT_OBJECT
-- On EQUIV reduce production defined_atom -> DISTINCT_OBJECT
-- On EQUAL reduce production defined_atom -> DISTINCT_OBJECT
-- On DOT reduce production defined_atom -> DISTINCT_OBJECT
-- On COMMA reduce production defined_atom -> DISTINCT_OBJECT
-- On AND_ALSO reduce production defined_atom -> DISTINCT_OBJECT
-- On AND reduce production defined_atom -> DISTINCT_OBJECT

State 65:
term -> variable . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production term -> variable
-- On VLINE reduce production term -> variable
-- On RIGHT_PAREN reduce production term -> variable
-- On RIGHT_BRACKET reduce production term -> variable
-- On NOT_EQUAL reduce production term -> variable
-- On NOTVLINE reduce production term -> variable
-- On NOTAND reduce production term -> variable
-- On LEFT_IMPLY reduce production term -> variable
-- On IMPLY reduce production term -> variable
-- On IF reduce production term -> variable
-- On EQUIV reduce production term -> variable
-- On EQUAL reduce production term -> variable
-- On DOT reduce production term -> variable
-- On COMMA reduce production term -> variable
-- On AND_ALSO reduce production term -> variable
-- On AND reduce production term -> variable

State 66:
atomic_formula -> term . EQUAL term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
atomic_formula -> term . NOT_EQUAL term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On NOT_EQUAL shift to state 67
-- On EQUAL shift to state 98

State 67:
atomic_formula -> term NOT_EQUAL . term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 68
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91

State 68:
atomic_formula -> term NOT_EQUAL term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_formula -> term NOT_EQUAL term
-- On VLINE reduce production atomic_formula -> term NOT_EQUAL term
-- On RIGHT_PAREN reduce production atomic_formula -> term NOT_EQUAL term
-- On RIGHT_BRACKET reduce production atomic_formula -> term NOT_EQUAL term
-- On NOTVLINE reduce production atomic_formula -> term NOT_EQUAL term
-- On NOTAND reduce production atomic_formula -> term NOT_EQUAL term
-- On LEFT_IMPLY reduce production atomic_formula -> term NOT_EQUAL term
-- On IMPLY reduce production atomic_formula -> term NOT_EQUAL term
-- On IF reduce production atomic_formula -> term NOT_EQUAL term
-- On EQUIV reduce production atomic_formula -> term NOT_EQUAL term
-- On DOT reduce production atomic_formula -> term NOT_EQUAL term
-- On COMMA reduce production atomic_formula -> term NOT_EQUAL term
-- On AND_ALSO reduce production atomic_formula -> term NOT_EQUAL term
-- On AND reduce production atomic_formula -> term NOT_EQUAL term

State 69:
function_term -> system_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production function_term -> system_term
-- On VLINE reduce production function_term -> system_term
-- On RIGHT_PAREN reduce production function_term -> system_term
-- On RIGHT_BRACKET reduce production function_term -> system_term
-- On NOT_EQUAL reduce production function_term -> system_term
-- On NOTVLINE reduce production function_term -> system_term
-- On NOTAND reduce production function_term -> system_term
-- On LEFT_IMPLY reduce production function_term -> system_term
-- On IMPLY reduce production function_term -> system_term
-- On IF reduce production function_term -> system_term
-- On EQUIV reduce production function_term -> system_term
-- On EQUAL reduce production function_term -> system_term
-- On DOT reduce production function_term -> system_term
-- On COMMA reduce production function_term -> system_term
-- On AND_ALSO reduce production function_term -> system_term
-- On AND reduce production function_term -> system_term

State 70:
system_constant -> system_functor . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
system_term -> system_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On LEFT_PAREN shift to state 71
-- On XOR reduce production system_constant -> system_functor
-- On VLINE reduce production system_constant -> system_functor
-- On RIGHT_PAREN reduce production system_constant -> system_functor
-- On RIGHT_BRACKET reduce production system_constant -> system_functor
-- On NOT_EQUAL reduce production system_constant -> system_functor
-- On NOTVLINE reduce production system_constant -> system_functor
-- On NOTAND reduce production system_constant -> system_functor
-- On LEFT_IMPLY reduce production system_constant -> system_functor
-- On IMPLY reduce production system_constant -> system_functor
-- On IF reduce production system_constant -> system_functor
-- On EQUIV reduce production system_constant -> system_functor
-- On EQUAL reduce production system_constant -> system_functor
-- On DOT reduce production system_constant -> system_functor
-- On COMMA reduce production system_constant -> system_functor
-- On AND_ALSO reduce production system_constant -> system_functor
-- On AND reduce production system_constant -> system_functor

State 71:
system_term -> system_functor LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 72
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,term) shift to state 79
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91
-- On arguments shift to state 96

State 72:
separated_nonempty_list(COMMA,term) -> term . [ RIGHT_PAREN ]
separated_nonempty_list(COMMA,term) -> term . COMMA separated_nonempty_list(COMMA,term) [ RIGHT_PAREN ]
-- On COMMA shift to state 73
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,term) -> term

State 73:
separated_nonempty_list(COMMA,term) -> term COMMA . separated_nonempty_list(COMMA,term) [ RIGHT_PAREN ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 72
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,term) shift to state 75
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91

State 74:
system_term -> system_constant . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production system_term -> system_constant
-- On VLINE reduce production system_term -> system_constant
-- On RIGHT_PAREN reduce production system_term -> system_constant
-- On RIGHT_BRACKET reduce production system_term -> system_constant
-- On NOT_EQUAL reduce production system_term -> system_constant
-- On NOTVLINE reduce production system_term -> system_constant
-- On NOTAND reduce production system_term -> system_constant
-- On LEFT_IMPLY reduce production system_term -> system_constant
-- On IMPLY reduce production system_term -> system_constant
-- On IF reduce production system_term -> system_constant
-- On EQUIV reduce production system_term -> system_constant
-- On EQUAL reduce production system_term -> system_constant
-- On DOT reduce production system_term -> system_constant
-- On COMMA reduce production system_term -> system_constant
-- On AND_ALSO reduce production system_term -> system_constant
-- On AND reduce production system_term -> system_constant

State 75:
separated_nonempty_list(COMMA,term) -> term COMMA separated_nonempty_list(COMMA,term) . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,term) -> term COMMA separated_nonempty_list(COMMA,term)

State 76:
function_term -> plain_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production function_term -> plain_term
-- On VLINE reduce production function_term -> plain_term
-- On RIGHT_PAREN reduce production function_term -> plain_term
-- On RIGHT_BRACKET reduce production function_term -> plain_term
-- On NOT_EQUAL reduce production function_term -> plain_term
-- On NOTVLINE reduce production function_term -> plain_term
-- On NOTAND reduce production function_term -> plain_term
-- On LEFT_IMPLY reduce production function_term -> plain_term
-- On IMPLY reduce production function_term -> plain_term
-- On IF reduce production function_term -> plain_term
-- On EQUIV reduce production function_term -> plain_term
-- On EQUAL reduce production function_term -> plain_term
-- On DOT reduce production function_term -> plain_term
-- On COMMA reduce production function_term -> plain_term
-- On AND_ALSO reduce production function_term -> plain_term
-- On AND reduce production function_term -> plain_term

State 77:
plain_term -> functor_ . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On LEFT_PAREN shift to state 78

State 78:
plain_term -> functor_ LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 72
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,term) shift to state 79
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91
-- On arguments shift to state 94

State 79:
arguments -> separated_nonempty_list(COMMA,term) . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production arguments -> separated_nonempty_list(COMMA,term)

State 80:
term -> function_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production term -> function_term
-- On VLINE reduce production term -> function_term
-- On RIGHT_PAREN reduce production term -> function_term
-- On RIGHT_BRACKET reduce production term -> function_term
-- On NOTVLINE reduce production term -> function_term
-- On NOTAND reduce production term -> function_term
-- On LEFT_IMPLY reduce production term -> function_term
-- On IMPLY reduce production term -> function_term
-- On IF reduce production term -> function_term
-- On EQUIV reduce production term -> function_term
-- On DOT reduce production term -> function_term
-- On COMMA reduce production term -> function_term
-- On AND_ALSO reduce production term -> function_term
-- On AND reduce production term -> function_term

State 81:
function_term -> defined_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production function_term -> defined_term
-- On VLINE reduce production function_term -> defined_term
-- On RIGHT_PAREN reduce production function_term -> defined_term
-- On RIGHT_BRACKET reduce production function_term -> defined_term
-- On NOT_EQUAL reduce production function_term -> defined_term
-- On NOTVLINE reduce production function_term -> defined_term
-- On NOTAND reduce production function_term -> defined_term
-- On LEFT_IMPLY reduce production function_term -> defined_term
-- On IMPLY reduce production function_term -> defined_term
-- On IF reduce production function_term -> defined_term
-- On EQUIV reduce production function_term -> defined_term
-- On EQUAL reduce production function_term -> defined_term
-- On DOT reduce production function_term -> defined_term
-- On COMMA reduce production function_term -> defined_term
-- On AND_ALSO reduce production function_term -> defined_term
-- On AND reduce production function_term -> defined_term

State 82:
defined_atomic_term -> defined_plain_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_atomic_term -> defined_plain_term
-- On VLINE reduce production defined_atomic_term -> defined_plain_term
-- On RIGHT_PAREN reduce production defined_atomic_term -> defined_plain_term
-- On RIGHT_BRACKET reduce production defined_atomic_term -> defined_plain_term
-- On NOT_EQUAL reduce production defined_atomic_term -> defined_plain_term
-- On NOTVLINE reduce production defined_atomic_term -> defined_plain_term
-- On NOTAND reduce production defined_atomic_term -> defined_plain_term
-- On LEFT_IMPLY reduce production defined_atomic_term -> defined_plain_term
-- On IMPLY reduce production defined_atomic_term -> defined_plain_term
-- On IF reduce production defined_atomic_term -> defined_plain_term
-- On EQUIV reduce production defined_atomic_term -> defined_plain_term
-- On EQUAL reduce production defined_atomic_term -> defined_plain_term
-- On DOT reduce production defined_atomic_term -> defined_plain_term
-- On COMMA reduce production defined_atomic_term -> defined_plain_term
-- On AND_ALSO reduce production defined_atomic_term -> defined_plain_term
-- On AND reduce production defined_atomic_term -> defined_plain_term

State 83:
defined_constant -> defined_functor . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
defined_plain_term -> defined_functor . LEFT_PAREN arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On LEFT_PAREN shift to state 84
-- On XOR reduce production defined_constant -> defined_functor
-- On VLINE reduce production defined_constant -> defined_functor
-- On RIGHT_PAREN reduce production defined_constant -> defined_functor
-- On RIGHT_BRACKET reduce production defined_constant -> defined_functor
-- On NOT_EQUAL reduce production defined_constant -> defined_functor
-- On NOTVLINE reduce production defined_constant -> defined_functor
-- On NOTAND reduce production defined_constant -> defined_functor
-- On LEFT_IMPLY reduce production defined_constant -> defined_functor
-- On IMPLY reduce production defined_constant -> defined_functor
-- On IF reduce production defined_constant -> defined_functor
-- On EQUIV reduce production defined_constant -> defined_functor
-- On EQUAL reduce production defined_constant -> defined_functor
-- On DOT reduce production defined_constant -> defined_functor
-- On COMMA reduce production defined_constant -> defined_functor
-- On AND_ALSO reduce production defined_constant -> defined_functor
-- On AND reduce production defined_constant -> defined_functor

State 84:
defined_plain_term -> defined_functor LEFT_PAREN . arguments RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 72
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,term) shift to state 79
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91
-- On arguments shift to state 92

State 85:
defined_plain_term -> defined_constant . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_plain_term -> defined_constant
-- On VLINE reduce production defined_plain_term -> defined_constant
-- On RIGHT_PAREN reduce production defined_plain_term -> defined_constant
-- On RIGHT_BRACKET reduce production defined_plain_term -> defined_constant
-- On NOT_EQUAL reduce production defined_plain_term -> defined_constant
-- On NOTVLINE reduce production defined_plain_term -> defined_constant
-- On NOTAND reduce production defined_plain_term -> defined_constant
-- On LEFT_IMPLY reduce production defined_plain_term -> defined_constant
-- On IMPLY reduce production defined_plain_term -> defined_constant
-- On IF reduce production defined_plain_term -> defined_constant
-- On EQUIV reduce production defined_plain_term -> defined_constant
-- On EQUAL reduce production defined_plain_term -> defined_constant
-- On DOT reduce production defined_plain_term -> defined_constant
-- On COMMA reduce production defined_plain_term -> defined_constant
-- On AND_ALSO reduce production defined_plain_term -> defined_constant
-- On AND reduce production defined_plain_term -> defined_constant

State 86:
defined_term -> defined_atomic_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_term -> defined_atomic_term
-- On VLINE reduce production defined_term -> defined_atomic_term
-- On RIGHT_PAREN reduce production defined_term -> defined_atomic_term
-- On RIGHT_BRACKET reduce production defined_term -> defined_atomic_term
-- On NOT_EQUAL reduce production defined_term -> defined_atomic_term
-- On NOTVLINE reduce production defined_term -> defined_atomic_term
-- On NOTAND reduce production defined_term -> defined_atomic_term
-- On LEFT_IMPLY reduce production defined_term -> defined_atomic_term
-- On IMPLY reduce production defined_term -> defined_atomic_term
-- On IF reduce production defined_term -> defined_atomic_term
-- On EQUIV reduce production defined_term -> defined_atomic_term
-- On EQUAL reduce production defined_term -> defined_atomic_term
-- On DOT reduce production defined_term -> defined_atomic_term
-- On COMMA reduce production defined_term -> defined_atomic_term
-- On AND_ALSO reduce production defined_term -> defined_atomic_term
-- On AND reduce production defined_term -> defined_atomic_term

State 87:
defined_term -> defined_atom . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_term -> defined_atom
-- On VLINE reduce production defined_term -> defined_atom
-- On RIGHT_PAREN reduce production defined_term -> defined_atom
-- On RIGHT_BRACKET reduce production defined_term -> defined_atom
-- On NOT_EQUAL reduce production defined_term -> defined_atom
-- On NOTVLINE reduce production defined_term -> defined_atom
-- On NOTAND reduce production defined_term -> defined_atom
-- On LEFT_IMPLY reduce production defined_term -> defined_atom
-- On IMPLY reduce production defined_term -> defined_atom
-- On IF reduce production defined_term -> defined_atom
-- On EQUIV reduce production defined_term -> defined_atom
-- On EQUAL reduce production defined_term -> defined_atom
-- On DOT reduce production defined_term -> defined_atom
-- On COMMA reduce production defined_term -> defined_atom
-- On AND_ALSO reduce production defined_term -> defined_atom
-- On AND reduce production defined_term -> defined_atom

State 88:
plain_term -> constant . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production plain_term -> constant
-- On VLINE reduce production plain_term -> constant
-- On RIGHT_PAREN reduce production plain_term -> constant
-- On RIGHT_BRACKET reduce production plain_term -> constant
-- On NOT_EQUAL reduce production plain_term -> constant
-- On NOTVLINE reduce production plain_term -> constant
-- On NOTAND reduce production plain_term -> constant
-- On LEFT_IMPLY reduce production plain_term -> constant
-- On IMPLY reduce production plain_term -> constant
-- On IF reduce production plain_term -> constant
-- On EQUIV reduce production plain_term -> constant
-- On EQUAL reduce production plain_term -> constant
-- On DOT reduce production plain_term -> constant
-- On COMMA reduce production plain_term -> constant
-- On AND_ALSO reduce production plain_term -> constant
-- On AND reduce production plain_term -> constant

State 89:
constant -> atomic_word . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
functor_ -> atomic_word . [ LEFT_PAREN ]
-- On XOR reduce production constant -> atomic_word
-- On VLINE reduce production constant -> atomic_word
-- On RIGHT_PAREN reduce production constant -> atomic_word
-- On RIGHT_BRACKET reduce production constant -> atomic_word
-- On NOT_EQUAL reduce production constant -> atomic_word
-- On NOTVLINE reduce production constant -> atomic_word
-- On NOTAND reduce production constant -> atomic_word
-- On LEFT_PAREN reduce production functor_ -> atomic_word
-- On LEFT_IMPLY reduce production constant -> atomic_word
-- On IMPLY reduce production constant -> atomic_word
-- On IF reduce production constant -> atomic_word
-- On EQUIV reduce production constant -> atomic_word
-- On EQUAL reduce production constant -> atomic_word
-- On DOT reduce production constant -> atomic_word
-- On COMMA reduce production constant -> atomic_word
-- On AND_ALSO reduce production constant -> atomic_word
-- On AND reduce production constant -> atomic_word

State 90:
system_functor -> atomic_system_word . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production system_functor -> atomic_system_word
-- On VLINE reduce production system_functor -> atomic_system_word
-- On RIGHT_PAREN reduce production system_functor -> atomic_system_word
-- On RIGHT_BRACKET reduce production system_functor -> atomic_system_word
-- On NOT_EQUAL reduce production system_functor -> atomic_system_word
-- On NOTVLINE reduce production system_functor -> atomic_system_word
-- On NOTAND reduce production system_functor -> atomic_system_word
-- On LEFT_PAREN reduce production system_functor -> atomic_system_word
-- On LEFT_IMPLY reduce production system_functor -> atomic_system_word
-- On IMPLY reduce production system_functor -> atomic_system_word
-- On IF reduce production system_functor -> atomic_system_word
-- On EQUIV reduce production system_functor -> atomic_system_word
-- On EQUAL reduce production system_functor -> atomic_system_word
-- On DOT reduce production system_functor -> atomic_system_word
-- On COMMA reduce production system_functor -> atomic_system_word
-- On AND_ALSO reduce production system_functor -> atomic_system_word
-- On AND reduce production system_functor -> atomic_system_word

State 91:
constant -> atomic_defined_word . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
defined_functor -> atomic_defined_word . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production constant -> atomic_defined_word
-- On XOR reduce production defined_functor -> atomic_defined_word
-- On VLINE reduce production constant -> atomic_defined_word
-- On VLINE reduce production defined_functor -> atomic_defined_word
-- On RIGHT_PAREN reduce production constant -> atomic_defined_word
-- On RIGHT_PAREN reduce production defined_functor -> atomic_defined_word
-- On RIGHT_BRACKET reduce production constant -> atomic_defined_word
-- On RIGHT_BRACKET reduce production defined_functor -> atomic_defined_word
-- On NOT_EQUAL reduce production constant -> atomic_defined_word
-- On NOT_EQUAL reduce production defined_functor -> atomic_defined_word
-- On NOTVLINE reduce production constant -> atomic_defined_word
-- On NOTVLINE reduce production defined_functor -> atomic_defined_word
-- On NOTAND reduce production constant -> atomic_defined_word
-- On NOTAND reduce production defined_functor -> atomic_defined_word
-- On LEFT_PAREN reduce production defined_functor -> atomic_defined_word
-- On LEFT_IMPLY reduce production constant -> atomic_defined_word
-- On LEFT_IMPLY reduce production defined_functor -> atomic_defined_word
-- On IMPLY reduce production constant -> atomic_defined_word
-- On IMPLY reduce production defined_functor -> atomic_defined_word
-- On IF reduce production constant -> atomic_defined_word
-- On IF reduce production defined_functor -> atomic_defined_word
-- On EQUIV reduce production constant -> atomic_defined_word
-- On EQUIV reduce production defined_functor -> atomic_defined_word
-- On EQUAL reduce production constant -> atomic_defined_word
-- On EQUAL reduce production defined_functor -> atomic_defined_word
-- On DOT reduce production constant -> atomic_defined_word
-- On DOT reduce production defined_functor -> atomic_defined_word
-- On COMMA reduce production constant -> atomic_defined_word
-- On COMMA reduce production defined_functor -> atomic_defined_word
-- On AND_ALSO reduce production constant -> atomic_defined_word
-- On AND_ALSO reduce production defined_functor -> atomic_defined_word
-- On AND reduce production constant -> atomic_defined_word
-- On AND reduce production defined_functor -> atomic_defined_word
** Conflict on XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND

State 92:
defined_plain_term -> defined_functor LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 93

State 93:
defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On VLINE reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_PAREN reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_BRACKET reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOT_EQUAL reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOTVLINE reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOTAND reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On LEFT_IMPLY reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On IMPLY reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On IF reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On EQUIV reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On EQUAL reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On DOT reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On COMMA reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On AND_ALSO reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN
-- On AND reduce production defined_plain_term -> defined_functor LEFT_PAREN arguments RIGHT_PAREN

State 94:
plain_term -> functor_ LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 95

State 95:
plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On VLINE reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_PAREN reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_BRACKET reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On NOT_EQUAL reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On NOTVLINE reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On NOTAND reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On LEFT_IMPLY reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On IMPLY reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On IF reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On EQUIV reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On EQUAL reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On DOT reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On COMMA reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On AND_ALSO reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN
-- On AND reduce production plain_term -> functor_ LEFT_PAREN arguments RIGHT_PAREN

State 96:
system_term -> system_functor LEFT_PAREN arguments . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On RIGHT_PAREN shift to state 97

State 97:
system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND ]
-- On XOR reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On VLINE reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_PAREN reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On RIGHT_BRACKET reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOT_EQUAL reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOTVLINE reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On NOTAND reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On LEFT_IMPLY reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On IMPLY reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On IF reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On EQUIV reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On EQUAL reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On DOT reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On COMMA reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On AND_ALSO reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN
-- On AND reduce production system_term -> system_functor LEFT_PAREN arguments RIGHT_PAREN

State 98:
atomic_formula -> term EQUAL . term [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On LOWER_WORD shift to state 5
-- On INTEGER shift to state 50
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 99
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 80
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_defined_word shift to state 91

State 99:
atomic_formula -> term EQUAL term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production atomic_formula -> term EQUAL term
-- On VLINE reduce production atomic_formula -> term EQUAL term
-- On RIGHT_PAREN reduce production atomic_formula -> term EQUAL term
-- On RIGHT_BRACKET reduce production atomic_formula -> term EQUAL term
-- On NOTVLINE reduce production atomic_formula -> term EQUAL term
-- On NOTAND reduce production atomic_formula -> term EQUAL term
-- On LEFT_IMPLY reduce production atomic_formula -> term EQUAL term
-- On IMPLY reduce production atomic_formula -> term EQUAL term
-- On IF reduce production atomic_formula -> term EQUAL term
-- On EQUIV reduce production atomic_formula -> term EQUAL term
-- On DOT reduce production atomic_formula -> term EQUAL term
-- On COMMA reduce production atomic_formula -> term EQUAL term
-- On AND_ALSO reduce production atomic_formula -> term EQUAL term
-- On AND reduce production atomic_formula -> term EQUAL term

State 100:
atomic_formula -> function_term . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
term -> function_term . [ NOT_EQUAL EQUAL ]
-- On XOR reduce production atomic_formula -> function_term
-- On VLINE reduce production atomic_formula -> function_term
-- On RIGHT_PAREN reduce production atomic_formula -> function_term
-- On RIGHT_BRACKET reduce production atomic_formula -> function_term
-- On NOT_EQUAL reduce production term -> function_term
-- On NOTVLINE reduce production atomic_formula -> function_term
-- On NOTAND reduce production atomic_formula -> function_term
-- On LEFT_IMPLY reduce production atomic_formula -> function_term
-- On IMPLY reduce production atomic_formula -> function_term
-- On IF reduce production atomic_formula -> function_term
-- On EQUIV reduce production atomic_formula -> function_term
-- On EQUAL reduce production term -> function_term
-- On DOT reduce production atomic_formula -> function_term
-- On COMMA reduce production atomic_formula -> function_term
-- On AND_ALSO reduce production atomic_formula -> function_term
-- On AND reduce production atomic_formula -> function_term

State 101:
fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On VLINE reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On RIGHT_PAREN reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On RIGHT_BRACKET reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On NOTVLINE reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On NOTAND reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On LEFT_IMPLY reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On IMPLY reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On IF reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On EQUIV reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On DOT reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On COMMA reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On AND_ALSO reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On AND reduce production fof_quantified_formula -> EXISTS LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula

State 102:
fof_unitary_formula -> fof_unary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_unitary_formula -> fof_unary_formula
-- On VLINE reduce production fof_unitary_formula -> fof_unary_formula
-- On RIGHT_PAREN reduce production fof_unitary_formula -> fof_unary_formula
-- On RIGHT_BRACKET reduce production fof_unitary_formula -> fof_unary_formula
-- On NOTVLINE reduce production fof_unitary_formula -> fof_unary_formula
-- On NOTAND reduce production fof_unitary_formula -> fof_unary_formula
-- On LEFT_IMPLY reduce production fof_unitary_formula -> fof_unary_formula
-- On IMPLY reduce production fof_unitary_formula -> fof_unary_formula
-- On IF reduce production fof_unitary_formula -> fof_unary_formula
-- On EQUIV reduce production fof_unitary_formula -> fof_unary_formula
-- On DOT reduce production fof_unitary_formula -> fof_unary_formula
-- On COMMA reduce production fof_unitary_formula -> fof_unary_formula
-- On AND_ALSO reduce production fof_unitary_formula -> fof_unary_formula
-- On AND reduce production fof_unitary_formula -> fof_unary_formula

State 103:
fof_unitary_formula -> fof_quantified_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_unitary_formula -> fof_quantified_formula
-- On VLINE reduce production fof_unitary_formula -> fof_quantified_formula
-- On RIGHT_PAREN reduce production fof_unitary_formula -> fof_quantified_formula
-- On RIGHT_BRACKET reduce production fof_unitary_formula -> fof_quantified_formula
-- On NOTVLINE reduce production fof_unitary_formula -> fof_quantified_formula
-- On NOTAND reduce production fof_unitary_formula -> fof_quantified_formula
-- On LEFT_IMPLY reduce production fof_unitary_formula -> fof_quantified_formula
-- On IMPLY reduce production fof_unitary_formula -> fof_quantified_formula
-- On IF reduce production fof_unitary_formula -> fof_quantified_formula
-- On EQUIV reduce production fof_unitary_formula -> fof_quantified_formula
-- On DOT reduce production fof_unitary_formula -> fof_quantified_formula
-- On COMMA reduce production fof_unitary_formula -> fof_quantified_formula
-- On AND_ALSO reduce production fof_unitary_formula -> fof_quantified_formula
-- On AND reduce production fof_unitary_formula -> fof_quantified_formula

State 104:
fof_unitary_formula -> atomic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_unitary_formula -> atomic_formula
-- On VLINE reduce production fof_unitary_formula -> atomic_formula
-- On RIGHT_PAREN reduce production fof_unitary_formula -> atomic_formula
-- On RIGHT_BRACKET reduce production fof_unitary_formula -> atomic_formula
-- On NOTVLINE reduce production fof_unitary_formula -> atomic_formula
-- On NOTAND reduce production fof_unitary_formula -> atomic_formula
-- On LEFT_IMPLY reduce production fof_unitary_formula -> atomic_formula
-- On IMPLY reduce production fof_unitary_formula -> atomic_formula
-- On IF reduce production fof_unitary_formula -> atomic_formula
-- On EQUIV reduce production fof_unitary_formula -> atomic_formula
-- On DOT reduce production fof_unitary_formula -> atomic_formula
-- On COMMA reduce production fof_unitary_formula -> atomic_formula
-- On AND_ALSO reduce production fof_unitary_formula -> atomic_formula
-- On AND reduce production fof_unitary_formula -> atomic_formula

State 105:
separated_nonempty_list(COMMA,variable) -> variable . [ RIGHT_BRACKET ]
separated_nonempty_list(COMMA,variable) -> variable . COMMA separated_nonempty_list(COMMA,variable) [ RIGHT_BRACKET ]
-- On COMMA shift to state 106
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,variable) -> variable

State 106:
separated_nonempty_list(COMMA,variable) -> variable COMMA . separated_nonempty_list(COMMA,variable) [ RIGHT_BRACKET ]
-- On UPPER_WORD shift to state 13
-- On variable shift to state 105
-- On separated_nonempty_list(COMMA,variable) shift to state 107

State 107:
separated_nonempty_list(COMMA,variable) -> variable COMMA separated_nonempty_list(COMMA,variable) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,variable) -> variable COMMA separated_nonempty_list(COMMA,variable)

State 108:
variables -> separated_nonempty_list(COMMA,variable) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production variables -> separated_nonempty_list(COMMA,variable)

State 109:
fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On VLINE reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On RIGHT_PAREN reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On RIGHT_BRACKET reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On NOTVLINE reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On NOTAND reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On LEFT_IMPLY reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On IMPLY reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On IF reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On EQUIV reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On DOT reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On COMMA reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On AND_ALSO reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula
-- On AND reduce production fof_quantified_formula -> FORALL LEFT_BRACKET variables RIGHT_BRACKET COLUMN fof_unitary_formula

State 110:
fof_logic_formula -> fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_logic_formula -> fof_unitary_formula
-- On VLINE reduce production fof_logic_formula -> fof_unitary_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_unitary_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_unitary_formula
-- On NOTVLINE reduce production fof_logic_formula -> fof_unitary_formula
-- On NOTAND reduce production fof_logic_formula -> fof_unitary_formula
-- On LEFT_IMPLY reduce production fof_logic_formula -> fof_unitary_formula
-- On IMPLY reduce production fof_logic_formula -> fof_unitary_formula
-- On IF reduce production fof_logic_formula -> fof_unitary_formula
-- On EQUIV reduce production fof_logic_formula -> fof_unitary_formula
-- On DOT reduce production fof_logic_formula -> fof_unitary_formula
-- On COMMA reduce production fof_logic_formula -> fof_unitary_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_unitary_formula
-- On AND reduce production fof_logic_formula -> fof_unitary_formula

State 111:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND ]
fof_unitary_formula -> LEFT_PAREN fof_logic_formula . RIGHT_PAREN [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR shift to state 112
-- On VLINE shift to state 122
-- On RIGHT_PAREN shift to state 128
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On EQUIV shift to state 124
-- On AND shift to state 126

State 112:
fof_logic_formula -> fof_logic_formula XOR . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 113
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 113:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula XOR fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On EQUIV reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula XOR fof_logic_formula

State 114:
fof_logic_formula -> fof_logic_formula NOTVLINE . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 115
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 115:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On NOTAND shift to state 116
-- On XOR reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On LEFT_IMPLY reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On IMPLY reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On EQUIV reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula NOTVLINE fof_logic_formula

State 116:
fof_logic_formula -> fof_logic_formula NOTAND . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 117
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 117:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On NOTVLINE reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On LEFT_IMPLY reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On IMPLY reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On EQUIV reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula NOTAND fof_logic_formula

State 118:
fof_logic_formula -> fof_logic_formula LEFT_IMPLY . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 119
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 119:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On XOR reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On IMPLY reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On EQUIV reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula LEFT_IMPLY fof_logic_formula

State 120:
fof_logic_formula -> fof_logic_formula IMPLY . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 121
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 121:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On XOR reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On EQUIV reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula IMPLY fof_logic_formula

State 122:
fof_logic_formula -> fof_logic_formula VLINE . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 123
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 123:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR shift to state 112
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On EQUIV shift to state 124
-- On AND shift to state 126
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula VLINE fof_logic_formula

State 124:
fof_logic_formula -> fof_logic_formula EQUIV . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 125
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 125:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR shift to state 112
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula EQUIV fof_logic_formula

State 126:
fof_logic_formula -> fof_logic_formula AND . fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 127
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 127:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula AND fof_logic_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR shift to state 112
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On EQUIV shift to state 124
-- On VLINE reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On RIGHT_PAREN reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On RIGHT_BRACKET reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On IF reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On DOT reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On COMMA reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On AND_ALSO reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula
-- On AND reduce production fof_logic_formula -> fof_logic_formula AND fof_logic_formula

State 128:
fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On VLINE reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On RIGHT_PAREN reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On RIGHT_BRACKET reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On NOTVLINE reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On NOTAND reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On LEFT_IMPLY reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On IMPLY reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On IF reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On EQUIV reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On DOT reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On COMMA reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On AND_ALSO reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN
-- On AND reduce production fof_unitary_formula -> LEFT_PAREN fof_logic_formula RIGHT_PAREN

State 129:
fof_unary_formula -> NOT fof_unitary_formula . [ XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND ]
-- On XOR reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On VLINE reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On RIGHT_PAREN reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On RIGHT_BRACKET reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On NOTVLINE reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On NOTAND reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On LEFT_IMPLY reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On IMPLY reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On IF reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On EQUIV reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On DOT reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On COMMA reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On AND_ALSO reduce production fof_unary_formula -> NOT fof_unitary_formula
-- On AND reduce production fof_unary_formula -> NOT fof_unitary_formula

State 130:
fof_sequent -> LEFT_PAREN . fof_sequent RIGHT_PAREN [ RIGHT_PAREN IF DOT AND_ALSO ]
fof_unitary_formula -> LEFT_PAREN . fof_logic_formula RIGHT_PAREN [ XOR VLINE RIGHT_PAREN NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 141
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 111
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 131:
fof_tuple -> LEFT_BRACKET . loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET [ RIGHT_PAREN IF GENTZEN_ARROW DOT AND_ALSO ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,fof_logic_formula) shift to state 132
-- On plain_term shift to state 76
-- On loption(separated_nonempty_list(COMMA,fof_logic_formula)) shift to state 133
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 135
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91
-- On RIGHT_BRACKET reduce production loption(separated_nonempty_list(COMMA,fof_logic_formula)) ->

State 132:
loption(separated_nonempty_list(COMMA,fof_logic_formula)) -> separated_nonempty_list(COMMA,fof_logic_formula) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production loption(separated_nonempty_list(COMMA,fof_logic_formula)) -> separated_nonempty_list(COMMA,fof_logic_formula)

State 133:
fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) . RIGHT_BRACKET [ RIGHT_PAREN IF GENTZEN_ARROW DOT AND_ALSO ]
-- On RIGHT_BRACKET shift to state 134

State 134:
fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET . [ RIGHT_PAREN IF GENTZEN_ARROW DOT AND_ALSO ]
-- On RIGHT_PAREN reduce production fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET
-- On IF reduce production fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET
-- On GENTZEN_ARROW reduce production fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET
-- On DOT reduce production fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET
-- On AND_ALSO reduce production fof_tuple -> LEFT_BRACKET loption(separated_nonempty_list(COMMA,fof_logic_formula)) RIGHT_BRACKET

State 135:
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND ]
separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula . [ RIGHT_BRACKET ]
separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula . COMMA separated_nonempty_list(COMMA,fof_logic_formula) [ RIGHT_BRACKET ]
-- On XOR shift to state 112
-- On VLINE shift to state 122
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On EQUIV shift to state 124
-- On COMMA shift to state 136
-- On AND shift to state 126
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula

State 136:
separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula COMMA . separated_nonempty_list(COMMA,fof_logic_formula) [ RIGHT_BRACKET ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 49
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(COMMA,fof_logic_formula) shift to state 137
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 135
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 137:
separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula COMMA separated_nonempty_list(COMMA,fof_logic_formula) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production separated_nonempty_list(COMMA,fof_logic_formula) -> fof_logic_formula COMMA separated_nonempty_list(COMMA,fof_logic_formula)

State 138:
fof_sequent -> fof_tuple . GENTZEN_ARROW fof_tuple [ RIGHT_PAREN IF DOT AND_ALSO ]
-- On GENTZEN_ARROW shift to state 139

State 139:
fof_sequent -> fof_tuple GENTZEN_ARROW . fof_tuple [ RIGHT_PAREN IF DOT AND_ALSO ]
-- On LEFT_BRACKET shift to state 131
-- On fof_tuple shift to state 140

State 140:
fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple . [ RIGHT_PAREN IF DOT AND_ALSO ]
-- On RIGHT_PAREN reduce production fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple
-- On IF reduce production fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple
-- On DOT reduce production fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple
-- On AND_ALSO reduce production fof_sequent -> fof_tuple GENTZEN_ARROW fof_tuple

State 141:
fof_sequent -> LEFT_PAREN fof_sequent . RIGHT_PAREN [ RIGHT_PAREN IF DOT AND_ALSO ]
-- On RIGHT_PAREN shift to state 142

State 142:
fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN . [ RIGHT_PAREN IF DOT AND_ALSO ]
-- On RIGHT_PAREN reduce production fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN
-- On IF reduce production fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN
-- On DOT reduce production fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN
-- On AND_ALSO reduce production fof_sequent -> LEFT_PAREN fof_sequent RIGHT_PAREN

State 143:
premise -> AXIOM . datalog_atom [ DOT AND_ALSO ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 144

State 144:
premise -> AXIOM datalog_atom . [ DOT AND_ALSO ]
-- On DOT reduce production premise -> AXIOM datalog_atom
-- On AND_ALSO reduce production premise -> AXIOM datalog_atom

State 145:
premises -> separated_nonempty_list(AND_ALSO,premise) . [ DOT ]
-- On DOT reduce production premises -> separated_nonempty_list(AND_ALSO,premise)

State 146:
theory -> THEORY datalog_atom IS premises . DOT [ EOI ]
-- On DOT shift to state 147

State 147:
theory -> THEORY datalog_atom IS premises DOT . [ EOI ]
-- On EOI reduce production theory -> THEORY datalog_atom IS premises DOT

State 148:
separated_nonempty_list(AND_ALSO,premise) -> premise . [ DOT ]
separated_nonempty_list(AND_ALSO,premise) -> premise . AND_ALSO separated_nonempty_list(AND_ALSO,premise) [ DOT ]
-- On AND_ALSO shift to state 149
-- On DOT reduce production separated_nonempty_list(AND_ALSO,premise) -> premise

State 149:
separated_nonempty_list(AND_ALSO,premise) -> premise AND_ALSO . separated_nonempty_list(AND_ALSO,premise) [ DOT ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 150
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 150:
separated_nonempty_list(AND_ALSO,premise) -> premise AND_ALSO separated_nonempty_list(AND_ALSO,premise) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND_ALSO,premise) -> premise AND_ALSO separated_nonempty_list(AND_ALSO,premise)

State 151:
fof_formula -> fof_sequent . [ IF DOT AND_ALSO ]
-- On IF reduce production fof_formula -> fof_sequent
-- On DOT reduce production fof_formula -> fof_sequent
-- On AND_ALSO reduce production fof_formula -> fof_sequent

State 152:
fof_formula -> fof_logic_formula . [ IF DOT AND_ALSO ]
fof_logic_formula -> fof_logic_formula . EQUIV fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . IMPLY fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . LEFT_IMPLY fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . XOR fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTVLINE fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . NOTAND fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . AND fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
fof_logic_formula -> fof_logic_formula . VLINE fof_logic_formula [ XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT AND_ALSO AND ]
-- On XOR shift to state 112
-- On VLINE shift to state 122
-- On NOTVLINE shift to state 114
-- On NOTAND shift to state 116
-- On LEFT_IMPLY shift to state 118
-- On IMPLY shift to state 120
-- On EQUIV shift to state 124
-- On AND shift to state 126
-- On IF reduce production fof_formula -> fof_logic_formula
-- On DOT reduce production fof_formula -> fof_logic_formula
-- On AND_ALSO reduce production fof_formula -> fof_logic_formula

State 153:
premise -> fof_formula . [ DOT AND_ALSO ]
-- On DOT reduce production premise -> fof_formula
-- On AND_ALSO reduce production premise -> fof_formula

State 154:
clause -> RAW . datalog_lit DOT [ EOI ]
clause -> RAW . datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT [ EOI ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On datalog_lit shift to state 155
-- On atomic_word shift to state 162

State 155:
clause -> RAW datalog_lit . DOT [ EOI ]
clause -> RAW datalog_lit . IF separated_nonempty_list(COMMA,datalog_lit) DOT [ EOI ]
-- On IF shift to state 156
-- On DOT shift to state 171

State 156:
clause -> RAW datalog_lit IF . separated_nonempty_list(COMMA,datalog_lit) DOT [ EOI ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,datalog_lit) shift to state 157
-- On datalog_lit shift to state 159
-- On atomic_word shift to state 162

State 157:
clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) . DOT [ EOI ]
-- On DOT shift to state 158

State 158:
clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT . [ EOI ]
-- On EOI reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT

State 159:
separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit . [ DOT ]
separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit . COMMA separated_nonempty_list(COMMA,datalog_lit) [ DOT ]
-- On COMMA shift to state 160
-- On DOT reduce production separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit

State 160:
separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit COMMA . separated_nonempty_list(COMMA,datalog_lit) [ DOT ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,datalog_lit) shift to state 161
-- On datalog_lit shift to state 159
-- On atomic_word shift to state 162

State 161:
separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit COMMA separated_nonempty_list(COMMA,datalog_lit) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(COMMA,datalog_lit) -> datalog_lit COMMA separated_nonempty_list(COMMA,datalog_lit)

State 162:
datalog_lit -> atomic_word . [ IF DOT COMMA ]
datalog_lit -> atomic_word . LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN [ IF DOT COMMA ]
-- On LEFT_PAREN shift to state 163
-- On IF reduce production datalog_lit -> atomic_word
-- On DOT reduce production datalog_lit -> atomic_word
-- On COMMA reduce production datalog_lit -> atomic_word

State 163:
datalog_lit -> atomic_word LEFT_PAREN . separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN [ IF DOT COMMA ]
-- On UPPER_WORD shift to state 164
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,datalog_term) shift to state 165
-- On datalog_term shift to state 167
-- On atomic_word shift to state 170

State 164:
datalog_term -> UPPER_WORD . [ RIGHT_PAREN COMMA ]
-- On RIGHT_PAREN reduce production datalog_term -> UPPER_WORD
-- On COMMA reduce production datalog_term -> UPPER_WORD

State 165:
datalog_lit -> atomic_word LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) . RIGHT_PAREN [ IF DOT COMMA ]
-- On RIGHT_PAREN shift to state 166

State 166:
datalog_lit -> atomic_word LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN . [ IF DOT COMMA ]
-- On IF reduce production datalog_lit -> atomic_word LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN
-- On DOT reduce production datalog_lit -> atomic_word LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN
-- On COMMA reduce production datalog_lit -> atomic_word LEFT_PAREN separated_nonempty_list(COMMA,datalog_term) RIGHT_PAREN

State 167:
separated_nonempty_list(COMMA,datalog_term) -> datalog_term . [ RIGHT_PAREN ]
separated_nonempty_list(COMMA,datalog_term) -> datalog_term . COMMA separated_nonempty_list(COMMA,datalog_term) [ RIGHT_PAREN ]
-- On COMMA shift to state 168
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,datalog_term) -> datalog_term

State 168:
separated_nonempty_list(COMMA,datalog_term) -> datalog_term COMMA . separated_nonempty_list(COMMA,datalog_term) [ RIGHT_PAREN ]
-- On UPPER_WORD shift to state 164
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,datalog_term) shift to state 169
-- On datalog_term shift to state 167
-- On atomic_word shift to state 170

State 169:
separated_nonempty_list(COMMA,datalog_term) -> datalog_term COMMA separated_nonempty_list(COMMA,datalog_term) . [ RIGHT_PAREN ]
-- On RIGHT_PAREN reduce production separated_nonempty_list(COMMA,datalog_term) -> datalog_term COMMA separated_nonempty_list(COMMA,datalog_term)

State 170:
datalog_term -> atomic_word . [ RIGHT_PAREN COMMA ]
-- On RIGHT_PAREN reduce production datalog_term -> atomic_word
-- On COMMA reduce production datalog_term -> atomic_word

State 171:
clause -> RAW datalog_lit DOT . [ EOI ]
-- On EOI reduce production clause -> RAW datalog_lit DOT

State 172:
lemma -> LEMMA . fof_formula IF premises DOT [ EOI ]
lemma -> LEMMA . AXIOM datalog_atom IF premises DOT [ EOI ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 173
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 178
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 173:
lemma -> LEMMA AXIOM . datalog_atom IF premises DOT [ EOI ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 174

State 174:
lemma -> LEMMA AXIOM datalog_atom . IF premises DOT [ EOI ]
-- On IF shift to state 175

State 175:
lemma -> LEMMA AXIOM datalog_atom IF . premises DOT [ EOI ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 176
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 176:
lemma -> LEMMA AXIOM datalog_atom IF premises . DOT [ EOI ]
-- On DOT shift to state 177

State 177:
lemma -> LEMMA AXIOM datalog_atom IF premises DOT . [ EOI ]
-- On EOI reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT

State 178:
lemma -> LEMMA fof_formula . IF premises DOT [ EOI ]
-- On IF shift to state 179

State 179:
lemma -> LEMMA fof_formula IF . premises DOT [ EOI ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 180
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 180:
lemma -> LEMMA fof_formula IF premises . DOT [ EOI ]
-- On DOT shift to state 181

State 181:
lemma -> LEMMA fof_formula IF premises DOT . [ EOI ]
-- On EOI reduce production lemma -> LEMMA fof_formula IF premises DOT

State 182:
include_ -> INCLUDE . atomic_word DOT [ EOI ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On atomic_word shift to state 183

State 183:
include_ -> INCLUDE atomic_word . DOT [ EOI ]
-- On DOT shift to state 184

State 184:
include_ -> INCLUDE atomic_word DOT . [ EOI ]
-- On EOI reduce production include_ -> INCLUDE atomic_word DOT

State 185:
axiom -> AXIOM . datalog_atom IS fof_formula DOT [ EOI ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 186

State 186:
axiom -> AXIOM datalog_atom . IS fof_formula DOT [ EOI ]
-- On IS shift to state 187

State 187:
axiom -> AXIOM datalog_atom IS . fof_formula DOT [ EOI ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 188
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 188:
axiom -> AXIOM datalog_atom IS fof_formula . DOT [ EOI ]
-- On DOT shift to state 189

State 189:
axiom -> AXIOM datalog_atom IS fof_formula DOT . [ EOI ]
-- On EOI reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT

State 190:
statement -> theory . [ EOI ]
-- On EOI reduce production statement -> theory

State 191:
parse_statement -> statement . EOI [ # ]
-- On EOI shift to state 192

State 192:
parse_statement -> statement EOI . [ # ]
-- On # reduce production parse_statement -> statement EOI

State 193:
parse_statement' -> parse_statement . [ # ]
-- On # accept parse_statement

State 194:
statement -> lemma . [ EOI ]
-- On EOI reduce production statement -> lemma

State 195:
statement -> include_ . [ EOI ]
-- On EOI reduce production statement -> include_

State 196:
statement -> clause . [ EOI ]
-- On EOI reduce production statement -> clause

State 197:
statement -> axiom . [ EOI ]
-- On EOI reduce production statement -> axiom

State 198:
parse_statements' -> . parse_statements [ # ]
-- On error shift to state 199
-- On THEORY shift to state 200
-- On RAW shift to state 205
-- On LEMMA shift to state 211
-- On INCLUDE shift to state 221
-- On EOI shift to state 224
-- On AXIOM shift to state 225
-- On theory shift to state 230
-- On statements shift to state 238
-- On statement shift to state 232
-- On parse_statements shift to state 240
-- On lemma shift to state 234
-- On include_ shift to state 235
-- On clause shift to state 236
-- On axiom shift to state 237

State 199:
statements -> error . statements [ EOI ]
-- On error shift to state 199
-- On THEORY shift to state 200
-- On RAW shift to state 205
-- On LEMMA shift to state 211
-- On INCLUDE shift to state 221
-- On EOI shift to state 224
-- On AXIOM shift to state 225
-- On theory shift to state 230
-- On statements shift to state 231
-- On statement shift to state 232
-- On lemma shift to state 234
-- On include_ shift to state 235
-- On clause shift to state 236
-- On axiom shift to state 237

State 200:
theory -> THEORY . datalog_atom IS premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 201

State 201:
theory -> THEORY datalog_atom . IS premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On IS shift to state 202

State 202:
theory -> THEORY datalog_atom IS . premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 203
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 203:
theory -> THEORY datalog_atom IS premises . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 204

State 204:
theory -> THEORY datalog_atom IS premises DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production theory -> THEORY datalog_atom IS premises DOT
-- On THEORY reduce production theory -> THEORY datalog_atom IS premises DOT
-- On RAW reduce production theory -> THEORY datalog_atom IS premises DOT
-- On LEMMA reduce production theory -> THEORY datalog_atom IS premises DOT
-- On INCLUDE reduce production theory -> THEORY datalog_atom IS premises DOT
-- On EOI reduce production theory -> THEORY datalog_atom IS premises DOT
-- On AXIOM reduce production theory -> THEORY datalog_atom IS premises DOT

State 205:
clause -> RAW . datalog_lit DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
clause -> RAW . datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On datalog_lit shift to state 206
-- On atomic_word shift to state 162

State 206:
clause -> RAW datalog_lit . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
clause -> RAW datalog_lit . IF separated_nonempty_list(COMMA,datalog_lit) DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On IF shift to state 207
-- On DOT shift to state 210

State 207:
clause -> RAW datalog_lit IF . separated_nonempty_list(COMMA,datalog_lit) DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On separated_nonempty_list(COMMA,datalog_lit) shift to state 208
-- On datalog_lit shift to state 159
-- On atomic_word shift to state 162

State 208:
clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 209

State 209:
clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On THEORY reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On RAW reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On LEMMA reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On INCLUDE reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On EOI reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT
-- On AXIOM reduce production clause -> RAW datalog_lit IF separated_nonempty_list(COMMA,datalog_lit) DOT

State 210:
clause -> RAW datalog_lit DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production clause -> RAW datalog_lit DOT
-- On THEORY reduce production clause -> RAW datalog_lit DOT
-- On RAW reduce production clause -> RAW datalog_lit DOT
-- On LEMMA reduce production clause -> RAW datalog_lit DOT
-- On INCLUDE reduce production clause -> RAW datalog_lit DOT
-- On EOI reduce production clause -> RAW datalog_lit DOT
-- On AXIOM reduce production clause -> RAW datalog_lit DOT

State 211:
lemma -> LEMMA . fof_formula IF premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
lemma -> LEMMA . AXIOM datalog_atom IF premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 212
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 217
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 212:
lemma -> LEMMA AXIOM . datalog_atom IF premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 213

State 213:
lemma -> LEMMA AXIOM datalog_atom . IF premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On IF shift to state 214

State 214:
lemma -> LEMMA AXIOM datalog_atom IF . premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 215
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 215:
lemma -> LEMMA AXIOM datalog_atom IF premises . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 216

State 216:
lemma -> LEMMA AXIOM datalog_atom IF premises DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On THEORY reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On RAW reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On LEMMA reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On INCLUDE reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On EOI reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT
-- On AXIOM reduce production lemma -> LEMMA AXIOM datalog_atom IF premises DOT

State 217:
lemma -> LEMMA fof_formula . IF premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On IF shift to state 218

State 218:
lemma -> LEMMA fof_formula IF . premises DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On THEORY shift to state 44
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On AXIOM shift to state 143
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On separated_nonempty_list(AND_ALSO,premise) shift to state 145
-- On premises shift to state 219
-- On premise shift to state 148
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 153
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 219:
lemma -> LEMMA fof_formula IF premises . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 220

State 220:
lemma -> LEMMA fof_formula IF premises DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On THEORY reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On RAW reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On LEMMA reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On INCLUDE reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On EOI reduce production lemma -> LEMMA fof_formula IF premises DOT
-- On AXIOM reduce production lemma -> LEMMA fof_formula IF premises DOT

State 221:
include_ -> INCLUDE . atomic_word DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On SINGLE_QUOTED shift to state 4
-- On LOWER_WORD shift to state 5
-- On atomic_word shift to state 222

State 222:
include_ -> INCLUDE atomic_word . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 223

State 223:
include_ -> INCLUDE atomic_word DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production include_ -> INCLUDE atomic_word DOT
-- On THEORY reduce production include_ -> INCLUDE atomic_word DOT
-- On RAW reduce production include_ -> INCLUDE atomic_word DOT
-- On LEMMA reduce production include_ -> INCLUDE atomic_word DOT
-- On INCLUDE reduce production include_ -> INCLUDE atomic_word DOT
-- On EOI reduce production include_ -> INCLUDE atomic_word DOT
-- On AXIOM reduce production include_ -> INCLUDE atomic_word DOT

State 224:
statements -> EOI . [ EOI ]
-- On EOI reduce production statements -> EOI

State 225:
axiom -> AXIOM . datalog_atom IS fof_formula DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On LOWER_WORD shift to state 2
-- On datalog_atom shift to state 226

State 226:
axiom -> AXIOM datalog_atom . IS fof_formula DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On IS shift to state 227

State 227:
axiom -> AXIOM datalog_atom IS . fof_formula DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On UPPER_WORD shift to state 13
-- On TRUE shift to state 43
-- On SINGLE_QUOTED shift to state 4
-- On REAL shift to state 46
-- On RATIONAL shift to state 47
-- On NOT shift to state 48
-- On LOWER_WORD shift to state 5
-- On LEFT_PAREN shift to state 130
-- On LEFT_BRACKET shift to state 131
-- On INTEGER shift to state 50
-- On FORALL shift to state 51
-- On FALSE shift to state 56
-- On EXISTS shift to state 57
-- On DOLLAR_WORD shift to state 62
-- On DOLLAR_DOLLAR_WORD shift to state 63
-- On DISTINCT_OBJECT shift to state 64
-- On variable shift to state 65
-- On term shift to state 66
-- On system_term shift to state 69
-- On system_functor shift to state 70
-- On system_constant shift to state 74
-- On plain_term shift to state 76
-- On functor_ shift to state 77
-- On function_term shift to state 100
-- On fof_unitary_formula shift to state 110
-- On fof_unary_formula shift to state 102
-- On fof_tuple shift to state 138
-- On fof_sequent shift to state 151
-- On fof_quantified_formula shift to state 103
-- On fof_logic_formula shift to state 152
-- On fof_formula shift to state 228
-- On defined_term shift to state 81
-- On defined_plain_term shift to state 82
-- On defined_functor shift to state 83
-- On defined_constant shift to state 85
-- On defined_atomic_term shift to state 86
-- On defined_atom shift to state 87
-- On constant shift to state 88
-- On atomic_word shift to state 89
-- On atomic_system_word shift to state 90
-- On atomic_formula shift to state 104
-- On atomic_defined_word shift to state 91

State 228:
axiom -> AXIOM datalog_atom IS fof_formula . DOT [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On DOT shift to state 229

State 229:
axiom -> AXIOM datalog_atom IS fof_formula DOT . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On THEORY reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On RAW reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On LEMMA reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On INCLUDE reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On EOI reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT
-- On AXIOM reduce production axiom -> AXIOM datalog_atom IS fof_formula DOT

State 230:
statement -> theory . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production statement -> theory
-- On THEORY reduce production statement -> theory
-- On RAW reduce production statement -> theory
-- On LEMMA reduce production statement -> theory
-- On INCLUDE reduce production statement -> theory
-- On EOI reduce production statement -> theory
-- On AXIOM reduce production statement -> theory

State 231:
statements -> error statements . [ EOI ]
-- On EOI reduce production statements -> error statements

State 232:
statements -> statement . statements [ EOI ]
-- On error shift to state 199
-- On THEORY shift to state 200
-- On RAW shift to state 205
-- On LEMMA shift to state 211
-- On INCLUDE shift to state 221
-- On EOI shift to state 224
-- On AXIOM shift to state 225
-- On theory shift to state 230
-- On statements shift to state 233
-- On statement shift to state 232
-- On lemma shift to state 234
-- On include_ shift to state 235
-- On clause shift to state 236
-- On axiom shift to state 237

State 233:
statements -> statement statements . [ EOI ]
-- On EOI reduce production statements -> statement statements

State 234:
statement -> lemma . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production statement -> lemma
-- On THEORY reduce production statement -> lemma
-- On RAW reduce production statement -> lemma
-- On LEMMA reduce production statement -> lemma
-- On INCLUDE reduce production statement -> lemma
-- On EOI reduce production statement -> lemma
-- On AXIOM reduce production statement -> lemma

State 235:
statement -> include_ . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production statement -> include_
-- On THEORY reduce production statement -> include_
-- On RAW reduce production statement -> include_
-- On LEMMA reduce production statement -> include_
-- On INCLUDE reduce production statement -> include_
-- On EOI reduce production statement -> include_
-- On AXIOM reduce production statement -> include_

State 236:
statement -> clause . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production statement -> clause
-- On THEORY reduce production statement -> clause
-- On RAW reduce production statement -> clause
-- On LEMMA reduce production statement -> clause
-- On INCLUDE reduce production statement -> clause
-- On EOI reduce production statement -> clause
-- On AXIOM reduce production statement -> clause

State 237:
statement -> axiom . [ error THEORY RAW LEMMA INCLUDE EOI AXIOM ]
-- On error reduce production statement -> axiom
-- On THEORY reduce production statement -> axiom
-- On RAW reduce production statement -> axiom
-- On LEMMA reduce production statement -> axiom
-- On INCLUDE reduce production statement -> axiom
-- On EOI reduce production statement -> axiom
-- On AXIOM reduce production statement -> axiom

State 238:
parse_statements -> statements . EOI [ # ]
-- On EOI shift to state 239

State 239:
parse_statements -> statements EOI . [ # ]
-- On # reduce production parse_statements -> statements EOI

State 240:
parse_statements' -> parse_statements . [ # ]
-- On # accept parse_statements

