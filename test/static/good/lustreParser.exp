Grammar has 75 nonterminal symbols, among which 1 start symbols.
Grammar has 69 terminal symbols.
Grammar has 188 productions.
nullable(var_decls) = false
nullable(var_decl) = false
nullable(typed_idents) = false
nullable(typed_ident) = false
nullable(type_decl) = false
nullable(tuple_type) = false
nullable(tlist_tail(SEMICOLON,RPAREN,typed_idents)) = false
nullable(tlist_tail(SEMICOLON,RPAREN,const_typed_idents)) = false
nullable(tlist_tail(SEMICOLON,RPAREN,const_clocked_typed_idents)) = false
nullable(tlist_tail(SEMICOLON,RPAREN,clocked_typed_idents)) = false
nullable(tlist_tail(SEMICOLON,RPARAMBRACKET,static_param)) = false
nullable(tlist_tail(SEMICOLON,RPARAMBRACKET,node_call_static_param)) = false
nullable(tlist_tail(SEMICOLON,RCURLYBRACKET,typed_idents)) = false
nullable(tlist_tail(SEMICOLON,RCURLYBRACKET,record_field_assign)) = false
nullable(tlist(LPAREN,SEMICOLON,RPAREN,typed_idents)) = false
nullable(tlist(LPAREN,SEMICOLON,RPAREN,const_clocked_typed_idents)) = false
nullable(tlist(LPAREN,SEMICOLON,RPAREN,clocked_typed_idents)) = false
nullable(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,static_param)) = false
nullable(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,node_call_static_param)) = false
nullable(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,typed_idents)) = false
nullable(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,record_field_assign)) = false
nullable(struct_item_list) = false
nullable(struct_item) = false
nullable(static_params) = false
nullable(static_param) = false
nullable(separated_nonempty_list(COMMA,struct_item)) = false
nullable(separated_nonempty_list(COMMA,lustre_type)) = false
nullable(separated_nonempty_list(COMMA,ident)) = false
nullable(separated_nonempty_list(COMMA,expr)) = false
nullable(separated_nonempty_list(COMMA,array_slice)) = false
nullable(record_type) = false
nullable(record_field_assign) = false
nullable(option(node_sep)) = true
nullable(option(STRUCT)) = true
nullable(option(SEMICOLON)) = true
nullable(one_index) = false
nullable(nonempty_list(var_decl)) = false
nullable(nonempty_list(one_index)) = false
nullable(nonempty_list(const_decl_body)) = false
nullable(node_sep) = false
nullable(node_param_inst) = false
nullable(node_local_decl) = false
nullable(node_equation) = false
nullable(node_decl) = false
nullable(node_call_static_param) = false
nullable(node_call) = false
nullable(main) = false
nullable(lustre_type_list) = false
nullable(lustre_type) = false
nullable(loption(static_params)) = true
nullable(loption(separated_nonempty_list(COMMA,expr))) = true
nullable(list(node_local_decl)) = true
nullable(list(node_equation)) = true
nullable(list(decl)) = true
nullable(list(contract_clause)) = true
nullable(left_side) = false
nullable(ident_list) = false
nullable(ident) = false
nullable(func_decl) = false
nullable(expr_list) = false
nullable(expr) = false
nullable(enum_type) = false
nullable(decl) = false
nullable(contract_clause) = false
nullable(contract) = true
nullable(const_typed_idents) = false
nullable(const_decl_body) = false
nullable(const_decl) = false
nullable(const_clocked_typed_idents) = false
nullable(clocked_typed_idents) = false
nullable(clock_expr) = false
nullable(boption(CONST)) = true
nullable(array_type) = false
nullable(array_slice_list) = false
nullable(array_slice) = false
first(var_decls) = VAR
first(var_decl) = SYM LPAREN
first(typed_idents) = SYM
first(typed_ident) = SYM
first(type_decl) = TYPE
first(tuple_type) = LSQBRACKET
first(tlist_tail(SEMICOLON,RPAREN,typed_idents)) = SYM
first(tlist_tail(SEMICOLON,RPAREN,const_typed_idents)) = SYM CONST
first(tlist_tail(SEMICOLON,RPAREN,const_clocked_typed_idents)) = SYM LPAREN CONST
first(tlist_tail(SEMICOLON,RPAREN,clocked_typed_idents)) = SYM LPAREN
first(tlist_tail(SEMICOLON,RPARAMBRACKET,static_param)) = TYPE
first(tlist_tail(SEMICOLON,RPARAMBRACKET,node_call_static_param)) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(tlist_tail(SEMICOLON,RCURLYBRACKET,typed_idents)) = SYM
first(tlist_tail(SEMICOLON,RCURLYBRACKET,record_field_assign)) = SYM
first(tlist(LPAREN,SEMICOLON,RPAREN,typed_idents)) = LPAREN
first(tlist(LPAREN,SEMICOLON,RPAREN,const_clocked_typed_idents)) = LPAREN
first(tlist(LPAREN,SEMICOLON,RPAREN,clocked_typed_idents)) = LPAREN
first(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,static_param)) = LPARAMBRACKET
first(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,node_call_static_param)) = LPARAMBRACKET
first(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,typed_idents)) = LCURLYBRACKET
first(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,record_field_assign)) = LCURLYBRACKET
first(struct_item_list) = SYM
first(struct_item) = SYM
first(static_params) = LPARAMBRACKET
first(static_param) = TYPE
first(separated_nonempty_list(COMMA,struct_item)) = SYM
first(separated_nonempty_list(COMMA,lustre_type)) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(separated_nonempty_list(COMMA,ident)) = SYM
first(separated_nonempty_list(COMMA,expr)) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(separated_nonempty_list(COMMA,array_slice)) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(record_type) = STRUCT LCURLYBRACKET
first(record_field_assign) = SYM
first(option(node_sep)) = SEMICOLON DOT
first(option(STRUCT)) = STRUCT
first(option(SEMICOLON)) = SEMICOLON
first(one_index) = LSQBRACKET DOT
first(nonempty_list(var_decl)) = SYM LPAREN
first(nonempty_list(one_index)) = LSQBRACKET DOT
first(nonempty_list(const_decl_body)) = SYM
first(node_sep) = SEMICOLON DOT
first(node_param_inst) = NODE
first(node_local_decl) = VAR CONST
first(node_equation) = SYM PROPERTY MAIN LPAREN ASSERT
first(node_decl) = NODE
first(node_call_static_param) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(node_call) = SYM
first(main) = TYPE NODE FUNCTION EOF CONST
first(lustre_type_list) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(lustre_type) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(loption(static_params)) = LPARAMBRACKET
first(loption(separated_nonempty_list(COMMA,expr))) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(list(node_local_decl)) = VAR CONST
first(list(node_equation)) = SYM PROPERTY MAIN LPAREN ASSERT
first(list(decl)) = TYPE NODE FUNCTION CONST
first(list(contract_clause)) = REQUIRES ENSURES
first(left_side) = SYM LPAREN
first(ident_list) = SYM
first(ident) = SYM
first(func_decl) = FUNCTION
first(expr_list) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(expr) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(enum_type) = ENUM
first(decl) = TYPE NODE FUNCTION CONST
first(contract_clause) = REQUIRES ENSURES
first(contract) = REQUIRES ENSURES
first(const_typed_idents) = SYM CONST
first(const_decl_body) = SYM
first(const_decl) = CONST
first(const_clocked_typed_idents) = SYM LPAREN CONST
first(clocked_typed_idents) = SYM LPAREN
first(clock_expr) = TRUE SYM NOT
first(boption(CONST)) = CONST
first(array_type) = SYM SUBRANGE REAL LSQBRACKET INT ENUM BOOL
first(array_slice_list) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
first(array_slice) = WITH TRUE SYM REAL PRE NUMERAL NOT MINUS LSQBRACKET LPAREN INT IF HASH FBY FALSE DECIMAL CURRENT CONDACT
minimal(var_decls) = (* 5 *) VAR SYM COLON BOOL SEMICOLON
minimal(var_decl) = (* 4 *) SYM COLON BOOL SEMICOLON
minimal(typed_idents) = (* 3 *) SYM COLON BOOL
minimal(typed_ident) = (* 3 *) SYM COLON BOOL
minimal(type_decl) = (* 3 *) TYPE SYM SEMICOLON
minimal(tuple_type) = (* 3 *) LSQBRACKET BOOL RSQBRACKET
minimal(tlist_tail(SEMICOLON,RPAREN,typed_idents)) = (* 4 *) SYM COLON BOOL RPAREN
minimal(tlist_tail(SEMICOLON,RPAREN,const_typed_idents)) = (* 4 *) SYM COLON BOOL RPAREN
minimal(tlist_tail(SEMICOLON,RPAREN,const_clocked_typed_idents)) = (* 4 *) SYM COLON BOOL RPAREN
minimal(tlist_tail(SEMICOLON,RPAREN,clocked_typed_idents)) = (* 4 *) SYM COLON BOOL RPAREN
minimal(tlist_tail(SEMICOLON,RPARAMBRACKET,static_param)) = (* 3 *) TYPE SYM RPARAMBRACKET
minimal(tlist_tail(SEMICOLON,RPARAMBRACKET,node_call_static_param)) = (* 2 *) BOOL RPARAMBRACKET
minimal(tlist_tail(SEMICOLON,RCURLYBRACKET,typed_idents)) = (* 4 *) SYM COLON BOOL RCURLYBRACKET
minimal(tlist_tail(SEMICOLON,RCURLYBRACKET,record_field_assign)) = (* 4 *) SYM EQUALS SYM RCURLYBRACKET
minimal(tlist(LPAREN,SEMICOLON,RPAREN,typed_idents)) = (* 2 *) LPAREN RPAREN
minimal(tlist(LPAREN,SEMICOLON,RPAREN,const_clocked_typed_idents)) = (* 2 *) LPAREN RPAREN
minimal(tlist(LPAREN,SEMICOLON,RPAREN,clocked_typed_idents)) = (* 2 *) LPAREN RPAREN
minimal(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,static_param)) = (* 2 *) LPARAMBRACKET RPARAMBRACKET
minimal(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,node_call_static_param)) = (* 2 *) LPARAMBRACKET RPARAMBRACKET
minimal(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,typed_idents)) = (* 2 *) LCURLYBRACKET RCURLYBRACKET
minimal(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,record_field_assign)) = (* 2 *) LCURLYBRACKET RCURLYBRACKET
minimal(struct_item_list) = (* 1 *) SYM
minimal(struct_item) = (* 1 *) SYM
minimal(static_params) = (* 2 *) LPARAMBRACKET RPARAMBRACKET
minimal(static_param) = (* 2 *) TYPE SYM
minimal(separated_nonempty_list(COMMA,struct_item)) = (* 1 *) SYM
minimal(separated_nonempty_list(COMMA,lustre_type)) = (* 1 *) BOOL
minimal(separated_nonempty_list(COMMA,ident)) = (* 1 *) SYM
minimal(separated_nonempty_list(COMMA,expr)) = (* 1 *) SYM
minimal(separated_nonempty_list(COMMA,array_slice)) = (* 3 *) SYM DOTDOT SYM
minimal(record_type) = (* 2 *) LCURLYBRACKET RCURLYBRACKET
minimal(record_field_assign) = (* 3 *) SYM EQUALS SYM
minimal(option(node_sep)) = (* 0 *)
minimal(option(STRUCT)) = (* 0 *)
minimal(option(SEMICOLON)) = (* 0 *)
minimal(one_index) = (* 2 *) DOT SYM
minimal(nonempty_list(var_decl)) = (* 4 *) SYM COLON BOOL SEMICOLON
minimal(nonempty_list(one_index)) = (* 2 *) DOT SYM
minimal(nonempty_list(const_decl_body)) = (* 4 *) SYM COLON BOOL SEMICOLON
minimal(node_sep) = (* 1 *) DOT
minimal(node_param_inst) = (* 7 *) NODE SYM EQUALS SYM LPARAMBRACKET RPARAMBRACKET SEMICOLON
minimal(node_local_decl) = (* 5 *) CONST SYM COLON BOOL SEMICOLON
minimal(node_equation) = (* 1 *) MAIN
minimal(node_decl) = (* 10 *) NODE SYM LPAREN RPAREN RETURNS LPAREN RPAREN SEMICOLON LET TEL
minimal(node_call_static_param) = (* 1 *) BOOL
minimal(node_call) = (* 3 *) SYM LPAREN RPAREN
minimal(main) = (* 1 *) EOF
minimal(lustre_type_list) = (* 1 *) BOOL
minimal(lustre_type) = (* 1 *) BOOL
minimal(loption(static_params)) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,expr))) = (* 0 *)
minimal(list(node_local_decl)) = (* 0 *)
minimal(list(node_equation)) = (* 0 *)
minimal(list(decl)) = (* 0 *)
minimal(list(contract_clause)) = (* 0 *)
minimal(left_side) = (* 1 *) SYM
minimal(ident_list) = (* 1 *) SYM
minimal(ident) = (* 1 *) SYM
minimal(func_decl) = (* 8 *) FUNCTION SYM LPAREN RPAREN RETURNS LPAREN RPAREN SEMICOLON
minimal(expr_list) = (* 1 *) SYM
minimal(expr) = (* 1 *) SYM
minimal(enum_type) = (* 4 *) ENUM LCURLYBRACKET SYM RCURLYBRACKET
minimal(decl) = (* 3 *) TYPE SYM SEMICOLON
minimal(contract_clause) = (* 3 *) REQUIRES SYM SEMICOLON
minimal(contract) = (* 0 *)
minimal(const_typed_idents) = (* 3 *) SYM COLON BOOL
minimal(const_decl_body) = (* 4 *) SYM COLON BOOL SEMICOLON
minimal(const_decl) = (* 5 *) CONST SYM COLON BOOL SEMICOLON
minimal(const_clocked_typed_idents) = (* 3 *) SYM COLON BOOL
minimal(clocked_typed_idents) = (* 3 *) SYM COLON BOOL
minimal(clock_expr) = (* 1 *) SYM
minimal(boption(CONST)) = (* 0 *)
minimal(array_type) = (* 3 *) BOOL CARET SYM
minimal(array_slice_list) = (* 3 *) SYM DOTDOT SYM
minimal(array_slice) = (* 3 *) SYM DOTDOT SYM
follow(var_decls) = VAR LET CONST
follow(var_decl) = VAR SYM LPAREN LET CONST
follow(typed_idents) = WHEN SEMICOLON RPAREN RCURLYBRACKET
follow(typed_ident) = EQUALS
follow(type_decl) = TYPE NODE FUNCTION EOF CONST
follow(tuple_type) = WHEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET EQUALS COMMA CARET
follow(tlist_tail(SEMICOLON,RPAREN,typed_idents)) = WHEN SEMICOLON RETURNS
follow(tlist_tail(SEMICOLON,RPAREN,const_typed_idents)) = WHEN
follow(tlist_tail(SEMICOLON,RPAREN,const_clocked_typed_idents)) = RETURNS
follow(tlist_tail(SEMICOLON,RPAREN,clocked_typed_idents)) = SEMICOLON
follow(tlist_tail(SEMICOLON,RPARAMBRACKET,static_param)) = LPAREN
follow(tlist_tail(SEMICOLON,RPARAMBRACKET,node_call_static_param)) = SEMICOLON LPAREN
follow(tlist_tail(SEMICOLON,RCURLYBRACKET,typed_idents)) = SEMICOLON
follow(tlist_tail(SEMICOLON,RCURLYBRACKET,record_field_assign)) = XOR WHEN THEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET PLUS PIPE OR NEQ MULT MOD MINUS LTE LT INTDIV IMPL GTE GT EQUALS ELSE DOTDOT DIV COMMA CARET ARROW AND
follow(tlist(LPAREN,SEMICOLON,RPAREN,typed_idents)) = SEMICOLON RETURNS
follow(tlist(LPAREN,SEMICOLON,RPAREN,const_clocked_typed_idents)) = RETURNS
follow(tlist(LPAREN,SEMICOLON,RPAREN,clocked_typed_idents)) = SEMICOLON
follow(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,static_param)) = LPAREN
follow(tlist(LPARAMBRACKET,SEMICOLON,RPARAMBRACKET,node_call_static_param)) = SEMICOLON LPAREN
follow(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,typed_idents)) = SEMICOLON
follow(tlist(LCURLYBRACKET,SEMICOLON,RCURLYBRACKET,record_field_assign)) = XOR WHEN THEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET PLUS PIPE OR NEQ MULT MOD MINUS LTE LT INTDIV IMPL GTE GT EQUALS ELSE DOTDOT DIV COMMA CARET ARROW AND
follow(struct_item_list) = RPAREN EQUALS
follow(struct_item) = RPAREN EQUALS COMMA
follow(static_params) = LPAREN
follow(static_param) = SEMICOLON RPARAMBRACKET
follow(separated_nonempty_list(COMMA,struct_item)) = RPAREN EQUALS
follow(separated_nonempty_list(COMMA,lustre_type)) = RSQBRACKET
follow(separated_nonempty_list(COMMA,ident)) = SEMICOLON RCURLYBRACKET EQUALS COLON
follow(separated_nonempty_list(COMMA,expr)) = RSQBRACKET RPAREN
follow(separated_nonempty_list(COMMA,array_slice)) = RSQBRACKET
follow(record_type) = SEMICOLON
follow(record_field_assign) = SEMICOLON RCURLYBRACKET
follow(option(node_sep)) = TYPE NODE FUNCTION EOF CONST
follow(option(STRUCT)) = LCURLYBRACKET
follow(option(SEMICOLON)) = RPAREN RPARAMBRACKET RCURLYBRACKET
follow(one_index) = RPAREN LSQBRACKET EQUALS DOT COMMA
follow(nonempty_list(var_decl)) = VAR LET CONST
follow(nonempty_list(one_index)) = RPAREN EQUALS COMMA
follow(nonempty_list(const_decl_body)) = VAR TYPE NODE LET FUNCTION EOF CONST
follow(node_sep) = TYPE NODE FUNCTION EOF CONST
follow(node_param_inst) = TYPE NODE FUNCTION EOF CONST
follow(node_local_decl) = VAR LET CONST
follow(node_equation) = TEL SYM PROPERTY MAIN LPAREN ASSERT
follow(node_decl) = TYPE NODE FUNCTION EOF CONST
follow(node_call_static_param) = SEMICOLON RPARAMBRACKET
follow(node_call) = XOR WHEN THEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET PLUS PIPE OR NEQ MULT MOD MINUS LTE LT INTDIV IMPL GTE GT EQUALS ELSE DOTDOT DIV COMMA CARET ARROW AND
follow(main) = #
follow(lustre_type_list) = RSQBRACKET
follow(lustre_type) = WHEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET EQUALS COMMA CARET
follow(loption(static_params)) = LPAREN
follow(loption(separated_nonempty_list(COMMA,expr))) = RPAREN
follow(list(node_local_decl)) = LET
follow(list(node_equation)) = TEL
follow(list(decl)) = EOF
follow(list(contract_clause)) = VAR LET CONST
follow(left_side) = EQUALS
follow(ident_list) = SEMICOLON RCURLYBRACKET EQUALS COLON
follow(ident) = XOR WHEN THEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET PLUS PIPE OR NEQ MULT MOD MINUS LTE LT LSQBRACKET LPAREN LPARAMBRACKET LCURLYBRACKET INTDIV IMPL GTE GT EQUALS ELSE DOTDOT DOT DIV COMMA COLON CARET ARROW AND
follow(func_decl) = TYPE NODE FUNCTION EOF CONST
follow(expr_list) = RSQBRACKET RPAREN
follow(expr) = XOR WHEN THEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET PLUS PIPE OR NEQ MULT MOD MINUS LTE LT INTDIV IMPL GTE GT EQUALS ELSE DOTDOT DIV COMMA CARET ARROW AND
follow(enum_type) = WHEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET EQUALS COMMA CARET
follow(decl) = TYPE NODE FUNCTION EOF CONST
follow(contract_clause) = VAR REQUIRES LET ENSURES CONST
follow(contract) = VAR LET CONST
follow(const_typed_idents) = WHEN SEMICOLON RPAREN
follow(const_decl_body) = VAR TYPE SYM NODE LET FUNCTION EOF CONST
follow(const_decl) = VAR TYPE NODE LET FUNCTION EOF CONST
follow(const_clocked_typed_idents) = SEMICOLON RPAREN
follow(clocked_typed_idents) = SEMICOLON RPAREN
follow(clock_expr) = SEMICOLON RPAREN
follow(boption(CONST)) = SYM
follow(array_type) = WHEN SEMICOLON RSQBRACKET RPAREN RPARAMBRACKET RCURLYBRACKET EQUALS COMMA CARET
follow(array_slice_list) = RSQBRACKET
follow(array_slice) = RSQBRACKET COMMA
Built an LR(0) automaton with 388 states.
The grammar is not SLR(1) -- 29 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 388 states.
563 shift/reduce conflicts were silently solved.
135 out of 388 states have a default reduction.
132 out of 388 states are represented.
53 out of 147 symbols keep track of their start position.
2 out of 147 symbols keep track of their end position.
116 out of 189 productions exploit shiftreduce optimization.
0 out of 388 states can peek at an error.
1046 functions before inlining, 128 functions after inlining.
