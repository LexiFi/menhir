State 0:
## Known stack suffix:
##
## LR(1) items:
main' -> . main [ # ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 358
-- On nxtoplevel shift to state 360
-- On main shift to state 362
## Reductions:
-- On EOI reduce production sxblock ->

State 1:
## Known stack suffix:
## VARINSTR
## LR(1) items:
sxbot -> VARINSTR . END [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On END shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## VARINSTR END
## LR(1) items:
sxbot -> VARINSTR END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> VARINSTR END
-- On SPACE reduce production sxbot -> VARINSTR END
-- On SEP reduce production sxbot -> VARINSTR END
-- On EOI reduce production sxbot -> VARINSTR END
-- On EGRP reduce production sxbot -> VARINSTR END
-- On CTRLSEQ reduce production sxbot -> VARINSTR END
-- On CLOSESTR reduce production sxbot -> VARINSTR END
-- On CLOSEQT reduce production sxbot -> VARINSTR END
-- On CHAR reduce production sxbot -> VARINSTR END
-- On BREAK reduce production sxbot -> VARINSTR END

State 3:
## Known stack suffix:
## SPACE
## LR(1) items:
sxbot -> SPACE . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> SPACE
-- On SPACE reduce production sxbot -> SPACE
-- On SEP reduce production sxbot -> SPACE
-- On EOI reduce production sxbot -> SPACE
-- On EGRP reduce production sxbot -> SPACE
-- On CTRLSEQ reduce production sxbot -> SPACE
-- On CLOSESTR reduce production sxbot -> SPACE
-- On CLOSEQT reduce production sxbot -> SPACE
-- On CHAR reduce production sxbot -> SPACE
-- On BREAK reduce production sxbot -> SPACE

State 4:
## Known stack suffix:
## MUTUAL
## LR(1) items:
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## MUTUAL LET
## LR(1) items:
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 6
-- On CTRLSEQ shift to state 350
## Reductions:

State 6:
## Known stack suffix:
## MUTUAL LET VAR
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 9
## Reductions:
-- On DEFEQ reduce production argvar ->

State 7:
## Known stack suffix:
## VAR
## LR(1) items:
argvar -> VAR . argvar [ DEFEQ ARROW ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 8
## Reductions:
-- On DEFEQ reduce production argvar ->
-- On ARROW reduce production argvar ->

State 8:
## Known stack suffix:
## VAR argvar
## LR(1) items:
argvar -> VAR argvar . [ DEFEQ ARROW ]
## Transitions:
## Reductions:
-- On DEFEQ reduce production argvar -> VAR argvar
-- On ARROW reduce production argvar -> VAR argvar

State 9:
## Known stack suffix:
## MUTUAL LET VAR argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 300
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 11:
## Known stack suffix:
## WHILE
## LR(1) items:
nxwhl -> WHILE . nxlet DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . nxlet DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 12
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 296
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 12:
## Known stack suffix:
## WHILE error
## LR(1) items:
nxwhl -> WHILE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxwhl -> WHILE error
-- On RPAREN reduce production nxwhl -> WHILE error
-- On OVERWRITEGLOBALHASH reduce production nxwhl -> WHILE error
-- On MUTUAL reduce production nxwhl -> WHILE error
-- On LISTPUNCT reduce production nxwhl -> WHILE error
-- On LETMUTABLE reduce production nxwhl -> WHILE error
-- On LETAND reduce production nxwhl -> WHILE error
-- On LET reduce production nxwhl -> WHILE error
-- On IN reduce production nxwhl -> WHILE error
-- On EOI reduce production nxwhl -> WHILE error
-- On ENDMUTUAL reduce production nxwhl -> WHILE error
-- On ELSE reduce production nxwhl -> WHILE error
-- On ELIST reduce production nxwhl -> WHILE error
-- On DO reduce production nxwhl -> WHILE error
-- On CLOSENUM reduce production nxwhl -> WHILE error

State 13:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxlambda -> VAR . OVERWRITEEQ nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEEQ shift to state 14
## Reductions:
-- On VAR reduce production nxbot -> VAR
-- On UNITVALUE reduce production nxbot -> VAR
-- On TRUE reduce production nxbot -> VAR
-- On TIMES reduce production nxbot -> VAR
-- On THEN reduce production nxbot -> VAR
-- On RPAREN reduce production nxbot -> VAR
-- On PLUS reduce production nxbot -> VAR
-- On OVERWRITEGLOBALHASH reduce production nxbot -> VAR
-- On OPENSTR reduce production nxbot -> VAR
-- On OPENQT reduce production nxbot -> VAR
-- On NUMCONST reduce production nxbot -> VAR
-- On NEQ reduce production nxbot -> VAR
-- On MUTUAL reduce production nxbot -> VAR
-- On MOD reduce production nxbot -> VAR
-- On MINUS reduce production nxbot -> VAR
-- On LT reduce production nxbot -> VAR
-- On LPAREN reduce production nxbot -> VAR
-- On LOR reduce production nxbot -> VAR
-- On LISTPUNCT reduce production nxbot -> VAR
-- On LETMUTABLE reduce production nxbot -> VAR
-- On LETAND reduce production nxbot -> VAR
-- On LET reduce production nxbot -> VAR
-- On LEQ reduce production nxbot -> VAR
-- On LAND reduce production nxbot -> VAR
-- On IN reduce production nxbot -> VAR
-- On GT reduce production nxbot -> VAR
-- On GEQ reduce production nxbot -> VAR
-- On FINISH reduce production nxbot -> VAR
-- On FALSE reduce production nxbot -> VAR
-- On EQ reduce production nxbot -> VAR
-- On EOI reduce production nxbot -> VAR
-- On ENDMUTUAL reduce production nxbot -> VAR
-- On ELSE reduce production nxbot -> VAR
-- On ELIST reduce production nxbot -> VAR
-- On DO reduce production nxbot -> VAR
-- On DIVIDES reduce production nxbot -> VAR
-- On CONS reduce production nxbot -> VAR
-- On CONCAT reduce production nxbot -> VAR
-- On CLOSENUM reduce production nxbot -> VAR
-- On BLIST reduce production nxbot -> VAR
-- On BEFORE reduce production nxbot -> VAR

State 14:
## Known stack suffix:
## VAR OVERWRITEEQ
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 295
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 15:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> VAR
-- On UNITVALUE reduce production nxbot -> VAR
-- On TRUE reduce production nxbot -> VAR
-- On TIMES reduce production nxbot -> VAR
-- On THEN reduce production nxbot -> VAR
-- On RPAREN reduce production nxbot -> VAR
-- On PLUS reduce production nxbot -> VAR
-- On OVERWRITEGLOBALHASH reduce production nxbot -> VAR
-- On OPENSTR reduce production nxbot -> VAR
-- On OPENQT reduce production nxbot -> VAR
-- On NUMCONST reduce production nxbot -> VAR
-- On NEQ reduce production nxbot -> VAR
-- On MUTUAL reduce production nxbot -> VAR
-- On MOD reduce production nxbot -> VAR
-- On MINUS reduce production nxbot -> VAR
-- On LT reduce production nxbot -> VAR
-- On LPAREN reduce production nxbot -> VAR
-- On LOR reduce production nxbot -> VAR
-- On LISTPUNCT reduce production nxbot -> VAR
-- On LETMUTABLE reduce production nxbot -> VAR
-- On LETAND reduce production nxbot -> VAR
-- On LET reduce production nxbot -> VAR
-- On LEQ reduce production nxbot -> VAR
-- On LAND reduce production nxbot -> VAR
-- On IN reduce production nxbot -> VAR
-- On GT reduce production nxbot -> VAR
-- On GEQ reduce production nxbot -> VAR
-- On FINISH reduce production nxbot -> VAR
-- On FALSE reduce production nxbot -> VAR
-- On EQ reduce production nxbot -> VAR
-- On EOI reduce production nxbot -> VAR
-- On ENDMUTUAL reduce production nxbot -> VAR
-- On ELSE reduce production nxbot -> VAR
-- On ELIST reduce production nxbot -> VAR
-- On DO reduce production nxbot -> VAR
-- On DIVIDES reduce production nxbot -> VAR
-- On CONS reduce production nxbot -> VAR
-- On CONCAT reduce production nxbot -> VAR
-- On CLOSENUM reduce production nxbot -> VAR
-- On BLIST reduce production nxbot -> VAR
-- On BEFORE reduce production nxbot -> VAR

State 16:
## Known stack suffix:
## UNITVALUE
## LR(1) items:
nxbot -> UNITVALUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> UNITVALUE
-- On UNITVALUE reduce production nxbot -> UNITVALUE
-- On TRUE reduce production nxbot -> UNITVALUE
-- On TIMES reduce production nxbot -> UNITVALUE
-- On THEN reduce production nxbot -> UNITVALUE
-- On RPAREN reduce production nxbot -> UNITVALUE
-- On PLUS reduce production nxbot -> UNITVALUE
-- On OVERWRITEGLOBALHASH reduce production nxbot -> UNITVALUE
-- On OPENSTR reduce production nxbot -> UNITVALUE
-- On OPENQT reduce production nxbot -> UNITVALUE
-- On NUMCONST reduce production nxbot -> UNITVALUE
-- On NEQ reduce production nxbot -> UNITVALUE
-- On MUTUAL reduce production nxbot -> UNITVALUE
-- On MOD reduce production nxbot -> UNITVALUE
-- On MINUS reduce production nxbot -> UNITVALUE
-- On LT reduce production nxbot -> UNITVALUE
-- On LPAREN reduce production nxbot -> UNITVALUE
-- On LOR reduce production nxbot -> UNITVALUE
-- On LISTPUNCT reduce production nxbot -> UNITVALUE
-- On LETMUTABLE reduce production nxbot -> UNITVALUE
-- On LETAND reduce production nxbot -> UNITVALUE
-- On LET reduce production nxbot -> UNITVALUE
-- On LEQ reduce production nxbot -> UNITVALUE
-- On LAND reduce production nxbot -> UNITVALUE
-- On IN reduce production nxbot -> UNITVALUE
-- On GT reduce production nxbot -> UNITVALUE
-- On GEQ reduce production nxbot -> UNITVALUE
-- On FINISH reduce production nxbot -> UNITVALUE
-- On FALSE reduce production nxbot -> UNITVALUE
-- On EQ reduce production nxbot -> UNITVALUE
-- On EOI reduce production nxbot -> UNITVALUE
-- On ENDMUTUAL reduce production nxbot -> UNITVALUE
-- On ELSE reduce production nxbot -> UNITVALUE
-- On ELIST reduce production nxbot -> UNITVALUE
-- On DO reduce production nxbot -> UNITVALUE
-- On DIVIDES reduce production nxbot -> UNITVALUE
-- On CONS reduce production nxbot -> UNITVALUE
-- On CONCAT reduce production nxbot -> UNITVALUE
-- On CLOSENUM reduce production nxbot -> UNITVALUE
-- On BLIST reduce production nxbot -> UNITVALUE
-- On BEFORE reduce production nxbot -> UNITVALUE

State 17:
## Known stack suffix:
## TRUE
## LR(1) items:
nxbot -> TRUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> TRUE
-- On UNITVALUE reduce production nxbot -> TRUE
-- On TRUE reduce production nxbot -> TRUE
-- On TIMES reduce production nxbot -> TRUE
-- On THEN reduce production nxbot -> TRUE
-- On RPAREN reduce production nxbot -> TRUE
-- On PLUS reduce production nxbot -> TRUE
-- On OVERWRITEGLOBALHASH reduce production nxbot -> TRUE
-- On OPENSTR reduce production nxbot -> TRUE
-- On OPENQT reduce production nxbot -> TRUE
-- On NUMCONST reduce production nxbot -> TRUE
-- On NEQ reduce production nxbot -> TRUE
-- On MUTUAL reduce production nxbot -> TRUE
-- On MOD reduce production nxbot -> TRUE
-- On MINUS reduce production nxbot -> TRUE
-- On LT reduce production nxbot -> TRUE
-- On LPAREN reduce production nxbot -> TRUE
-- On LOR reduce production nxbot -> TRUE
-- On LISTPUNCT reduce production nxbot -> TRUE
-- On LETMUTABLE reduce production nxbot -> TRUE
-- On LETAND reduce production nxbot -> TRUE
-- On LET reduce production nxbot -> TRUE
-- On LEQ reduce production nxbot -> TRUE
-- On LAND reduce production nxbot -> TRUE
-- On IN reduce production nxbot -> TRUE
-- On GT reduce production nxbot -> TRUE
-- On GEQ reduce production nxbot -> TRUE
-- On FINISH reduce production nxbot -> TRUE
-- On FALSE reduce production nxbot -> TRUE
-- On EQ reduce production nxbot -> TRUE
-- On EOI reduce production nxbot -> TRUE
-- On ENDMUTUAL reduce production nxbot -> TRUE
-- On ELSE reduce production nxbot -> TRUE
-- On ELIST reduce production nxbot -> TRUE
-- On DO reduce production nxbot -> TRUE
-- On DIVIDES reduce production nxbot -> TRUE
-- On CONS reduce production nxbot -> TRUE
-- On CONCAT reduce production nxbot -> TRUE
-- On CLOSENUM reduce production nxbot -> TRUE
-- On BLIST reduce production nxbot -> TRUE
-- On BEFORE reduce production nxbot -> TRUE

State 18:
## Known stack suffix:
## REFNOW
## LR(1) items:
nxun -> REFNOW . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFNOW . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 19
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 294
## Reductions:

State 19:
## Known stack suffix:
## REFNOW error
## LR(1) items:
nxun -> REFNOW error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On TIMES reduce production nxun -> REFNOW error
-- On THEN reduce production nxun -> REFNOW error
-- On RPAREN reduce production nxun -> REFNOW error
-- On PLUS reduce production nxun -> REFNOW error
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFNOW error
-- On NEQ reduce production nxun -> REFNOW error
-- On MUTUAL reduce production nxun -> REFNOW error
-- On MOD reduce production nxun -> REFNOW error
-- On MINUS reduce production nxun -> REFNOW error
-- On LT reduce production nxun -> REFNOW error
-- On LOR reduce production nxun -> REFNOW error
-- On LISTPUNCT reduce production nxun -> REFNOW error
-- On LETMUTABLE reduce production nxun -> REFNOW error
-- On LETAND reduce production nxun -> REFNOW error
-- On LET reduce production nxun -> REFNOW error
-- On LEQ reduce production nxun -> REFNOW error
-- On LAND reduce production nxun -> REFNOW error
-- On IN reduce production nxun -> REFNOW error
-- On GT reduce production nxun -> REFNOW error
-- On GEQ reduce production nxun -> REFNOW error
-- On EQ reduce production nxun -> REFNOW error
-- On EOI reduce production nxun -> REFNOW error
-- On ENDMUTUAL reduce production nxun -> REFNOW error
-- On ELSE reduce production nxun -> REFNOW error
-- On ELIST reduce production nxun -> REFNOW error
-- On DO reduce production nxun -> REFNOW error
-- On DIVIDES reduce production nxun -> REFNOW error
-- On CONS reduce production nxun -> REFNOW error
-- On CONCAT reduce production nxun -> REFNOW error
-- On CLOSENUM reduce production nxun -> REFNOW error
-- On BEFORE reduce production nxun -> REFNOW error

State 20:
## Known stack suffix:
## OPENSTR
## LR(1) items:
nxbot -> OPENSTR . sxsep CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> OPENSTR . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 21
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 292
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSESTR reduce production sxblock ->

State 21:
## Known stack suffix:
## OPENSTR error
## LR(1) items:
nxbot -> OPENSTR error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> OPENSTR error
-- On UNITVALUE reduce production nxbot -> OPENSTR error
-- On TRUE reduce production nxbot -> OPENSTR error
-- On TIMES reduce production nxbot -> OPENSTR error
-- On THEN reduce production nxbot -> OPENSTR error
-- On RPAREN reduce production nxbot -> OPENSTR error
-- On PLUS reduce production nxbot -> OPENSTR error
-- On OVERWRITEGLOBALHASH reduce production nxbot -> OPENSTR error
-- On OPENSTR reduce production nxbot -> OPENSTR error
-- On OPENQT reduce production nxbot -> OPENSTR error
-- On NUMCONST reduce production nxbot -> OPENSTR error
-- On NEQ reduce production nxbot -> OPENSTR error
-- On MUTUAL reduce production nxbot -> OPENSTR error
-- On MOD reduce production nxbot -> OPENSTR error
-- On MINUS reduce production nxbot -> OPENSTR error
-- On LT reduce production nxbot -> OPENSTR error
-- On LPAREN reduce production nxbot -> OPENSTR error
-- On LOR reduce production nxbot -> OPENSTR error
-- On LISTPUNCT reduce production nxbot -> OPENSTR error
-- On LETMUTABLE reduce production nxbot -> OPENSTR error
-- On LETAND reduce production nxbot -> OPENSTR error
-- On LET reduce production nxbot -> OPENSTR error
-- On LEQ reduce production nxbot -> OPENSTR error
-- On LAND reduce production nxbot -> OPENSTR error
-- On IN reduce production nxbot -> OPENSTR error
-- On GT reduce production nxbot -> OPENSTR error
-- On GEQ reduce production nxbot -> OPENSTR error
-- On FINISH reduce production nxbot -> OPENSTR error
-- On FALSE reduce production nxbot -> OPENSTR error
-- On EQ reduce production nxbot -> OPENSTR error
-- On EOI reduce production nxbot -> OPENSTR error
-- On ENDMUTUAL reduce production nxbot -> OPENSTR error
-- On ELSE reduce production nxbot -> OPENSTR error
-- On ELIST reduce production nxbot -> OPENSTR error
-- On DO reduce production nxbot -> OPENSTR error
-- On DIVIDES reduce production nxbot -> OPENSTR error
-- On CONS reduce production nxbot -> OPENSTR error
-- On CONCAT reduce production nxbot -> OPENSTR error
-- On CLOSENUM reduce production nxbot -> OPENSTR error
-- On BLIST reduce production nxbot -> OPENSTR error
-- On BEFORE reduce production nxbot -> OPENSTR error

State 22:
## Known stack suffix:
## SEP
## LR(1) items:
sxsep -> SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsep -> SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 23
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 287
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP reduce production sxblock ->
-- On EGRP reduce production sxsepsub ->
-- On CLOSESTR reduce production sxsepsub ->
-- On CLOSEQT reduce production sxsepsub ->

State 23:
## Known stack suffix:
## SEP error
## LR(1) items:
sxsep -> SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On EGRP reduce production sxsep -> SEP error
-- On CLOSESTR reduce production sxsep -> SEP error
-- On CLOSEQT reduce production sxsep -> SEP error

State 24:
## Known stack suffix:
## CTRLSEQ
## LR(1) items:
sxbot -> CTRLSEQ . sxclsnm sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sxbot -> CTRLSEQ . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 25
-- On CLASSNAME shift to state 26
-- On sxclsnm shift to state 27
## Reductions:
-- On OPENQT reduce production sxclsnm ->
-- On OPENNUM reduce production sxclsnm ->
-- On IDNAME reduce production sxclsnm ->
-- On END reduce production sxclsnm ->
-- On BGRP reduce production sxclsnm ->

State 25:
## Known stack suffix:
## CTRLSEQ error
## LR(1) items:
sxbot -> CTRLSEQ error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> CTRLSEQ error
-- On SPACE reduce production sxbot -> CTRLSEQ error
-- On SEP reduce production sxbot -> CTRLSEQ error
-- On EOI reduce production sxbot -> CTRLSEQ error
-- On EGRP reduce production sxbot -> CTRLSEQ error
-- On CTRLSEQ reduce production sxbot -> CTRLSEQ error
-- On CLOSESTR reduce production sxbot -> CTRLSEQ error
-- On CLOSEQT reduce production sxbot -> CTRLSEQ error
-- On CHAR reduce production sxbot -> CTRLSEQ error
-- On BREAK reduce production sxbot -> CTRLSEQ error

State 26:
## Known stack suffix:
## CLASSNAME
## LR(1) items:
sxclsnm -> CLASSNAME . [ OPENQT OPENNUM IDNAME END BGRP ]
## Transitions:
## Reductions:
-- On OPENQT reduce production sxclsnm -> CLASSNAME
-- On OPENNUM reduce production sxclsnm -> CLASSNAME
-- On IDNAME reduce production sxclsnm -> CLASSNAME
-- On END reduce production sxclsnm -> CLASSNAME
-- On BGRP reduce production sxclsnm -> CLASSNAME

State 27:
## Known stack suffix:
## CTRLSEQ sxclsnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm . sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On IDNAME shift to state 28
-- On sxidnm shift to state 29
## Reductions:
-- On OPENQT reduce production sxidnm ->
-- On OPENNUM reduce production sxidnm ->
-- On END reduce production sxidnm ->
-- On BGRP reduce production sxidnm ->

State 28:
## Known stack suffix:
## IDNAME
## LR(1) items:
sxidnm -> IDNAME . [ OPENQT OPENNUM END BGRP ]
## Transitions:
## Reductions:
-- On OPENQT reduce production sxidnm -> IDNAME
-- On OPENNUM reduce production sxidnm -> IDNAME
-- On END reduce production sxidnm -> IDNAME
-- On BGRP reduce production sxidnm -> IDNAME

State 29:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm . narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENNUM shift to state 30
-- On narg shift to state 264
## Reductions:
-- On OPENQT reduce production narg ->
-- On END reduce production narg ->
-- On BGRP reduce production narg ->

State 30:
## Known stack suffix:
## OPENNUM
## LR(1) items:
narg -> OPENNUM . nxlet CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM . error [ OPENQT END BGRP ]
narg -> OPENNUM . nxlet CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 31
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 260
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 31:
## Known stack suffix:
## OPENNUM error
## LR(1) items:
narg -> OPENNUM error . [ OPENQT END BGRP ]
## Transitions:
## Reductions:
-- On OPENQT reduce production narg -> OPENNUM error
-- On END reduce production narg -> OPENNUM error
-- On BGRP reduce production narg -> OPENNUM error

State 32:
## Known stack suffix:
## RENEWGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 33
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 256
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 33:
## Known stack suffix:
## RENEWGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> RENEWGLOBALHASH error
-- On RPAREN reduce production nxlambda -> RENEWGLOBALHASH error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> RENEWGLOBALHASH error
-- On MUTUAL reduce production nxlambda -> RENEWGLOBALHASH error
-- On LISTPUNCT reduce production nxlambda -> RENEWGLOBALHASH error
-- On LETMUTABLE reduce production nxlambda -> RENEWGLOBALHASH error
-- On LETAND reduce production nxlambda -> RENEWGLOBALHASH error
-- On LET reduce production nxlambda -> RENEWGLOBALHASH error
-- On IN reduce production nxlambda -> RENEWGLOBALHASH error
-- On EOI reduce production nxlambda -> RENEWGLOBALHASH error
-- On ENDMUTUAL reduce production nxlambda -> RENEWGLOBALHASH error
-- On ELSE reduce production nxlambda -> RENEWGLOBALHASH error
-- On ELIST reduce production nxlambda -> RENEWGLOBALHASH error
-- On DO reduce production nxlambda -> RENEWGLOBALHASH error
-- On CLOSENUM reduce production nxlambda -> RENEWGLOBALHASH error
-- On BEFORE reduce production nxlambda -> RENEWGLOBALHASH error

State 34:
## Known stack suffix:
## REFFINAL
## LR(1) items:
nxun -> REFFINAL . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFFINAL . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 35
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 255
## Reductions:

State 35:
## Known stack suffix:
## REFFINAL error
## LR(1) items:
nxun -> REFFINAL error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On TIMES reduce production nxun -> REFFINAL error
-- On THEN reduce production nxun -> REFFINAL error
-- On RPAREN reduce production nxun -> REFFINAL error
-- On PLUS reduce production nxun -> REFFINAL error
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFFINAL error
-- On NEQ reduce production nxun -> REFFINAL error
-- On MUTUAL reduce production nxun -> REFFINAL error
-- On MOD reduce production nxun -> REFFINAL error
-- On MINUS reduce production nxun -> REFFINAL error
-- On LT reduce production nxun -> REFFINAL error
-- On LOR reduce production nxun -> REFFINAL error
-- On LISTPUNCT reduce production nxun -> REFFINAL error
-- On LETMUTABLE reduce production nxun -> REFFINAL error
-- On LETAND reduce production nxun -> REFFINAL error
-- On LET reduce production nxun -> REFFINAL error
-- On LEQ reduce production nxun -> REFFINAL error
-- On LAND reduce production nxun -> REFFINAL error
-- On IN reduce production nxun -> REFFINAL error
-- On GT reduce production nxun -> REFFINAL error
-- On GEQ reduce production nxun -> REFFINAL error
-- On EQ reduce production nxun -> REFFINAL error
-- On EOI reduce production nxun -> REFFINAL error
-- On ENDMUTUAL reduce production nxun -> REFFINAL error
-- On ELSE reduce production nxun -> REFFINAL error
-- On ELIST reduce production nxun -> REFFINAL error
-- On DO reduce production nxun -> REFFINAL error
-- On DIVIDES reduce production nxun -> REFFINAL error
-- On CONS reduce production nxun -> REFFINAL error
-- On CONCAT reduce production nxun -> REFFINAL error
-- On CLOSENUM reduce production nxun -> REFFINAL error
-- On BEFORE reduce production nxun -> REFFINAL error

State 36:
## Known stack suffix:
## OPENQT
## LR(1) items:
nxbot -> OPENQT . sxsep CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 39
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 37:
## Known stack suffix:
## CHAR
## LR(1) items:
sxbot -> CHAR . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> CHAR
-- On SPACE reduce production sxbot -> CHAR
-- On SEP reduce production sxbot -> CHAR
-- On EOI reduce production sxbot -> CHAR
-- On EGRP reduce production sxbot -> CHAR
-- On CTRLSEQ reduce production sxbot -> CHAR
-- On CLOSESTR reduce production sxbot -> CHAR
-- On CLOSEQT reduce production sxbot -> CHAR
-- On CHAR reduce production sxbot -> CHAR
-- On BREAK reduce production sxbot -> CHAR

State 38:
## Known stack suffix:
## BREAK
## LR(1) items:
sxbot -> BREAK . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> BREAK
-- On SPACE reduce production sxbot -> BREAK
-- On SEP reduce production sxbot -> BREAK
-- On EOI reduce production sxbot -> BREAK
-- On EGRP reduce production sxbot -> BREAK
-- On CTRLSEQ reduce production sxbot -> BREAK
-- On CLOSESTR reduce production sxbot -> BREAK
-- On CLOSEQT reduce production sxbot -> BREAK
-- On CHAR reduce production sxbot -> BREAK
-- On BREAK reduce production sxbot -> BREAK

State 39:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
nxbot -> OPENQT sxsep . CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSEQT shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
nxbot -> OPENQT sxsep CLOSEQT . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On UNITVALUE reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On TRUE reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On TIMES reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On THEN reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On RPAREN reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On PLUS reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On OVERWRITEGLOBALHASH reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On OPENSTR reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On OPENQT reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On NUMCONST reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On NEQ reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On MUTUAL reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On MOD reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On MINUS reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LT reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LPAREN reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LOR reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LISTPUNCT reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LETMUTABLE reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LETAND reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LET reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LEQ reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On LAND reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On IN reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On GT reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On GEQ reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On FINISH reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On FALSE reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On EQ reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On EOI reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On ENDMUTUAL reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On ELSE reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On ELIST reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On DO reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On DIVIDES reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On CONS reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On CONCAT reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On CLOSENUM reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On BLIST reduce production nxbot -> OPENQT sxsep CLOSEQT
-- On BEFORE reduce production nxbot -> OPENQT sxsep CLOSEQT

State 41:
## Known stack suffix:
## sxbot
## LR(1) items:
sxblock -> sxbot . sxblock [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 42
## Reductions:
-- On SEP reduce production sxblock ->
-- On EOI reduce production sxblock ->
-- On EGRP reduce production sxblock ->
-- On CLOSESTR reduce production sxblock ->
-- On CLOSEQT reduce production sxblock ->

State 42:
## Known stack suffix:
## sxbot sxblock
## LR(1) items:
sxblock -> sxbot sxblock . [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On SEP reduce production sxblock -> sxbot sxblock
-- On EOI reduce production sxblock -> sxbot sxblock
-- On EGRP reduce production sxblock -> sxbot sxblock
-- On CLOSESTR reduce production sxblock -> sxbot sxblock
-- On CLOSEQT reduce production sxblock -> sxbot sxblock

State 43:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsep -> sxblock . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On EGRP reduce production sxsep -> sxblock
-- On CLOSESTR reduce production sxsep -> sxblock
-- On CLOSEQT reduce production sxsep -> sxblock

State 44:
## Known stack suffix:
## NUMCONST
## LR(1) items:
nxbot -> NUMCONST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> NUMCONST
-- On UNITVALUE reduce production nxbot -> NUMCONST
-- On TRUE reduce production nxbot -> NUMCONST
-- On TIMES reduce production nxbot -> NUMCONST
-- On THEN reduce production nxbot -> NUMCONST
-- On RPAREN reduce production nxbot -> NUMCONST
-- On PLUS reduce production nxbot -> NUMCONST
-- On OVERWRITEGLOBALHASH reduce production nxbot -> NUMCONST
-- On OPENSTR reduce production nxbot -> NUMCONST
-- On OPENQT reduce production nxbot -> NUMCONST
-- On NUMCONST reduce production nxbot -> NUMCONST
-- On NEQ reduce production nxbot -> NUMCONST
-- On MUTUAL reduce production nxbot -> NUMCONST
-- On MOD reduce production nxbot -> NUMCONST
-- On MINUS reduce production nxbot -> NUMCONST
-- On LT reduce production nxbot -> NUMCONST
-- On LPAREN reduce production nxbot -> NUMCONST
-- On LOR reduce production nxbot -> NUMCONST
-- On LISTPUNCT reduce production nxbot -> NUMCONST
-- On LETMUTABLE reduce production nxbot -> NUMCONST
-- On LETAND reduce production nxbot -> NUMCONST
-- On LET reduce production nxbot -> NUMCONST
-- On LEQ reduce production nxbot -> NUMCONST
-- On LAND reduce production nxbot -> NUMCONST
-- On IN reduce production nxbot -> NUMCONST
-- On GT reduce production nxbot -> NUMCONST
-- On GEQ reduce production nxbot -> NUMCONST
-- On FINISH reduce production nxbot -> NUMCONST
-- On FALSE reduce production nxbot -> NUMCONST
-- On EQ reduce production nxbot -> NUMCONST
-- On EOI reduce production nxbot -> NUMCONST
-- On ENDMUTUAL reduce production nxbot -> NUMCONST
-- On ELSE reduce production nxbot -> NUMCONST
-- On ELIST reduce production nxbot -> NUMCONST
-- On DO reduce production nxbot -> NUMCONST
-- On DIVIDES reduce production nxbot -> NUMCONST
-- On CONS reduce production nxbot -> NUMCONST
-- On CONCAT reduce production nxbot -> NUMCONST
-- On CLOSENUM reduce production nxbot -> NUMCONST
-- On BLIST reduce production nxbot -> NUMCONST
-- On BEFORE reduce production nxbot -> NUMCONST

State 45:
## Known stack suffix:
## LPAREN
## LR(1) items:
nxbot -> LPAREN . nxlet RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . binop RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 46
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 47
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On PLUS shift to state 48
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On NEQ shift to state 49
-- On MOD shift to state 50
-- On MINUS shift to state 51
-- On LT shift to state 240
-- On LPAREN shift to state 45
-- On LOR shift to state 241
-- On LNOT shift to state 242
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LEQ shift to state 243
-- On LAND shift to state 244
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On GT shift to state 245
-- On GEQ shift to state 246
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On EQ shift to state 247
-- On DIVIDES shift to state 248
-- On DECGLOBALHASH shift to state 163
-- On CONCAT shift to state 249
-- On BLIST shift to state 55
-- On BEFORE shift to state 250
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 251
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
-- On binop shift to state 253
## Reductions:

State 46:
## Known stack suffix:
## LPAREN error
## LR(1) items:
nxbot -> LPAREN error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> LPAREN error
-- On UNITVALUE reduce production nxbot -> LPAREN error
-- On TRUE reduce production nxbot -> LPAREN error
-- On TIMES reduce production nxbot -> LPAREN error
-- On THEN reduce production nxbot -> LPAREN error
-- On RPAREN reduce production nxbot -> LPAREN error
-- On PLUS reduce production nxbot -> LPAREN error
-- On OVERWRITEGLOBALHASH reduce production nxbot -> LPAREN error
-- On OPENSTR reduce production nxbot -> LPAREN error
-- On OPENQT reduce production nxbot -> LPAREN error
-- On NUMCONST reduce production nxbot -> LPAREN error
-- On NEQ reduce production nxbot -> LPAREN error
-- On MUTUAL reduce production nxbot -> LPAREN error
-- On MOD reduce production nxbot -> LPAREN error
-- On MINUS reduce production nxbot -> LPAREN error
-- On LT reduce production nxbot -> LPAREN error
-- On LPAREN reduce production nxbot -> LPAREN error
-- On LOR reduce production nxbot -> LPAREN error
-- On LISTPUNCT reduce production nxbot -> LPAREN error
-- On LETMUTABLE reduce production nxbot -> LPAREN error
-- On LETAND reduce production nxbot -> LPAREN error
-- On LET reduce production nxbot -> LPAREN error
-- On LEQ reduce production nxbot -> LPAREN error
-- On LAND reduce production nxbot -> LPAREN error
-- On IN reduce production nxbot -> LPAREN error
-- On GT reduce production nxbot -> LPAREN error
-- On GEQ reduce production nxbot -> LPAREN error
-- On FINISH reduce production nxbot -> LPAREN error
-- On FALSE reduce production nxbot -> LPAREN error
-- On EQ reduce production nxbot -> LPAREN error
-- On EOI reduce production nxbot -> LPAREN error
-- On ENDMUTUAL reduce production nxbot -> LPAREN error
-- On ELSE reduce production nxbot -> LPAREN error
-- On ELIST reduce production nxbot -> LPAREN error
-- On DO reduce production nxbot -> LPAREN error
-- On DIVIDES reduce production nxbot -> LPAREN error
-- On CONS reduce production nxbot -> LPAREN error
-- On CONCAT reduce production nxbot -> LPAREN error
-- On CLOSENUM reduce production nxbot -> LPAREN error
-- On BLIST reduce production nxbot -> LPAREN error
-- On BEFORE reduce production nxbot -> LPAREN error

State 47:
## Known stack suffix:
## TIMES
## LR(1) items:
binop -> TIMES . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> TIMES

State 48:
## Known stack suffix:
## PLUS
## LR(1) items:
binop -> PLUS . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> PLUS

State 49:
## Known stack suffix:
## NEQ
## LR(1) items:
binop -> NEQ . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> NEQ

State 50:
## Known stack suffix:
## MOD
## LR(1) items:
binop -> MOD . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> MOD

State 51:
## Known stack suffix:
## MINUS
## LR(1) items:
binop -> MINUS . [ RPAREN ]
nxun -> MINUS . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> MINUS . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:
-- On RPAREN reduce production binop -> MINUS

State 52:
## Known stack suffix:
## MINUS error
## LR(1) items:
nxun -> MINUS error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On TIMES reduce production nxun -> MINUS error
-- On THEN reduce production nxun -> MINUS error
-- On RPAREN reduce production nxun -> MINUS error
-- On PLUS reduce production nxun -> MINUS error
-- On OVERWRITEGLOBALHASH reduce production nxun -> MINUS error
-- On NEQ reduce production nxun -> MINUS error
-- On MUTUAL reduce production nxun -> MINUS error
-- On MOD reduce production nxun -> MINUS error
-- On MINUS reduce production nxun -> MINUS error
-- On LT reduce production nxun -> MINUS error
-- On LOR reduce production nxun -> MINUS error
-- On LISTPUNCT reduce production nxun -> MINUS error
-- On LETMUTABLE reduce production nxun -> MINUS error
-- On LETAND reduce production nxun -> MINUS error
-- On LET reduce production nxun -> MINUS error
-- On LEQ reduce production nxun -> MINUS error
-- On LAND reduce production nxun -> MINUS error
-- On IN reduce production nxun -> MINUS error
-- On GT reduce production nxun -> MINUS error
-- On GEQ reduce production nxun -> MINUS error
-- On EQ reduce production nxun -> MINUS error
-- On EOI reduce production nxun -> MINUS error
-- On ENDMUTUAL reduce production nxun -> MINUS error
-- On ELSE reduce production nxun -> MINUS error
-- On ELIST reduce production nxun -> MINUS error
-- On DO reduce production nxun -> MINUS error
-- On DIVIDES reduce production nxun -> MINUS error
-- On CONS reduce production nxun -> MINUS error
-- On CONCAT reduce production nxun -> MINUS error
-- On CLOSENUM reduce production nxun -> MINUS error
-- On BEFORE reduce production nxun -> MINUS error

State 53:
## Known stack suffix:
## FINISH
## LR(1) items:
nxbot -> FINISH . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> FINISH
-- On UNITVALUE reduce production nxbot -> FINISH
-- On TRUE reduce production nxbot -> FINISH
-- On TIMES reduce production nxbot -> FINISH
-- On THEN reduce production nxbot -> FINISH
-- On RPAREN reduce production nxbot -> FINISH
-- On PLUS reduce production nxbot -> FINISH
-- On OVERWRITEGLOBALHASH reduce production nxbot -> FINISH
-- On OPENSTR reduce production nxbot -> FINISH
-- On OPENQT reduce production nxbot -> FINISH
-- On NUMCONST reduce production nxbot -> FINISH
-- On NEQ reduce production nxbot -> FINISH
-- On MUTUAL reduce production nxbot -> FINISH
-- On MOD reduce production nxbot -> FINISH
-- On MINUS reduce production nxbot -> FINISH
-- On LT reduce production nxbot -> FINISH
-- On LPAREN reduce production nxbot -> FINISH
-- On LOR reduce production nxbot -> FINISH
-- On LISTPUNCT reduce production nxbot -> FINISH
-- On LETMUTABLE reduce production nxbot -> FINISH
-- On LETAND reduce production nxbot -> FINISH
-- On LET reduce production nxbot -> FINISH
-- On LEQ reduce production nxbot -> FINISH
-- On LAND reduce production nxbot -> FINISH
-- On IN reduce production nxbot -> FINISH
-- On GT reduce production nxbot -> FINISH
-- On GEQ reduce production nxbot -> FINISH
-- On FINISH reduce production nxbot -> FINISH
-- On FALSE reduce production nxbot -> FINISH
-- On EQ reduce production nxbot -> FINISH
-- On EOI reduce production nxbot -> FINISH
-- On ENDMUTUAL reduce production nxbot -> FINISH
-- On ELSE reduce production nxbot -> FINISH
-- On ELIST reduce production nxbot -> FINISH
-- On DO reduce production nxbot -> FINISH
-- On DIVIDES reduce production nxbot -> FINISH
-- On CONS reduce production nxbot -> FINISH
-- On CONCAT reduce production nxbot -> FINISH
-- On CLOSENUM reduce production nxbot -> FINISH
-- On BLIST reduce production nxbot -> FINISH
-- On BEFORE reduce production nxbot -> FINISH

State 54:
## Known stack suffix:
## FALSE
## LR(1) items:
nxbot -> FALSE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> FALSE
-- On UNITVALUE reduce production nxbot -> FALSE
-- On TRUE reduce production nxbot -> FALSE
-- On TIMES reduce production nxbot -> FALSE
-- On THEN reduce production nxbot -> FALSE
-- On RPAREN reduce production nxbot -> FALSE
-- On PLUS reduce production nxbot -> FALSE
-- On OVERWRITEGLOBALHASH reduce production nxbot -> FALSE
-- On OPENSTR reduce production nxbot -> FALSE
-- On OPENQT reduce production nxbot -> FALSE
-- On NUMCONST reduce production nxbot -> FALSE
-- On NEQ reduce production nxbot -> FALSE
-- On MUTUAL reduce production nxbot -> FALSE
-- On MOD reduce production nxbot -> FALSE
-- On MINUS reduce production nxbot -> FALSE
-- On LT reduce production nxbot -> FALSE
-- On LPAREN reduce production nxbot -> FALSE
-- On LOR reduce production nxbot -> FALSE
-- On LISTPUNCT reduce production nxbot -> FALSE
-- On LETMUTABLE reduce production nxbot -> FALSE
-- On LETAND reduce production nxbot -> FALSE
-- On LET reduce production nxbot -> FALSE
-- On LEQ reduce production nxbot -> FALSE
-- On LAND reduce production nxbot -> FALSE
-- On IN reduce production nxbot -> FALSE
-- On GT reduce production nxbot -> FALSE
-- On GEQ reduce production nxbot -> FALSE
-- On FINISH reduce production nxbot -> FALSE
-- On FALSE reduce production nxbot -> FALSE
-- On EQ reduce production nxbot -> FALSE
-- On EOI reduce production nxbot -> FALSE
-- On ENDMUTUAL reduce production nxbot -> FALSE
-- On ELSE reduce production nxbot -> FALSE
-- On ELIST reduce production nxbot -> FALSE
-- On DO reduce production nxbot -> FALSE
-- On DIVIDES reduce production nxbot -> FALSE
-- On CONS reduce production nxbot -> FALSE
-- On CONCAT reduce production nxbot -> FALSE
-- On CLOSENUM reduce production nxbot -> FALSE
-- On BLIST reduce production nxbot -> FALSE
-- On BEFORE reduce production nxbot -> FALSE

State 55:
## Known stack suffix:
## BLIST
## LR(1) items:
nxbot -> BLIST . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . nxlet nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 56
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On ELIST shift to state 232
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 233
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 56:
## Known stack suffix:
## BLIST error
## LR(1) items:
nxbot -> BLIST error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> BLIST error
-- On UNITVALUE reduce production nxbot -> BLIST error
-- On TRUE reduce production nxbot -> BLIST error
-- On TIMES reduce production nxbot -> BLIST error
-- On THEN reduce production nxbot -> BLIST error
-- On RPAREN reduce production nxbot -> BLIST error
-- On PLUS reduce production nxbot -> BLIST error
-- On OVERWRITEGLOBALHASH reduce production nxbot -> BLIST error
-- On OPENSTR reduce production nxbot -> BLIST error
-- On OPENQT reduce production nxbot -> BLIST error
-- On NUMCONST reduce production nxbot -> BLIST error
-- On NEQ reduce production nxbot -> BLIST error
-- On MUTUAL reduce production nxbot -> BLIST error
-- On MOD reduce production nxbot -> BLIST error
-- On MINUS reduce production nxbot -> BLIST error
-- On LT reduce production nxbot -> BLIST error
-- On LPAREN reduce production nxbot -> BLIST error
-- On LOR reduce production nxbot -> BLIST error
-- On LISTPUNCT reduce production nxbot -> BLIST error
-- On LETMUTABLE reduce production nxbot -> BLIST error
-- On LETAND reduce production nxbot -> BLIST error
-- On LET reduce production nxbot -> BLIST error
-- On LEQ reduce production nxbot -> BLIST error
-- On LAND reduce production nxbot -> BLIST error
-- On IN reduce production nxbot -> BLIST error
-- On GT reduce production nxbot -> BLIST error
-- On GEQ reduce production nxbot -> BLIST error
-- On FINISH reduce production nxbot -> BLIST error
-- On FALSE reduce production nxbot -> BLIST error
-- On EQ reduce production nxbot -> BLIST error
-- On EOI reduce production nxbot -> BLIST error
-- On ENDMUTUAL reduce production nxbot -> BLIST error
-- On ELSE reduce production nxbot -> BLIST error
-- On ELIST reduce production nxbot -> BLIST error
-- On DO reduce production nxbot -> BLIST error
-- On DIVIDES reduce production nxbot -> BLIST error
-- On CONS reduce production nxbot -> BLIST error
-- On CONCAT reduce production nxbot -> BLIST error
-- On CLOSENUM reduce production nxbot -> BLIST error
-- On BLIST reduce production nxbot -> BLIST error
-- On BEFORE reduce production nxbot -> BLIST error

State 57:
## Known stack suffix:
## MINUS
## LR(1) items:
nxun -> MINUS . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> MINUS . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:

State 58:
## Known stack suffix:
## nxbot
## LR(1) items:
nxapp -> nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxapp -> nxbot
-- On UNITVALUE reduce production nxapp -> nxbot
-- On TRUE reduce production nxapp -> nxbot
-- On TIMES reduce production nxapp -> nxbot
-- On THEN reduce production nxapp -> nxbot
-- On RPAREN reduce production nxapp -> nxbot
-- On PLUS reduce production nxapp -> nxbot
-- On OVERWRITEGLOBALHASH reduce production nxapp -> nxbot
-- On OPENSTR reduce production nxapp -> nxbot
-- On OPENQT reduce production nxapp -> nxbot
-- On NUMCONST reduce production nxapp -> nxbot
-- On NEQ reduce production nxapp -> nxbot
-- On MUTUAL reduce production nxapp -> nxbot
-- On MOD reduce production nxapp -> nxbot
-- On MINUS reduce production nxapp -> nxbot
-- On LT reduce production nxapp -> nxbot
-- On LPAREN reduce production nxapp -> nxbot
-- On LOR reduce production nxapp -> nxbot
-- On LISTPUNCT reduce production nxapp -> nxbot
-- On LETMUTABLE reduce production nxapp -> nxbot
-- On LETAND reduce production nxapp -> nxbot
-- On LET reduce production nxapp -> nxbot
-- On LEQ reduce production nxapp -> nxbot
-- On LAND reduce production nxapp -> nxbot
-- On IN reduce production nxapp -> nxbot
-- On GT reduce production nxapp -> nxbot
-- On GEQ reduce production nxapp -> nxbot
-- On FINISH reduce production nxapp -> nxbot
-- On FALSE reduce production nxapp -> nxbot
-- On EQ reduce production nxapp -> nxbot
-- On EOI reduce production nxapp -> nxbot
-- On ENDMUTUAL reduce production nxapp -> nxbot
-- On ELSE reduce production nxapp -> nxbot
-- On ELIST reduce production nxapp -> nxbot
-- On DO reduce production nxapp -> nxbot
-- On DIVIDES reduce production nxapp -> nxbot
-- On CONS reduce production nxapp -> nxbot
-- On CONCAT reduce production nxapp -> nxbot
-- On CLOSENUM reduce production nxapp -> nxbot
-- On BLIST reduce production nxapp -> nxbot
-- On BEFORE reduce production nxapp -> nxbot

State 59:
## Known stack suffix:
## MINUS nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> MINUS nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> MINUS nxapp
-- On THEN reduce production nxun -> MINUS nxapp
-- On RPAREN reduce production nxun -> MINUS nxapp
-- On PLUS reduce production nxun -> MINUS nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> MINUS nxapp
-- On NEQ reduce production nxun -> MINUS nxapp
-- On MUTUAL reduce production nxun -> MINUS nxapp
-- On MOD reduce production nxun -> MINUS nxapp
-- On MINUS reduce production nxun -> MINUS nxapp
-- On LT reduce production nxun -> MINUS nxapp
-- On LOR reduce production nxun -> MINUS nxapp
-- On LISTPUNCT reduce production nxun -> MINUS nxapp
-- On LETMUTABLE reduce production nxun -> MINUS nxapp
-- On LETAND reduce production nxun -> MINUS nxapp
-- On LET reduce production nxun -> MINUS nxapp
-- On LEQ reduce production nxun -> MINUS nxapp
-- On LAND reduce production nxun -> MINUS nxapp
-- On IN reduce production nxun -> MINUS nxapp
-- On GT reduce production nxun -> MINUS nxapp
-- On GEQ reduce production nxun -> MINUS nxapp
-- On EQ reduce production nxun -> MINUS nxapp
-- On EOI reduce production nxun -> MINUS nxapp
-- On ENDMUTUAL reduce production nxun -> MINUS nxapp
-- On ELSE reduce production nxun -> MINUS nxapp
-- On ELIST reduce production nxun -> MINUS nxapp
-- On DO reduce production nxun -> MINUS nxapp
-- On DIVIDES reduce production nxun -> MINUS nxapp
-- On CONS reduce production nxun -> MINUS nxapp
-- On CONCAT reduce production nxun -> MINUS nxapp
-- On CLOSENUM reduce production nxun -> MINUS nxapp
-- On BEFORE reduce production nxun -> MINUS nxapp

State 60:
## Known stack suffix:
## nxapp nxbot
## LR(1) items:
nxapp -> nxapp nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxapp -> nxapp nxbot
-- On UNITVALUE reduce production nxapp -> nxapp nxbot
-- On TRUE reduce production nxapp -> nxapp nxbot
-- On TIMES reduce production nxapp -> nxapp nxbot
-- On THEN reduce production nxapp -> nxapp nxbot
-- On RPAREN reduce production nxapp -> nxapp nxbot
-- On PLUS reduce production nxapp -> nxapp nxbot
-- On OVERWRITEGLOBALHASH reduce production nxapp -> nxapp nxbot
-- On OPENSTR reduce production nxapp -> nxapp nxbot
-- On OPENQT reduce production nxapp -> nxapp nxbot
-- On NUMCONST reduce production nxapp -> nxapp nxbot
-- On NEQ reduce production nxapp -> nxapp nxbot
-- On MUTUAL reduce production nxapp -> nxapp nxbot
-- On MOD reduce production nxapp -> nxapp nxbot
-- On MINUS reduce production nxapp -> nxapp nxbot
-- On LT reduce production nxapp -> nxapp nxbot
-- On LPAREN reduce production nxapp -> nxapp nxbot
-- On LOR reduce production nxapp -> nxapp nxbot
-- On LISTPUNCT reduce production nxapp -> nxapp nxbot
-- On LETMUTABLE reduce production nxapp -> nxapp nxbot
-- On LETAND reduce production nxapp -> nxapp nxbot
-- On LET reduce production nxapp -> nxapp nxbot
-- On LEQ reduce production nxapp -> nxapp nxbot
-- On LAND reduce production nxapp -> nxapp nxbot
-- On IN reduce production nxapp -> nxapp nxbot
-- On GT reduce production nxapp -> nxapp nxbot
-- On GEQ reduce production nxapp -> nxapp nxbot
-- On FINISH reduce production nxapp -> nxapp nxbot
-- On FALSE reduce production nxapp -> nxapp nxbot
-- On EQ reduce production nxapp -> nxapp nxbot
-- On EOI reduce production nxapp -> nxapp nxbot
-- On ENDMUTUAL reduce production nxapp -> nxapp nxbot
-- On ELSE reduce production nxapp -> nxapp nxbot
-- On ELIST reduce production nxapp -> nxapp nxbot
-- On DO reduce production nxapp -> nxapp nxbot
-- On DIVIDES reduce production nxapp -> nxapp nxbot
-- On CONS reduce production nxapp -> nxapp nxbot
-- On CONCAT reduce production nxapp -> nxapp nxbot
-- On CLOSENUM reduce production nxapp -> nxapp nxbot
-- On BLIST reduce production nxapp -> nxapp nxbot
-- On BEFORE reduce production nxapp -> nxapp nxbot

State 61:
## Known stack suffix:
## LNOT
## LR(1) items:
nxun -> LNOT . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> LNOT . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:

State 62:
## Known stack suffix:
## LNOT error
## LR(1) items:
nxun -> LNOT error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On TIMES reduce production nxun -> LNOT error
-- On THEN reduce production nxun -> LNOT error
-- On RPAREN reduce production nxun -> LNOT error
-- On PLUS reduce production nxun -> LNOT error
-- On OVERWRITEGLOBALHASH reduce production nxun -> LNOT error
-- On NEQ reduce production nxun -> LNOT error
-- On MUTUAL reduce production nxun -> LNOT error
-- On MOD reduce production nxun -> LNOT error
-- On MINUS reduce production nxun -> LNOT error
-- On LT reduce production nxun -> LNOT error
-- On LOR reduce production nxun -> LNOT error
-- On LISTPUNCT reduce production nxun -> LNOT error
-- On LETMUTABLE reduce production nxun -> LNOT error
-- On LETAND reduce production nxun -> LNOT error
-- On LET reduce production nxun -> LNOT error
-- On LEQ reduce production nxun -> LNOT error
-- On LAND reduce production nxun -> LNOT error
-- On IN reduce production nxun -> LNOT error
-- On GT reduce production nxun -> LNOT error
-- On GEQ reduce production nxun -> LNOT error
-- On EQ reduce production nxun -> LNOT error
-- On EOI reduce production nxun -> LNOT error
-- On ENDMUTUAL reduce production nxun -> LNOT error
-- On ELSE reduce production nxun -> LNOT error
-- On ELIST reduce production nxun -> LNOT error
-- On DO reduce production nxun -> LNOT error
-- On DIVIDES reduce production nxun -> LNOT error
-- On CONS reduce production nxun -> LNOT error
-- On CONCAT reduce production nxun -> LNOT error
-- On CLOSENUM reduce production nxun -> LNOT error
-- On BEFORE reduce production nxun -> LNOT error

State 63:
## Known stack suffix:
## LNOT nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> LNOT nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> LNOT nxapp
-- On THEN reduce production nxun -> LNOT nxapp
-- On RPAREN reduce production nxun -> LNOT nxapp
-- On PLUS reduce production nxun -> LNOT nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> LNOT nxapp
-- On NEQ reduce production nxun -> LNOT nxapp
-- On MUTUAL reduce production nxun -> LNOT nxapp
-- On MOD reduce production nxun -> LNOT nxapp
-- On MINUS reduce production nxun -> LNOT nxapp
-- On LT reduce production nxun -> LNOT nxapp
-- On LOR reduce production nxun -> LNOT nxapp
-- On LISTPUNCT reduce production nxun -> LNOT nxapp
-- On LETMUTABLE reduce production nxun -> LNOT nxapp
-- On LETAND reduce production nxun -> LNOT nxapp
-- On LET reduce production nxun -> LNOT nxapp
-- On LEQ reduce production nxun -> LNOT nxapp
-- On LAND reduce production nxun -> LNOT nxapp
-- On IN reduce production nxun -> LNOT nxapp
-- On GT reduce production nxun -> LNOT nxapp
-- On GEQ reduce production nxun -> LNOT nxapp
-- On EQ reduce production nxun -> LNOT nxapp
-- On EOI reduce production nxun -> LNOT nxapp
-- On ENDMUTUAL reduce production nxun -> LNOT nxapp
-- On ELSE reduce production nxun -> LNOT nxapp
-- On ELIST reduce production nxun -> LNOT nxapp
-- On DO reduce production nxun -> LNOT nxapp
-- On DIVIDES reduce production nxun -> LNOT nxapp
-- On CONS reduce production nxun -> LNOT nxapp
-- On CONCAT reduce production nxun -> LNOT nxapp
-- On CLOSENUM reduce production nxun -> LNOT nxapp
-- On BEFORE reduce production nxun -> LNOT nxapp

State 64:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 65
-- On VAR shift to state 66
## Reductions:

State 65:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxlet -> LETMUTABLE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LETMUTABLE error
-- On RPAREN reduce production nxlet -> LETMUTABLE error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LETMUTABLE error
-- On MUTUAL reduce production nxlet -> LETMUTABLE error
-- On LISTPUNCT reduce production nxlet -> LETMUTABLE error
-- On LETMUTABLE reduce production nxlet -> LETMUTABLE error
-- On LETAND reduce production nxlet -> LETMUTABLE error
-- On LET reduce production nxlet -> LETMUTABLE error
-- On IN reduce production nxlet -> LETMUTABLE error
-- On EOI reduce production nxlet -> LETMUTABLE error
-- On ENDMUTUAL reduce production nxlet -> LETMUTABLE error
-- On ELSE reduce production nxlet -> LETMUTABLE error
-- On ELIST reduce production nxlet -> LETMUTABLE error
-- On DO reduce production nxlet -> LETMUTABLE error
-- On CLOSENUM reduce production nxlet -> LETMUTABLE error

State 66:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 67
-- On OVERWRITEEQ shift to state 68
## Reductions:

State 67:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxlet -> LETMUTABLE VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LETMUTABLE VAR error
-- On RPAREN reduce production nxlet -> LETMUTABLE VAR error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LETMUTABLE VAR error
-- On MUTUAL reduce production nxlet -> LETMUTABLE VAR error
-- On LISTPUNCT reduce production nxlet -> LETMUTABLE VAR error
-- On LETMUTABLE reduce production nxlet -> LETMUTABLE VAR error
-- On LETAND reduce production nxlet -> LETMUTABLE VAR error
-- On LET reduce production nxlet -> LETMUTABLE VAR error
-- On IN reduce production nxlet -> LETMUTABLE VAR error
-- On EOI reduce production nxlet -> LETMUTABLE VAR error
-- On ENDMUTUAL reduce production nxlet -> LETMUTABLE VAR error
-- On ELSE reduce production nxlet -> LETMUTABLE VAR error
-- On ELIST reduce production nxlet -> LETMUTABLE VAR error
-- On DO reduce production nxlet -> LETMUTABLE VAR error
-- On CLOSENUM reduce production nxlet -> LETMUTABLE VAR error

State 68:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 69
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 228
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 69:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On RPAREN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On MUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On LISTPUNCT reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On LETMUTABLE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On LETAND reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On LET reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On IN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On EOI reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On ENDMUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On ELSE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On ELIST reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On DO reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error
-- On CLOSENUM reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error

State 70:
## Known stack suffix:
## LET
## LR(1) items:
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 71
-- On VAR shift to state 72
-- On CTRLSEQ shift to state 218
## Reductions:

State 71:
## Known stack suffix:
## LET error
## LR(1) items:
nxlet -> LET error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET error
-- On RPAREN reduce production nxlet -> LET error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET error
-- On MUTUAL reduce production nxlet -> LET error
-- On LISTPUNCT reduce production nxlet -> LET error
-- On LETMUTABLE reduce production nxlet -> LET error
-- On LETAND reduce production nxlet -> LET error
-- On LET reduce production nxlet -> LET error
-- On IN reduce production nxlet -> LET error
-- On EOI reduce production nxlet -> LET error
-- On ENDMUTUAL reduce production nxlet -> LET error
-- On ELSE reduce production nxlet -> LET error
-- On ELIST reduce production nxlet -> LET error
-- On DO reduce production nxlet -> LET error
-- On CLOSENUM reduce production nxlet -> LET error

State 72:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 73
-- On VAR shift to state 7
-- On argvar shift to state 74
## Reductions:
-- On DEFEQ reduce production argvar ->

State 73:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxlet -> LET VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET VAR error
-- On RPAREN reduce production nxlet -> LET VAR error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET VAR error
-- On MUTUAL reduce production nxlet -> LET VAR error
-- On LISTPUNCT reduce production nxlet -> LET VAR error
-- On LETMUTABLE reduce production nxlet -> LET VAR error
-- On LETAND reduce production nxlet -> LET VAR error
-- On LET reduce production nxlet -> LET VAR error
-- On IN reduce production nxlet -> LET VAR error
-- On EOI reduce production nxlet -> LET VAR error
-- On ENDMUTUAL reduce production nxlet -> LET VAR error
-- On ELSE reduce production nxlet -> LET VAR error
-- On ELIST reduce production nxlet -> LET VAR error
-- On DO reduce production nxlet -> LET VAR error
-- On CLOSENUM reduce production nxlet -> LET VAR error

State 74:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 76
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 200
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 76:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET VAR argvar DEFEQ error
-- On RPAREN reduce production nxlet -> LET VAR argvar DEFEQ error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET VAR argvar DEFEQ error
-- On MUTUAL reduce production nxlet -> LET VAR argvar DEFEQ error
-- On LISTPUNCT reduce production nxlet -> LET VAR argvar DEFEQ error
-- On LETMUTABLE reduce production nxlet -> LET VAR argvar DEFEQ error
-- On LETAND reduce production nxlet -> LET VAR argvar DEFEQ error
-- On LET reduce production nxlet -> LET VAR argvar DEFEQ error
-- On IN reduce production nxlet -> LET VAR argvar DEFEQ error
-- On EOI reduce production nxlet -> LET VAR argvar DEFEQ error
-- On ENDMUTUAL reduce production nxlet -> LET VAR argvar DEFEQ error
-- On ELSE reduce production nxlet -> LET VAR argvar DEFEQ error
-- On ELIST reduce production nxlet -> LET VAR argvar DEFEQ error
-- On DO reduce production nxlet -> LET VAR argvar DEFEQ error
-- On CLOSENUM reduce production nxlet -> LET VAR argvar DEFEQ error

State 77:
## Known stack suffix:
## LAMBDA
## LR(1) items:
nxlambda -> LAMBDA . argvar ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . argvar ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 78
-- On VAR shift to state 7
-- On argvar shift to state 79
## Reductions:
-- On ARROW reduce production argvar ->

State 78:
## Known stack suffix:
## LAMBDA error
## LR(1) items:
nxlambda -> LAMBDA error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> LAMBDA error
-- On RPAREN reduce production nxlambda -> LAMBDA error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> LAMBDA error
-- On MUTUAL reduce production nxlambda -> LAMBDA error
-- On LISTPUNCT reduce production nxlambda -> LAMBDA error
-- On LETMUTABLE reduce production nxlambda -> LAMBDA error
-- On LETAND reduce production nxlambda -> LAMBDA error
-- On LET reduce production nxlambda -> LAMBDA error
-- On IN reduce production nxlambda -> LAMBDA error
-- On EOI reduce production nxlambda -> LAMBDA error
-- On ENDMUTUAL reduce production nxlambda -> LAMBDA error
-- On ELSE reduce production nxlambda -> LAMBDA error
-- On ELIST reduce production nxlambda -> LAMBDA error
-- On DO reduce production nxlambda -> LAMBDA error
-- On CLOSENUM reduce production nxlambda -> LAMBDA error
-- On BEFORE reduce production nxlambda -> LAMBDA error

State 79:
## Known stack suffix:
## LAMBDA argvar
## LR(1) items:
nxlambda -> LAMBDA argvar . ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar . ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On ARROW shift to state 80
## Reductions:

State 80:
## Known stack suffix:
## LAMBDA argvar ARROW
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar ARROW . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 81
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 125
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 81:
## Known stack suffix:
## LAMBDA argvar ARROW error
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> LAMBDA argvar ARROW error
-- On RPAREN reduce production nxlambda -> LAMBDA argvar ARROW error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> LAMBDA argvar ARROW error
-- On MUTUAL reduce production nxlambda -> LAMBDA argvar ARROW error
-- On LISTPUNCT reduce production nxlambda -> LAMBDA argvar ARROW error
-- On LETMUTABLE reduce production nxlambda -> LAMBDA argvar ARROW error
-- On LETAND reduce production nxlambda -> LAMBDA argvar ARROW error
-- On LET reduce production nxlambda -> LAMBDA argvar ARROW error
-- On IN reduce production nxlambda -> LAMBDA argvar ARROW error
-- On EOI reduce production nxlambda -> LAMBDA argvar ARROW error
-- On ENDMUTUAL reduce production nxlambda -> LAMBDA argvar ARROW error
-- On ELSE reduce production nxlambda -> LAMBDA argvar ARROW error
-- On ELIST reduce production nxlambda -> LAMBDA argvar ARROW error
-- On DO reduce production nxlambda -> LAMBDA argvar ARROW error
-- On CLOSENUM reduce production nxlambda -> LAMBDA argvar ARROW error
-- On BEFORE reduce production nxlambda -> LAMBDA argvar ARROW error

State 82:
## Known stack suffix:
## nxun
## LR(1) items:
nxltimes -> nxun . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On TIMES shift to state 83
## Reductions:
-- On THEN reduce production nxltimes -> nxun
-- On RPAREN reduce production nxltimes -> nxun
-- On PLUS reduce production nxltimes -> nxun
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxun
-- On NEQ reduce production nxltimes -> nxun
-- On MUTUAL reduce production nxltimes -> nxun
-- On MOD reduce production nxltimes -> nxun
-- On MINUS reduce production nxltimes -> nxun
-- On LT reduce production nxltimes -> nxun
-- On LOR reduce production nxltimes -> nxun
-- On LISTPUNCT reduce production nxltimes -> nxun
-- On LETMUTABLE reduce production nxltimes -> nxun
-- On LETAND reduce production nxltimes -> nxun
-- On LET reduce production nxltimes -> nxun
-- On LEQ reduce production nxltimes -> nxun
-- On LAND reduce production nxltimes -> nxun
-- On IN reduce production nxltimes -> nxun
-- On GT reduce production nxltimes -> nxun
-- On GEQ reduce production nxltimes -> nxun
-- On EQ reduce production nxltimes -> nxun
-- On EOI reduce production nxltimes -> nxun
-- On ENDMUTUAL reduce production nxltimes -> nxun
-- On ELSE reduce production nxltimes -> nxun
-- On ELIST reduce production nxltimes -> nxun
-- On DO reduce production nxltimes -> nxun
-- On DIVIDES reduce production nxltimes -> nxun
-- On CONS reduce production nxltimes -> nxun
-- On CONCAT reduce production nxltimes -> nxun
-- On CLOSENUM reduce production nxltimes -> nxun
-- On BEFORE reduce production nxltimes -> nxun

State 83:
## Known stack suffix:
## nxun TIMES
## LR(1) items:
nxltimes -> nxun TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 84
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 85
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 84:
## Known stack suffix:
## nxun TIMES error
## LR(1) items:
nxltimes -> nxun TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxltimes -> nxun TIMES error
-- On RPAREN reduce production nxltimes -> nxun TIMES error
-- On PLUS reduce production nxltimes -> nxun TIMES error
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxun TIMES error
-- On NEQ reduce production nxltimes -> nxun TIMES error
-- On MUTUAL reduce production nxltimes -> nxun TIMES error
-- On MOD reduce production nxltimes -> nxun TIMES error
-- On MINUS reduce production nxltimes -> nxun TIMES error
-- On LT reduce production nxltimes -> nxun TIMES error
-- On LOR reduce production nxltimes -> nxun TIMES error
-- On LISTPUNCT reduce production nxltimes -> nxun TIMES error
-- On LETMUTABLE reduce production nxltimes -> nxun TIMES error
-- On LETAND reduce production nxltimes -> nxun TIMES error
-- On LET reduce production nxltimes -> nxun TIMES error
-- On LEQ reduce production nxltimes -> nxun TIMES error
-- On LAND reduce production nxltimes -> nxun TIMES error
-- On IN reduce production nxltimes -> nxun TIMES error
-- On GT reduce production nxltimes -> nxun TIMES error
-- On GEQ reduce production nxltimes -> nxun TIMES error
-- On EQ reduce production nxltimes -> nxun TIMES error
-- On EOI reduce production nxltimes -> nxun TIMES error
-- On ENDMUTUAL reduce production nxltimes -> nxun TIMES error
-- On ELSE reduce production nxltimes -> nxun TIMES error
-- On ELIST reduce production nxltimes -> nxun TIMES error
-- On DO reduce production nxltimes -> nxun TIMES error
-- On DIVIDES reduce production nxltimes -> nxun TIMES error
-- On CONS reduce production nxltimes -> nxun TIMES error
-- On CONCAT reduce production nxltimes -> nxun TIMES error
-- On CLOSENUM reduce production nxltimes -> nxun TIMES error
-- On BEFORE reduce production nxltimes -> nxun TIMES error

State 85:
## Known stack suffix:
## nxun TIMES nxrtimes
## LR(1) items:
nxltimes -> nxun TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxltimes -> nxun TIMES nxrtimes
-- On RPAREN reduce production nxltimes -> nxun TIMES nxrtimes
-- On PLUS reduce production nxltimes -> nxun TIMES nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxun TIMES nxrtimes
-- On NEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On MUTUAL reduce production nxltimes -> nxun TIMES nxrtimes
-- On MINUS reduce production nxltimes -> nxun TIMES nxrtimes
-- On LT reduce production nxltimes -> nxun TIMES nxrtimes
-- On LOR reduce production nxltimes -> nxun TIMES nxrtimes
-- On LISTPUNCT reduce production nxltimes -> nxun TIMES nxrtimes
-- On LETMUTABLE reduce production nxltimes -> nxun TIMES nxrtimes
-- On LETAND reduce production nxltimes -> nxun TIMES nxrtimes
-- On LET reduce production nxltimes -> nxun TIMES nxrtimes
-- On LEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On LAND reduce production nxltimes -> nxun TIMES nxrtimes
-- On IN reduce production nxltimes -> nxun TIMES nxrtimes
-- On GT reduce production nxltimes -> nxun TIMES nxrtimes
-- On GEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On EQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On EOI reduce production nxltimes -> nxun TIMES nxrtimes
-- On ENDMUTUAL reduce production nxltimes -> nxun TIMES nxrtimes
-- On ELSE reduce production nxltimes -> nxun TIMES nxrtimes
-- On ELIST reduce production nxltimes -> nxun TIMES nxrtimes
-- On DO reduce production nxltimes -> nxun TIMES nxrtimes
-- On CONS reduce production nxltimes -> nxun TIMES nxrtimes
-- On CONCAT reduce production nxltimes -> nxun TIMES nxrtimes
-- On CLOSENUM reduce production nxltimes -> nxun TIMES nxrtimes
-- On BEFORE reduce production nxltimes -> nxun TIMES nxrtimes

State 86:
## Known stack suffix:
## nxrtimes MOD
## LR(1) items:
nxrtimes -> nxrtimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 87
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 88
## Reductions:

State 87:
## Known stack suffix:
## nxrtimes MOD error
## LR(1) items:
nxrtimes -> nxrtimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes MOD error
-- On RPAREN reduce production nxrtimes -> nxrtimes MOD error
-- On PLUS reduce production nxrtimes -> nxrtimes MOD error
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes MOD error
-- On NEQ reduce production nxrtimes -> nxrtimes MOD error
-- On MUTUAL reduce production nxrtimes -> nxrtimes MOD error
-- On MOD reduce production nxrtimes -> nxrtimes MOD error
-- On MINUS reduce production nxrtimes -> nxrtimes MOD error
-- On LT reduce production nxrtimes -> nxrtimes MOD error
-- On LOR reduce production nxrtimes -> nxrtimes MOD error
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes MOD error
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes MOD error
-- On LETAND reduce production nxrtimes -> nxrtimes MOD error
-- On LET reduce production nxrtimes -> nxrtimes MOD error
-- On LEQ reduce production nxrtimes -> nxrtimes MOD error
-- On LAND reduce production nxrtimes -> nxrtimes MOD error
-- On IN reduce production nxrtimes -> nxrtimes MOD error
-- On GT reduce production nxrtimes -> nxrtimes MOD error
-- On GEQ reduce production nxrtimes -> nxrtimes MOD error
-- On EQ reduce production nxrtimes -> nxrtimes MOD error
-- On EOI reduce production nxrtimes -> nxrtimes MOD error
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes MOD error
-- On ELSE reduce production nxrtimes -> nxrtimes MOD error
-- On ELIST reduce production nxrtimes -> nxrtimes MOD error
-- On DO reduce production nxrtimes -> nxrtimes MOD error
-- On DIVIDES reduce production nxrtimes -> nxrtimes MOD error
-- On CONS reduce production nxrtimes -> nxrtimes MOD error
-- On CONCAT reduce production nxrtimes -> nxrtimes MOD error
-- On CLOSENUM reduce production nxrtimes -> nxrtimes MOD error
-- On BEFORE reduce production nxrtimes -> nxrtimes MOD error

State 88:
## Known stack suffix:
## nxrtimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On RPAREN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On PLUS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes MOD nxapp
-- On NEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MUTUAL reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MOD reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MINUS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LOR reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LETAND reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LET reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LAND reduce production nxrtimes -> nxrtimes MOD nxapp
-- On IN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On GT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On GEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On EQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On EOI reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ELSE reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ELIST reduce production nxrtimes -> nxrtimes MOD nxapp
-- On DO reduce production nxrtimes -> nxrtimes MOD nxapp
-- On DIVIDES reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CONS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CONCAT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CLOSENUM reduce production nxrtimes -> nxrtimes MOD nxapp
-- On BEFORE reduce production nxrtimes -> nxrtimes MOD nxapp

State 89:
## Known stack suffix:
## nxrtimes DIVIDES
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 90
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 91
## Reductions:

State 90:
## Known stack suffix:
## nxrtimes DIVIDES error
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes DIVIDES error
-- On RPAREN reduce production nxrtimes -> nxrtimes DIVIDES error
-- On PLUS reduce production nxrtimes -> nxrtimes DIVIDES error
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes DIVIDES error
-- On NEQ reduce production nxrtimes -> nxrtimes DIVIDES error
-- On MUTUAL reduce production nxrtimes -> nxrtimes DIVIDES error
-- On MOD reduce production nxrtimes -> nxrtimes DIVIDES error
-- On MINUS reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LT reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LOR reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LETAND reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LET reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LEQ reduce production nxrtimes -> nxrtimes DIVIDES error
-- On LAND reduce production nxrtimes -> nxrtimes DIVIDES error
-- On IN reduce production nxrtimes -> nxrtimes DIVIDES error
-- On GT reduce production nxrtimes -> nxrtimes DIVIDES error
-- On GEQ reduce production nxrtimes -> nxrtimes DIVIDES error
-- On EQ reduce production nxrtimes -> nxrtimes DIVIDES error
-- On EOI reduce production nxrtimes -> nxrtimes DIVIDES error
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes DIVIDES error
-- On ELSE reduce production nxrtimes -> nxrtimes DIVIDES error
-- On ELIST reduce production nxrtimes -> nxrtimes DIVIDES error
-- On DO reduce production nxrtimes -> nxrtimes DIVIDES error
-- On DIVIDES reduce production nxrtimes -> nxrtimes DIVIDES error
-- On CONS reduce production nxrtimes -> nxrtimes DIVIDES error
-- On CONCAT reduce production nxrtimes -> nxrtimes DIVIDES error
-- On CLOSENUM reduce production nxrtimes -> nxrtimes DIVIDES error
-- On BEFORE reduce production nxrtimes -> nxrtimes DIVIDES error

State 91:
## Known stack suffix:
## nxrtimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On RPAREN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On PLUS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On NEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MUTUAL reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MOD reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MINUS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LOR reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LETAND reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LET reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LAND reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On IN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On GT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On GEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On EQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On EOI reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ELSE reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ELIST reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On DO reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On DIVIDES reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CONS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CONCAT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CLOSENUM reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On BEFORE reduce production nxrtimes -> nxrtimes DIVIDES nxapp

State 92:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxapp . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 93
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxapp
-- On RPAREN reduce production nxrtimes -> nxapp
-- On PLUS reduce production nxrtimes -> nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxapp
-- On NEQ reduce production nxrtimes -> nxapp
-- On MUTUAL reduce production nxrtimes -> nxapp
-- On MOD reduce production nxrtimes -> nxapp
-- On MINUS reduce production nxrtimes -> nxapp
-- On LT reduce production nxrtimes -> nxapp
-- On LOR reduce production nxrtimes -> nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxapp
-- On LETAND reduce production nxrtimes -> nxapp
-- On LET reduce production nxrtimes -> nxapp
-- On LEQ reduce production nxrtimes -> nxapp
-- On LAND reduce production nxrtimes -> nxapp
-- On IN reduce production nxrtimes -> nxapp
-- On GT reduce production nxrtimes -> nxapp
-- On GEQ reduce production nxrtimes -> nxapp
-- On EQ reduce production nxrtimes -> nxapp
-- On EOI reduce production nxrtimes -> nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxapp
-- On ELSE reduce production nxrtimes -> nxapp
-- On ELIST reduce production nxrtimes -> nxapp
-- On DO reduce production nxrtimes -> nxapp
-- On DIVIDES reduce production nxrtimes -> nxapp
-- On CONS reduce production nxrtimes -> nxapp
-- On CONCAT reduce production nxrtimes -> nxapp
-- On CLOSENUM reduce production nxrtimes -> nxapp
-- On BEFORE reduce production nxrtimes -> nxapp

State 93:
## Known stack suffix:
## nxapp TIMES
## LR(1) items:
nxrtimes -> nxapp TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 94
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 95
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 94:
## Known stack suffix:
## nxapp TIMES error
## LR(1) items:
nxrtimes -> nxapp TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxrtimes -> nxapp TIMES error
-- On RPAREN reduce production nxrtimes -> nxapp TIMES error
-- On PLUS reduce production nxrtimes -> nxapp TIMES error
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxapp TIMES error
-- On NEQ reduce production nxrtimes -> nxapp TIMES error
-- On MUTUAL reduce production nxrtimes -> nxapp TIMES error
-- On MOD reduce production nxrtimes -> nxapp TIMES error
-- On MINUS reduce production nxrtimes -> nxapp TIMES error
-- On LT reduce production nxrtimes -> nxapp TIMES error
-- On LOR reduce production nxrtimes -> nxapp TIMES error
-- On LISTPUNCT reduce production nxrtimes -> nxapp TIMES error
-- On LETMUTABLE reduce production nxrtimes -> nxapp TIMES error
-- On LETAND reduce production nxrtimes -> nxapp TIMES error
-- On LET reduce production nxrtimes -> nxapp TIMES error
-- On LEQ reduce production nxrtimes -> nxapp TIMES error
-- On LAND reduce production nxrtimes -> nxapp TIMES error
-- On IN reduce production nxrtimes -> nxapp TIMES error
-- On GT reduce production nxrtimes -> nxapp TIMES error
-- On GEQ reduce production nxrtimes -> nxapp TIMES error
-- On EQ reduce production nxrtimes -> nxapp TIMES error
-- On EOI reduce production nxrtimes -> nxapp TIMES error
-- On ENDMUTUAL reduce production nxrtimes -> nxapp TIMES error
-- On ELSE reduce production nxrtimes -> nxapp TIMES error
-- On ELIST reduce production nxrtimes -> nxapp TIMES error
-- On DO reduce production nxrtimes -> nxapp TIMES error
-- On DIVIDES reduce production nxrtimes -> nxapp TIMES error
-- On CONS reduce production nxrtimes -> nxapp TIMES error
-- On CONCAT reduce production nxrtimes -> nxapp TIMES error
-- On CLOSENUM reduce production nxrtimes -> nxapp TIMES error
-- On BEFORE reduce production nxrtimes -> nxapp TIMES error

State 95:
## Known stack suffix:
## nxapp TIMES nxrtimes
## LR(1) items:
nxrtimes -> nxapp TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On RPAREN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On PLUS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On NEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On MUTUAL reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On MINUS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LOR reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LISTPUNCT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LETMUTABLE reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LETAND reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LET reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LAND reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On IN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On GT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On GEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On EQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On EOI reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ENDMUTUAL reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ELSE reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ELIST reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On DO reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CONS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CONCAT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CLOSENUM reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On BEFORE reduce production nxrtimes -> nxapp TIMES nxrtimes

State 96:
## Known stack suffix:
## nxltimes
## LR(1) items:
nxlminus -> nxltimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 97
-- On DIVIDES shift to state 100
## Reductions:
-- On THEN reduce production nxlminus -> nxltimes
-- On RPAREN reduce production nxlminus -> nxltimes
-- On PLUS reduce production nxlminus -> nxltimes
-- On OVERWRITEGLOBALHASH reduce production nxlminus -> nxltimes
-- On NEQ reduce production nxlminus -> nxltimes
-- On MUTUAL reduce production nxlminus -> nxltimes
-- On MINUS reduce production nxlminus -> nxltimes
-- On LT reduce production nxlminus -> nxltimes
-- On LOR reduce production nxlminus -> nxltimes
-- On LISTPUNCT reduce production nxlminus -> nxltimes
-- On LETMUTABLE reduce production nxlminus -> nxltimes
-- On LETAND reduce production nxlminus -> nxltimes
-- On LET reduce production nxlminus -> nxltimes
-- On LEQ reduce production nxlminus -> nxltimes
-- On LAND reduce production nxlminus -> nxltimes
-- On IN reduce production nxlminus -> nxltimes
-- On GT reduce production nxlminus -> nxltimes
-- On GEQ reduce production nxlminus -> nxltimes
-- On EQ reduce production nxlminus -> nxltimes
-- On EOI reduce production nxlminus -> nxltimes
-- On ENDMUTUAL reduce production nxlminus -> nxltimes
-- On ELSE reduce production nxlminus -> nxltimes
-- On ELIST reduce production nxlminus -> nxltimes
-- On DO reduce production nxlminus -> nxltimes
-- On CONS reduce production nxlminus -> nxltimes
-- On CONCAT reduce production nxlminus -> nxltimes
-- On CLOSENUM reduce production nxlminus -> nxltimes
-- On BEFORE reduce production nxlminus -> nxltimes

State 97:
## Known stack suffix:
## nxltimes MOD
## LR(1) items:
nxltimes -> nxltimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 98
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 99
## Reductions:

State 98:
## Known stack suffix:
## nxltimes MOD error
## LR(1) items:
nxltimes -> nxltimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes MOD error
-- On RPAREN reduce production nxltimes -> nxltimes MOD error
-- On PLUS reduce production nxltimes -> nxltimes MOD error
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes MOD error
-- On NEQ reduce production nxltimes -> nxltimes MOD error
-- On MUTUAL reduce production nxltimes -> nxltimes MOD error
-- On MOD reduce production nxltimes -> nxltimes MOD error
-- On MINUS reduce production nxltimes -> nxltimes MOD error
-- On LT reduce production nxltimes -> nxltimes MOD error
-- On LOR reduce production nxltimes -> nxltimes MOD error
-- On LISTPUNCT reduce production nxltimes -> nxltimes MOD error
-- On LETMUTABLE reduce production nxltimes -> nxltimes MOD error
-- On LETAND reduce production nxltimes -> nxltimes MOD error
-- On LET reduce production nxltimes -> nxltimes MOD error
-- On LEQ reduce production nxltimes -> nxltimes MOD error
-- On LAND reduce production nxltimes -> nxltimes MOD error
-- On IN reduce production nxltimes -> nxltimes MOD error
-- On GT reduce production nxltimes -> nxltimes MOD error
-- On GEQ reduce production nxltimes -> nxltimes MOD error
-- On EQ reduce production nxltimes -> nxltimes MOD error
-- On EOI reduce production nxltimes -> nxltimes MOD error
-- On ENDMUTUAL reduce production nxltimes -> nxltimes MOD error
-- On ELSE reduce production nxltimes -> nxltimes MOD error
-- On ELIST reduce production nxltimes -> nxltimes MOD error
-- On DO reduce production nxltimes -> nxltimes MOD error
-- On DIVIDES reduce production nxltimes -> nxltimes MOD error
-- On CONS reduce production nxltimes -> nxltimes MOD error
-- On CONCAT reduce production nxltimes -> nxltimes MOD error
-- On CLOSENUM reduce production nxltimes -> nxltimes MOD error
-- On BEFORE reduce production nxltimes -> nxltimes MOD error

State 99:
## Known stack suffix:
## nxltimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes MOD nxapp
-- On RPAREN reduce production nxltimes -> nxltimes MOD nxapp
-- On PLUS reduce production nxltimes -> nxltimes MOD nxapp
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes MOD nxapp
-- On NEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On MUTUAL reduce production nxltimes -> nxltimes MOD nxapp
-- On MOD reduce production nxltimes -> nxltimes MOD nxapp
-- On MINUS reduce production nxltimes -> nxltimes MOD nxapp
-- On LT reduce production nxltimes -> nxltimes MOD nxapp
-- On LOR reduce production nxltimes -> nxltimes MOD nxapp
-- On LISTPUNCT reduce production nxltimes -> nxltimes MOD nxapp
-- On LETMUTABLE reduce production nxltimes -> nxltimes MOD nxapp
-- On LETAND reduce production nxltimes -> nxltimes MOD nxapp
-- On LET reduce production nxltimes -> nxltimes MOD nxapp
-- On LEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On LAND reduce production nxltimes -> nxltimes MOD nxapp
-- On IN reduce production nxltimes -> nxltimes MOD nxapp
-- On GT reduce production nxltimes -> nxltimes MOD nxapp
-- On GEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On EQ reduce production nxltimes -> nxltimes MOD nxapp
-- On EOI reduce production nxltimes -> nxltimes MOD nxapp
-- On ENDMUTUAL reduce production nxltimes -> nxltimes MOD nxapp
-- On ELSE reduce production nxltimes -> nxltimes MOD nxapp
-- On ELIST reduce production nxltimes -> nxltimes MOD nxapp
-- On DO reduce production nxltimes -> nxltimes MOD nxapp
-- On DIVIDES reduce production nxltimes -> nxltimes MOD nxapp
-- On CONS reduce production nxltimes -> nxltimes MOD nxapp
-- On CONCAT reduce production nxltimes -> nxltimes MOD nxapp
-- On CLOSENUM reduce production nxltimes -> nxltimes MOD nxapp
-- On BEFORE reduce production nxltimes -> nxltimes MOD nxapp

State 100:
## Known stack suffix:
## nxltimes DIVIDES
## LR(1) items:
nxltimes -> nxltimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 101
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 102
## Reductions:

State 101:
## Known stack suffix:
## nxltimes DIVIDES error
## LR(1) items:
nxltimes -> nxltimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes DIVIDES error
-- On RPAREN reduce production nxltimes -> nxltimes DIVIDES error
-- On PLUS reduce production nxltimes -> nxltimes DIVIDES error
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes DIVIDES error
-- On NEQ reduce production nxltimes -> nxltimes DIVIDES error
-- On MUTUAL reduce production nxltimes -> nxltimes DIVIDES error
-- On MOD reduce production nxltimes -> nxltimes DIVIDES error
-- On MINUS reduce production nxltimes -> nxltimes DIVIDES error
-- On LT reduce production nxltimes -> nxltimes DIVIDES error
-- On LOR reduce production nxltimes -> nxltimes DIVIDES error
-- On LISTPUNCT reduce production nxltimes -> nxltimes DIVIDES error
-- On LETMUTABLE reduce production nxltimes -> nxltimes DIVIDES error
-- On LETAND reduce production nxltimes -> nxltimes DIVIDES error
-- On LET reduce production nxltimes -> nxltimes DIVIDES error
-- On LEQ reduce production nxltimes -> nxltimes DIVIDES error
-- On LAND reduce production nxltimes -> nxltimes DIVIDES error
-- On IN reduce production nxltimes -> nxltimes DIVIDES error
-- On GT reduce production nxltimes -> nxltimes DIVIDES error
-- On GEQ reduce production nxltimes -> nxltimes DIVIDES error
-- On EQ reduce production nxltimes -> nxltimes DIVIDES error
-- On EOI reduce production nxltimes -> nxltimes DIVIDES error
-- On ENDMUTUAL reduce production nxltimes -> nxltimes DIVIDES error
-- On ELSE reduce production nxltimes -> nxltimes DIVIDES error
-- On ELIST reduce production nxltimes -> nxltimes DIVIDES error
-- On DO reduce production nxltimes -> nxltimes DIVIDES error
-- On DIVIDES reduce production nxltimes -> nxltimes DIVIDES error
-- On CONS reduce production nxltimes -> nxltimes DIVIDES error
-- On CONCAT reduce production nxltimes -> nxltimes DIVIDES error
-- On CLOSENUM reduce production nxltimes -> nxltimes DIVIDES error
-- On BEFORE reduce production nxltimes -> nxltimes DIVIDES error

State 102:
## Known stack suffix:
## nxltimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On RPAREN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On PLUS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On NEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MUTUAL reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MOD reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MINUS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LOR reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LISTPUNCT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LETMUTABLE reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LETAND reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LET reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LAND reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On IN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On GT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On GEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On EQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On EOI reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ENDMUTUAL reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ELSE reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ELIST reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On DO reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On DIVIDES reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CONS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CONCAT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CLOSENUM reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On BEFORE reduce production nxltimes -> nxltimes DIVIDES nxapp

State 103:
## Known stack suffix:
## nxlplus
## LR(1) items:
nxconcat -> nxlplus . CONCAT nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONS nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONCAT error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 104
-- On CONS shift to state 107
-- On CONCAT shift to state 122
## Reductions:
-- On THEN reduce production nxconcat -> nxlplus
-- On RPAREN reduce production nxconcat -> nxlplus
-- On OVERWRITEGLOBALHASH reduce production nxconcat -> nxlplus
-- On NEQ reduce production nxconcat -> nxlplus
-- On MUTUAL reduce production nxconcat -> nxlplus
-- On LT reduce production nxconcat -> nxlplus
-- On LOR reduce production nxconcat -> nxlplus
-- On LISTPUNCT reduce production nxconcat -> nxlplus
-- On LETMUTABLE reduce production nxconcat -> nxlplus
-- On LETAND reduce production nxconcat -> nxlplus
-- On LET reduce production nxconcat -> nxlplus
-- On LEQ reduce production nxconcat -> nxlplus
-- On LAND reduce production nxconcat -> nxlplus
-- On IN reduce production nxconcat -> nxlplus
-- On GT reduce production nxconcat -> nxlplus
-- On GEQ reduce production nxconcat -> nxlplus
-- On EQ reduce production nxconcat -> nxlplus
-- On EOI reduce production nxconcat -> nxlplus
-- On ENDMUTUAL reduce production nxconcat -> nxlplus
-- On ELSE reduce production nxconcat -> nxlplus
-- On ELIST reduce production nxconcat -> nxlplus
-- On DO reduce production nxconcat -> nxlplus
-- On CLOSENUM reduce production nxconcat -> nxlplus
-- On BEFORE reduce production nxconcat -> nxlplus

State 104:
## Known stack suffix:
## nxlplus MINUS
## LR(1) items:
nxlminus -> nxlplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 105
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 106
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 105:
## Known stack suffix:
## nxlplus MINUS error
## LR(1) items:
nxlminus -> nxlplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlminus -> nxlplus MINUS error
-- On RPAREN reduce production nxlminus -> nxlplus MINUS error
-- On PLUS reduce production nxlminus -> nxlplus MINUS error
-- On OVERWRITEGLOBALHASH reduce production nxlminus -> nxlplus MINUS error
-- On NEQ reduce production nxlminus -> nxlplus MINUS error
-- On MUTUAL reduce production nxlminus -> nxlplus MINUS error
-- On MINUS reduce production nxlminus -> nxlplus MINUS error
-- On LT reduce production nxlminus -> nxlplus MINUS error
-- On LOR reduce production nxlminus -> nxlplus MINUS error
-- On LISTPUNCT reduce production nxlminus -> nxlplus MINUS error
-- On LETMUTABLE reduce production nxlminus -> nxlplus MINUS error
-- On LETAND reduce production nxlminus -> nxlplus MINUS error
-- On LET reduce production nxlminus -> nxlplus MINUS error
-- On LEQ reduce production nxlminus -> nxlplus MINUS error
-- On LAND reduce production nxlminus -> nxlplus MINUS error
-- On IN reduce production nxlminus -> nxlplus MINUS error
-- On GT reduce production nxlminus -> nxlplus MINUS error
-- On GEQ reduce production nxlminus -> nxlplus MINUS error
-- On EQ reduce production nxlminus -> nxlplus MINUS error
-- On EOI reduce production nxlminus -> nxlplus MINUS error
-- On ENDMUTUAL reduce production nxlminus -> nxlplus MINUS error
-- On ELSE reduce production nxlminus -> nxlplus MINUS error
-- On ELIST reduce production nxlminus -> nxlplus MINUS error
-- On DO reduce production nxlminus -> nxlplus MINUS error
-- On CONS reduce production nxlminus -> nxlplus MINUS error
-- On CONCAT reduce production nxlminus -> nxlplus MINUS error
-- On CLOSENUM reduce production nxlminus -> nxlplus MINUS error
-- On BEFORE reduce production nxlminus -> nxlplus MINUS error

State 106:
## Known stack suffix:
## nxlplus MINUS nxrtimes
## LR(1) items:
nxlminus -> nxlplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On RPAREN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On PLUS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On NEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On MUTUAL reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On MINUS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LOR reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LISTPUNCT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LETMUTABLE reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LETAND reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LET reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LAND reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On IN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On GT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On GEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On EQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On EOI reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ENDMUTUAL reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ELSE reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ELIST reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On DO reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CONS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CONCAT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CLOSENUM reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On BEFORE reduce production nxlminus -> nxlplus MINUS nxrtimes

State 107:
## Known stack suffix:
## nxlplus CONS
## LR(1) items:
nxconcat -> nxlplus CONS . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 120
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 108:
## Known stack suffix:
## nxlminus
## LR(1) items:
nxlplus -> nxlminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 109
## Reductions:
-- On THEN reduce production nxlplus -> nxlminus
-- On RPAREN reduce production nxlplus -> nxlminus
-- On OVERWRITEGLOBALHASH reduce production nxlplus -> nxlminus
-- On NEQ reduce production nxlplus -> nxlminus
-- On MUTUAL reduce production nxlplus -> nxlminus
-- On MINUS reduce production nxlplus -> nxlminus
-- On LT reduce production nxlplus -> nxlminus
-- On LOR reduce production nxlplus -> nxlminus
-- On LISTPUNCT reduce production nxlplus -> nxlminus
-- On LETMUTABLE reduce production nxlplus -> nxlminus
-- On LETAND reduce production nxlplus -> nxlminus
-- On LET reduce production nxlplus -> nxlminus
-- On LEQ reduce production nxlplus -> nxlminus
-- On LAND reduce production nxlplus -> nxlminus
-- On IN reduce production nxlplus -> nxlminus
-- On GT reduce production nxlplus -> nxlminus
-- On GEQ reduce production nxlplus -> nxlminus
-- On EQ reduce production nxlplus -> nxlminus
-- On EOI reduce production nxlplus -> nxlminus
-- On ENDMUTUAL reduce production nxlplus -> nxlminus
-- On ELSE reduce production nxlplus -> nxlminus
-- On ELIST reduce production nxlplus -> nxlminus
-- On DO reduce production nxlplus -> nxlminus
-- On CONS reduce production nxlplus -> nxlminus
-- On CONCAT reduce production nxlplus -> nxlminus
-- On CLOSENUM reduce production nxlplus -> nxlminus
-- On BEFORE reduce production nxlplus -> nxlminus

State 109:
## Known stack suffix:
## nxlminus PLUS
## LR(1) items:
nxlplus -> nxlminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 110
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 112
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 110:
## Known stack suffix:
## nxlminus PLUS error
## LR(1) items:
nxlplus -> nxlminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlplus -> nxlminus PLUS error
-- On RPAREN reduce production nxlplus -> nxlminus PLUS error
-- On OVERWRITEGLOBALHASH reduce production nxlplus -> nxlminus PLUS error
-- On NEQ reduce production nxlplus -> nxlminus PLUS error
-- On MUTUAL reduce production nxlplus -> nxlminus PLUS error
-- On MINUS reduce production nxlplus -> nxlminus PLUS error
-- On LT reduce production nxlplus -> nxlminus PLUS error
-- On LOR reduce production nxlplus -> nxlminus PLUS error
-- On LISTPUNCT reduce production nxlplus -> nxlminus PLUS error
-- On LETMUTABLE reduce production nxlplus -> nxlminus PLUS error
-- On LETAND reduce production nxlplus -> nxlminus PLUS error
-- On LET reduce production nxlplus -> nxlminus PLUS error
-- On LEQ reduce production nxlplus -> nxlminus PLUS error
-- On LAND reduce production nxlplus -> nxlminus PLUS error
-- On IN reduce production nxlplus -> nxlminus PLUS error
-- On GT reduce production nxlplus -> nxlminus PLUS error
-- On GEQ reduce production nxlplus -> nxlminus PLUS error
-- On EQ reduce production nxlplus -> nxlminus PLUS error
-- On EOI reduce production nxlplus -> nxlminus PLUS error
-- On ENDMUTUAL reduce production nxlplus -> nxlminus PLUS error
-- On ELSE reduce production nxlplus -> nxlminus PLUS error
-- On ELIST reduce production nxlplus -> nxlminus PLUS error
-- On DO reduce production nxlplus -> nxlminus PLUS error
-- On CONS reduce production nxlplus -> nxlminus PLUS error
-- On CONCAT reduce production nxlplus -> nxlminus PLUS error
-- On CLOSENUM reduce production nxlplus -> nxlminus PLUS error
-- On BEFORE reduce production nxlplus -> nxlminus PLUS error

State 111:
## Known stack suffix:
## nxrtimes
## LR(1) items:
nxrminus -> nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrminus -> nxrtimes
-- On RPAREN reduce production nxrminus -> nxrtimes
-- On PLUS reduce production nxrminus -> nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrminus -> nxrtimes
-- On NEQ reduce production nxrminus -> nxrtimes
-- On MUTUAL reduce production nxrminus -> nxrtimes
-- On MINUS reduce production nxrminus -> nxrtimes
-- On LT reduce production nxrminus -> nxrtimes
-- On LOR reduce production nxrminus -> nxrtimes
-- On LISTPUNCT reduce production nxrminus -> nxrtimes
-- On LETMUTABLE reduce production nxrminus -> nxrtimes
-- On LETAND reduce production nxrminus -> nxrtimes
-- On LET reduce production nxrminus -> nxrtimes
-- On LEQ reduce production nxrminus -> nxrtimes
-- On LAND reduce production nxrminus -> nxrtimes
-- On IN reduce production nxrminus -> nxrtimes
-- On GT reduce production nxrminus -> nxrtimes
-- On GEQ reduce production nxrminus -> nxrtimes
-- On EQ reduce production nxrminus -> nxrtimes
-- On EOI reduce production nxrminus -> nxrtimes
-- On ENDMUTUAL reduce production nxrminus -> nxrtimes
-- On ELSE reduce production nxrminus -> nxrtimes
-- On ELIST reduce production nxrminus -> nxrtimes
-- On DO reduce production nxrminus -> nxrtimes
-- On CONS reduce production nxrminus -> nxrtimes
-- On CONCAT reduce production nxrminus -> nxrtimes
-- On CLOSENUM reduce production nxrminus -> nxrtimes
-- On BEFORE reduce production nxrminus -> nxrtimes

State 112:
## Known stack suffix:
## nxlminus PLUS nxrplus
## LR(1) items:
nxlplus -> nxlminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On RPAREN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On OVERWRITEGLOBALHASH reduce production nxlplus -> nxlminus PLUS nxrplus
-- On NEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On MUTUAL reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LOR reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LISTPUNCT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LETMUTABLE reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LETAND reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LET reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LAND reduce production nxlplus -> nxlminus PLUS nxrplus
-- On IN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On GT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On GEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On EQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On EOI reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ENDMUTUAL reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ELSE reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ELIST reduce production nxlplus -> nxlminus PLUS nxrplus
-- On DO reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CONS reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CONCAT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CLOSENUM reduce production nxlplus -> nxlminus PLUS nxrplus
-- On BEFORE reduce production nxlplus -> nxlminus PLUS nxrplus

State 113:
## Known stack suffix:
## nxrplus MINUS
## LR(1) items:
nxrminus -> nxrplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 114
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 115
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 114:
## Known stack suffix:
## nxrplus MINUS error
## LR(1) items:
nxrminus -> nxrplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxrminus -> nxrplus MINUS error
-- On RPAREN reduce production nxrminus -> nxrplus MINUS error
-- On PLUS reduce production nxrminus -> nxrplus MINUS error
-- On OVERWRITEGLOBALHASH reduce production nxrminus -> nxrplus MINUS error
-- On NEQ reduce production nxrminus -> nxrplus MINUS error
-- On MUTUAL reduce production nxrminus -> nxrplus MINUS error
-- On MINUS reduce production nxrminus -> nxrplus MINUS error
-- On LT reduce production nxrminus -> nxrplus MINUS error
-- On LOR reduce production nxrminus -> nxrplus MINUS error
-- On LISTPUNCT reduce production nxrminus -> nxrplus MINUS error
-- On LETMUTABLE reduce production nxrminus -> nxrplus MINUS error
-- On LETAND reduce production nxrminus -> nxrplus MINUS error
-- On LET reduce production nxrminus -> nxrplus MINUS error
-- On LEQ reduce production nxrminus -> nxrplus MINUS error
-- On LAND reduce production nxrminus -> nxrplus MINUS error
-- On IN reduce production nxrminus -> nxrplus MINUS error
-- On GT reduce production nxrminus -> nxrplus MINUS error
-- On GEQ reduce production nxrminus -> nxrplus MINUS error
-- On EQ reduce production nxrminus -> nxrplus MINUS error
-- On EOI reduce production nxrminus -> nxrplus MINUS error
-- On ENDMUTUAL reduce production nxrminus -> nxrplus MINUS error
-- On ELSE reduce production nxrminus -> nxrplus MINUS error
-- On ELIST reduce production nxrminus -> nxrplus MINUS error
-- On DO reduce production nxrminus -> nxrplus MINUS error
-- On CONS reduce production nxrminus -> nxrplus MINUS error
-- On CONCAT reduce production nxrminus -> nxrplus MINUS error
-- On CLOSENUM reduce production nxrminus -> nxrplus MINUS error
-- On BEFORE reduce production nxrminus -> nxrplus MINUS error

State 115:
## Known stack suffix:
## nxrplus MINUS nxrtimes
## LR(1) items:
nxrminus -> nxrplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On RPAREN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On PLUS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On NEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On MUTUAL reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On MINUS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LOR reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LISTPUNCT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LETMUTABLE reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LETAND reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LET reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LAND reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On IN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On GT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On GEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On EQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On EOI reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ENDMUTUAL reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ELSE reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ELIST reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On DO reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CONS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CONCAT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CLOSENUM reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On BEFORE reduce production nxrminus -> nxrplus MINUS nxrtimes

State 116:
## Known stack suffix:
## nxrminus
## LR(1) items:
nxrplus -> nxrminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 117
## Reductions:
-- On THEN reduce production nxrplus -> nxrminus
-- On RPAREN reduce production nxrplus -> nxrminus
-- On OVERWRITEGLOBALHASH reduce production nxrplus -> nxrminus
-- On NEQ reduce production nxrplus -> nxrminus
-- On MUTUAL reduce production nxrplus -> nxrminus
-- On MINUS reduce production nxrplus -> nxrminus
-- On LT reduce production nxrplus -> nxrminus
-- On LOR reduce production nxrplus -> nxrminus
-- On LISTPUNCT reduce production nxrplus -> nxrminus
-- On LETMUTABLE reduce production nxrplus -> nxrminus
-- On LETAND reduce production nxrplus -> nxrminus
-- On LET reduce production nxrplus -> nxrminus
-- On LEQ reduce production nxrplus -> nxrminus
-- On LAND reduce production nxrplus -> nxrminus
-- On IN reduce production nxrplus -> nxrminus
-- On GT reduce production nxrplus -> nxrminus
-- On GEQ reduce production nxrplus -> nxrminus
-- On EQ reduce production nxrplus -> nxrminus
-- On EOI reduce production nxrplus -> nxrminus
-- On ENDMUTUAL reduce production nxrplus -> nxrminus
-- On ELSE reduce production nxrplus -> nxrminus
-- On ELIST reduce production nxrplus -> nxrminus
-- On DO reduce production nxrplus -> nxrminus
-- On CONS reduce production nxrplus -> nxrminus
-- On CONCAT reduce production nxrplus -> nxrminus
-- On CLOSENUM reduce production nxrplus -> nxrminus
-- On BEFORE reduce production nxrplus -> nxrminus

State 117:
## Known stack suffix:
## nxrminus PLUS
## LR(1) items:
nxrplus -> nxrminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 118
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 119
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 118:
## Known stack suffix:
## nxrminus PLUS error
## LR(1) items:
nxrplus -> nxrminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxrplus -> nxrminus PLUS error
-- On RPAREN reduce production nxrplus -> nxrminus PLUS error
-- On OVERWRITEGLOBALHASH reduce production nxrplus -> nxrminus PLUS error
-- On NEQ reduce production nxrplus -> nxrminus PLUS error
-- On MUTUAL reduce production nxrplus -> nxrminus PLUS error
-- On MINUS reduce production nxrplus -> nxrminus PLUS error
-- On LT reduce production nxrplus -> nxrminus PLUS error
-- On LOR reduce production nxrplus -> nxrminus PLUS error
-- On LISTPUNCT reduce production nxrplus -> nxrminus PLUS error
-- On LETMUTABLE reduce production nxrplus -> nxrminus PLUS error
-- On LETAND reduce production nxrplus -> nxrminus PLUS error
-- On LET reduce production nxrplus -> nxrminus PLUS error
-- On LEQ reduce production nxrplus -> nxrminus PLUS error
-- On LAND reduce production nxrplus -> nxrminus PLUS error
-- On IN reduce production nxrplus -> nxrminus PLUS error
-- On GT reduce production nxrplus -> nxrminus PLUS error
-- On GEQ reduce production nxrplus -> nxrminus PLUS error
-- On EQ reduce production nxrplus -> nxrminus PLUS error
-- On EOI reduce production nxrplus -> nxrminus PLUS error
-- On ENDMUTUAL reduce production nxrplus -> nxrminus PLUS error
-- On ELSE reduce production nxrplus -> nxrminus PLUS error
-- On ELIST reduce production nxrplus -> nxrminus PLUS error
-- On DO reduce production nxrplus -> nxrminus PLUS error
-- On CONS reduce production nxrplus -> nxrminus PLUS error
-- On CONCAT reduce production nxrplus -> nxrminus PLUS error
-- On CLOSENUM reduce production nxrplus -> nxrminus PLUS error
-- On BEFORE reduce production nxrplus -> nxrminus PLUS error

State 119:
## Known stack suffix:
## nxrminus PLUS nxrplus
## LR(1) items:
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On RPAREN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On OVERWRITEGLOBALHASH reduce production nxrplus -> nxrminus PLUS nxrplus
-- On NEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On MUTUAL reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LOR reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LISTPUNCT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LETMUTABLE reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LETAND reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LET reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LAND reduce production nxrplus -> nxrminus PLUS nxrplus
-- On IN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On GT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On GEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On EQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On EOI reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ENDMUTUAL reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ELSE reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ELIST reduce production nxrplus -> nxrminus PLUS nxrplus
-- On DO reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CONS reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CONCAT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CLOSENUM reduce production nxrplus -> nxrminus PLUS nxrplus
-- On BEFORE reduce production nxrplus -> nxrminus PLUS nxrplus

State 120:
## Known stack suffix:
## nxlplus CONS nxconcat
## LR(1) items:
nxconcat -> nxlplus CONS nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxconcat -> nxlplus CONS nxconcat
-- On RPAREN reduce production nxconcat -> nxlplus CONS nxconcat
-- On OVERWRITEGLOBALHASH reduce production nxconcat -> nxlplus CONS nxconcat
-- On NEQ reduce production nxconcat -> nxlplus CONS nxconcat
-- On MUTUAL reduce production nxconcat -> nxlplus CONS nxconcat
-- On LT reduce production nxconcat -> nxlplus CONS nxconcat
-- On LOR reduce production nxconcat -> nxlplus CONS nxconcat
-- On LISTPUNCT reduce production nxconcat -> nxlplus CONS nxconcat
-- On LETMUTABLE reduce production nxconcat -> nxlplus CONS nxconcat
-- On LETAND reduce production nxconcat -> nxlplus CONS nxconcat
-- On LET reduce production nxconcat -> nxlplus CONS nxconcat
-- On LEQ reduce production nxconcat -> nxlplus CONS nxconcat
-- On LAND reduce production nxconcat -> nxlplus CONS nxconcat
-- On IN reduce production nxconcat -> nxlplus CONS nxconcat
-- On GT reduce production nxconcat -> nxlplus CONS nxconcat
-- On GEQ reduce production nxconcat -> nxlplus CONS nxconcat
-- On EQ reduce production nxconcat -> nxlplus CONS nxconcat
-- On EOI reduce production nxconcat -> nxlplus CONS nxconcat
-- On ENDMUTUAL reduce production nxconcat -> nxlplus CONS nxconcat
-- On ELSE reduce production nxconcat -> nxlplus CONS nxconcat
-- On ELIST reduce production nxconcat -> nxlplus CONS nxconcat
-- On DO reduce production nxconcat -> nxlplus CONS nxconcat
-- On CLOSENUM reduce production nxconcat -> nxlplus CONS nxconcat
-- On BEFORE reduce production nxconcat -> nxlplus CONS nxconcat

State 121:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> nxapp
-- On THEN reduce production nxun -> nxapp
-- On RPAREN reduce production nxun -> nxapp
-- On PLUS reduce production nxun -> nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> nxapp
-- On NEQ reduce production nxun -> nxapp
-- On MUTUAL reduce production nxun -> nxapp
-- On MOD reduce production nxun -> nxapp
-- On MINUS reduce production nxun -> nxapp
-- On LT reduce production nxun -> nxapp
-- On LOR reduce production nxun -> nxapp
-- On LISTPUNCT reduce production nxun -> nxapp
-- On LETMUTABLE reduce production nxun -> nxapp
-- On LETAND reduce production nxun -> nxapp
-- On LET reduce production nxun -> nxapp
-- On LEQ reduce production nxun -> nxapp
-- On LAND reduce production nxun -> nxapp
-- On IN reduce production nxun -> nxapp
-- On GT reduce production nxun -> nxapp
-- On GEQ reduce production nxun -> nxapp
-- On EQ reduce production nxun -> nxapp
-- On EOI reduce production nxun -> nxapp
-- On ENDMUTUAL reduce production nxun -> nxapp
-- On ELSE reduce production nxun -> nxapp
-- On ELIST reduce production nxun -> nxapp
-- On DO reduce production nxun -> nxapp
-- On DIVIDES reduce production nxun -> nxapp
-- On CONS reduce production nxun -> nxapp
-- On CONCAT reduce production nxun -> nxapp
-- On CLOSENUM reduce production nxun -> nxapp
-- On BEFORE reduce production nxun -> nxapp

State 122:
## Known stack suffix:
## nxlplus CONCAT
## LR(1) items:
nxconcat -> nxlplus CONCAT . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus CONCAT . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 123
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 124
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 123:
## Known stack suffix:
## nxlplus CONCAT error
## LR(1) items:
nxconcat -> nxlplus CONCAT error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxconcat -> nxlplus CONCAT error
-- On RPAREN reduce production nxconcat -> nxlplus CONCAT error
-- On OVERWRITEGLOBALHASH reduce production nxconcat -> nxlplus CONCAT error
-- On NEQ reduce production nxconcat -> nxlplus CONCAT error
-- On MUTUAL reduce production nxconcat -> nxlplus CONCAT error
-- On LT reduce production nxconcat -> nxlplus CONCAT error
-- On LOR reduce production nxconcat -> nxlplus CONCAT error
-- On LISTPUNCT reduce production nxconcat -> nxlplus CONCAT error
-- On LETMUTABLE reduce production nxconcat -> nxlplus CONCAT error
-- On LETAND reduce production nxconcat -> nxlplus CONCAT error
-- On LET reduce production nxconcat -> nxlplus CONCAT error
-- On LEQ reduce production nxconcat -> nxlplus CONCAT error
-- On LAND reduce production nxconcat -> nxlplus CONCAT error
-- On IN reduce production nxconcat -> nxlplus CONCAT error
-- On GT reduce production nxconcat -> nxlplus CONCAT error
-- On GEQ reduce production nxconcat -> nxlplus CONCAT error
-- On EQ reduce production nxconcat -> nxlplus CONCAT error
-- On EOI reduce production nxconcat -> nxlplus CONCAT error
-- On ENDMUTUAL reduce production nxconcat -> nxlplus CONCAT error
-- On ELSE reduce production nxconcat -> nxlplus CONCAT error
-- On ELIST reduce production nxconcat -> nxlplus CONCAT error
-- On DO reduce production nxconcat -> nxlplus CONCAT error
-- On CLOSENUM reduce production nxconcat -> nxlplus CONCAT error
-- On BEFORE reduce production nxconcat -> nxlplus CONCAT error

State 124:
## Known stack suffix:
## nxlplus CONCAT nxconcat
## LR(1) items:
nxconcat -> nxlplus CONCAT nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On RPAREN reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On OVERWRITEGLOBALHASH reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On NEQ reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On MUTUAL reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LT reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LOR reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LISTPUNCT reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LETMUTABLE reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LETAND reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LET reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LEQ reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On LAND reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On IN reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On GT reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On GEQ reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On EQ reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On EOI reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On ENDMUTUAL reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On ELSE reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On ELIST reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On DO reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On CLOSENUM reduce production nxconcat -> nxlplus CONCAT nxconcat
-- On BEFORE reduce production nxconcat -> nxlplus CONCAT nxconcat

State 125:
## Known stack suffix:
## LAMBDA argvar ARROW nxlor
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On RPAREN reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On MUTUAL reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On LISTPUNCT reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On LETMUTABLE reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On LETAND reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On LET reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On IN reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On EOI reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On ENDMUTUAL reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On ELSE reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On ELIST reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On DO reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On CLOSENUM reduce production nxlambda -> LAMBDA argvar ARROW nxlor
-- On BEFORE reduce production nxlambda -> LAMBDA argvar ARROW nxlor

State 126:
## Known stack suffix:
## nxland
## LR(1) items:
nxlor -> nxland . LOR nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . LOR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LOR shift to state 127
## Reductions:
-- On THEN reduce production nxlor -> nxland
-- On RPAREN reduce production nxlor -> nxland
-- On OVERWRITEGLOBALHASH reduce production nxlor -> nxland
-- On MUTUAL reduce production nxlor -> nxland
-- On LISTPUNCT reduce production nxlor -> nxland
-- On LETMUTABLE reduce production nxlor -> nxland
-- On LETAND reduce production nxlor -> nxland
-- On LET reduce production nxlor -> nxland
-- On IN reduce production nxlor -> nxland
-- On EOI reduce production nxlor -> nxland
-- On ENDMUTUAL reduce production nxlor -> nxland
-- On ELSE reduce production nxlor -> nxland
-- On ELIST reduce production nxlor -> nxland
-- On DO reduce production nxlor -> nxland
-- On CLOSENUM reduce production nxlor -> nxland
-- On BEFORE reduce production nxlor -> nxland

State 127:
## Known stack suffix:
## nxland LOR
## LR(1) items:
nxlor -> nxland LOR . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland LOR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 128
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 129
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 128:
## Known stack suffix:
## nxland LOR error
## LR(1) items:
nxlor -> nxland LOR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlor -> nxland LOR error
-- On RPAREN reduce production nxlor -> nxland LOR error
-- On OVERWRITEGLOBALHASH reduce production nxlor -> nxland LOR error
-- On MUTUAL reduce production nxlor -> nxland LOR error
-- On LISTPUNCT reduce production nxlor -> nxland LOR error
-- On LETMUTABLE reduce production nxlor -> nxland LOR error
-- On LETAND reduce production nxlor -> nxland LOR error
-- On LET reduce production nxlor -> nxland LOR error
-- On IN reduce production nxlor -> nxland LOR error
-- On EOI reduce production nxlor -> nxland LOR error
-- On ENDMUTUAL reduce production nxlor -> nxland LOR error
-- On ELSE reduce production nxlor -> nxland LOR error
-- On ELIST reduce production nxlor -> nxland LOR error
-- On DO reduce production nxlor -> nxland LOR error
-- On CLOSENUM reduce production nxlor -> nxland LOR error
-- On BEFORE reduce production nxlor -> nxland LOR error

State 129:
## Known stack suffix:
## nxland LOR nxlor
## LR(1) items:
nxlor -> nxland LOR nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlor -> nxland LOR nxlor
-- On RPAREN reduce production nxlor -> nxland LOR nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlor -> nxland LOR nxlor
-- On MUTUAL reduce production nxlor -> nxland LOR nxlor
-- On LISTPUNCT reduce production nxlor -> nxland LOR nxlor
-- On LETMUTABLE reduce production nxlor -> nxland LOR nxlor
-- On LETAND reduce production nxlor -> nxland LOR nxlor
-- On LET reduce production nxlor -> nxland LOR nxlor
-- On IN reduce production nxlor -> nxland LOR nxlor
-- On EOI reduce production nxlor -> nxland LOR nxlor
-- On ENDMUTUAL reduce production nxlor -> nxland LOR nxlor
-- On ELSE reduce production nxlor -> nxland LOR nxlor
-- On ELIST reduce production nxlor -> nxland LOR nxlor
-- On DO reduce production nxlor -> nxland LOR nxlor
-- On CLOSENUM reduce production nxlor -> nxland LOR nxlor
-- On BEFORE reduce production nxlor -> nxland LOR nxlor

State 130:
## Known stack suffix:
## nxconcat
## LR(1) items:
nxcomp -> nxconcat . EQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . EQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On NEQ shift to state 131
-- On LT shift to state 134
-- On LEQ shift to state 137
-- On GT shift to state 140
-- On GEQ shift to state 143
-- On EQ shift to state 146
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat
-- On RPAREN reduce production nxcomp -> nxconcat
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat
-- On MUTUAL reduce production nxcomp -> nxconcat
-- On LOR reduce production nxcomp -> nxconcat
-- On LISTPUNCT reduce production nxcomp -> nxconcat
-- On LETMUTABLE reduce production nxcomp -> nxconcat
-- On LETAND reduce production nxcomp -> nxconcat
-- On LET reduce production nxcomp -> nxconcat
-- On LAND reduce production nxcomp -> nxconcat
-- On IN reduce production nxcomp -> nxconcat
-- On EOI reduce production nxcomp -> nxconcat
-- On ENDMUTUAL reduce production nxcomp -> nxconcat
-- On ELSE reduce production nxcomp -> nxconcat
-- On ELIST reduce production nxcomp -> nxconcat
-- On DO reduce production nxcomp -> nxconcat
-- On CLOSENUM reduce production nxcomp -> nxconcat
-- On BEFORE reduce production nxcomp -> nxconcat

State 131:
## Known stack suffix:
## nxconcat NEQ
## LR(1) items:
nxcomp -> nxconcat NEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat NEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 132
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 133
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 132:
## Known stack suffix:
## nxconcat NEQ error
## LR(1) items:
nxcomp -> nxconcat NEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat NEQ error
-- On RPAREN reduce production nxcomp -> nxconcat NEQ error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat NEQ error
-- On MUTUAL reduce production nxcomp -> nxconcat NEQ error
-- On LOR reduce production nxcomp -> nxconcat NEQ error
-- On LISTPUNCT reduce production nxcomp -> nxconcat NEQ error
-- On LETMUTABLE reduce production nxcomp -> nxconcat NEQ error
-- On LETAND reduce production nxcomp -> nxconcat NEQ error
-- On LET reduce production nxcomp -> nxconcat NEQ error
-- On LAND reduce production nxcomp -> nxconcat NEQ error
-- On IN reduce production nxcomp -> nxconcat NEQ error
-- On EOI reduce production nxcomp -> nxconcat NEQ error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat NEQ error
-- On ELSE reduce production nxcomp -> nxconcat NEQ error
-- On ELIST reduce production nxcomp -> nxconcat NEQ error
-- On DO reduce production nxcomp -> nxconcat NEQ error
-- On CLOSENUM reduce production nxcomp -> nxconcat NEQ error
-- On BEFORE reduce production nxcomp -> nxconcat NEQ error

State 133:
## Known stack suffix:
## nxconcat NEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat NEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat NEQ nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat NEQ nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat NEQ nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LOR reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LETAND reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LET reduce production nxcomp -> nxconcat NEQ nxcomp
-- On LAND reduce production nxcomp -> nxconcat NEQ nxcomp
-- On IN reduce production nxcomp -> nxconcat NEQ nxcomp
-- On EOI reduce production nxcomp -> nxconcat NEQ nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat NEQ nxcomp
-- On ELSE reduce production nxcomp -> nxconcat NEQ nxcomp
-- On ELIST reduce production nxcomp -> nxconcat NEQ nxcomp
-- On DO reduce production nxcomp -> nxconcat NEQ nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat NEQ nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat NEQ nxcomp

State 134:
## Known stack suffix:
## nxconcat LT
## LR(1) items:
nxcomp -> nxconcat LT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 135
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 136
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 135:
## Known stack suffix:
## nxconcat LT error
## LR(1) items:
nxcomp -> nxconcat LT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat LT error
-- On RPAREN reduce production nxcomp -> nxconcat LT error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat LT error
-- On MUTUAL reduce production nxcomp -> nxconcat LT error
-- On LOR reduce production nxcomp -> nxconcat LT error
-- On LISTPUNCT reduce production nxcomp -> nxconcat LT error
-- On LETMUTABLE reduce production nxcomp -> nxconcat LT error
-- On LETAND reduce production nxcomp -> nxconcat LT error
-- On LET reduce production nxcomp -> nxconcat LT error
-- On LAND reduce production nxcomp -> nxconcat LT error
-- On IN reduce production nxcomp -> nxconcat LT error
-- On EOI reduce production nxcomp -> nxconcat LT error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat LT error
-- On ELSE reduce production nxcomp -> nxconcat LT error
-- On ELIST reduce production nxcomp -> nxconcat LT error
-- On DO reduce production nxcomp -> nxconcat LT error
-- On CLOSENUM reduce production nxcomp -> nxconcat LT error
-- On BEFORE reduce production nxcomp -> nxconcat LT error

State 136:
## Known stack suffix:
## nxconcat LT nxcomp
## LR(1) items:
nxcomp -> nxconcat LT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat LT nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat LT nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat LT nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat LT nxcomp
-- On LOR reduce production nxcomp -> nxconcat LT nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat LT nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat LT nxcomp
-- On LETAND reduce production nxcomp -> nxconcat LT nxcomp
-- On LET reduce production nxcomp -> nxconcat LT nxcomp
-- On LAND reduce production nxcomp -> nxconcat LT nxcomp
-- On IN reduce production nxcomp -> nxconcat LT nxcomp
-- On EOI reduce production nxcomp -> nxconcat LT nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat LT nxcomp
-- On ELSE reduce production nxcomp -> nxconcat LT nxcomp
-- On ELIST reduce production nxcomp -> nxconcat LT nxcomp
-- On DO reduce production nxcomp -> nxconcat LT nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat LT nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat LT nxcomp

State 137:
## Known stack suffix:
## nxconcat LEQ
## LR(1) items:
nxcomp -> nxconcat LEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 138
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 139
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 138:
## Known stack suffix:
## nxconcat LEQ error
## LR(1) items:
nxcomp -> nxconcat LEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat LEQ error
-- On RPAREN reduce production nxcomp -> nxconcat LEQ error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat LEQ error
-- On MUTUAL reduce production nxcomp -> nxconcat LEQ error
-- On LOR reduce production nxcomp -> nxconcat LEQ error
-- On LISTPUNCT reduce production nxcomp -> nxconcat LEQ error
-- On LETMUTABLE reduce production nxcomp -> nxconcat LEQ error
-- On LETAND reduce production nxcomp -> nxconcat LEQ error
-- On LET reduce production nxcomp -> nxconcat LEQ error
-- On LAND reduce production nxcomp -> nxconcat LEQ error
-- On IN reduce production nxcomp -> nxconcat LEQ error
-- On EOI reduce production nxcomp -> nxconcat LEQ error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat LEQ error
-- On ELSE reduce production nxcomp -> nxconcat LEQ error
-- On ELIST reduce production nxcomp -> nxconcat LEQ error
-- On DO reduce production nxcomp -> nxconcat LEQ error
-- On CLOSENUM reduce production nxcomp -> nxconcat LEQ error
-- On BEFORE reduce production nxcomp -> nxconcat LEQ error

State 139:
## Known stack suffix:
## nxconcat LEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat LEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat LEQ nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat LEQ nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat LEQ nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LOR reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LETAND reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LET reduce production nxcomp -> nxconcat LEQ nxcomp
-- On LAND reduce production nxcomp -> nxconcat LEQ nxcomp
-- On IN reduce production nxcomp -> nxconcat LEQ nxcomp
-- On EOI reduce production nxcomp -> nxconcat LEQ nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat LEQ nxcomp
-- On ELSE reduce production nxcomp -> nxconcat LEQ nxcomp
-- On ELIST reduce production nxcomp -> nxconcat LEQ nxcomp
-- On DO reduce production nxcomp -> nxconcat LEQ nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat LEQ nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat LEQ nxcomp

State 140:
## Known stack suffix:
## nxconcat GT
## LR(1) items:
nxcomp -> nxconcat GT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 141
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 142
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 141:
## Known stack suffix:
## nxconcat GT error
## LR(1) items:
nxcomp -> nxconcat GT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat GT error
-- On RPAREN reduce production nxcomp -> nxconcat GT error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat GT error
-- On MUTUAL reduce production nxcomp -> nxconcat GT error
-- On LOR reduce production nxcomp -> nxconcat GT error
-- On LISTPUNCT reduce production nxcomp -> nxconcat GT error
-- On LETMUTABLE reduce production nxcomp -> nxconcat GT error
-- On LETAND reduce production nxcomp -> nxconcat GT error
-- On LET reduce production nxcomp -> nxconcat GT error
-- On LAND reduce production nxcomp -> nxconcat GT error
-- On IN reduce production nxcomp -> nxconcat GT error
-- On EOI reduce production nxcomp -> nxconcat GT error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat GT error
-- On ELSE reduce production nxcomp -> nxconcat GT error
-- On ELIST reduce production nxcomp -> nxconcat GT error
-- On DO reduce production nxcomp -> nxconcat GT error
-- On CLOSENUM reduce production nxcomp -> nxconcat GT error
-- On BEFORE reduce production nxcomp -> nxconcat GT error

State 142:
## Known stack suffix:
## nxconcat GT nxcomp
## LR(1) items:
nxcomp -> nxconcat GT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat GT nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat GT nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat GT nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat GT nxcomp
-- On LOR reduce production nxcomp -> nxconcat GT nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat GT nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat GT nxcomp
-- On LETAND reduce production nxcomp -> nxconcat GT nxcomp
-- On LET reduce production nxcomp -> nxconcat GT nxcomp
-- On LAND reduce production nxcomp -> nxconcat GT nxcomp
-- On IN reduce production nxcomp -> nxconcat GT nxcomp
-- On EOI reduce production nxcomp -> nxconcat GT nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat GT nxcomp
-- On ELSE reduce production nxcomp -> nxconcat GT nxcomp
-- On ELIST reduce production nxcomp -> nxconcat GT nxcomp
-- On DO reduce production nxcomp -> nxconcat GT nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat GT nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat GT nxcomp

State 143:
## Known stack suffix:
## nxconcat GEQ
## LR(1) items:
nxcomp -> nxconcat GEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 144
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 145
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 144:
## Known stack suffix:
## nxconcat GEQ error
## LR(1) items:
nxcomp -> nxconcat GEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat GEQ error
-- On RPAREN reduce production nxcomp -> nxconcat GEQ error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat GEQ error
-- On MUTUAL reduce production nxcomp -> nxconcat GEQ error
-- On LOR reduce production nxcomp -> nxconcat GEQ error
-- On LISTPUNCT reduce production nxcomp -> nxconcat GEQ error
-- On LETMUTABLE reduce production nxcomp -> nxconcat GEQ error
-- On LETAND reduce production nxcomp -> nxconcat GEQ error
-- On LET reduce production nxcomp -> nxconcat GEQ error
-- On LAND reduce production nxcomp -> nxconcat GEQ error
-- On IN reduce production nxcomp -> nxconcat GEQ error
-- On EOI reduce production nxcomp -> nxconcat GEQ error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat GEQ error
-- On ELSE reduce production nxcomp -> nxconcat GEQ error
-- On ELIST reduce production nxcomp -> nxconcat GEQ error
-- On DO reduce production nxcomp -> nxconcat GEQ error
-- On CLOSENUM reduce production nxcomp -> nxconcat GEQ error
-- On BEFORE reduce production nxcomp -> nxconcat GEQ error

State 145:
## Known stack suffix:
## nxconcat GEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat GEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat GEQ nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat GEQ nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat GEQ nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LOR reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LETAND reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LET reduce production nxcomp -> nxconcat GEQ nxcomp
-- On LAND reduce production nxcomp -> nxconcat GEQ nxcomp
-- On IN reduce production nxcomp -> nxconcat GEQ nxcomp
-- On EOI reduce production nxcomp -> nxconcat GEQ nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat GEQ nxcomp
-- On ELSE reduce production nxcomp -> nxconcat GEQ nxcomp
-- On ELIST reduce production nxcomp -> nxconcat GEQ nxcomp
-- On DO reduce production nxcomp -> nxconcat GEQ nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat GEQ nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat GEQ nxcomp

State 146:
## Known stack suffix:
## nxconcat EQ
## LR(1) items:
nxcomp -> nxconcat EQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat EQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 147
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 148
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 147:
## Known stack suffix:
## nxconcat EQ error
## LR(1) items:
nxcomp -> nxconcat EQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat EQ error
-- On RPAREN reduce production nxcomp -> nxconcat EQ error
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat EQ error
-- On MUTUAL reduce production nxcomp -> nxconcat EQ error
-- On LOR reduce production nxcomp -> nxconcat EQ error
-- On LISTPUNCT reduce production nxcomp -> nxconcat EQ error
-- On LETMUTABLE reduce production nxcomp -> nxconcat EQ error
-- On LETAND reduce production nxcomp -> nxconcat EQ error
-- On LET reduce production nxcomp -> nxconcat EQ error
-- On LAND reduce production nxcomp -> nxconcat EQ error
-- On IN reduce production nxcomp -> nxconcat EQ error
-- On EOI reduce production nxcomp -> nxconcat EQ error
-- On ENDMUTUAL reduce production nxcomp -> nxconcat EQ error
-- On ELSE reduce production nxcomp -> nxconcat EQ error
-- On ELIST reduce production nxcomp -> nxconcat EQ error
-- On DO reduce production nxcomp -> nxconcat EQ error
-- On CLOSENUM reduce production nxcomp -> nxconcat EQ error
-- On BEFORE reduce production nxcomp -> nxconcat EQ error

State 148:
## Known stack suffix:
## nxconcat EQ nxcomp
## LR(1) items:
nxcomp -> nxconcat EQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat EQ nxcomp
-- On RPAREN reduce production nxcomp -> nxconcat EQ nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat EQ nxcomp
-- On MUTUAL reduce production nxcomp -> nxconcat EQ nxcomp
-- On LOR reduce production nxcomp -> nxconcat EQ nxcomp
-- On LISTPUNCT reduce production nxcomp -> nxconcat EQ nxcomp
-- On LETMUTABLE reduce production nxcomp -> nxconcat EQ nxcomp
-- On LETAND reduce production nxcomp -> nxconcat EQ nxcomp
-- On LET reduce production nxcomp -> nxconcat EQ nxcomp
-- On LAND reduce production nxcomp -> nxconcat EQ nxcomp
-- On IN reduce production nxcomp -> nxconcat EQ nxcomp
-- On EOI reduce production nxcomp -> nxconcat EQ nxcomp
-- On ENDMUTUAL reduce production nxcomp -> nxconcat EQ nxcomp
-- On ELSE reduce production nxcomp -> nxconcat EQ nxcomp
-- On ELIST reduce production nxcomp -> nxconcat EQ nxcomp
-- On DO reduce production nxcomp -> nxconcat EQ nxcomp
-- On CLOSENUM reduce production nxcomp -> nxconcat EQ nxcomp
-- On BEFORE reduce production nxcomp -> nxconcat EQ nxcomp

State 149:
## Known stack suffix:
## nxcomp
## LR(1) items:
nxland -> nxcomp . LAND nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . LAND error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LAND shift to state 150
## Reductions:
-- On THEN reduce production nxland -> nxcomp
-- On RPAREN reduce production nxland -> nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxland -> nxcomp
-- On MUTUAL reduce production nxland -> nxcomp
-- On LOR reduce production nxland -> nxcomp
-- On LISTPUNCT reduce production nxland -> nxcomp
-- On LETMUTABLE reduce production nxland -> nxcomp
-- On LETAND reduce production nxland -> nxcomp
-- On LET reduce production nxland -> nxcomp
-- On IN reduce production nxland -> nxcomp
-- On EOI reduce production nxland -> nxcomp
-- On ENDMUTUAL reduce production nxland -> nxcomp
-- On ELSE reduce production nxland -> nxcomp
-- On ELIST reduce production nxland -> nxcomp
-- On DO reduce production nxland -> nxcomp
-- On CLOSENUM reduce production nxland -> nxcomp
-- On BEFORE reduce production nxland -> nxcomp

State 150:
## Known stack suffix:
## nxcomp LAND
## LR(1) items:
nxland -> nxcomp LAND . nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp LAND . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 151
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxland shift to state 152
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 151:
## Known stack suffix:
## nxcomp LAND error
## LR(1) items:
nxland -> nxcomp LAND error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxland -> nxcomp LAND error
-- On RPAREN reduce production nxland -> nxcomp LAND error
-- On OVERWRITEGLOBALHASH reduce production nxland -> nxcomp LAND error
-- On MUTUAL reduce production nxland -> nxcomp LAND error
-- On LOR reduce production nxland -> nxcomp LAND error
-- On LISTPUNCT reduce production nxland -> nxcomp LAND error
-- On LETMUTABLE reduce production nxland -> nxcomp LAND error
-- On LETAND reduce production nxland -> nxcomp LAND error
-- On LET reduce production nxland -> nxcomp LAND error
-- On IN reduce production nxland -> nxcomp LAND error
-- On EOI reduce production nxland -> nxcomp LAND error
-- On ENDMUTUAL reduce production nxland -> nxcomp LAND error
-- On ELSE reduce production nxland -> nxcomp LAND error
-- On ELIST reduce production nxland -> nxcomp LAND error
-- On DO reduce production nxland -> nxcomp LAND error
-- On CLOSENUM reduce production nxland -> nxcomp LAND error
-- On BEFORE reduce production nxland -> nxcomp LAND error

State 152:
## Known stack suffix:
## nxcomp LAND nxland
## LR(1) items:
nxland -> nxcomp LAND nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxland -> nxcomp LAND nxland
-- On RPAREN reduce production nxland -> nxcomp LAND nxland
-- On OVERWRITEGLOBALHASH reduce production nxland -> nxcomp LAND nxland
-- On MUTUAL reduce production nxland -> nxcomp LAND nxland
-- On LOR reduce production nxland -> nxcomp LAND nxland
-- On LISTPUNCT reduce production nxland -> nxcomp LAND nxland
-- On LETMUTABLE reduce production nxland -> nxcomp LAND nxland
-- On LETAND reduce production nxland -> nxcomp LAND nxland
-- On LET reduce production nxland -> nxcomp LAND nxland
-- On IN reduce production nxland -> nxcomp LAND nxland
-- On EOI reduce production nxland -> nxcomp LAND nxland
-- On ENDMUTUAL reduce production nxland -> nxcomp LAND nxland
-- On ELSE reduce production nxland -> nxcomp LAND nxland
-- On ELIST reduce production nxland -> nxcomp LAND nxland
-- On DO reduce production nxland -> nxcomp LAND nxland
-- On CLOSENUM reduce production nxland -> nxcomp LAND nxland
-- On BEFORE reduce production nxland -> nxcomp LAND nxland

State 153:
## Known stack suffix:
## IFIDISVALID
## LR(1) items:
nxif -> IFIDISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 154
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 155
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 196
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 154:
## Known stack suffix:
## IFIDISVALID error
## LR(1) items:
nxif -> IFIDISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID error
-- On RPAREN reduce production nxif -> IFIDISVALID error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID error
-- On MUTUAL reduce production nxif -> IFIDISVALID error
-- On LISTPUNCT reduce production nxif -> IFIDISVALID error
-- On LETMUTABLE reduce production nxif -> IFIDISVALID error
-- On LETAND reduce production nxif -> IFIDISVALID error
-- On LET reduce production nxif -> IFIDISVALID error
-- On IN reduce production nxif -> IFIDISVALID error
-- On EOI reduce production nxif -> IFIDISVALID error
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID error
-- On ELSE reduce production nxif -> IFIDISVALID error
-- On ELIST reduce production nxif -> IFIDISVALID error
-- On DO reduce production nxif -> IFIDISVALID error
-- On CLOSENUM reduce production nxif -> IFIDISVALID error

State 155:
## Known stack suffix:
## IFIDISVALID THEN
## LR(1) items:
nxif -> IFIDISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 156
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 192
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 156:
## Known stack suffix:
## IFIDISVALID THEN error
## LR(1) items:
nxif -> IFIDISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID THEN error
-- On RPAREN reduce production nxif -> IFIDISVALID THEN error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID THEN error
-- On MUTUAL reduce production nxif -> IFIDISVALID THEN error
-- On LISTPUNCT reduce production nxif -> IFIDISVALID THEN error
-- On LETMUTABLE reduce production nxif -> IFIDISVALID THEN error
-- On LETAND reduce production nxif -> IFIDISVALID THEN error
-- On LET reduce production nxif -> IFIDISVALID THEN error
-- On IN reduce production nxif -> IFIDISVALID THEN error
-- On EOI reduce production nxif -> IFIDISVALID THEN error
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID THEN error
-- On ELSE reduce production nxif -> IFIDISVALID THEN error
-- On ELIST reduce production nxif -> IFIDISVALID THEN error
-- On DO reduce production nxif -> IFIDISVALID THEN error
-- On CLOSENUM reduce production nxif -> IFIDISVALID THEN error

State 157:
## Known stack suffix:
## IFCLASSISVALID
## LR(1) items:
nxif -> IFCLASSISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 158
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 159
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 188
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 158:
## Known stack suffix:
## IFCLASSISVALID error
## LR(1) items:
nxif -> IFCLASSISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID error
-- On RPAREN reduce production nxif -> IFCLASSISVALID error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID error
-- On MUTUAL reduce production nxif -> IFCLASSISVALID error
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID error
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID error
-- On LETAND reduce production nxif -> IFCLASSISVALID error
-- On LET reduce production nxif -> IFCLASSISVALID error
-- On IN reduce production nxif -> IFCLASSISVALID error
-- On EOI reduce production nxif -> IFCLASSISVALID error
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID error
-- On ELSE reduce production nxif -> IFCLASSISVALID error
-- On ELIST reduce production nxif -> IFCLASSISVALID error
-- On DO reduce production nxif -> IFCLASSISVALID error
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID error

State 159:
## Known stack suffix:
## IFCLASSISVALID THEN
## LR(1) items:
nxif -> IFCLASSISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 160
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 184
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 160:
## Known stack suffix:
## IFCLASSISVALID THEN error
## LR(1) items:
nxif -> IFCLASSISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID THEN error
-- On RPAREN reduce production nxif -> IFCLASSISVALID THEN error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID THEN error
-- On MUTUAL reduce production nxif -> IFCLASSISVALID THEN error
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID THEN error
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID THEN error
-- On LETAND reduce production nxif -> IFCLASSISVALID THEN error
-- On LET reduce production nxif -> IFCLASSISVALID THEN error
-- On IN reduce production nxif -> IFCLASSISVALID THEN error
-- On EOI reduce production nxif -> IFCLASSISVALID THEN error
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID THEN error
-- On ELSE reduce production nxif -> IFCLASSISVALID THEN error
-- On ELIST reduce production nxif -> IFCLASSISVALID THEN error
-- On DO reduce production nxif -> IFCLASSISVALID THEN error
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID THEN error

State 161:
## Known stack suffix:
## IF
## LR(1) items:
nxif -> IF . nxlet THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 162
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 177
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 162:
## Known stack suffix:
## IF error
## LR(1) items:
nxif -> IF error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IF error
-- On RPAREN reduce production nxif -> IF error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IF error
-- On MUTUAL reduce production nxif -> IF error
-- On LISTPUNCT reduce production nxif -> IF error
-- On LETMUTABLE reduce production nxif -> IF error
-- On LETAND reduce production nxif -> IF error
-- On LET reduce production nxif -> IF error
-- On IN reduce production nxif -> IF error
-- On EOI reduce production nxif -> IF error
-- On ENDMUTUAL reduce production nxif -> IF error
-- On ELSE reduce production nxif -> IF error
-- On ELIST reduce production nxif -> IF error
-- On DO reduce production nxif -> IF error
-- On CLOSENUM reduce production nxif -> IF error

State 163:
## Known stack suffix:
## DECGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 164
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 167
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 164:
## Known stack suffix:
## DECGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> DECGLOBALHASH error
-- On RPAREN reduce production nxlambda -> DECGLOBALHASH error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> DECGLOBALHASH error
-- On MUTUAL reduce production nxlambda -> DECGLOBALHASH error
-- On LISTPUNCT reduce production nxlambda -> DECGLOBALHASH error
-- On LETMUTABLE reduce production nxlambda -> DECGLOBALHASH error
-- On LETAND reduce production nxlambda -> DECGLOBALHASH error
-- On LET reduce production nxlambda -> DECGLOBALHASH error
-- On IN reduce production nxlambda -> DECGLOBALHASH error
-- On EOI reduce production nxlambda -> DECGLOBALHASH error
-- On ENDMUTUAL reduce production nxlambda -> DECGLOBALHASH error
-- On ELSE reduce production nxlambda -> DECGLOBALHASH error
-- On ELIST reduce production nxlambda -> DECGLOBALHASH error
-- On DO reduce production nxlambda -> DECGLOBALHASH error
-- On CLOSENUM reduce production nxlambda -> DECGLOBALHASH error
-- On BEFORE reduce production nxlambda -> DECGLOBALHASH error

State 165:
## Known stack suffix:
## nxwhl
## LR(1) items:
nxlet -> nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> nxwhl
-- On RPAREN reduce production nxlet -> nxwhl
-- On OVERWRITEGLOBALHASH reduce production nxlet -> nxwhl
-- On MUTUAL reduce production nxlet -> nxwhl
-- On LISTPUNCT reduce production nxlet -> nxwhl
-- On LETMUTABLE reduce production nxlet -> nxwhl
-- On LETAND reduce production nxlet -> nxwhl
-- On LET reduce production nxlet -> nxwhl
-- On IN reduce production nxlet -> nxwhl
-- On EOI reduce production nxlet -> nxwhl
-- On ENDMUTUAL reduce production nxlet -> nxwhl
-- On ELSE reduce production nxlet -> nxwhl
-- On ELIST reduce production nxlet -> nxwhl
-- On DO reduce production nxlet -> nxwhl
-- On CLOSENUM reduce production nxlet -> nxwhl

State 166:
## Known stack suffix:
## nxlor
## LR(1) items:
nxlambda -> nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> nxlor
-- On RPAREN reduce production nxlambda -> nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> nxlor
-- On MUTUAL reduce production nxlambda -> nxlor
-- On LISTPUNCT reduce production nxlambda -> nxlor
-- On LETMUTABLE reduce production nxlambda -> nxlor
-- On LETAND reduce production nxlambda -> nxlor
-- On LET reduce production nxlambda -> nxlor
-- On IN reduce production nxlambda -> nxlor
-- On EOI reduce production nxlambda -> nxlor
-- On ENDMUTUAL reduce production nxlambda -> nxlor
-- On ELSE reduce production nxlambda -> nxlor
-- On ELIST reduce production nxlambda -> nxlor
-- On DO reduce production nxlambda -> nxlor
-- On CLOSENUM reduce production nxlambda -> nxlor
-- On BEFORE reduce production nxlambda -> nxlor

State 167:
## Known stack suffix:
## DECGLOBALHASH nxlet
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 169
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 170
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 169:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On RPAREN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On MUTUAL reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LISTPUNCT reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LETMUTABLE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LETAND reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LET reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On IN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On EOI reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ENDMUTUAL reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ELSE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ELIST reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On DO reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On CLOSENUM reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On BEFORE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 170:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On RPAREN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On MUTUAL reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LISTPUNCT reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LETMUTABLE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LETAND reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LET reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On IN reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On EOI reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ENDMUTUAL reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ELSE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ELIST reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On DO reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On CLOSENUM reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On BEFORE reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 171:
## Known stack suffix:
## nxlambda
## LR(1) items:
nxbfr -> nxlambda . BEFORE nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . BEFORE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On BEFORE shift to state 172
## Reductions:
-- On THEN reduce production nxbfr -> nxlambda
-- On RPAREN reduce production nxbfr -> nxlambda
-- On OVERWRITEGLOBALHASH reduce production nxbfr -> nxlambda
-- On MUTUAL reduce production nxbfr -> nxlambda
-- On LISTPUNCT reduce production nxbfr -> nxlambda
-- On LETMUTABLE reduce production nxbfr -> nxlambda
-- On LETAND reduce production nxbfr -> nxlambda
-- On LET reduce production nxbfr -> nxlambda
-- On IN reduce production nxbfr -> nxlambda
-- On EOI reduce production nxbfr -> nxlambda
-- On ENDMUTUAL reduce production nxbfr -> nxlambda
-- On ELSE reduce production nxbfr -> nxlambda
-- On ELIST reduce production nxbfr -> nxlambda
-- On DO reduce production nxbfr -> nxlambda
-- On CLOSENUM reduce production nxbfr -> nxlambda

State 172:
## Known stack suffix:
## nxlambda BEFORE
## LR(1) items:
nxbfr -> nxlambda BEFORE . nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda BEFORE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 173
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 174
-- On nxapp shift to state 121
## Reductions:

State 173:
## Known stack suffix:
## nxlambda BEFORE error
## LR(1) items:
nxbfr -> nxlambda BEFORE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxbfr -> nxlambda BEFORE error
-- On RPAREN reduce production nxbfr -> nxlambda BEFORE error
-- On OVERWRITEGLOBALHASH reduce production nxbfr -> nxlambda BEFORE error
-- On MUTUAL reduce production nxbfr -> nxlambda BEFORE error
-- On LISTPUNCT reduce production nxbfr -> nxlambda BEFORE error
-- On LETMUTABLE reduce production nxbfr -> nxlambda BEFORE error
-- On LETAND reduce production nxbfr -> nxlambda BEFORE error
-- On LET reduce production nxbfr -> nxlambda BEFORE error
-- On IN reduce production nxbfr -> nxlambda BEFORE error
-- On EOI reduce production nxbfr -> nxlambda BEFORE error
-- On ENDMUTUAL reduce production nxbfr -> nxlambda BEFORE error
-- On ELSE reduce production nxbfr -> nxlambda BEFORE error
-- On ELIST reduce production nxbfr -> nxlambda BEFORE error
-- On DO reduce production nxbfr -> nxlambda BEFORE error
-- On CLOSENUM reduce production nxbfr -> nxlambda BEFORE error

State 174:
## Known stack suffix:
## nxlambda BEFORE nxbfr
## LR(1) items:
nxbfr -> nxlambda BEFORE nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On RPAREN reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On OVERWRITEGLOBALHASH reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On MUTUAL reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On LISTPUNCT reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On LETMUTABLE reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On LETAND reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On LET reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On IN reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On EOI reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On ENDMUTUAL reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On ELSE reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On ELIST reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On DO reduce production nxbfr -> nxlambda BEFORE nxbfr
-- On CLOSENUM reduce production nxbfr -> nxlambda BEFORE nxbfr

State 175:
## Known stack suffix:
## nxif
## LR(1) items:
nxwhl -> nxif . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxwhl -> nxif
-- On RPAREN reduce production nxwhl -> nxif
-- On OVERWRITEGLOBALHASH reduce production nxwhl -> nxif
-- On MUTUAL reduce production nxwhl -> nxif
-- On LISTPUNCT reduce production nxwhl -> nxif
-- On LETMUTABLE reduce production nxwhl -> nxif
-- On LETAND reduce production nxwhl -> nxif
-- On LET reduce production nxwhl -> nxif
-- On IN reduce production nxwhl -> nxif
-- On EOI reduce production nxwhl -> nxif
-- On ENDMUTUAL reduce production nxwhl -> nxif
-- On ELSE reduce production nxwhl -> nxif
-- On ELIST reduce production nxwhl -> nxif
-- On DO reduce production nxwhl -> nxif
-- On CLOSENUM reduce production nxwhl -> nxif

State 176:
## Known stack suffix:
## nxbfr
## LR(1) items:
nxif -> nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> nxbfr
-- On RPAREN reduce production nxif -> nxbfr
-- On OVERWRITEGLOBALHASH reduce production nxif -> nxbfr
-- On MUTUAL reduce production nxif -> nxbfr
-- On LISTPUNCT reduce production nxif -> nxbfr
-- On LETMUTABLE reduce production nxif -> nxbfr
-- On LETAND reduce production nxif -> nxbfr
-- On LET reduce production nxif -> nxbfr
-- On IN reduce production nxif -> nxbfr
-- On EOI reduce production nxif -> nxbfr
-- On ENDMUTUAL reduce production nxif -> nxbfr
-- On ELSE reduce production nxif -> nxbfr
-- On ELIST reduce production nxif -> nxbfr
-- On DO reduce production nxif -> nxbfr
-- On CLOSENUM reduce production nxif -> nxbfr

State 177:
## Known stack suffix:
## IF nxlet
## LR(1) items:
nxif -> IF nxlet . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On THEN shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## IF nxlet THEN
## LR(1) items:
nxif -> IF nxlet THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 179
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 180
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 179:
## Known stack suffix:
## IF nxlet THEN error
## LR(1) items:
nxif -> IF nxlet THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IF nxlet THEN error
-- On RPAREN reduce production nxif -> IF nxlet THEN error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IF nxlet THEN error
-- On MUTUAL reduce production nxif -> IF nxlet THEN error
-- On LISTPUNCT reduce production nxif -> IF nxlet THEN error
-- On LETMUTABLE reduce production nxif -> IF nxlet THEN error
-- On LETAND reduce production nxif -> IF nxlet THEN error
-- On LET reduce production nxif -> IF nxlet THEN error
-- On IN reduce production nxif -> IF nxlet THEN error
-- On EOI reduce production nxif -> IF nxlet THEN error
-- On ENDMUTUAL reduce production nxif -> IF nxlet THEN error
-- On ELSE reduce production nxif -> IF nxlet THEN error
-- On ELIST reduce production nxif -> IF nxlet THEN error
-- On DO reduce production nxif -> IF nxlet THEN error
-- On CLOSENUM reduce production nxif -> IF nxlet THEN error

State 180:
## Known stack suffix:
## IF nxlet THEN nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 182
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 183
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 182:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE error
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On RPAREN reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On MUTUAL reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On LISTPUNCT reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On LETMUTABLE reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On LETAND reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On LET reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On IN reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On EOI reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On ENDMUTUAL reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On ELSE reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On ELIST reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On DO reduce production nxif -> IF nxlet THEN nxlet ELSE error
-- On CLOSENUM reduce production nxif -> IF nxlet THEN nxlet ELSE error

State 183:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On RPAREN reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On OVERWRITEGLOBALHASH reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On MUTUAL reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On LISTPUNCT reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On LETMUTABLE reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On LETAND reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On LET reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On IN reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On EOI reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On ENDMUTUAL reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On ELSE reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On ELIST reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On DO reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet
-- On CLOSENUM reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet

State 184:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 186
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 187
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 186:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On RPAREN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On MUTUAL reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On LETAND reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On LET reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On IN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On EOI reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On ELSE reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On ELIST reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On DO reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error

State 187:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On RPAREN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On MUTUAL reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On LETAND reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On LET reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On IN reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On EOI reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On ELSE reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On ELIST reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On DO reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet

State 188:
## Known stack suffix:
## IFCLASSISVALID nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 189
## Reductions:

State 189:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 190
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 191
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 190:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On RPAREN reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On MUTUAL reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On LETAND reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On LET reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On IN reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On EOI reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On ELSE reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On ELIST reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On DO reduce production nxif -> IFCLASSISVALID nxlet ELSE error
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID nxlet ELSE error

State 191:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On RPAREN reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On MUTUAL reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On LISTPUNCT reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On LETMUTABLE reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On LETAND reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On LET reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On IN reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On EOI reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On ENDMUTUAL reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On ELSE reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On ELIST reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On DO reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet
-- On CLOSENUM reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet

State 192:
## Known stack suffix:
## IFIDISVALID THEN nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 194
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 195
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 194:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On RPAREN reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On MUTUAL reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On LISTPUNCT reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On LETMUTABLE reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On LETAND reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On LET reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On IN reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On EOI reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On ELSE reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On ELIST reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On DO reduce production nxif -> IFIDISVALID THEN nxlet ELSE error
-- On CLOSENUM reduce production nxif -> IFIDISVALID THEN nxlet ELSE error

State 195:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On RPAREN reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On MUTUAL reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On LISTPUNCT reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On LETMUTABLE reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On LETAND reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On LET reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On IN reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On EOI reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On ELSE reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On ELIST reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On DO reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet
-- On CLOSENUM reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet

State 196:
## Known stack suffix:
## IFIDISVALID nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## IFIDISVALID nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 198
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 199
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 198:
## Known stack suffix:
## IFIDISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On RPAREN reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On MUTUAL reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On LISTPUNCT reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On LETMUTABLE reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On LETAND reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On LET reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On IN reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On EOI reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On ELSE reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On ELIST reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On DO reduce production nxif -> IFIDISVALID nxlet ELSE error
-- On CLOSENUM reduce production nxif -> IFIDISVALID nxlet ELSE error

State 199:
## Known stack suffix:
## IFIDISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On RPAREN reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On OVERWRITEGLOBALHASH reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On MUTUAL reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On LISTPUNCT reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On LETMUTABLE reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On LETAND reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On LET reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On IN reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On EOI reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On ENDMUTUAL reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On ELSE reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On ELIST reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On DO reduce production nxif -> IFIDISVALID nxlet ELSE nxlet
-- On CLOSENUM reduce production nxif -> IFIDISVALID nxlet ELSE nxlet

State 200:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 214
## Reductions:
-- On IN reduce production nxdec ->

State 201:
## Known stack suffix:
## LETAND
## LR(1) items:
nxdec -> LETAND . VAR argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . VAR error [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 202
-- On CTRLSEQ shift to state 208
## Reductions:

State 202:
## Known stack suffix:
## LETAND VAR
## LR(1) items:
nxdec -> LETAND VAR . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND VAR . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 203
-- On VAR shift to state 7
-- On argvar shift to state 204
## Reductions:
-- On DEFEQ reduce production argvar ->

State 203:
## Known stack suffix:
## LETAND VAR error
## LR(1) items:
nxdec -> LETAND VAR error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxdec -> LETAND VAR error
-- On LETMUTABLE reduce production nxdec -> LETAND VAR error
-- On LET reduce production nxdec -> LETAND VAR error
-- On IN reduce production nxdec -> LETAND VAR error
-- On EOI reduce production nxdec -> LETAND VAR error

State 204:
## Known stack suffix:
## LETAND VAR argvar
## LR(1) items:
nxdec -> LETAND VAR argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 205
## Reductions:

State 205:
## Known stack suffix:
## LETAND VAR argvar DEFEQ
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 206
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 206:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 207
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 207:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec
-- On LETMUTABLE reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec
-- On LET reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec
-- On IN reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec
-- On EOI reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec

State 208:
## Known stack suffix:
## LETAND CTRLSEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND CTRLSEQ . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 209
-- On VAR shift to state 7
-- On argvar shift to state 210
## Reductions:
-- On DEFEQ reduce production argvar ->

State 209:
## Known stack suffix:
## LETAND CTRLSEQ error
## LR(1) items:
nxdec -> LETAND CTRLSEQ error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxdec -> LETAND CTRLSEQ error
-- On LETMUTABLE reduce production nxdec -> LETAND CTRLSEQ error
-- On LET reduce production nxdec -> LETAND CTRLSEQ error
-- On IN reduce production nxdec -> LETAND CTRLSEQ error
-- On EOI reduce production nxdec -> LETAND CTRLSEQ error

State 210:
## Known stack suffix:
## LETAND CTRLSEQ argvar
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 211
## Reductions:

State 211:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 212
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 212:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 213
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 213:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
-- On LETMUTABLE reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
-- On LET reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
-- On IN reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
-- On EOI reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec

State 214:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 215
## Reductions:

State 215:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 216
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 217
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 216:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On RPAREN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On MUTUAL reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On LISTPUNCT reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On LETMUTABLE reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On LETAND reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On LET reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On IN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On EOI reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On ENDMUTUAL reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On ELSE reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On ELIST reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On DO reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error
-- On CLOSENUM reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error

State 217:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On RPAREN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On MUTUAL reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On LISTPUNCT reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On LETMUTABLE reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On LETAND reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On LET reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On IN reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On EOI reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On ENDMUTUAL reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On ELSE reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On ELIST reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On DO reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet
-- On CLOSENUM reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 218:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 219
-- On VAR shift to state 7
-- On argvar shift to state 220
## Reductions:
-- On DEFEQ reduce production argvar ->

State 219:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET CTRLSEQ error
-- On RPAREN reduce production nxlet -> LET CTRLSEQ error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET CTRLSEQ error
-- On MUTUAL reduce production nxlet -> LET CTRLSEQ error
-- On LISTPUNCT reduce production nxlet -> LET CTRLSEQ error
-- On LETMUTABLE reduce production nxlet -> LET CTRLSEQ error
-- On LETAND reduce production nxlet -> LET CTRLSEQ error
-- On LET reduce production nxlet -> LET CTRLSEQ error
-- On IN reduce production nxlet -> LET CTRLSEQ error
-- On EOI reduce production nxlet -> LET CTRLSEQ error
-- On ENDMUTUAL reduce production nxlet -> LET CTRLSEQ error
-- On ELSE reduce production nxlet -> LET CTRLSEQ error
-- On ELIST reduce production nxlet -> LET CTRLSEQ error
-- On DO reduce production nxlet -> LET CTRLSEQ error
-- On CLOSENUM reduce production nxlet -> LET CTRLSEQ error

State 220:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 222
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 223
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 222:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On RPAREN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On MUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On LISTPUNCT reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On LETMUTABLE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On LETAND reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On LET reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On IN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On EOI reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On ENDMUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On ELSE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On ELIST reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On DO reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error
-- On CLOSENUM reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error

State 223:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 224
## Reductions:
-- On IN reduce production nxdec ->

State 224:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 226
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 227
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 226:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On RPAREN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On MUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On LISTPUNCT reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On LETMUTABLE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On LETAND reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On LET reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On IN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On EOI reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On ENDMUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On ELSE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On ELIST reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On DO reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
-- On CLOSENUM reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 227:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On RPAREN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On MUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On LISTPUNCT reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On LETMUTABLE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On LETAND reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On LET reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On IN reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On EOI reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On ENDMUTUAL reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On ELSE reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On ELIST reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On DO reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
-- On CLOSENUM reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 228:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 229
## Reductions:

State 229:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 230
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 231
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 230:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On RPAREN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On MUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On LISTPUNCT reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On LETMUTABLE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On LETAND reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On LET reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On IN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On EOI reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On ENDMUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On ELSE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On ELIST reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On DO reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error
-- On CLOSENUM reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error

State 231:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On RPAREN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On OVERWRITEGLOBALHASH reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On MUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On LISTPUNCT reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On LETMUTABLE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On LETAND reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On LET reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On IN reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On EOI reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On ENDMUTUAL reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On ELSE reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On ELIST reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On DO reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
-- On CLOSENUM reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 232:
## Known stack suffix:
## BLIST ELIST
## LR(1) items:
nxbot -> BLIST ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> BLIST ELIST
-- On UNITVALUE reduce production nxbot -> BLIST ELIST
-- On TRUE reduce production nxbot -> BLIST ELIST
-- On TIMES reduce production nxbot -> BLIST ELIST
-- On THEN reduce production nxbot -> BLIST ELIST
-- On RPAREN reduce production nxbot -> BLIST ELIST
-- On PLUS reduce production nxbot -> BLIST ELIST
-- On OVERWRITEGLOBALHASH reduce production nxbot -> BLIST ELIST
-- On OPENSTR reduce production nxbot -> BLIST ELIST
-- On OPENQT reduce production nxbot -> BLIST ELIST
-- On NUMCONST reduce production nxbot -> BLIST ELIST
-- On NEQ reduce production nxbot -> BLIST ELIST
-- On MUTUAL reduce production nxbot -> BLIST ELIST
-- On MOD reduce production nxbot -> BLIST ELIST
-- On MINUS reduce production nxbot -> BLIST ELIST
-- On LT reduce production nxbot -> BLIST ELIST
-- On LPAREN reduce production nxbot -> BLIST ELIST
-- On LOR reduce production nxbot -> BLIST ELIST
-- On LISTPUNCT reduce production nxbot -> BLIST ELIST
-- On LETMUTABLE reduce production nxbot -> BLIST ELIST
-- On LETAND reduce production nxbot -> BLIST ELIST
-- On LET reduce production nxbot -> BLIST ELIST
-- On LEQ reduce production nxbot -> BLIST ELIST
-- On LAND reduce production nxbot -> BLIST ELIST
-- On IN reduce production nxbot -> BLIST ELIST
-- On GT reduce production nxbot -> BLIST ELIST
-- On GEQ reduce production nxbot -> BLIST ELIST
-- On FINISH reduce production nxbot -> BLIST ELIST
-- On FALSE reduce production nxbot -> BLIST ELIST
-- On EQ reduce production nxbot -> BLIST ELIST
-- On EOI reduce production nxbot -> BLIST ELIST
-- On ENDMUTUAL reduce production nxbot -> BLIST ELIST
-- On ELSE reduce production nxbot -> BLIST ELIST
-- On ELIST reduce production nxbot -> BLIST ELIST
-- On DO reduce production nxbot -> BLIST ELIST
-- On DIVIDES reduce production nxbot -> BLIST ELIST
-- On CONS reduce production nxbot -> BLIST ELIST
-- On CONCAT reduce production nxbot -> BLIST ELIST
-- On CLOSENUM reduce production nxbot -> BLIST ELIST
-- On BLIST reduce production nxbot -> BLIST ELIST
-- On BEFORE reduce production nxbot -> BLIST ELIST

State 233:
## Known stack suffix:
## BLIST nxlet
## LR(1) items:
nxbot -> BLIST nxlet . nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 238
## Reductions:
-- On ELIST reduce production nxlist ->

State 234:
## Known stack suffix:
## LISTPUNCT
## LR(1) items:
nxlist -> LISTPUNCT . nxlet nxlist [ ELIST ]
nxlist -> LISTPUNCT . error [ ELIST ]
## Transitions:
-- On error shift to state 235
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 236
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 235:
## Known stack suffix:
## LISTPUNCT error
## LR(1) items:
nxlist -> LISTPUNCT error . [ ELIST ]
## Transitions:
## Reductions:
-- On ELIST reduce production nxlist -> LISTPUNCT error

State 236:
## Known stack suffix:
## LISTPUNCT nxlet
## LR(1) items:
nxlist -> LISTPUNCT nxlet . nxlist [ ELIST ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 237
## Reductions:
-- On ELIST reduce production nxlist ->

State 237:
## Known stack suffix:
## LISTPUNCT nxlet nxlist
## LR(1) items:
nxlist -> LISTPUNCT nxlet nxlist . [ ELIST ]
## Transitions:
## Reductions:
-- On ELIST reduce production nxlist -> LISTPUNCT nxlet nxlist

State 238:
## Known stack suffix:
## BLIST nxlet nxlist
## LR(1) items:
nxbot -> BLIST nxlet nxlist . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On ELIST shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## BLIST nxlet nxlist ELIST
## LR(1) items:
nxbot -> BLIST nxlet nxlist ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On UNITVALUE reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On TRUE reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On TIMES reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On THEN reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On RPAREN reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On PLUS reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On OVERWRITEGLOBALHASH reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On OPENSTR reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On OPENQT reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On NUMCONST reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On NEQ reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On MUTUAL reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On MOD reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On MINUS reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LT reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LPAREN reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LOR reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LISTPUNCT reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LETMUTABLE reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LETAND reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LET reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LEQ reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On LAND reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On IN reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On GT reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On GEQ reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On FINISH reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On FALSE reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On EQ reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On EOI reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On ENDMUTUAL reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On ELSE reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On ELIST reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On DO reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On DIVIDES reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On CONS reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On CONCAT reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On CLOSENUM reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On BLIST reduce production nxbot -> BLIST nxlet nxlist ELIST
-- On BEFORE reduce production nxbot -> BLIST nxlet nxlist ELIST

State 240:
## Known stack suffix:
## LT
## LR(1) items:
binop -> LT . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> LT

State 241:
## Known stack suffix:
## LOR
## LR(1) items:
binop -> LOR . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> LOR

State 242:
## Known stack suffix:
## LNOT
## LR(1) items:
binop -> LNOT . [ RPAREN ]
nxun -> LNOT . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> LNOT . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:
-- On RPAREN reduce production binop -> LNOT

State 243:
## Known stack suffix:
## LEQ
## LR(1) items:
binop -> LEQ . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> LEQ

State 244:
## Known stack suffix:
## LAND
## LR(1) items:
binop -> LAND . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> LAND

State 245:
## Known stack suffix:
## GT
## LR(1) items:
binop -> GT . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> GT

State 246:
## Known stack suffix:
## GEQ
## LR(1) items:
binop -> GEQ . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> GEQ

State 247:
## Known stack suffix:
## EQ
## LR(1) items:
binop -> EQ . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> EQ

State 248:
## Known stack suffix:
## DIVIDES
## LR(1) items:
binop -> DIVIDES . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> DIVIDES

State 249:
## Known stack suffix:
## CONCAT
## LR(1) items:
binop -> CONCAT . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> CONCAT

State 250:
## Known stack suffix:
## BEFORE
## LR(1) items:
binop -> BEFORE . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN reduce production binop -> BEFORE

State 251:
## Known stack suffix:
## LPAREN nxlet
## LR(1) items:
nxbot -> LPAREN nxlet . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## LPAREN nxlet RPAREN
## LR(1) items:
nxbot -> LPAREN nxlet RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> LPAREN nxlet RPAREN
-- On UNITVALUE reduce production nxbot -> LPAREN nxlet RPAREN
-- On TRUE reduce production nxbot -> LPAREN nxlet RPAREN
-- On TIMES reduce production nxbot -> LPAREN nxlet RPAREN
-- On THEN reduce production nxbot -> LPAREN nxlet RPAREN
-- On RPAREN reduce production nxbot -> LPAREN nxlet RPAREN
-- On PLUS reduce production nxbot -> LPAREN nxlet RPAREN
-- On OVERWRITEGLOBALHASH reduce production nxbot -> LPAREN nxlet RPAREN
-- On OPENSTR reduce production nxbot -> LPAREN nxlet RPAREN
-- On OPENQT reduce production nxbot -> LPAREN nxlet RPAREN
-- On NUMCONST reduce production nxbot -> LPAREN nxlet RPAREN
-- On NEQ reduce production nxbot -> LPAREN nxlet RPAREN
-- On MUTUAL reduce production nxbot -> LPAREN nxlet RPAREN
-- On MOD reduce production nxbot -> LPAREN nxlet RPAREN
-- On MINUS reduce production nxbot -> LPAREN nxlet RPAREN
-- On LT reduce production nxbot -> LPAREN nxlet RPAREN
-- On LPAREN reduce production nxbot -> LPAREN nxlet RPAREN
-- On LOR reduce production nxbot -> LPAREN nxlet RPAREN
-- On LISTPUNCT reduce production nxbot -> LPAREN nxlet RPAREN
-- On LETMUTABLE reduce production nxbot -> LPAREN nxlet RPAREN
-- On LETAND reduce production nxbot -> LPAREN nxlet RPAREN
-- On LET reduce production nxbot -> LPAREN nxlet RPAREN
-- On LEQ reduce production nxbot -> LPAREN nxlet RPAREN
-- On LAND reduce production nxbot -> LPAREN nxlet RPAREN
-- On IN reduce production nxbot -> LPAREN nxlet RPAREN
-- On GT reduce production nxbot -> LPAREN nxlet RPAREN
-- On GEQ reduce production nxbot -> LPAREN nxlet RPAREN
-- On FINISH reduce production nxbot -> LPAREN nxlet RPAREN
-- On FALSE reduce production nxbot -> LPAREN nxlet RPAREN
-- On EQ reduce production nxbot -> LPAREN nxlet RPAREN
-- On EOI reduce production nxbot -> LPAREN nxlet RPAREN
-- On ENDMUTUAL reduce production nxbot -> LPAREN nxlet RPAREN
-- On ELSE reduce production nxbot -> LPAREN nxlet RPAREN
-- On ELIST reduce production nxbot -> LPAREN nxlet RPAREN
-- On DO reduce production nxbot -> LPAREN nxlet RPAREN
-- On DIVIDES reduce production nxbot -> LPAREN nxlet RPAREN
-- On CONS reduce production nxbot -> LPAREN nxlet RPAREN
-- On CONCAT reduce production nxbot -> LPAREN nxlet RPAREN
-- On CLOSENUM reduce production nxbot -> LPAREN nxlet RPAREN
-- On BLIST reduce production nxbot -> LPAREN nxlet RPAREN
-- On BEFORE reduce production nxbot -> LPAREN nxlet RPAREN

State 253:
## Known stack suffix:
## LPAREN binop
## LR(1) items:
nxbot -> LPAREN binop . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## LPAREN binop RPAREN
## LR(1) items:
nxbot -> LPAREN binop RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> LPAREN binop RPAREN
-- On UNITVALUE reduce production nxbot -> LPAREN binop RPAREN
-- On TRUE reduce production nxbot -> LPAREN binop RPAREN
-- On TIMES reduce production nxbot -> LPAREN binop RPAREN
-- On THEN reduce production nxbot -> LPAREN binop RPAREN
-- On RPAREN reduce production nxbot -> LPAREN binop RPAREN
-- On PLUS reduce production nxbot -> LPAREN binop RPAREN
-- On OVERWRITEGLOBALHASH reduce production nxbot -> LPAREN binop RPAREN
-- On OPENSTR reduce production nxbot -> LPAREN binop RPAREN
-- On OPENQT reduce production nxbot -> LPAREN binop RPAREN
-- On NUMCONST reduce production nxbot -> LPAREN binop RPAREN
-- On NEQ reduce production nxbot -> LPAREN binop RPAREN
-- On MUTUAL reduce production nxbot -> LPAREN binop RPAREN
-- On MOD reduce production nxbot -> LPAREN binop RPAREN
-- On MINUS reduce production nxbot -> LPAREN binop RPAREN
-- On LT reduce production nxbot -> LPAREN binop RPAREN
-- On LPAREN reduce production nxbot -> LPAREN binop RPAREN
-- On LOR reduce production nxbot -> LPAREN binop RPAREN
-- On LISTPUNCT reduce production nxbot -> LPAREN binop RPAREN
-- On LETMUTABLE reduce production nxbot -> LPAREN binop RPAREN
-- On LETAND reduce production nxbot -> LPAREN binop RPAREN
-- On LET reduce production nxbot -> LPAREN binop RPAREN
-- On LEQ reduce production nxbot -> LPAREN binop RPAREN
-- On LAND reduce production nxbot -> LPAREN binop RPAREN
-- On IN reduce production nxbot -> LPAREN binop RPAREN
-- On GT reduce production nxbot -> LPAREN binop RPAREN
-- On GEQ reduce production nxbot -> LPAREN binop RPAREN
-- On FINISH reduce production nxbot -> LPAREN binop RPAREN
-- On FALSE reduce production nxbot -> LPAREN binop RPAREN
-- On EQ reduce production nxbot -> LPAREN binop RPAREN
-- On EOI reduce production nxbot -> LPAREN binop RPAREN
-- On ENDMUTUAL reduce production nxbot -> LPAREN binop RPAREN
-- On ELSE reduce production nxbot -> LPAREN binop RPAREN
-- On ELIST reduce production nxbot -> LPAREN binop RPAREN
-- On DO reduce production nxbot -> LPAREN binop RPAREN
-- On DIVIDES reduce production nxbot -> LPAREN binop RPAREN
-- On CONS reduce production nxbot -> LPAREN binop RPAREN
-- On CONCAT reduce production nxbot -> LPAREN binop RPAREN
-- On CLOSENUM reduce production nxbot -> LPAREN binop RPAREN
-- On BLIST reduce production nxbot -> LPAREN binop RPAREN
-- On BEFORE reduce production nxbot -> LPAREN binop RPAREN

State 255:
## Known stack suffix:
## REFFINAL nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFFINAL nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> REFFINAL nxapp
-- On THEN reduce production nxun -> REFFINAL nxapp
-- On RPAREN reduce production nxun -> REFFINAL nxapp
-- On PLUS reduce production nxun -> REFFINAL nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFFINAL nxapp
-- On NEQ reduce production nxun -> REFFINAL nxapp
-- On MUTUAL reduce production nxun -> REFFINAL nxapp
-- On MOD reduce production nxun -> REFFINAL nxapp
-- On MINUS reduce production nxun -> REFFINAL nxapp
-- On LT reduce production nxun -> REFFINAL nxapp
-- On LOR reduce production nxun -> REFFINAL nxapp
-- On LISTPUNCT reduce production nxun -> REFFINAL nxapp
-- On LETMUTABLE reduce production nxun -> REFFINAL nxapp
-- On LETAND reduce production nxun -> REFFINAL nxapp
-- On LET reduce production nxun -> REFFINAL nxapp
-- On LEQ reduce production nxun -> REFFINAL nxapp
-- On LAND reduce production nxun -> REFFINAL nxapp
-- On IN reduce production nxun -> REFFINAL nxapp
-- On GT reduce production nxun -> REFFINAL nxapp
-- On GEQ reduce production nxun -> REFFINAL nxapp
-- On EQ reduce production nxun -> REFFINAL nxapp
-- On EOI reduce production nxun -> REFFINAL nxapp
-- On ENDMUTUAL reduce production nxun -> REFFINAL nxapp
-- On ELSE reduce production nxun -> REFFINAL nxapp
-- On ELIST reduce production nxun -> REFFINAL nxapp
-- On DO reduce production nxun -> REFFINAL nxapp
-- On DIVIDES reduce production nxun -> REFFINAL nxapp
-- On CONS reduce production nxun -> REFFINAL nxapp
-- On CONCAT reduce production nxun -> REFFINAL nxapp
-- On CLOSENUM reduce production nxun -> REFFINAL nxapp
-- On BEFORE reduce production nxun -> REFFINAL nxapp

State 256:
## Known stack suffix:
## RENEWGLOBALHASH nxlet
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 258
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 259
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 258:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On RPAREN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On MUTUAL reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LISTPUNCT reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LETMUTABLE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LETAND reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On LET reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On IN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On EOI reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ENDMUTUAL reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ELSE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On ELIST reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On DO reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On CLOSENUM reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
-- On BEFORE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 259:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On RPAREN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On MUTUAL reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LISTPUNCT reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LETMUTABLE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LETAND reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On LET reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On IN reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On EOI reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ENDMUTUAL reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ELSE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On ELIST reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On DO reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On CLOSENUM reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
-- On BEFORE reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 260:
## Known stack suffix:
## OPENNUM nxlet
## LR(1) items:
narg -> OPENNUM nxlet . CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet . CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On CLOSENUM shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM . narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet CLOSENUM . error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 262
-- On OPENNUM shift to state 30
-- On narg shift to state 263
## Reductions:
-- On OPENQT reduce production narg ->
-- On END reduce production narg ->
-- On BGRP reduce production narg ->

State 262:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM error
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM error . [ OPENQT END BGRP ]
## Transitions:
## Reductions:
-- On OPENQT reduce production narg -> OPENNUM nxlet CLOSENUM error
-- On END reduce production narg -> OPENNUM nxlet CLOSENUM error
-- On BGRP reduce production narg -> OPENNUM nxlet CLOSENUM error

State 263:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM narg
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM narg . [ OPENQT END BGRP ]
## Transitions:
## Reductions:
-- On OPENQT reduce production narg -> OPENNUM nxlet CLOSENUM narg
-- On END reduce production narg -> OPENNUM nxlet CLOSENUM narg
-- On BGRP reduce production narg -> OPENNUM nxlet CLOSENUM narg

State 264:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg . sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 265
-- On END shift to state 279
-- On BGRP shift to state 280
-- On sarg shift to state 286
## Reductions:

State 265:
## Known stack suffix:
## OPENQT
## LR(1) items:
sarg -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 266
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 266:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sarg -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 278
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 268:
## Known stack suffix:
## OPENQT
## LR(1) items:
sargsub -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 269
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 269:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sargsub -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 277
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 271:
## Known stack suffix:
## BGRP
## LR(1) items:
sargsub -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 272
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 273
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP reduce production sxblock ->

State 272:
## Known stack suffix:
## BGRP error
## LR(1) items:
sargsub -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sargsub -> BGRP error
-- On SPACE reduce production sargsub -> BGRP error
-- On SEP reduce production sargsub -> BGRP error
-- On EOI reduce production sargsub -> BGRP error
-- On EGRP reduce production sargsub -> BGRP error
-- On CTRLSEQ reduce production sargsub -> BGRP error
-- On CLOSESTR reduce production sargsub -> BGRP error
-- On CLOSEQT reduce production sargsub -> BGRP error
-- On CHAR reduce production sargsub -> BGRP error
-- On BREAK reduce production sargsub -> BGRP error

State 273:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sargsub -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sargsub -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 275
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 276
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 275:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sargsub -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sargsub -> BGRP sxsep EGRP error
-- On SPACE reduce production sargsub -> BGRP sxsep EGRP error
-- On SEP reduce production sargsub -> BGRP sxsep EGRP error
-- On EOI reduce production sargsub -> BGRP sxsep EGRP error
-- On EGRP reduce production sargsub -> BGRP sxsep EGRP error
-- On CTRLSEQ reduce production sargsub -> BGRP sxsep EGRP error
-- On CLOSESTR reduce production sargsub -> BGRP sxsep EGRP error
-- On CLOSEQT reduce production sargsub -> BGRP sxsep EGRP error
-- On CHAR reduce production sargsub -> BGRP sxsep EGRP error
-- On BREAK reduce production sargsub -> BGRP sxsep EGRP error

State 276:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sargsub -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On SPACE reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On SEP reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On EOI reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On EGRP reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On CTRLSEQ reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On CLOSESTR reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On CLOSEQT reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On CHAR reduce production sargsub -> BGRP sxsep EGRP sargsub
-- On BREAK reduce production sargsub -> BGRP sxsep EGRP sargsub

State 277:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On SPACE reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On SEP reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On EOI reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On EGRP reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On CTRLSEQ reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On CLOSESTR reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On CLOSEQT reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On CHAR reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub
-- On BREAK reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub

State 278:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On SPACE reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On SEP reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On EOI reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On EGRP reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On CTRLSEQ reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On CLOSESTR reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On CLOSEQT reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On CHAR reduce production sarg -> OPENQT sxsep CLOSEQT sargsub
-- On BREAK reduce production sarg -> OPENQT sxsep CLOSEQT sargsub

State 279:
## Known stack suffix:
## END
## LR(1) items:
sarg -> END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sarg -> END
-- On SPACE reduce production sarg -> END
-- On SEP reduce production sarg -> END
-- On EOI reduce production sarg -> END
-- On EGRP reduce production sarg -> END
-- On CTRLSEQ reduce production sarg -> END
-- On CLOSESTR reduce production sarg -> END
-- On CLOSEQT reduce production sarg -> END
-- On CHAR reduce production sarg -> END
-- On BREAK reduce production sarg -> END

State 280:
## Known stack suffix:
## BGRP
## LR(1) items:
sarg -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 281
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 282
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP reduce production sxblock ->

State 281:
## Known stack suffix:
## BGRP error
## LR(1) items:
sarg -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sarg -> BGRP error
-- On SPACE reduce production sarg -> BGRP error
-- On SEP reduce production sarg -> BGRP error
-- On EOI reduce production sarg -> BGRP error
-- On EGRP reduce production sarg -> BGRP error
-- On CTRLSEQ reduce production sarg -> BGRP error
-- On CLOSESTR reduce production sarg -> BGRP error
-- On CLOSEQT reduce production sarg -> BGRP error
-- On CHAR reduce production sarg -> BGRP error
-- On BREAK reduce production sarg -> BGRP error

State 282:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sarg -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sarg -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 284
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 285
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 284:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sarg -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sarg -> BGRP sxsep EGRP error
-- On SPACE reduce production sarg -> BGRP sxsep EGRP error
-- On SEP reduce production sarg -> BGRP sxsep EGRP error
-- On EOI reduce production sarg -> BGRP sxsep EGRP error
-- On EGRP reduce production sarg -> BGRP sxsep EGRP error
-- On CTRLSEQ reduce production sarg -> BGRP sxsep EGRP error
-- On CLOSESTR reduce production sarg -> BGRP sxsep EGRP error
-- On CLOSEQT reduce production sarg -> BGRP sxsep EGRP error
-- On CHAR reduce production sarg -> BGRP sxsep EGRP error
-- On BREAK reduce production sarg -> BGRP sxsep EGRP error

State 285:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sarg -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sarg -> BGRP sxsep EGRP sargsub
-- On SPACE reduce production sarg -> BGRP sxsep EGRP sargsub
-- On SEP reduce production sarg -> BGRP sxsep EGRP sargsub
-- On EOI reduce production sarg -> BGRP sxsep EGRP sargsub
-- On EGRP reduce production sarg -> BGRP sxsep EGRP sargsub
-- On CTRLSEQ reduce production sarg -> BGRP sxsep EGRP sargsub
-- On CLOSESTR reduce production sarg -> BGRP sxsep EGRP sargsub
-- On CLOSEQT reduce production sarg -> BGRP sxsep EGRP sargsub
-- On CHAR reduce production sarg -> BGRP sxsep EGRP sargsub
-- On BREAK reduce production sarg -> BGRP sxsep EGRP sargsub

State 286:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg sarg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Reductions:
-- On VARINSTR reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On SPACE reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On SEP reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On EOI reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On EGRP reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On CTRLSEQ reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On CLOSESTR reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On CLOSEQT reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On CHAR reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg
-- On BREAK reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg

State 287:
## Known stack suffix:
## SEP sxsepsub
## LR(1) items:
sxsep -> SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On EGRP reduce production sxsep -> SEP sxsepsub
-- On CLOSESTR reduce production sxsep -> SEP sxsepsub
-- On CLOSEQT reduce production sxsep -> SEP sxsepsub

State 288:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsepsub -> sxblock . SEP sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock . SEP error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On SEP shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## sxblock SEP
## LR(1) items:
sxsepsub -> sxblock SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 290
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 291
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP reduce production sxblock ->
-- On EGRP reduce production sxsepsub ->
-- On CLOSESTR reduce production sxsepsub ->
-- On CLOSEQT reduce production sxsepsub ->

State 290:
## Known stack suffix:
## sxblock SEP error
## LR(1) items:
sxsepsub -> sxblock SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On EGRP reduce production sxsepsub -> sxblock SEP error
-- On CLOSESTR reduce production sxsepsub -> sxblock SEP error
-- On CLOSEQT reduce production sxsepsub -> sxblock SEP error

State 291:
## Known stack suffix:
## sxblock SEP sxsepsub
## LR(1) items:
sxsepsub -> sxblock SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Reductions:
-- On EGRP reduce production sxsepsub -> sxblock SEP sxsepsub
-- On CLOSESTR reduce production sxsepsub -> sxblock SEP sxsepsub
-- On CLOSEQT reduce production sxsepsub -> sxblock SEP sxsepsub

State 292:
## Known stack suffix:
## OPENSTR sxsep
## LR(1) items:
nxbot -> OPENSTR sxsep . CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSESTR shift to state 293
## Reductions:

State 293:
## Known stack suffix:
## OPENSTR sxsep CLOSESTR
## LR(1) items:
nxbot -> OPENSTR sxsep CLOSESTR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Reductions:
-- On VAR reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On UNITVALUE reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On TRUE reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On TIMES reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On THEN reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On RPAREN reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On PLUS reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On OVERWRITEGLOBALHASH reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On OPENSTR reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On OPENQT reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On NUMCONST reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On NEQ reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On MUTUAL reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On MOD reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On MINUS reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LT reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LPAREN reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LOR reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LISTPUNCT reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LETMUTABLE reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LETAND reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LET reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LEQ reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On LAND reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On IN reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On GT reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On GEQ reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On FINISH reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On FALSE reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On EQ reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On EOI reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On ENDMUTUAL reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On ELSE reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On ELIST reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On DO reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On DIVIDES reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On CONS reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On CONCAT reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On CLOSENUM reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On BLIST reduce production nxbot -> OPENSTR sxsep CLOSESTR
-- On BEFORE reduce production nxbot -> OPENSTR sxsep CLOSESTR

State 294:
## Known stack suffix:
## REFNOW nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFNOW nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> REFNOW nxapp
-- On THEN reduce production nxun -> REFNOW nxapp
-- On RPAREN reduce production nxun -> REFNOW nxapp
-- On PLUS reduce production nxun -> REFNOW nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFNOW nxapp
-- On NEQ reduce production nxun -> REFNOW nxapp
-- On MUTUAL reduce production nxun -> REFNOW nxapp
-- On MOD reduce production nxun -> REFNOW nxapp
-- On MINUS reduce production nxun -> REFNOW nxapp
-- On LT reduce production nxun -> REFNOW nxapp
-- On LOR reduce production nxun -> REFNOW nxapp
-- On LISTPUNCT reduce production nxun -> REFNOW nxapp
-- On LETMUTABLE reduce production nxun -> REFNOW nxapp
-- On LETAND reduce production nxun -> REFNOW nxapp
-- On LET reduce production nxun -> REFNOW nxapp
-- On LEQ reduce production nxun -> REFNOW nxapp
-- On LAND reduce production nxun -> REFNOW nxapp
-- On IN reduce production nxun -> REFNOW nxapp
-- On GT reduce production nxun -> REFNOW nxapp
-- On GEQ reduce production nxun -> REFNOW nxapp
-- On EQ reduce production nxun -> REFNOW nxapp
-- On EOI reduce production nxun -> REFNOW nxapp
-- On ENDMUTUAL reduce production nxun -> REFNOW nxapp
-- On ELSE reduce production nxun -> REFNOW nxapp
-- On ELIST reduce production nxun -> REFNOW nxapp
-- On DO reduce production nxun -> REFNOW nxapp
-- On DIVIDES reduce production nxun -> REFNOW nxapp
-- On CONS reduce production nxun -> REFNOW nxapp
-- On CONCAT reduce production nxun -> REFNOW nxapp
-- On CLOSENUM reduce production nxun -> REFNOW nxapp
-- On BEFORE reduce production nxun -> REFNOW nxapp

State 295:
## Known stack suffix:
## VAR OVERWRITEEQ nxlor
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Reductions:
-- On THEN reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On RPAREN reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On OVERWRITEGLOBALHASH reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On MUTUAL reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On LISTPUNCT reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On LETMUTABLE reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On LETAND reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On LET reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On IN reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On EOI reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On ENDMUTUAL reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On ELSE reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On ELIST reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On DO reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On CLOSENUM reduce production nxlambda -> VAR OVERWRITEEQ nxlor
-- On BEFORE reduce production nxlambda -> VAR OVERWRITEEQ nxlor

State 296:
## Known stack suffix:
## WHILE nxlet
## LR(1) items:
nxwhl -> WHILE nxlet . DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet . DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DO shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## WHILE nxlet DO
## LR(1) items:
nxwhl -> WHILE nxlet DO . nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet DO . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 298
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 299
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 298:
## Known stack suffix:
## WHILE nxlet DO error
## LR(1) items:
nxwhl -> WHILE nxlet DO error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxwhl -> WHILE nxlet DO error
-- On RPAREN reduce production nxwhl -> WHILE nxlet DO error
-- On OVERWRITEGLOBALHASH reduce production nxwhl -> WHILE nxlet DO error
-- On MUTUAL reduce production nxwhl -> WHILE nxlet DO error
-- On LISTPUNCT reduce production nxwhl -> WHILE nxlet DO error
-- On LETMUTABLE reduce production nxwhl -> WHILE nxlet DO error
-- On LETAND reduce production nxwhl -> WHILE nxlet DO error
-- On LET reduce production nxwhl -> WHILE nxlet DO error
-- On IN reduce production nxwhl -> WHILE nxlet DO error
-- On EOI reduce production nxwhl -> WHILE nxlet DO error
-- On ENDMUTUAL reduce production nxwhl -> WHILE nxlet DO error
-- On ELSE reduce production nxwhl -> WHILE nxlet DO error
-- On ELIST reduce production nxwhl -> WHILE nxlet DO error
-- On DO reduce production nxwhl -> WHILE nxlet DO error
-- On CLOSENUM reduce production nxwhl -> WHILE nxlet DO error

State 299:
## Known stack suffix:
## WHILE nxlet DO nxwhl
## LR(1) items:
nxwhl -> WHILE nxlet DO nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Reductions:
-- On THEN reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On RPAREN reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On OVERWRITEGLOBALHASH reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On MUTUAL reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On LISTPUNCT reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On LETMUTABLE reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On LETAND reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On LET reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On IN reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On EOI reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On ENDMUTUAL reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On ELSE reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On ELIST reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On DO reduce production nxwhl -> WHILE nxlet DO nxwhl
-- On CLOSENUM reduce production nxwhl -> WHILE nxlet DO nxwhl

State 300:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 313
## Reductions:

State 301:
## Known stack suffix:
## LET
## LR(1) items:
nxmutual -> LET . VAR argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
nxmutual -> LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 302
-- On CTRLSEQ shift to state 308
## Reductions:

State 302:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxmutual -> LET VAR . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 303
## Reductions:
-- On DEFEQ reduce production argvar ->

State 303:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxmutual -> LET VAR argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 304
## Reductions:

State 304:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 305
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 305:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 307
## Reductions:

State 306:
## Known stack suffix:
## ENDMUTUAL
## LR(1) items:
nxmutual -> ENDMUTUAL . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxmutual -> ENDMUTUAL
-- On LETMUTABLE reduce production nxmutual -> ENDMUTUAL
-- On LET reduce production nxmutual -> ENDMUTUAL
-- On IN reduce production nxmutual -> ENDMUTUAL
-- On EOI reduce production nxmutual -> ENDMUTUAL

State 307:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual
-- On LETMUTABLE reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual
-- On LET reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual
-- On IN reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual
-- On EOI reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual

State 308:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 309
## Reductions:
-- On DEFEQ reduce production argvar ->

State 309:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 311
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 311:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Reductions:
-- On MUTUAL reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual
-- On LETMUTABLE reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual
-- On LET reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual
-- On IN reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual
-- On EOI reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 313:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 347
-- On nxtoplevel shift to state 349
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual

State 314:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 315
-- On VAR shift to state 316
## Reductions:

State 315:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxtoplevel -> LETMUTABLE error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE error

State 316:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . error [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 317
-- On OVERWRITEEQ shift to state 318
## Reductions:

State 317:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR error

State 318:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . error [ EOI ]
## Transitions:
-- On error shift to state 319
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 320
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 319:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error

State 320:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 344
-- On nxtoplevel shift to state 346
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet

State 321:
## Known stack suffix:
## LET
## LR(1) items:
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . error [ EOI ]
nxtoplevel -> LET . VAR error [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 322
-- On VAR shift to state 323
-- On CTRLSEQ shift to state 333
## Reductions:

State 322:
## Known stack suffix:
## LET error
## LR(1) items:
nxtoplevel -> LET error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET error

State 323:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR . error [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ error [ EOI ]
## Transitions:
-- On error shift to state 324
-- On VAR shift to state 7
-- On argvar shift to state 325
## Reductions:
-- On DEFEQ reduce production argvar ->

State 324:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxtoplevel -> LET VAR error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR error

State 325:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . error [ EOI ]
## Transitions:
-- On error shift to state 327
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 328
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 327:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR argvar DEFEQ error

State 328:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 329
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 329:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 330
-- On nxtoplevel shift to state 332
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec

State 330:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 331
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 331:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 332:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel

State 333:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 334
-- On VAR shift to state 7
-- On argvar shift to state 335
## Reductions:
-- On DEFEQ reduce production argvar ->

State 334:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ error

State 335:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 337
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 338
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 337:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ error

State 338:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 339
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 339:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 340
-- On nxtoplevel shift to state 343
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec

State 340:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ EOI ]
## Transitions:
-- On error shift to state 341
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 342
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 341:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 342:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 343:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel

State 344:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 345
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 345:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 346:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel

State 347:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 348
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 348:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet

State 349:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel

State 350:
## Known stack suffix:
## MUTUAL LET CTRLSEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 351
## Reductions:
-- On DEFEQ reduce production argvar ->

State 351:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 353
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 353:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 355
-- On nxtoplevel shift to state 357
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 355:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 356
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 356:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet

State 357:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel

State 358:
## Known stack suffix:
## sxblock
## LR(1) items:
main -> sxblock . EOI [ # ]
## Transitions:
-- On EOI shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## sxblock EOI
## LR(1) items:
main -> sxblock EOI . [ # ]
## Transitions:
## Reductions:
-- On # reduce production main -> sxblock EOI

State 360:
## Known stack suffix:
## nxtoplevel
## LR(1) items:
main -> nxtoplevel . EOI [ # ]
## Transitions:
-- On EOI shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## nxtoplevel EOI
## LR(1) items:
main -> nxtoplevel EOI . [ # ]
## Transitions:
## Reductions:
-- On # reduce production main -> nxtoplevel EOI

State 362:
## Known stack suffix:
## main
## LR(1) items:
main' -> main . [ # ]
## Transitions:
## Reductions:
-- On # accept main

