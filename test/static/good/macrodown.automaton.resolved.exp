State 0:
## Known stack suffix:
##
## LR(1) items:
main' -> . main [ # ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 358
-- On nxtoplevel shift to state 360
-- On main shift to state 362
## Reductions:
-- On EOI reduce production sxblock ->

State 1:
## Known stack suffix:
## VARINSTR
## LR(1) items:
sxbot -> VARINSTR . END [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On END shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## VARINSTR END
## LR(1) items:
sxbot -> VARINSTR END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> VARINSTR END

State 3:
## Known stack suffix:
## SPACE
## LR(1) items:
sxbot -> SPACE . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> SPACE

State 4:
## Known stack suffix:
## MUTUAL
## LR(1) items:
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## MUTUAL LET
## LR(1) items:
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 6
-- On CTRLSEQ shift to state 350
## Reductions:

State 6:
## Known stack suffix:
## MUTUAL LET VAR
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 9
## Reductions:
-- On DEFEQ reduce production argvar ->

State 7:
## Known stack suffix:
## VAR
## LR(1) items:
argvar -> VAR . argvar [ DEFEQ ARROW ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 8
## Reductions:
-- On DEFEQ reduce production argvar ->
-- On ARROW reduce production argvar ->

State 8:
## Known stack suffix:
## VAR argvar
## LR(1) items:
argvar -> VAR argvar . [ DEFEQ ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production argvar -> VAR argvar

State 9:
## Known stack suffix:
## MUTUAL LET VAR argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 300
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 11:
## Known stack suffix:
## WHILE
## LR(1) items:
nxwhl -> WHILE . nxlet DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . nxlet DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 12
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 296
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 12:
## Known stack suffix:
## WHILE error
## LR(1) items:
nxwhl -> WHILE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE error

State 13:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxlambda -> VAR . OVERWRITEEQ nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEEQ shift to state 14
## Reductions:
-- On VAR reduce production nxbot -> VAR
-- On UNITVALUE reduce production nxbot -> VAR
-- On TRUE reduce production nxbot -> VAR
-- On TIMES reduce production nxbot -> VAR
-- On THEN reduce production nxbot -> VAR
-- On RPAREN reduce production nxbot -> VAR
-- On PLUS reduce production nxbot -> VAR
-- On OVERWRITEGLOBALHASH reduce production nxbot -> VAR
-- On OPENSTR reduce production nxbot -> VAR
-- On OPENQT reduce production nxbot -> VAR
-- On NUMCONST reduce production nxbot -> VAR
-- On NEQ reduce production nxbot -> VAR
-- On MUTUAL reduce production nxbot -> VAR
-- On MOD reduce production nxbot -> VAR
-- On MINUS reduce production nxbot -> VAR
-- On LT reduce production nxbot -> VAR
-- On LPAREN reduce production nxbot -> VAR
-- On LOR reduce production nxbot -> VAR
-- On LISTPUNCT reduce production nxbot -> VAR
-- On LETMUTABLE reduce production nxbot -> VAR
-- On LETAND reduce production nxbot -> VAR
-- On LET reduce production nxbot -> VAR
-- On LEQ reduce production nxbot -> VAR
-- On LAND reduce production nxbot -> VAR
-- On IN reduce production nxbot -> VAR
-- On GT reduce production nxbot -> VAR
-- On GEQ reduce production nxbot -> VAR
-- On FINISH reduce production nxbot -> VAR
-- On FALSE reduce production nxbot -> VAR
-- On EQ reduce production nxbot -> VAR
-- On EOI reduce production nxbot -> VAR
-- On ENDMUTUAL reduce production nxbot -> VAR
-- On ELSE reduce production nxbot -> VAR
-- On ELIST reduce production nxbot -> VAR
-- On DO reduce production nxbot -> VAR
-- On DIVIDES reduce production nxbot -> VAR
-- On CONS reduce production nxbot -> VAR
-- On CONCAT reduce production nxbot -> VAR
-- On CLOSENUM reduce production nxbot -> VAR
-- On BLIST reduce production nxbot -> VAR
-- On BEFORE reduce production nxbot -> VAR

State 14:
## Known stack suffix:
## VAR OVERWRITEEQ
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 295
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 15:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> VAR

State 16:
## Known stack suffix:
## UNITVALUE
## LR(1) items:
nxbot -> UNITVALUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> UNITVALUE

State 17:
## Known stack suffix:
## TRUE
## LR(1) items:
nxbot -> TRUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> TRUE

State 18:
## Known stack suffix:
## REFNOW
## LR(1) items:
nxun -> REFNOW . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFNOW . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 19
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 294
## Reductions:

State 19:
## Known stack suffix:
## REFNOW error
## LR(1) items:
nxun -> REFNOW error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> REFNOW error

State 20:
## Known stack suffix:
## OPENSTR
## LR(1) items:
nxbot -> OPENSTR . sxsep CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> OPENSTR . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 21
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 292
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSESTR reduce production sxblock ->

State 21:
## Known stack suffix:
## OPENSTR error
## LR(1) items:
nxbot -> OPENSTR error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENSTR error

State 22:
## Known stack suffix:
## SEP
## LR(1) items:
sxsep -> SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsep -> SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 23
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 287
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP reduce production sxblock ->
-- On EGRP reduce production sxsepsub ->
-- On CLOSESTR reduce production sxsepsub ->
-- On CLOSEQT reduce production sxsepsub ->

State 23:
## Known stack suffix:
## SEP error
## LR(1) items:
sxsep -> SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> SEP error

State 24:
## Known stack suffix:
## CTRLSEQ
## LR(1) items:
sxbot -> CTRLSEQ . sxclsnm sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sxbot -> CTRLSEQ . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 25
-- On CLASSNAME shift to state 26
-- On sxclsnm shift to state 27
## Reductions:
-- On OPENQT reduce production sxclsnm ->
-- On OPENNUM reduce production sxclsnm ->
-- On IDNAME reduce production sxclsnm ->
-- On END reduce production sxclsnm ->
-- On BGRP reduce production sxclsnm ->

State 25:
## Known stack suffix:
## CTRLSEQ error
## LR(1) items:
sxbot -> CTRLSEQ error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CTRLSEQ error

State 26:
## Known stack suffix:
## CLASSNAME
## LR(1) items:
sxclsnm -> CLASSNAME . [ OPENQT OPENNUM IDNAME END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxclsnm -> CLASSNAME

State 27:
## Known stack suffix:
## CTRLSEQ sxclsnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm . sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On IDNAME shift to state 28
-- On sxidnm shift to state 29
## Reductions:
-- On OPENQT reduce production sxidnm ->
-- On OPENNUM reduce production sxidnm ->
-- On END reduce production sxidnm ->
-- On BGRP reduce production sxidnm ->

State 28:
## Known stack suffix:
## IDNAME
## LR(1) items:
sxidnm -> IDNAME . [ OPENQT OPENNUM END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxidnm -> IDNAME

State 29:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm . narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENNUM shift to state 30
-- On narg shift to state 264
## Reductions:
-- On OPENQT reduce production narg ->
-- On END reduce production narg ->
-- On BGRP reduce production narg ->

State 30:
## Known stack suffix:
## OPENNUM
## LR(1) items:
narg -> OPENNUM . nxlet CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM . error [ OPENQT END BGRP ]
narg -> OPENNUM . nxlet CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 31
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 260
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 31:
## Known stack suffix:
## OPENNUM error
## LR(1) items:
narg -> OPENNUM error . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM error

State 32:
## Known stack suffix:
## RENEWGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 33
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 256
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 33:
## Known stack suffix:
## RENEWGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH error

State 34:
## Known stack suffix:
## REFFINAL
## LR(1) items:
nxun -> REFFINAL . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFFINAL . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 35
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 255
## Reductions:

State 35:
## Known stack suffix:
## REFFINAL error
## LR(1) items:
nxun -> REFFINAL error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> REFFINAL error

State 36:
## Known stack suffix:
## OPENQT
## LR(1) items:
nxbot -> OPENQT . sxsep CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 39
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 37:
## Known stack suffix:
## CHAR
## LR(1) items:
sxbot -> CHAR . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CHAR

State 38:
## Known stack suffix:
## BREAK
## LR(1) items:
sxbot -> BREAK . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> BREAK

State 39:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
nxbot -> OPENQT sxsep . CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSEQT shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
nxbot -> OPENQT sxsep CLOSEQT . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENQT sxsep CLOSEQT

State 41:
## Known stack suffix:
## sxbot
## LR(1) items:
sxblock -> sxbot . sxblock [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 42
## Reductions:
-- On SEP reduce production sxblock ->
-- On EOI reduce production sxblock ->
-- On EGRP reduce production sxblock ->
-- On CLOSESTR reduce production sxblock ->
-- On CLOSEQT reduce production sxblock ->

State 42:
## Known stack suffix:
## sxbot sxblock
## LR(1) items:
sxblock -> sxbot sxblock . [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxblock -> sxbot sxblock

State 43:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsep -> sxblock . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> sxblock

State 44:
## Known stack suffix:
## NUMCONST
## LR(1) items:
nxbot -> NUMCONST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> NUMCONST

State 45:
## Known stack suffix:
## LPAREN
## LR(1) items:
nxbot -> LPAREN . nxlet RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . binop RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 46
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 47
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On PLUS shift to state 48
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On NEQ shift to state 49
-- On MOD shift to state 50
-- On MINUS shift to state 51
-- On LT shift to state 240
-- On LPAREN shift to state 45
-- On LOR shift to state 241
-- On LNOT shift to state 242
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LEQ shift to state 243
-- On LAND shift to state 244
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On GT shift to state 245
-- On GEQ shift to state 246
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On EQ shift to state 247
-- On DIVIDES shift to state 248
-- On DECGLOBALHASH shift to state 163
-- On CONCAT shift to state 249
-- On BLIST shift to state 55
-- On BEFORE shift to state 250
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 251
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
-- On binop shift to state 253
## Reductions:

State 46:
## Known stack suffix:
## LPAREN error
## LR(1) items:
nxbot -> LPAREN error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN error

State 47:
## Known stack suffix:
## TIMES
## LR(1) items:
binop -> TIMES . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> TIMES

State 48:
## Known stack suffix:
## PLUS
## LR(1) items:
binop -> PLUS . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> PLUS

State 49:
## Known stack suffix:
## NEQ
## LR(1) items:
binop -> NEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> NEQ

State 50:
## Known stack suffix:
## MOD
## LR(1) items:
binop -> MOD . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> MOD

State 51:
## Known stack suffix:
## MINUS
## LR(1) items:
binop -> MINUS . [ RPAREN ]
nxun -> MINUS . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> MINUS . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:
-- On RPAREN reduce production binop -> MINUS

State 52:
## Known stack suffix:
## MINUS error
## LR(1) items:
nxun -> MINUS error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> MINUS error

State 53:
## Known stack suffix:
## FINISH
## LR(1) items:
nxbot -> FINISH . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> FINISH

State 54:
## Known stack suffix:
## FALSE
## LR(1) items:
nxbot -> FALSE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> FALSE

State 55:
## Known stack suffix:
## BLIST
## LR(1) items:
nxbot -> BLIST . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . nxlet nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 56
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On ELIST shift to state 232
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 233
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 56:
## Known stack suffix:
## BLIST error
## LR(1) items:
nxbot -> BLIST error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST error

State 57:
## Known stack suffix:
## MINUS
## LR(1) items:
nxun -> MINUS . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> MINUS . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:

State 58:
## Known stack suffix:
## nxbot
## LR(1) items:
nxapp -> nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxapp -> nxbot

State 59:
## Known stack suffix:
## MINUS nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> MINUS nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> MINUS nxapp
-- On THEN reduce production nxun -> MINUS nxapp
-- On RPAREN reduce production nxun -> MINUS nxapp
-- On PLUS reduce production nxun -> MINUS nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> MINUS nxapp
-- On NEQ reduce production nxun -> MINUS nxapp
-- On MUTUAL reduce production nxun -> MINUS nxapp
-- On MOD reduce production nxun -> MINUS nxapp
-- On MINUS reduce production nxun -> MINUS nxapp
-- On LT reduce production nxun -> MINUS nxapp
-- On LOR reduce production nxun -> MINUS nxapp
-- On LISTPUNCT reduce production nxun -> MINUS nxapp
-- On LETMUTABLE reduce production nxun -> MINUS nxapp
-- On LETAND reduce production nxun -> MINUS nxapp
-- On LET reduce production nxun -> MINUS nxapp
-- On LEQ reduce production nxun -> MINUS nxapp
-- On LAND reduce production nxun -> MINUS nxapp
-- On IN reduce production nxun -> MINUS nxapp
-- On GT reduce production nxun -> MINUS nxapp
-- On GEQ reduce production nxun -> MINUS nxapp
-- On EQ reduce production nxun -> MINUS nxapp
-- On EOI reduce production nxun -> MINUS nxapp
-- On ENDMUTUAL reduce production nxun -> MINUS nxapp
-- On ELSE reduce production nxun -> MINUS nxapp
-- On ELIST reduce production nxun -> MINUS nxapp
-- On DO reduce production nxun -> MINUS nxapp
-- On DIVIDES reduce production nxun -> MINUS nxapp
-- On CONS reduce production nxun -> MINUS nxapp
-- On CONCAT reduce production nxun -> MINUS nxapp
-- On CLOSENUM reduce production nxun -> MINUS nxapp
-- On BEFORE reduce production nxun -> MINUS nxapp

State 60:
## Known stack suffix:
## nxapp nxbot
## LR(1) items:
nxapp -> nxapp nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxapp -> nxapp nxbot

State 61:
## Known stack suffix:
## LNOT
## LR(1) items:
nxun -> LNOT . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> LNOT . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:

State 62:
## Known stack suffix:
## LNOT error
## LR(1) items:
nxun -> LNOT error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> LNOT error

State 63:
## Known stack suffix:
## LNOT nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> LNOT nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> LNOT nxapp
-- On THEN reduce production nxun -> LNOT nxapp
-- On RPAREN reduce production nxun -> LNOT nxapp
-- On PLUS reduce production nxun -> LNOT nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> LNOT nxapp
-- On NEQ reduce production nxun -> LNOT nxapp
-- On MUTUAL reduce production nxun -> LNOT nxapp
-- On MOD reduce production nxun -> LNOT nxapp
-- On MINUS reduce production nxun -> LNOT nxapp
-- On LT reduce production nxun -> LNOT nxapp
-- On LOR reduce production nxun -> LNOT nxapp
-- On LISTPUNCT reduce production nxun -> LNOT nxapp
-- On LETMUTABLE reduce production nxun -> LNOT nxapp
-- On LETAND reduce production nxun -> LNOT nxapp
-- On LET reduce production nxun -> LNOT nxapp
-- On LEQ reduce production nxun -> LNOT nxapp
-- On LAND reduce production nxun -> LNOT nxapp
-- On IN reduce production nxun -> LNOT nxapp
-- On GT reduce production nxun -> LNOT nxapp
-- On GEQ reduce production nxun -> LNOT nxapp
-- On EQ reduce production nxun -> LNOT nxapp
-- On EOI reduce production nxun -> LNOT nxapp
-- On ENDMUTUAL reduce production nxun -> LNOT nxapp
-- On ELSE reduce production nxun -> LNOT nxapp
-- On ELIST reduce production nxun -> LNOT nxapp
-- On DO reduce production nxun -> LNOT nxapp
-- On DIVIDES reduce production nxun -> LNOT nxapp
-- On CONS reduce production nxun -> LNOT nxapp
-- On CONCAT reduce production nxun -> LNOT nxapp
-- On CLOSENUM reduce production nxun -> LNOT nxapp
-- On BEFORE reduce production nxun -> LNOT nxapp

State 64:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 65
-- On VAR shift to state 66
## Reductions:

State 65:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxlet -> LETMUTABLE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE error

State 66:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 67
-- On OVERWRITEEQ shift to state 68
## Reductions:

State 67:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxlet -> LETMUTABLE VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR error

State 68:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 69
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 228
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 69:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error

State 70:
## Known stack suffix:
## LET
## LR(1) items:
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 71
-- On VAR shift to state 72
-- On CTRLSEQ shift to state 218
## Reductions:

State 71:
## Known stack suffix:
## LET error
## LR(1) items:
nxlet -> LET error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET error

State 72:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 73
-- On VAR shift to state 7
-- On argvar shift to state 74
## Reductions:
-- On DEFEQ reduce production argvar ->

State 73:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxlet -> LET VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR error

State 74:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 76
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 200
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 76:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ error

State 77:
## Known stack suffix:
## LAMBDA
## LR(1) items:
nxlambda -> LAMBDA . argvar ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . argvar ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 78
-- On VAR shift to state 7
-- On argvar shift to state 79
## Reductions:
-- On ARROW reduce production argvar ->

State 78:
## Known stack suffix:
## LAMBDA error
## LR(1) items:
nxlambda -> LAMBDA error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA error

State 79:
## Known stack suffix:
## LAMBDA argvar
## LR(1) items:
nxlambda -> LAMBDA argvar . ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar . ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On ARROW shift to state 80
## Reductions:

State 80:
## Known stack suffix:
## LAMBDA argvar ARROW
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar ARROW . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 81
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 125
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 81:
## Known stack suffix:
## LAMBDA argvar ARROW error
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA argvar ARROW error

State 82:
## Known stack suffix:
## nxun
## LR(1) items:
nxltimes -> nxun . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On TIMES shift to state 83
## Reductions:
-- On THEN reduce production nxltimes -> nxun
-- On RPAREN reduce production nxltimes -> nxun
-- On PLUS reduce production nxltimes -> nxun
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxun
-- On NEQ reduce production nxltimes -> nxun
-- On MUTUAL reduce production nxltimes -> nxun
-- On MOD reduce production nxltimes -> nxun
-- On MINUS reduce production nxltimes -> nxun
-- On LT reduce production nxltimes -> nxun
-- On LOR reduce production nxltimes -> nxun
-- On LISTPUNCT reduce production nxltimes -> nxun
-- On LETMUTABLE reduce production nxltimes -> nxun
-- On LETAND reduce production nxltimes -> nxun
-- On LET reduce production nxltimes -> nxun
-- On LEQ reduce production nxltimes -> nxun
-- On LAND reduce production nxltimes -> nxun
-- On IN reduce production nxltimes -> nxun
-- On GT reduce production nxltimes -> nxun
-- On GEQ reduce production nxltimes -> nxun
-- On EQ reduce production nxltimes -> nxun
-- On EOI reduce production nxltimes -> nxun
-- On ENDMUTUAL reduce production nxltimes -> nxun
-- On ELSE reduce production nxltimes -> nxun
-- On ELIST reduce production nxltimes -> nxun
-- On DO reduce production nxltimes -> nxun
-- On DIVIDES reduce production nxltimes -> nxun
-- On CONS reduce production nxltimes -> nxun
-- On CONCAT reduce production nxltimes -> nxun
-- On CLOSENUM reduce production nxltimes -> nxun
-- On BEFORE reduce production nxltimes -> nxun

State 83:
## Known stack suffix:
## nxun TIMES
## LR(1) items:
nxltimes -> nxun TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 84
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 85
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 84:
## Known stack suffix:
## nxun TIMES error
## LR(1) items:
nxltimes -> nxun TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxun TIMES error

State 85:
## Known stack suffix:
## nxun TIMES nxrtimes
## LR(1) items:
nxltimes -> nxun TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxltimes -> nxun TIMES nxrtimes
-- On RPAREN reduce production nxltimes -> nxun TIMES nxrtimes
-- On PLUS reduce production nxltimes -> nxun TIMES nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxun TIMES nxrtimes
-- On NEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On MUTUAL reduce production nxltimes -> nxun TIMES nxrtimes
-- On MINUS reduce production nxltimes -> nxun TIMES nxrtimes
-- On LT reduce production nxltimes -> nxun TIMES nxrtimes
-- On LOR reduce production nxltimes -> nxun TIMES nxrtimes
-- On LISTPUNCT reduce production nxltimes -> nxun TIMES nxrtimes
-- On LETMUTABLE reduce production nxltimes -> nxun TIMES nxrtimes
-- On LETAND reduce production nxltimes -> nxun TIMES nxrtimes
-- On LET reduce production nxltimes -> nxun TIMES nxrtimes
-- On LEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On LAND reduce production nxltimes -> nxun TIMES nxrtimes
-- On IN reduce production nxltimes -> nxun TIMES nxrtimes
-- On GT reduce production nxltimes -> nxun TIMES nxrtimes
-- On GEQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On EQ reduce production nxltimes -> nxun TIMES nxrtimes
-- On EOI reduce production nxltimes -> nxun TIMES nxrtimes
-- On ENDMUTUAL reduce production nxltimes -> nxun TIMES nxrtimes
-- On ELSE reduce production nxltimes -> nxun TIMES nxrtimes
-- On ELIST reduce production nxltimes -> nxun TIMES nxrtimes
-- On DO reduce production nxltimes -> nxun TIMES nxrtimes
-- On CONS reduce production nxltimes -> nxun TIMES nxrtimes
-- On CONCAT reduce production nxltimes -> nxun TIMES nxrtimes
-- On CLOSENUM reduce production nxltimes -> nxun TIMES nxrtimes
-- On BEFORE reduce production nxltimes -> nxun TIMES nxrtimes

State 86:
## Known stack suffix:
## nxrtimes MOD
## LR(1) items:
nxrtimes -> nxrtimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 87
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 88
## Reductions:

State 87:
## Known stack suffix:
## nxrtimes MOD error
## LR(1) items:
nxrtimes -> nxrtimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxrtimes MOD error

State 88:
## Known stack suffix:
## nxrtimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On RPAREN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On PLUS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes MOD nxapp
-- On NEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MUTUAL reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MOD reduce production nxrtimes -> nxrtimes MOD nxapp
-- On MINUS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LOR reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LETAND reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LET reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On LAND reduce production nxrtimes -> nxrtimes MOD nxapp
-- On IN reduce production nxrtimes -> nxrtimes MOD nxapp
-- On GT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On GEQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On EQ reduce production nxrtimes -> nxrtimes MOD nxapp
-- On EOI reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ELSE reduce production nxrtimes -> nxrtimes MOD nxapp
-- On ELIST reduce production nxrtimes -> nxrtimes MOD nxapp
-- On DO reduce production nxrtimes -> nxrtimes MOD nxapp
-- On DIVIDES reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CONS reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CONCAT reduce production nxrtimes -> nxrtimes MOD nxapp
-- On CLOSENUM reduce production nxrtimes -> nxrtimes MOD nxapp
-- On BEFORE reduce production nxrtimes -> nxrtimes MOD nxapp

State 89:
## Known stack suffix:
## nxrtimes DIVIDES
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 90
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 91
## Reductions:

State 90:
## Known stack suffix:
## nxrtimes DIVIDES error
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxrtimes DIVIDES error

State 91:
## Known stack suffix:
## nxrtimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On RPAREN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On PLUS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On NEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MUTUAL reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MOD reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On MINUS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LOR reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LETAND reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LET reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On LAND reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On IN reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On GT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On GEQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On EQ reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On EOI reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ELSE reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On ELIST reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On DO reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On DIVIDES reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CONS reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CONCAT reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On CLOSENUM reduce production nxrtimes -> nxrtimes DIVIDES nxapp
-- On BEFORE reduce production nxrtimes -> nxrtimes DIVIDES nxapp

State 92:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxapp . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 93
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxrtimes -> nxapp
-- On RPAREN reduce production nxrtimes -> nxapp
-- On PLUS reduce production nxrtimes -> nxapp
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxapp
-- On NEQ reduce production nxrtimes -> nxapp
-- On MUTUAL reduce production nxrtimes -> nxapp
-- On MOD reduce production nxrtimes -> nxapp
-- On MINUS reduce production nxrtimes -> nxapp
-- On LT reduce production nxrtimes -> nxapp
-- On LOR reduce production nxrtimes -> nxapp
-- On LISTPUNCT reduce production nxrtimes -> nxapp
-- On LETMUTABLE reduce production nxrtimes -> nxapp
-- On LETAND reduce production nxrtimes -> nxapp
-- On LET reduce production nxrtimes -> nxapp
-- On LEQ reduce production nxrtimes -> nxapp
-- On LAND reduce production nxrtimes -> nxapp
-- On IN reduce production nxrtimes -> nxapp
-- On GT reduce production nxrtimes -> nxapp
-- On GEQ reduce production nxrtimes -> nxapp
-- On EQ reduce production nxrtimes -> nxapp
-- On EOI reduce production nxrtimes -> nxapp
-- On ENDMUTUAL reduce production nxrtimes -> nxapp
-- On ELSE reduce production nxrtimes -> nxapp
-- On ELIST reduce production nxrtimes -> nxapp
-- On DO reduce production nxrtimes -> nxapp
-- On DIVIDES reduce production nxrtimes -> nxapp
-- On CONS reduce production nxrtimes -> nxapp
-- On CONCAT reduce production nxrtimes -> nxapp
-- On CLOSENUM reduce production nxrtimes -> nxapp
-- On BEFORE reduce production nxrtimes -> nxapp

State 93:
## Known stack suffix:
## nxapp TIMES
## LR(1) items:
nxrtimes -> nxapp TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 94
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 95
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 94:
## Known stack suffix:
## nxapp TIMES error
## LR(1) items:
nxrtimes -> nxapp TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxapp TIMES error

State 95:
## Known stack suffix:
## nxapp TIMES nxrtimes
## LR(1) items:
nxrtimes -> nxapp TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On RPAREN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On PLUS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On NEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On MUTUAL reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On MINUS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LOR reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LISTPUNCT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LETMUTABLE reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LETAND reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LET reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On LAND reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On IN reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On GT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On GEQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On EQ reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On EOI reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ENDMUTUAL reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ELSE reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On ELIST reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On DO reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CONS reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CONCAT reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On CLOSENUM reduce production nxrtimes -> nxapp TIMES nxrtimes
-- On BEFORE reduce production nxrtimes -> nxapp TIMES nxrtimes

State 96:
## Known stack suffix:
## nxltimes
## LR(1) items:
nxlminus -> nxltimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 97
-- On DIVIDES shift to state 100
## Reductions:
-- On THEN reduce production nxlminus -> nxltimes
-- On RPAREN reduce production nxlminus -> nxltimes
-- On PLUS reduce production nxlminus -> nxltimes
-- On OVERWRITEGLOBALHASH reduce production nxlminus -> nxltimes
-- On NEQ reduce production nxlminus -> nxltimes
-- On MUTUAL reduce production nxlminus -> nxltimes
-- On MINUS reduce production nxlminus -> nxltimes
-- On LT reduce production nxlminus -> nxltimes
-- On LOR reduce production nxlminus -> nxltimes
-- On LISTPUNCT reduce production nxlminus -> nxltimes
-- On LETMUTABLE reduce production nxlminus -> nxltimes
-- On LETAND reduce production nxlminus -> nxltimes
-- On LET reduce production nxlminus -> nxltimes
-- On LEQ reduce production nxlminus -> nxltimes
-- On LAND reduce production nxlminus -> nxltimes
-- On IN reduce production nxlminus -> nxltimes
-- On GT reduce production nxlminus -> nxltimes
-- On GEQ reduce production nxlminus -> nxltimes
-- On EQ reduce production nxlminus -> nxltimes
-- On EOI reduce production nxlminus -> nxltimes
-- On ENDMUTUAL reduce production nxlminus -> nxltimes
-- On ELSE reduce production nxlminus -> nxltimes
-- On ELIST reduce production nxlminus -> nxltimes
-- On DO reduce production nxlminus -> nxltimes
-- On CONS reduce production nxlminus -> nxltimes
-- On CONCAT reduce production nxlminus -> nxltimes
-- On CLOSENUM reduce production nxlminus -> nxltimes
-- On BEFORE reduce production nxlminus -> nxltimes

State 97:
## Known stack suffix:
## nxltimes MOD
## LR(1) items:
nxltimes -> nxltimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 98
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 99
## Reductions:

State 98:
## Known stack suffix:
## nxltimes MOD error
## LR(1) items:
nxltimes -> nxltimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxltimes MOD error

State 99:
## Known stack suffix:
## nxltimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes MOD nxapp
-- On RPAREN reduce production nxltimes -> nxltimes MOD nxapp
-- On PLUS reduce production nxltimes -> nxltimes MOD nxapp
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes MOD nxapp
-- On NEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On MUTUAL reduce production nxltimes -> nxltimes MOD nxapp
-- On MOD reduce production nxltimes -> nxltimes MOD nxapp
-- On MINUS reduce production nxltimes -> nxltimes MOD nxapp
-- On LT reduce production nxltimes -> nxltimes MOD nxapp
-- On LOR reduce production nxltimes -> nxltimes MOD nxapp
-- On LISTPUNCT reduce production nxltimes -> nxltimes MOD nxapp
-- On LETMUTABLE reduce production nxltimes -> nxltimes MOD nxapp
-- On LETAND reduce production nxltimes -> nxltimes MOD nxapp
-- On LET reduce production nxltimes -> nxltimes MOD nxapp
-- On LEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On LAND reduce production nxltimes -> nxltimes MOD nxapp
-- On IN reduce production nxltimes -> nxltimes MOD nxapp
-- On GT reduce production nxltimes -> nxltimes MOD nxapp
-- On GEQ reduce production nxltimes -> nxltimes MOD nxapp
-- On EQ reduce production nxltimes -> nxltimes MOD nxapp
-- On EOI reduce production nxltimes -> nxltimes MOD nxapp
-- On ENDMUTUAL reduce production nxltimes -> nxltimes MOD nxapp
-- On ELSE reduce production nxltimes -> nxltimes MOD nxapp
-- On ELIST reduce production nxltimes -> nxltimes MOD nxapp
-- On DO reduce production nxltimes -> nxltimes MOD nxapp
-- On DIVIDES reduce production nxltimes -> nxltimes MOD nxapp
-- On CONS reduce production nxltimes -> nxltimes MOD nxapp
-- On CONCAT reduce production nxltimes -> nxltimes MOD nxapp
-- On CLOSENUM reduce production nxltimes -> nxltimes MOD nxapp
-- On BEFORE reduce production nxltimes -> nxltimes MOD nxapp

State 100:
## Known stack suffix:
## nxltimes DIVIDES
## LR(1) items:
nxltimes -> nxltimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 101
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 102
## Reductions:

State 101:
## Known stack suffix:
## nxltimes DIVIDES error
## LR(1) items:
nxltimes -> nxltimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxltimes DIVIDES error

State 102:
## Known stack suffix:
## nxltimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On RPAREN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On PLUS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On OVERWRITEGLOBALHASH reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On NEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MUTUAL reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MOD reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On MINUS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LOR reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LISTPUNCT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LETMUTABLE reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LETAND reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LET reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On LAND reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On IN reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On GT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On GEQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On EQ reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On EOI reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ENDMUTUAL reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ELSE reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On ELIST reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On DO reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On DIVIDES reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CONS reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CONCAT reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On CLOSENUM reduce production nxltimes -> nxltimes DIVIDES nxapp
-- On BEFORE reduce production nxltimes -> nxltimes DIVIDES nxapp

State 103:
## Known stack suffix:
## nxlplus
## LR(1) items:
nxconcat -> nxlplus . CONCAT nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONS nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONCAT error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 104
-- On CONS shift to state 107
-- On CONCAT shift to state 122
## Reductions:
-- On THEN reduce production nxconcat -> nxlplus
-- On RPAREN reduce production nxconcat -> nxlplus
-- On OVERWRITEGLOBALHASH reduce production nxconcat -> nxlplus
-- On NEQ reduce production nxconcat -> nxlplus
-- On MUTUAL reduce production nxconcat -> nxlplus
-- On LT reduce production nxconcat -> nxlplus
-- On LOR reduce production nxconcat -> nxlplus
-- On LISTPUNCT reduce production nxconcat -> nxlplus
-- On LETMUTABLE reduce production nxconcat -> nxlplus
-- On LETAND reduce production nxconcat -> nxlplus
-- On LET reduce production nxconcat -> nxlplus
-- On LEQ reduce production nxconcat -> nxlplus
-- On LAND reduce production nxconcat -> nxlplus
-- On IN reduce production nxconcat -> nxlplus
-- On GT reduce production nxconcat -> nxlplus
-- On GEQ reduce production nxconcat -> nxlplus
-- On EQ reduce production nxconcat -> nxlplus
-- On EOI reduce production nxconcat -> nxlplus
-- On ENDMUTUAL reduce production nxconcat -> nxlplus
-- On ELSE reduce production nxconcat -> nxlplus
-- On ELIST reduce production nxconcat -> nxlplus
-- On DO reduce production nxconcat -> nxlplus
-- On CLOSENUM reduce production nxconcat -> nxlplus
-- On BEFORE reduce production nxconcat -> nxlplus

State 104:
## Known stack suffix:
## nxlplus MINUS
## LR(1) items:
nxlminus -> nxlplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 105
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 106
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 105:
## Known stack suffix:
## nxlplus MINUS error
## LR(1) items:
nxlminus -> nxlplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlminus -> nxlplus MINUS error

State 106:
## Known stack suffix:
## nxlplus MINUS nxrtimes
## LR(1) items:
nxlminus -> nxlplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On RPAREN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On PLUS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On NEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On MUTUAL reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On MINUS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LOR reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LISTPUNCT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LETMUTABLE reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LETAND reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LET reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On LAND reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On IN reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On GT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On GEQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On EQ reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On EOI reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ENDMUTUAL reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ELSE reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On ELIST reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On DO reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CONS reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CONCAT reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On CLOSENUM reduce production nxlminus -> nxlplus MINUS nxrtimes
-- On BEFORE reduce production nxlminus -> nxlplus MINUS nxrtimes

State 107:
## Known stack suffix:
## nxlplus CONS
## LR(1) items:
nxconcat -> nxlplus CONS . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 120
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 108:
## Known stack suffix:
## nxlminus
## LR(1) items:
nxlplus -> nxlminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 109
## Reductions:
-- On THEN reduce production nxlplus -> nxlminus
-- On RPAREN reduce production nxlplus -> nxlminus
-- On OVERWRITEGLOBALHASH reduce production nxlplus -> nxlminus
-- On NEQ reduce production nxlplus -> nxlminus
-- On MUTUAL reduce production nxlplus -> nxlminus
-- On MINUS reduce production nxlplus -> nxlminus
-- On LT reduce production nxlplus -> nxlminus
-- On LOR reduce production nxlplus -> nxlminus
-- On LISTPUNCT reduce production nxlplus -> nxlminus
-- On LETMUTABLE reduce production nxlplus -> nxlminus
-- On LETAND reduce production nxlplus -> nxlminus
-- On LET reduce production nxlplus -> nxlminus
-- On LEQ reduce production nxlplus -> nxlminus
-- On LAND reduce production nxlplus -> nxlminus
-- On IN reduce production nxlplus -> nxlminus
-- On GT reduce production nxlplus -> nxlminus
-- On GEQ reduce production nxlplus -> nxlminus
-- On EQ reduce production nxlplus -> nxlminus
-- On EOI reduce production nxlplus -> nxlminus
-- On ENDMUTUAL reduce production nxlplus -> nxlminus
-- On ELSE reduce production nxlplus -> nxlminus
-- On ELIST reduce production nxlplus -> nxlminus
-- On DO reduce production nxlplus -> nxlminus
-- On CONS reduce production nxlplus -> nxlminus
-- On CONCAT reduce production nxlplus -> nxlminus
-- On CLOSENUM reduce production nxlplus -> nxlminus
-- On BEFORE reduce production nxlplus -> nxlminus

State 109:
## Known stack suffix:
## nxlminus PLUS
## LR(1) items:
nxlplus -> nxlminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 110
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 112
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 110:
## Known stack suffix:
## nxlminus PLUS error
## LR(1) items:
nxlplus -> nxlminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlplus -> nxlminus PLUS error

State 111:
## Known stack suffix:
## nxrtimes
## LR(1) items:
nxrminus -> nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrminus -> nxrtimes
-- On RPAREN reduce production nxrminus -> nxrtimes
-- On PLUS reduce production nxrminus -> nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrminus -> nxrtimes
-- On NEQ reduce production nxrminus -> nxrtimes
-- On MUTUAL reduce production nxrminus -> nxrtimes
-- On MINUS reduce production nxrminus -> nxrtimes
-- On LT reduce production nxrminus -> nxrtimes
-- On LOR reduce production nxrminus -> nxrtimes
-- On LISTPUNCT reduce production nxrminus -> nxrtimes
-- On LETMUTABLE reduce production nxrminus -> nxrtimes
-- On LETAND reduce production nxrminus -> nxrtimes
-- On LET reduce production nxrminus -> nxrtimes
-- On LEQ reduce production nxrminus -> nxrtimes
-- On LAND reduce production nxrminus -> nxrtimes
-- On IN reduce production nxrminus -> nxrtimes
-- On GT reduce production nxrminus -> nxrtimes
-- On GEQ reduce production nxrminus -> nxrtimes
-- On EQ reduce production nxrminus -> nxrtimes
-- On EOI reduce production nxrminus -> nxrtimes
-- On ENDMUTUAL reduce production nxrminus -> nxrtimes
-- On ELSE reduce production nxrminus -> nxrtimes
-- On ELIST reduce production nxrminus -> nxrtimes
-- On DO reduce production nxrminus -> nxrtimes
-- On CONS reduce production nxrminus -> nxrtimes
-- On CONCAT reduce production nxrminus -> nxrtimes
-- On CLOSENUM reduce production nxrminus -> nxrtimes
-- On BEFORE reduce production nxrminus -> nxrtimes

State 112:
## Known stack suffix:
## nxlminus PLUS nxrplus
## LR(1) items:
nxlplus -> nxlminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On RPAREN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On OVERWRITEGLOBALHASH reduce production nxlplus -> nxlminus PLUS nxrplus
-- On NEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On MUTUAL reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LOR reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LISTPUNCT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LETMUTABLE reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LETAND reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LET reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On LAND reduce production nxlplus -> nxlminus PLUS nxrplus
-- On IN reduce production nxlplus -> nxlminus PLUS nxrplus
-- On GT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On GEQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On EQ reduce production nxlplus -> nxlminus PLUS nxrplus
-- On EOI reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ENDMUTUAL reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ELSE reduce production nxlplus -> nxlminus PLUS nxrplus
-- On ELIST reduce production nxlplus -> nxlminus PLUS nxrplus
-- On DO reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CONS reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CONCAT reduce production nxlplus -> nxlminus PLUS nxrplus
-- On CLOSENUM reduce production nxlplus -> nxlminus PLUS nxrplus
-- On BEFORE reduce production nxlplus -> nxlminus PLUS nxrplus

State 113:
## Known stack suffix:
## nxrplus MINUS
## LR(1) items:
nxrminus -> nxrplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 114
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 115
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 114:
## Known stack suffix:
## nxrplus MINUS error
## LR(1) items:
nxrminus -> nxrplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrminus -> nxrplus MINUS error

State 115:
## Known stack suffix:
## nxrplus MINUS nxrtimes
## LR(1) items:
nxrminus -> nxrplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On RPAREN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On PLUS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On OVERWRITEGLOBALHASH reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On NEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On MUTUAL reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On MINUS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LOR reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LISTPUNCT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LETMUTABLE reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LETAND reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LET reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On LAND reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On IN reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On GT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On GEQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On EQ reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On EOI reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ENDMUTUAL reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ELSE reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On ELIST reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On DO reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CONS reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CONCAT reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On CLOSENUM reduce production nxrminus -> nxrplus MINUS nxrtimes
-- On BEFORE reduce production nxrminus -> nxrplus MINUS nxrtimes

State 116:
## Known stack suffix:
## nxrminus
## LR(1) items:
nxrplus -> nxrminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 117
## Reductions:
-- On THEN reduce production nxrplus -> nxrminus
-- On RPAREN reduce production nxrplus -> nxrminus
-- On OVERWRITEGLOBALHASH reduce production nxrplus -> nxrminus
-- On NEQ reduce production nxrplus -> nxrminus
-- On MUTUAL reduce production nxrplus -> nxrminus
-- On MINUS reduce production nxrplus -> nxrminus
-- On LT reduce production nxrplus -> nxrminus
-- On LOR reduce production nxrplus -> nxrminus
-- On LISTPUNCT reduce production nxrplus -> nxrminus
-- On LETMUTABLE reduce production nxrplus -> nxrminus
-- On LETAND reduce production nxrplus -> nxrminus
-- On LET reduce production nxrplus -> nxrminus
-- On LEQ reduce production nxrplus -> nxrminus
-- On LAND reduce production nxrplus -> nxrminus
-- On IN reduce production nxrplus -> nxrminus
-- On GT reduce production nxrplus -> nxrminus
-- On GEQ reduce production nxrplus -> nxrminus
-- On EQ reduce production nxrplus -> nxrminus
-- On EOI reduce production nxrplus -> nxrminus
-- On ENDMUTUAL reduce production nxrplus -> nxrminus
-- On ELSE reduce production nxrplus -> nxrminus
-- On ELIST reduce production nxrplus -> nxrminus
-- On DO reduce production nxrplus -> nxrminus
-- On CONS reduce production nxrplus -> nxrminus
-- On CONCAT reduce production nxrplus -> nxrminus
-- On CLOSENUM reduce production nxrplus -> nxrminus
-- On BEFORE reduce production nxrplus -> nxrminus

State 117:
## Known stack suffix:
## nxrminus PLUS
## LR(1) items:
nxrplus -> nxrminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 118
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 119
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 118:
## Known stack suffix:
## nxrminus PLUS error
## LR(1) items:
nxrplus -> nxrminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrplus -> nxrminus PLUS error

State 119:
## Known stack suffix:
## nxrminus PLUS nxrplus
## LR(1) items:
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On RPAREN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On OVERWRITEGLOBALHASH reduce production nxrplus -> nxrminus PLUS nxrplus
-- On NEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On MUTUAL reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LOR reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LISTPUNCT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LETMUTABLE reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LETAND reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LET reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On LAND reduce production nxrplus -> nxrminus PLUS nxrplus
-- On IN reduce production nxrplus -> nxrminus PLUS nxrplus
-- On GT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On GEQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On EQ reduce production nxrplus -> nxrminus PLUS nxrplus
-- On EOI reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ENDMUTUAL reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ELSE reduce production nxrplus -> nxrminus PLUS nxrplus
-- On ELIST reduce production nxrplus -> nxrminus PLUS nxrplus
-- On DO reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CONS reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CONCAT reduce production nxrplus -> nxrminus PLUS nxrplus
-- On CLOSENUM reduce production nxrplus -> nxrminus PLUS nxrplus
-- On BEFORE reduce production nxrplus -> nxrminus PLUS nxrplus

State 120:
## Known stack suffix:
## nxlplus CONS nxconcat
## LR(1) items:
nxconcat -> nxlplus CONS nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONS nxconcat

State 121:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> nxapp
-- On THEN reduce production nxun -> nxapp
-- On RPAREN reduce production nxun -> nxapp
-- On PLUS reduce production nxun -> nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> nxapp
-- On NEQ reduce production nxun -> nxapp
-- On MUTUAL reduce production nxun -> nxapp
-- On MOD reduce production nxun -> nxapp
-- On MINUS reduce production nxun -> nxapp
-- On LT reduce production nxun -> nxapp
-- On LOR reduce production nxun -> nxapp
-- On LISTPUNCT reduce production nxun -> nxapp
-- On LETMUTABLE reduce production nxun -> nxapp
-- On LETAND reduce production nxun -> nxapp
-- On LET reduce production nxun -> nxapp
-- On LEQ reduce production nxun -> nxapp
-- On LAND reduce production nxun -> nxapp
-- On IN reduce production nxun -> nxapp
-- On GT reduce production nxun -> nxapp
-- On GEQ reduce production nxun -> nxapp
-- On EQ reduce production nxun -> nxapp
-- On EOI reduce production nxun -> nxapp
-- On ENDMUTUAL reduce production nxun -> nxapp
-- On ELSE reduce production nxun -> nxapp
-- On ELIST reduce production nxun -> nxapp
-- On DO reduce production nxun -> nxapp
-- On DIVIDES reduce production nxun -> nxapp
-- On CONS reduce production nxun -> nxapp
-- On CONCAT reduce production nxun -> nxapp
-- On CLOSENUM reduce production nxun -> nxapp
-- On BEFORE reduce production nxun -> nxapp

State 122:
## Known stack suffix:
## nxlplus CONCAT
## LR(1) items:
nxconcat -> nxlplus CONCAT . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus CONCAT . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 123
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 124
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 123:
## Known stack suffix:
## nxlplus CONCAT error
## LR(1) items:
nxconcat -> nxlplus CONCAT error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONCAT error

State 124:
## Known stack suffix:
## nxlplus CONCAT nxconcat
## LR(1) items:
nxconcat -> nxlplus CONCAT nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONCAT nxconcat

State 125:
## Known stack suffix:
## LAMBDA argvar ARROW nxlor
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA argvar ARROW nxlor

State 126:
## Known stack suffix:
## nxland
## LR(1) items:
nxlor -> nxland . LOR nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . LOR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LOR shift to state 127
## Reductions:
-- On THEN reduce production nxlor -> nxland
-- On RPAREN reduce production nxlor -> nxland
-- On OVERWRITEGLOBALHASH reduce production nxlor -> nxland
-- On MUTUAL reduce production nxlor -> nxland
-- On LISTPUNCT reduce production nxlor -> nxland
-- On LETMUTABLE reduce production nxlor -> nxland
-- On LETAND reduce production nxlor -> nxland
-- On LET reduce production nxlor -> nxland
-- On IN reduce production nxlor -> nxland
-- On EOI reduce production nxlor -> nxland
-- On ENDMUTUAL reduce production nxlor -> nxland
-- On ELSE reduce production nxlor -> nxland
-- On ELIST reduce production nxlor -> nxland
-- On DO reduce production nxlor -> nxland
-- On CLOSENUM reduce production nxlor -> nxland
-- On BEFORE reduce production nxlor -> nxland

State 127:
## Known stack suffix:
## nxland LOR
## LR(1) items:
nxlor -> nxland LOR . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland LOR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 128
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 129
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 128:
## Known stack suffix:
## nxland LOR error
## LR(1) items:
nxlor -> nxland LOR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlor -> nxland LOR error

State 129:
## Known stack suffix:
## nxland LOR nxlor
## LR(1) items:
nxlor -> nxland LOR nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlor -> nxland LOR nxlor

State 130:
## Known stack suffix:
## nxconcat
## LR(1) items:
nxcomp -> nxconcat . EQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . EQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On NEQ shift to state 131
-- On LT shift to state 134
-- On LEQ shift to state 137
-- On GT shift to state 140
-- On GEQ shift to state 143
-- On EQ shift to state 146
## Reductions:
-- On THEN reduce production nxcomp -> nxconcat
-- On RPAREN reduce production nxcomp -> nxconcat
-- On OVERWRITEGLOBALHASH reduce production nxcomp -> nxconcat
-- On MUTUAL reduce production nxcomp -> nxconcat
-- On LOR reduce production nxcomp -> nxconcat
-- On LISTPUNCT reduce production nxcomp -> nxconcat
-- On LETMUTABLE reduce production nxcomp -> nxconcat
-- On LETAND reduce production nxcomp -> nxconcat
-- On LET reduce production nxcomp -> nxconcat
-- On LAND reduce production nxcomp -> nxconcat
-- On IN reduce production nxcomp -> nxconcat
-- On EOI reduce production nxcomp -> nxconcat
-- On ENDMUTUAL reduce production nxcomp -> nxconcat
-- On ELSE reduce production nxcomp -> nxconcat
-- On ELIST reduce production nxcomp -> nxconcat
-- On DO reduce production nxcomp -> nxconcat
-- On CLOSENUM reduce production nxcomp -> nxconcat
-- On BEFORE reduce production nxcomp -> nxconcat

State 131:
## Known stack suffix:
## nxconcat NEQ
## LR(1) items:
nxcomp -> nxconcat NEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat NEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 132
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 133
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 132:
## Known stack suffix:
## nxconcat NEQ error
## LR(1) items:
nxcomp -> nxconcat NEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat NEQ error

State 133:
## Known stack suffix:
## nxconcat NEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat NEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat NEQ nxcomp

State 134:
## Known stack suffix:
## nxconcat LT
## LR(1) items:
nxcomp -> nxconcat LT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 135
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 136
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 135:
## Known stack suffix:
## nxconcat LT error
## LR(1) items:
nxcomp -> nxconcat LT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LT error

State 136:
## Known stack suffix:
## nxconcat LT nxcomp
## LR(1) items:
nxcomp -> nxconcat LT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LT nxcomp

State 137:
## Known stack suffix:
## nxconcat LEQ
## LR(1) items:
nxcomp -> nxconcat LEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 138
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 139
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 138:
## Known stack suffix:
## nxconcat LEQ error
## LR(1) items:
nxcomp -> nxconcat LEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LEQ error

State 139:
## Known stack suffix:
## nxconcat LEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat LEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LEQ nxcomp

State 140:
## Known stack suffix:
## nxconcat GT
## LR(1) items:
nxcomp -> nxconcat GT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 141
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 142
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 141:
## Known stack suffix:
## nxconcat GT error
## LR(1) items:
nxcomp -> nxconcat GT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GT error

State 142:
## Known stack suffix:
## nxconcat GT nxcomp
## LR(1) items:
nxcomp -> nxconcat GT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GT nxcomp

State 143:
## Known stack suffix:
## nxconcat GEQ
## LR(1) items:
nxcomp -> nxconcat GEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 144
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 145
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 144:
## Known stack suffix:
## nxconcat GEQ error
## LR(1) items:
nxcomp -> nxconcat GEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GEQ error

State 145:
## Known stack suffix:
## nxconcat GEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat GEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GEQ nxcomp

State 146:
## Known stack suffix:
## nxconcat EQ
## LR(1) items:
nxcomp -> nxconcat EQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat EQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 147
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 148
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 147:
## Known stack suffix:
## nxconcat EQ error
## LR(1) items:
nxcomp -> nxconcat EQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat EQ error

State 148:
## Known stack suffix:
## nxconcat EQ nxcomp
## LR(1) items:
nxcomp -> nxconcat EQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat EQ nxcomp

State 149:
## Known stack suffix:
## nxcomp
## LR(1) items:
nxland -> nxcomp . LAND nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . LAND error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LAND shift to state 150
## Reductions:
-- On THEN reduce production nxland -> nxcomp
-- On RPAREN reduce production nxland -> nxcomp
-- On OVERWRITEGLOBALHASH reduce production nxland -> nxcomp
-- On MUTUAL reduce production nxland -> nxcomp
-- On LOR reduce production nxland -> nxcomp
-- On LISTPUNCT reduce production nxland -> nxcomp
-- On LETMUTABLE reduce production nxland -> nxcomp
-- On LETAND reduce production nxland -> nxcomp
-- On LET reduce production nxland -> nxcomp
-- On IN reduce production nxland -> nxcomp
-- On EOI reduce production nxland -> nxcomp
-- On ENDMUTUAL reduce production nxland -> nxcomp
-- On ELSE reduce production nxland -> nxcomp
-- On ELIST reduce production nxland -> nxcomp
-- On DO reduce production nxland -> nxcomp
-- On CLOSENUM reduce production nxland -> nxcomp
-- On BEFORE reduce production nxland -> nxcomp

State 150:
## Known stack suffix:
## nxcomp LAND
## LR(1) items:
nxland -> nxcomp LAND . nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp LAND . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 151
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxland shift to state 152
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 151:
## Known stack suffix:
## nxcomp LAND error
## LR(1) items:
nxland -> nxcomp LAND error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxland -> nxcomp LAND error

State 152:
## Known stack suffix:
## nxcomp LAND nxland
## LR(1) items:
nxland -> nxcomp LAND nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxland -> nxcomp LAND nxland

State 153:
## Known stack suffix:
## IFIDISVALID
## LR(1) items:
nxif -> IFIDISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 154
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 155
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 196
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 154:
## Known stack suffix:
## IFIDISVALID error
## LR(1) items:
nxif -> IFIDISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID error

State 155:
## Known stack suffix:
## IFIDISVALID THEN
## LR(1) items:
nxif -> IFIDISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 156
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 192
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 156:
## Known stack suffix:
## IFIDISVALID THEN error
## LR(1) items:
nxif -> IFIDISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN error

State 157:
## Known stack suffix:
## IFCLASSISVALID
## LR(1) items:
nxif -> IFCLASSISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 158
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 159
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 188
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 158:
## Known stack suffix:
## IFCLASSISVALID error
## LR(1) items:
nxif -> IFCLASSISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID error

State 159:
## Known stack suffix:
## IFCLASSISVALID THEN
## LR(1) items:
nxif -> IFCLASSISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 160
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 184
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 160:
## Known stack suffix:
## IFCLASSISVALID THEN error
## LR(1) items:
nxif -> IFCLASSISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN error

State 161:
## Known stack suffix:
## IF
## LR(1) items:
nxif -> IF . nxlet THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 162
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 177
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 162:
## Known stack suffix:
## IF error
## LR(1) items:
nxif -> IF error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF error

State 163:
## Known stack suffix:
## DECGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 164
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 167
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 164:
## Known stack suffix:
## DECGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH error

State 165:
## Known stack suffix:
## nxwhl
## LR(1) items:
nxlet -> nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> nxwhl

State 166:
## Known stack suffix:
## nxlor
## LR(1) items:
nxlambda -> nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> nxlor

State 167:
## Known stack suffix:
## DECGLOBALHASH nxlet
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 169
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 170
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 169:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 170:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 171:
## Known stack suffix:
## nxlambda
## LR(1) items:
nxbfr -> nxlambda . BEFORE nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . BEFORE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On BEFORE shift to state 172
## Reductions:
-- On THEN reduce production nxbfr -> nxlambda
-- On RPAREN reduce production nxbfr -> nxlambda
-- On OVERWRITEGLOBALHASH reduce production nxbfr -> nxlambda
-- On MUTUAL reduce production nxbfr -> nxlambda
-- On LISTPUNCT reduce production nxbfr -> nxlambda
-- On LETMUTABLE reduce production nxbfr -> nxlambda
-- On LETAND reduce production nxbfr -> nxlambda
-- On LET reduce production nxbfr -> nxlambda
-- On IN reduce production nxbfr -> nxlambda
-- On EOI reduce production nxbfr -> nxlambda
-- On ENDMUTUAL reduce production nxbfr -> nxlambda
-- On ELSE reduce production nxbfr -> nxlambda
-- On ELIST reduce production nxbfr -> nxlambda
-- On DO reduce production nxbfr -> nxlambda
-- On CLOSENUM reduce production nxbfr -> nxlambda

State 172:
## Known stack suffix:
## nxlambda BEFORE
## LR(1) items:
nxbfr -> nxlambda BEFORE . nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda BEFORE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 173
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 174
-- On nxapp shift to state 121
## Reductions:

State 173:
## Known stack suffix:
## nxlambda BEFORE error
## LR(1) items:
nxbfr -> nxlambda BEFORE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbfr -> nxlambda BEFORE error

State 174:
## Known stack suffix:
## nxlambda BEFORE nxbfr
## LR(1) items:
nxbfr -> nxlambda BEFORE nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbfr -> nxlambda BEFORE nxbfr

State 175:
## Known stack suffix:
## nxif
## LR(1) items:
nxwhl -> nxif . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> nxif

State 176:
## Known stack suffix:
## nxbfr
## LR(1) items:
nxif -> nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> nxbfr

State 177:
## Known stack suffix:
## IF nxlet
## LR(1) items:
nxif -> IF nxlet . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On THEN shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## IF nxlet THEN
## LR(1) items:
nxif -> IF nxlet THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 179
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 180
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 179:
## Known stack suffix:
## IF nxlet THEN error
## LR(1) items:
nxif -> IF nxlet THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN error

State 180:
## Known stack suffix:
## IF nxlet THEN nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 182
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 183
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 182:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE error
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN nxlet ELSE error

State 183:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet

State 184:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 186
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 187
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 186:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error

State 187:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet

State 188:
## Known stack suffix:
## IFCLASSISVALID nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 189
## Reductions:

State 189:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 190
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 191
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 190:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID nxlet ELSE error

State 191:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet

State 192:
## Known stack suffix:
## IFIDISVALID THEN nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 194
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 195
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 194:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN nxlet ELSE error

State 195:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet

State 196:
## Known stack suffix:
## IFIDISVALID nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## IFIDISVALID nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 198
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 199
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 198:
## Known stack suffix:
## IFIDISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID nxlet ELSE error

State 199:
## Known stack suffix:
## IFIDISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID nxlet ELSE nxlet

State 200:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 214
## Reductions:
-- On IN reduce production nxdec ->

State 201:
## Known stack suffix:
## LETAND
## LR(1) items:
nxdec -> LETAND . VAR argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . VAR error [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 202
-- On CTRLSEQ shift to state 208
## Reductions:

State 202:
## Known stack suffix:
## LETAND VAR
## LR(1) items:
nxdec -> LETAND VAR . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND VAR . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 203
-- On VAR shift to state 7
-- On argvar shift to state 204
## Reductions:
-- On DEFEQ reduce production argvar ->

State 203:
## Known stack suffix:
## LETAND VAR error
## LR(1) items:
nxdec -> LETAND VAR error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND VAR error

State 204:
## Known stack suffix:
## LETAND VAR argvar
## LR(1) items:
nxdec -> LETAND VAR argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 205
## Reductions:

State 205:
## Known stack suffix:
## LETAND VAR argvar DEFEQ
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 206
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 206:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 207
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 207:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec

State 208:
## Known stack suffix:
## LETAND CTRLSEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND CTRLSEQ . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 209
-- On VAR shift to state 7
-- On argvar shift to state 210
## Reductions:
-- On DEFEQ reduce production argvar ->

State 209:
## Known stack suffix:
## LETAND CTRLSEQ error
## LR(1) items:
nxdec -> LETAND CTRLSEQ error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND CTRLSEQ error

State 210:
## Known stack suffix:
## LETAND CTRLSEQ argvar
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 211
## Reductions:

State 211:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 212
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 212:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 213
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 213:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec

State 214:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 215
## Reductions:

State 215:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 216
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 217
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 216:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error

State 217:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 218:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 219
-- On VAR shift to state 7
-- On argvar shift to state 220
## Reductions:
-- On DEFEQ reduce production argvar ->

State 219:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ error

State 220:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 222
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 223
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 222:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error

State 223:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 224
## Reductions:
-- On IN reduce production nxdec ->

State 224:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 226
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 227
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 226:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 227:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 228:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 229
## Reductions:

State 229:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 230
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 231
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 230:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error

State 231:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 232:
## Known stack suffix:
## BLIST ELIST
## LR(1) items:
nxbot -> BLIST ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST ELIST

State 233:
## Known stack suffix:
## BLIST nxlet
## LR(1) items:
nxbot -> BLIST nxlet . nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 238
## Reductions:
-- On ELIST reduce production nxlist ->

State 234:
## Known stack suffix:
## LISTPUNCT
## LR(1) items:
nxlist -> LISTPUNCT . nxlet nxlist [ ELIST ]
nxlist -> LISTPUNCT . error [ ELIST ]
## Transitions:
-- On error shift to state 235
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 236
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 235:
## Known stack suffix:
## LISTPUNCT error
## LR(1) items:
nxlist -> LISTPUNCT error . [ ELIST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlist -> LISTPUNCT error

State 236:
## Known stack suffix:
## LISTPUNCT nxlet
## LR(1) items:
nxlist -> LISTPUNCT nxlet . nxlist [ ELIST ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 237
## Reductions:
-- On ELIST reduce production nxlist ->

State 237:
## Known stack suffix:
## LISTPUNCT nxlet nxlist
## LR(1) items:
nxlist -> LISTPUNCT nxlet nxlist . [ ELIST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlist -> LISTPUNCT nxlet nxlist

State 238:
## Known stack suffix:
## BLIST nxlet nxlist
## LR(1) items:
nxbot -> BLIST nxlet nxlist . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On ELIST shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## BLIST nxlet nxlist ELIST
## LR(1) items:
nxbot -> BLIST nxlet nxlist ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST nxlet nxlist ELIST

State 240:
## Known stack suffix:
## LT
## LR(1) items:
binop -> LT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LT

State 241:
## Known stack suffix:
## LOR
## LR(1) items:
binop -> LOR . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LOR

State 242:
## Known stack suffix:
## LNOT
## LR(1) items:
binop -> LNOT . [ RPAREN ]
nxun -> LNOT . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> LNOT . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:
-- On RPAREN reduce production binop -> LNOT

State 243:
## Known stack suffix:
## LEQ
## LR(1) items:
binop -> LEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LEQ

State 244:
## Known stack suffix:
## LAND
## LR(1) items:
binop -> LAND . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LAND

State 245:
## Known stack suffix:
## GT
## LR(1) items:
binop -> GT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> GT

State 246:
## Known stack suffix:
## GEQ
## LR(1) items:
binop -> GEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> GEQ

State 247:
## Known stack suffix:
## EQ
## LR(1) items:
binop -> EQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> EQ

State 248:
## Known stack suffix:
## DIVIDES
## LR(1) items:
binop -> DIVIDES . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> DIVIDES

State 249:
## Known stack suffix:
## CONCAT
## LR(1) items:
binop -> CONCAT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> CONCAT

State 250:
## Known stack suffix:
## BEFORE
## LR(1) items:
binop -> BEFORE . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> BEFORE

State 251:
## Known stack suffix:
## LPAREN nxlet
## LR(1) items:
nxbot -> LPAREN nxlet . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## LPAREN nxlet RPAREN
## LR(1) items:
nxbot -> LPAREN nxlet RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN nxlet RPAREN

State 253:
## Known stack suffix:
## LPAREN binop
## LR(1) items:
nxbot -> LPAREN binop . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## LPAREN binop RPAREN
## LR(1) items:
nxbot -> LPAREN binop RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN binop RPAREN

State 255:
## Known stack suffix:
## REFFINAL nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFFINAL nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> REFFINAL nxapp
-- On THEN reduce production nxun -> REFFINAL nxapp
-- On RPAREN reduce production nxun -> REFFINAL nxapp
-- On PLUS reduce production nxun -> REFFINAL nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFFINAL nxapp
-- On NEQ reduce production nxun -> REFFINAL nxapp
-- On MUTUAL reduce production nxun -> REFFINAL nxapp
-- On MOD reduce production nxun -> REFFINAL nxapp
-- On MINUS reduce production nxun -> REFFINAL nxapp
-- On LT reduce production nxun -> REFFINAL nxapp
-- On LOR reduce production nxun -> REFFINAL nxapp
-- On LISTPUNCT reduce production nxun -> REFFINAL nxapp
-- On LETMUTABLE reduce production nxun -> REFFINAL nxapp
-- On LETAND reduce production nxun -> REFFINAL nxapp
-- On LET reduce production nxun -> REFFINAL nxapp
-- On LEQ reduce production nxun -> REFFINAL nxapp
-- On LAND reduce production nxun -> REFFINAL nxapp
-- On IN reduce production nxun -> REFFINAL nxapp
-- On GT reduce production nxun -> REFFINAL nxapp
-- On GEQ reduce production nxun -> REFFINAL nxapp
-- On EQ reduce production nxun -> REFFINAL nxapp
-- On EOI reduce production nxun -> REFFINAL nxapp
-- On ENDMUTUAL reduce production nxun -> REFFINAL nxapp
-- On ELSE reduce production nxun -> REFFINAL nxapp
-- On ELIST reduce production nxun -> REFFINAL nxapp
-- On DO reduce production nxun -> REFFINAL nxapp
-- On DIVIDES reduce production nxun -> REFFINAL nxapp
-- On CONS reduce production nxun -> REFFINAL nxapp
-- On CONCAT reduce production nxun -> REFFINAL nxapp
-- On CLOSENUM reduce production nxun -> REFFINAL nxapp
-- On BEFORE reduce production nxun -> REFFINAL nxapp

State 256:
## Known stack suffix:
## RENEWGLOBALHASH nxlet
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 258
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 259
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 258:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 259:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 260:
## Known stack suffix:
## OPENNUM nxlet
## LR(1) items:
narg -> OPENNUM nxlet . CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet . CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On CLOSENUM shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM . narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet CLOSENUM . error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 262
-- On OPENNUM shift to state 30
-- On narg shift to state 263
## Reductions:
-- On OPENQT reduce production narg ->
-- On END reduce production narg ->
-- On BGRP reduce production narg ->

State 262:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM error
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM error . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM nxlet CLOSENUM error

State 263:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM narg
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM narg . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM nxlet CLOSENUM narg

State 264:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg . sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 265
-- On END shift to state 279
-- On BGRP shift to state 280
-- On sarg shift to state 286
## Reductions:

State 265:
## Known stack suffix:
## OPENQT
## LR(1) items:
sarg -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 266
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 266:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sarg -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 278
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 268:
## Known stack suffix:
## OPENQT
## LR(1) items:
sargsub -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 269
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT reduce production sxblock ->

State 269:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sargsub -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 277
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 271:
## Known stack suffix:
## BGRP
## LR(1) items:
sargsub -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 272
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 273
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP reduce production sxblock ->

State 272:
## Known stack suffix:
## BGRP error
## LR(1) items:
sargsub -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP error

State 273:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sargsub -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sargsub -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 275
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 276
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 275:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sargsub -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP sxsep EGRP error

State 276:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sargsub -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP sxsep EGRP sargsub

State 277:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub

State 278:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> OPENQT sxsep CLOSEQT sargsub

State 279:
## Known stack suffix:
## END
## LR(1) items:
sarg -> END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> END

State 280:
## Known stack suffix:
## BGRP
## LR(1) items:
sarg -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 281
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 282
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP reduce production sxblock ->

State 281:
## Known stack suffix:
## BGRP error
## LR(1) items:
sarg -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP error

State 282:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sarg -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sarg -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 284
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 285
## Reductions:
-- On VARINSTR reduce production sargsub ->
-- On SPACE reduce production sargsub ->
-- On SEP reduce production sargsub ->
-- On EOI reduce production sargsub ->
-- On EGRP reduce production sargsub ->
-- On CTRLSEQ reduce production sargsub ->
-- On CLOSESTR reduce production sargsub ->
-- On CLOSEQT reduce production sargsub ->
-- On CHAR reduce production sargsub ->
-- On BREAK reduce production sargsub ->

State 284:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sarg -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP sxsep EGRP error

State 285:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sarg -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP sxsep EGRP sargsub

State 286:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg sarg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg

State 287:
## Known stack suffix:
## SEP sxsepsub
## LR(1) items:
sxsep -> SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> SEP sxsepsub

State 288:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsepsub -> sxblock . SEP sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock . SEP error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On SEP shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## sxblock SEP
## LR(1) items:
sxsepsub -> sxblock SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 290
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 291
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP reduce production sxblock ->
-- On EGRP reduce production sxsepsub ->
-- On CLOSESTR reduce production sxsepsub ->
-- On CLOSEQT reduce production sxsepsub ->

State 290:
## Known stack suffix:
## sxblock SEP error
## LR(1) items:
sxsepsub -> sxblock SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsepsub -> sxblock SEP error

State 291:
## Known stack suffix:
## sxblock SEP sxsepsub
## LR(1) items:
sxsepsub -> sxblock SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsepsub -> sxblock SEP sxsepsub

State 292:
## Known stack suffix:
## OPENSTR sxsep
## LR(1) items:
nxbot -> OPENSTR sxsep . CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSESTR shift to state 293
## Reductions:

State 293:
## Known stack suffix:
## OPENSTR sxsep CLOSESTR
## LR(1) items:
nxbot -> OPENSTR sxsep CLOSESTR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENSTR sxsep CLOSESTR

State 294:
## Known stack suffix:
## REFNOW nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFNOW nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES reduce production nxun -> REFNOW nxapp
-- On THEN reduce production nxun -> REFNOW nxapp
-- On RPAREN reduce production nxun -> REFNOW nxapp
-- On PLUS reduce production nxun -> REFNOW nxapp
-- On OVERWRITEGLOBALHASH reduce production nxun -> REFNOW nxapp
-- On NEQ reduce production nxun -> REFNOW nxapp
-- On MUTUAL reduce production nxun -> REFNOW nxapp
-- On MOD reduce production nxun -> REFNOW nxapp
-- On MINUS reduce production nxun -> REFNOW nxapp
-- On LT reduce production nxun -> REFNOW nxapp
-- On LOR reduce production nxun -> REFNOW nxapp
-- On LISTPUNCT reduce production nxun -> REFNOW nxapp
-- On LETMUTABLE reduce production nxun -> REFNOW nxapp
-- On LETAND reduce production nxun -> REFNOW nxapp
-- On LET reduce production nxun -> REFNOW nxapp
-- On LEQ reduce production nxun -> REFNOW nxapp
-- On LAND reduce production nxun -> REFNOW nxapp
-- On IN reduce production nxun -> REFNOW nxapp
-- On GT reduce production nxun -> REFNOW nxapp
-- On GEQ reduce production nxun -> REFNOW nxapp
-- On EQ reduce production nxun -> REFNOW nxapp
-- On EOI reduce production nxun -> REFNOW nxapp
-- On ENDMUTUAL reduce production nxun -> REFNOW nxapp
-- On ELSE reduce production nxun -> REFNOW nxapp
-- On ELIST reduce production nxun -> REFNOW nxapp
-- On DO reduce production nxun -> REFNOW nxapp
-- On DIVIDES reduce production nxun -> REFNOW nxapp
-- On CONS reduce production nxun -> REFNOW nxapp
-- On CONCAT reduce production nxun -> REFNOW nxapp
-- On CLOSENUM reduce production nxun -> REFNOW nxapp
-- On BEFORE reduce production nxun -> REFNOW nxapp

State 295:
## Known stack suffix:
## VAR OVERWRITEEQ nxlor
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> VAR OVERWRITEEQ nxlor

State 296:
## Known stack suffix:
## WHILE nxlet
## LR(1) items:
nxwhl -> WHILE nxlet . DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet . DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DO shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## WHILE nxlet DO
## LR(1) items:
nxwhl -> WHILE nxlet DO . nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet DO . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 298
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 299
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 298:
## Known stack suffix:
## WHILE nxlet DO error
## LR(1) items:
nxwhl -> WHILE nxlet DO error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE nxlet DO error

State 299:
## Known stack suffix:
## WHILE nxlet DO nxwhl
## LR(1) items:
nxwhl -> WHILE nxlet DO nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE nxlet DO nxwhl

State 300:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 313
## Reductions:

State 301:
## Known stack suffix:
## LET
## LR(1) items:
nxmutual -> LET . VAR argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
nxmutual -> LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 302
-- On CTRLSEQ shift to state 308
## Reductions:

State 302:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxmutual -> LET VAR . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 303
## Reductions:
-- On DEFEQ reduce production argvar ->

State 303:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxmutual -> LET VAR argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 304
## Reductions:

State 304:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 305
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 305:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 307
## Reductions:

State 306:
## Known stack suffix:
## ENDMUTUAL
## LR(1) items:
nxmutual -> ENDMUTUAL . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> ENDMUTUAL

State 307:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual

State 308:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 309
## Reductions:
-- On DEFEQ reduce production argvar ->

State 309:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 311
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 311:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 313:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 347
-- On nxtoplevel shift to state 349
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual

State 314:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 315
-- On VAR shift to state 316
## Reductions:

State 315:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxtoplevel -> LETMUTABLE error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE error

State 316:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . error [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 317
-- On OVERWRITEEQ shift to state 318
## Reductions:

State 317:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR error

State 318:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . error [ EOI ]
## Transitions:
-- On error shift to state 319
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 320
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 319:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error

State 320:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 344
-- On nxtoplevel shift to state 346
## Reductions:
-- On EOI reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet

State 321:
## Known stack suffix:
## LET
## LR(1) items:
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . error [ EOI ]
nxtoplevel -> LET . VAR error [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 322
-- On VAR shift to state 323
-- On CTRLSEQ shift to state 333
## Reductions:

State 322:
## Known stack suffix:
## LET error
## LR(1) items:
nxtoplevel -> LET error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET error

State 323:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR . error [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ error [ EOI ]
## Transitions:
-- On error shift to state 324
-- On VAR shift to state 7
-- On argvar shift to state 325
## Reductions:
-- On DEFEQ reduce production argvar ->

State 324:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxtoplevel -> LET VAR error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR error

State 325:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . error [ EOI ]
## Transitions:
-- On error shift to state 327
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 328
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 327:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ error

State 328:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 329
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 329:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 330
-- On nxtoplevel shift to state 332
## Reductions:
-- On EOI reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec

State 330:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 331
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 331:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 332:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel

State 333:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 334
-- On VAR shift to state 7
-- On argvar shift to state 335
## Reductions:
-- On DEFEQ reduce production argvar ->

State 334:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ error

State 335:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 337
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 338
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 337:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ error

State 338:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 339
## Reductions:
-- On MUTUAL reduce production nxdec ->
-- On LETMUTABLE reduce production nxdec ->
-- On LET reduce production nxdec ->
-- On IN reduce production nxdec ->
-- On EOI reduce production nxdec ->

State 339:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 340
-- On nxtoplevel shift to state 343
## Reductions:
-- On EOI reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec

State 340:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ EOI ]
## Transitions:
-- On error shift to state 341
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 342
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 341:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 342:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 343:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel

State 344:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 345
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 345:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 346:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel

State 347:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 348
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 348:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet

State 349:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel

State 350:
## Known stack suffix:
## MUTUAL LET CTRLSEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 351
## Reductions:
-- On DEFEQ reduce production argvar ->

State 351:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 353
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 353:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 355
-- On nxtoplevel shift to state 357
## Reductions:
-- On EOI reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 355:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 356
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 356:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet

State 357:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel

State 358:
## Known stack suffix:
## sxblock
## LR(1) items:
main -> sxblock . EOI [ # ]
## Transitions:
-- On EOI shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## sxblock EOI
## LR(1) items:
main -> sxblock EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production main -> sxblock EOI

State 360:
## Known stack suffix:
## nxtoplevel
## LR(1) items:
main -> nxtoplevel . EOI [ # ]
## Transitions:
-- On EOI shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## nxtoplevel EOI
## LR(1) items:
main -> nxtoplevel EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production main -> nxtoplevel EOI

State 362:
## Known stack suffix:
## main
## LR(1) items:
main' -> main . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept main

