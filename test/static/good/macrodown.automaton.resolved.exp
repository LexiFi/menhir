State 0:
## Known stack suffix:
##
## LR(1) items:
main' -> . main [ # ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 358
-- On nxtoplevel shift to state 360
-- On main shift to state 362
## Reductions:
-- On EOI
--   reduce production sxblock ->

State 1:
## Known stack suffix:
## VARINSTR
## LR(1) items:
sxbot -> VARINSTR . END [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On END shift to state 2
## Reductions:

State 2:
## Known stack suffix:
## VARINSTR END
## LR(1) items:
sxbot -> VARINSTR END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> VARINSTR END

State 3:
## Known stack suffix:
## SPACE
## LR(1) items:
sxbot -> SPACE . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> SPACE

State 4:
## Known stack suffix:
## MUTUAL
## LR(1) items:
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL . LET VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL . LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## MUTUAL LET
## LR(1) items:
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET . VAR argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
nxtoplevel -> MUTUAL LET . CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 6
-- On CTRLSEQ shift to state 350
## Reductions:

State 6:
## Known stack suffix:
## MUTUAL LET VAR
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 9
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 7:
## Known stack suffix:
## VAR
## LR(1) items:
argvar -> VAR . argvar [ DEFEQ ARROW ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 8
## Reductions:
-- On DEFEQ ARROW
--   reduce production argvar ->

State 8:
## Known stack suffix:
## VAR argvar
## LR(1) items:
argvar -> VAR argvar . [ DEFEQ ARROW ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production argvar -> VAR argvar

State 9:
## Known stack suffix:
## MUTUAL LET VAR argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 300
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 11:
## Known stack suffix:
## WHILE
## LR(1) items:
nxwhl -> WHILE . nxlet DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE . nxlet DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 12
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 296
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 12:
## Known stack suffix:
## WHILE error
## LR(1) items:
nxwhl -> WHILE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE error

State 13:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxlambda -> VAR . OVERWRITEEQ nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEEQ shift to state 14
## Reductions:
-- On VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE
--   reduce production nxbot -> VAR

State 14:
## Known stack suffix:
## VAR OVERWRITEEQ
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 295
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 15:
## Known stack suffix:
## VAR
## LR(1) items:
nxbot -> VAR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> VAR

State 16:
## Known stack suffix:
## UNITVALUE
## LR(1) items:
nxbot -> UNITVALUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> UNITVALUE

State 17:
## Known stack suffix:
## TRUE
## LR(1) items:
nxbot -> TRUE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> TRUE

State 18:
## Known stack suffix:
## REFNOW
## LR(1) items:
nxun -> REFNOW . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFNOW . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 19
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 294
## Reductions:

State 19:
## Known stack suffix:
## REFNOW error
## LR(1) items:
nxun -> REFNOW error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> REFNOW error

State 20:
## Known stack suffix:
## OPENSTR
## LR(1) items:
nxbot -> OPENSTR . sxsep CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> OPENSTR . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 21
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 292
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSESTR
--   reduce production sxblock ->

State 21:
## Known stack suffix:
## OPENSTR error
## LR(1) items:
nxbot -> OPENSTR error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENSTR error

State 22:
## Known stack suffix:
## SEP
## LR(1) items:
sxsep -> SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsep -> SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 23
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 287
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP
--   reduce production sxblock ->
-- On EGRP CLOSESTR CLOSEQT
--   reduce production sxsepsub ->

State 23:
## Known stack suffix:
## SEP error
## LR(1) items:
sxsep -> SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> SEP error

State 24:
## Known stack suffix:
## CTRLSEQ
## LR(1) items:
sxbot -> CTRLSEQ . sxclsnm sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sxbot -> CTRLSEQ . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 25
-- On CLASSNAME shift to state 26
-- On sxclsnm shift to state 27
## Reductions:
-- On OPENQT OPENNUM IDNAME END BGRP
--   reduce production sxclsnm ->

State 25:
## Known stack suffix:
## CTRLSEQ error
## LR(1) items:
sxbot -> CTRLSEQ error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CTRLSEQ error

State 26:
## Known stack suffix:
## CLASSNAME
## LR(1) items:
sxclsnm -> CLASSNAME . [ OPENQT OPENNUM IDNAME END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxclsnm -> CLASSNAME

State 27:
## Known stack suffix:
## CTRLSEQ sxclsnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm . sxidnm narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On IDNAME shift to state 28
-- On sxidnm shift to state 29
## Reductions:
-- On OPENQT OPENNUM END BGRP
--   reduce production sxidnm ->

State 28:
## Known stack suffix:
## IDNAME
## LR(1) items:
sxidnm -> IDNAME . [ OPENQT OPENNUM END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxidnm -> IDNAME

State 29:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm . narg sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENNUM shift to state 30
-- On narg shift to state 264
## Reductions:
-- On OPENQT END BGRP
--   reduce production narg ->

State 30:
## Known stack suffix:
## OPENNUM
## LR(1) items:
narg -> OPENNUM . nxlet CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM . error [ OPENQT END BGRP ]
narg -> OPENNUM . nxlet CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 31
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 260
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 31:
## Known stack suffix:
## OPENNUM error
## LR(1) items:
narg -> OPENNUM error . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM error

State 32:
## Known stack suffix:
## RENEWGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 33
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 256
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 33:
## Known stack suffix:
## RENEWGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH error

State 34:
## Known stack suffix:
## REFFINAL
## LR(1) items:
nxun -> REFFINAL . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> REFFINAL . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 35
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 255
## Reductions:

State 35:
## Known stack suffix:
## REFFINAL error
## LR(1) items:
nxun -> REFFINAL error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> REFFINAL error

State 36:
## Known stack suffix:
## OPENQT
## LR(1) items:
nxbot -> OPENQT . sxsep CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 39
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT
--   reduce production sxblock ->

State 37:
## Known stack suffix:
## CHAR
## LR(1) items:
sxbot -> CHAR . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CHAR

State 38:
## Known stack suffix:
## BREAK
## LR(1) items:
sxbot -> BREAK . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> BREAK

State 39:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
nxbot -> OPENQT sxsep . CLOSEQT [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSEQT shift to state 40
## Reductions:

State 40:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
nxbot -> OPENQT sxsep CLOSEQT . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENQT sxsep CLOSEQT

State 41:
## Known stack suffix:
## sxbot
## LR(1) items:
sxblock -> sxbot . sxblock [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxbot shift to state 41
-- On sxblock shift to state 42
## Reductions:
-- On SEP EOI EGRP CLOSESTR CLOSEQT
--   reduce production sxblock ->

State 42:
## Known stack suffix:
## sxbot sxblock
## LR(1) items:
sxblock -> sxbot sxblock . [ SEP EOI EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxblock -> sxbot sxblock

State 43:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsep -> sxblock . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> sxblock

State 44:
## Known stack suffix:
## NUMCONST
## LR(1) items:
nxbot -> NUMCONST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> NUMCONST

State 45:
## Known stack suffix:
## LPAREN
## LR(1) items:
nxbot -> LPAREN . nxlet RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . binop RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> LPAREN . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 46
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 47
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On PLUS shift to state 48
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On NEQ shift to state 49
-- On MOD shift to state 50
-- On MINUS shift to state 51
-- On LT shift to state 240
-- On LPAREN shift to state 45
-- On LOR shift to state 241
-- On LNOT shift to state 242
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LEQ shift to state 243
-- On LAND shift to state 244
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On GT shift to state 245
-- On GEQ shift to state 246
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On EQ shift to state 247
-- On DIVIDES shift to state 248
-- On DECGLOBALHASH shift to state 163
-- On CONCAT shift to state 249
-- On BLIST shift to state 55
-- On BEFORE shift to state 250
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 251
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
-- On binop shift to state 253
## Reductions:

State 46:
## Known stack suffix:
## LPAREN error
## LR(1) items:
nxbot -> LPAREN error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN error

State 47:
## Known stack suffix:
## TIMES
## LR(1) items:
binop -> TIMES . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> TIMES

State 48:
## Known stack suffix:
## PLUS
## LR(1) items:
binop -> PLUS . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> PLUS

State 49:
## Known stack suffix:
## NEQ
## LR(1) items:
binop -> NEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> NEQ

State 50:
## Known stack suffix:
## MOD
## LR(1) items:
binop -> MOD . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> MOD

State 51:
## Known stack suffix:
## MINUS
## LR(1) items:
binop -> MINUS . [ RPAREN ]
nxun -> MINUS . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> MINUS . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:
-- On RPAREN
--   reduce production binop -> MINUS

State 52:
## Known stack suffix:
## MINUS error
## LR(1) items:
nxun -> MINUS error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> MINUS error

State 53:
## Known stack suffix:
## FINISH
## LR(1) items:
nxbot -> FINISH . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> FINISH

State 54:
## Known stack suffix:
## FALSE
## LR(1) items:
nxbot -> FALSE . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> FALSE

State 55:
## Known stack suffix:
## BLIST
## LR(1) items:
nxbot -> BLIST . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . nxlet nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxbot -> BLIST . error [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On error shift to state 56
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On ELIST shift to state 232
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 233
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 56:
## Known stack suffix:
## BLIST error
## LR(1) items:
nxbot -> BLIST error . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST error

State 57:
## Known stack suffix:
## MINUS
## LR(1) items:
nxun -> MINUS . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> MINUS . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 52
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 59
## Reductions:

State 58:
## Known stack suffix:
## nxbot
## LR(1) items:
nxapp -> nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxapp -> nxbot

State 59:
## Known stack suffix:
## MINUS nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> MINUS nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxun -> MINUS nxapp

State 60:
## Known stack suffix:
## nxapp nxbot
## LR(1) items:
nxapp -> nxapp nxbot . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxapp -> nxapp nxbot

State 61:
## Known stack suffix:
## LNOT
## LR(1) items:
nxun -> LNOT . nxapp [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxun -> LNOT . error [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:

State 62:
## Known stack suffix:
## LNOT error
## LR(1) items:
nxun -> LNOT error . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxun -> LNOT error

State 63:
## Known stack suffix:
## LNOT nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> LNOT nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxun -> LNOT nxapp

State 64:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 65
-- On VAR shift to state 66
## Reductions:

State 65:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxlet -> LETMUTABLE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE error

State 66:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 67
-- On OVERWRITEEQ shift to state 68
## Reductions:

State 67:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxlet -> LETMUTABLE VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR error

State 68:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 69
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 228
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 69:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ error

State 70:
## Known stack suffix:
## LET
## LR(1) items:
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . VAR argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 71
-- On VAR shift to state 72
-- On CTRLSEQ shift to state 218
## Reductions:

State 71:
## Known stack suffix:
## LET error
## LR(1) items:
nxlet -> LET error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET error

State 72:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 73
-- On VAR shift to state 7
-- On argvar shift to state 74
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 73:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxlet -> LET VAR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR error

State 74:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 76
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 200
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 76:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ error

State 77:
## Known stack suffix:
## LAMBDA
## LR(1) items:
nxlambda -> LAMBDA . argvar ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA . argvar ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 78
-- On VAR shift to state 7
-- On argvar shift to state 79
## Reductions:
-- On ARROW
--   reduce production argvar ->

State 78:
## Known stack suffix:
## LAMBDA error
## LR(1) items:
nxlambda -> LAMBDA error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA error

State 79:
## Known stack suffix:
## LAMBDA argvar
## LR(1) items:
nxlambda -> LAMBDA argvar . ARROW nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar . ARROW error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On ARROW shift to state 80
## Reductions:

State 80:
## Known stack suffix:
## LAMBDA argvar ARROW
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> LAMBDA argvar ARROW . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 81
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 125
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 81:
## Known stack suffix:
## LAMBDA argvar ARROW error
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA argvar ARROW error

State 82:
## Known stack suffix:
## nxun
## LR(1) items:
nxltimes -> nxun . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On TIMES shift to state 83
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxltimes -> nxun

State 83:
## Known stack suffix:
## nxun TIMES
## LR(1) items:
nxltimes -> nxun TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxun TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 84
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 85
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 84:
## Known stack suffix:
## nxun TIMES error
## LR(1) items:
nxltimes -> nxun TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxun TIMES error

State 85:
## Known stack suffix:
## nxun TIMES nxrtimes
## LR(1) items:
nxltimes -> nxun TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxltimes -> nxun TIMES nxrtimes

State 86:
## Known stack suffix:
## nxrtimes MOD
## LR(1) items:
nxrtimes -> nxrtimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 87
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 88
## Reductions:

State 87:
## Known stack suffix:
## nxrtimes MOD error
## LR(1) items:
nxrtimes -> nxrtimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxrtimes MOD error

State 88:
## Known stack suffix:
## nxrtimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrtimes -> nxrtimes MOD nxapp

State 89:
## Known stack suffix:
## nxrtimes DIVIDES
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 90
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 91
## Reductions:

State 90:
## Known stack suffix:
## nxrtimes DIVIDES error
## LR(1) items:
nxrtimes -> nxrtimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxrtimes DIVIDES error

State 91:
## Known stack suffix:
## nxrtimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxrtimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrtimes -> nxrtimes DIVIDES nxapp

State 92:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxrtimes -> nxapp . TIMES nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp . TIMES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On TIMES shift to state 93
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrtimes -> nxapp

State 93:
## Known stack suffix:
## nxapp TIMES
## LR(1) items:
nxrtimes -> nxapp TIMES . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxapp TIMES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 94
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 95
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 94:
## Known stack suffix:
## nxapp TIMES error
## LR(1) items:
nxrtimes -> nxapp TIMES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrtimes -> nxapp TIMES error

State 95:
## Known stack suffix:
## nxapp TIMES nxrtimes
## LR(1) items:
nxrtimes -> nxapp TIMES nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrtimes -> nxapp TIMES nxrtimes

State 96:
## Known stack suffix:
## nxltimes
## LR(1) items:
nxlminus -> nxltimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 97
-- On DIVIDES shift to state 100
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxlminus -> nxltimes

State 97:
## Known stack suffix:
## nxltimes MOD
## LR(1) items:
nxltimes -> nxltimes MOD . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes MOD . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 98
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 99
## Reductions:

State 98:
## Known stack suffix:
## nxltimes MOD error
## LR(1) items:
nxltimes -> nxltimes MOD error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxltimes MOD error

State 99:
## Known stack suffix:
## nxltimes MOD nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes MOD nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxltimes -> nxltimes MOD nxapp

State 100:
## Known stack suffix:
## nxltimes DIVIDES
## LR(1) items:
nxltimes -> nxltimes DIVIDES . nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxltimes -> nxltimes DIVIDES . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 101
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 102
## Reductions:

State 101:
## Known stack suffix:
## nxltimes DIVIDES error
## LR(1) items:
nxltimes -> nxltimes DIVIDES error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxltimes -> nxltimes DIVIDES error

State 102:
## Known stack suffix:
## nxltimes DIVIDES nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxltimes -> nxltimes DIVIDES nxapp . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxltimes -> nxltimes DIVIDES nxapp

State 103:
## Known stack suffix:
## nxlplus
## LR(1) items:
nxconcat -> nxlplus . CONCAT nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONS nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus . CONCAT error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 104
-- On CONS shift to state 107
-- On CONCAT shift to state 122
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
--   reduce production nxconcat -> nxlplus

State 104:
## Known stack suffix:
## nxlplus MINUS
## LR(1) items:
nxlminus -> nxlplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlminus -> nxlplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 105
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 106
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 105:
## Known stack suffix:
## nxlplus MINUS error
## LR(1) items:
nxlminus -> nxlplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlminus -> nxlplus MINUS error

State 106:
## Known stack suffix:
## nxlplus MINUS nxrtimes
## LR(1) items:
nxlminus -> nxlplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxlminus -> nxlplus MINUS nxrtimes

State 107:
## Known stack suffix:
## nxlplus CONS
## LR(1) items:
nxconcat -> nxlplus CONS . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 120
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 108:
## Known stack suffix:
## nxlminus
## LR(1) items:
nxlplus -> nxlminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 109
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxlplus -> nxlminus

State 109:
## Known stack suffix:
## nxlminus PLUS
## LR(1) items:
nxlplus -> nxlminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxlplus -> nxlminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 110
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 112
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 110:
## Known stack suffix:
## nxlminus PLUS error
## LR(1) items:
nxlplus -> nxlminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlplus -> nxlminus PLUS error

State 111:
## Known stack suffix:
## nxrtimes
## LR(1) items:
nxrminus -> nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrminus -> nxrtimes

State 112:
## Known stack suffix:
## nxlminus PLUS nxrplus
## LR(1) items:
nxlplus -> nxlminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxlplus -> nxlminus PLUS nxrplus

State 113:
## Known stack suffix:
## nxrplus MINUS
## LR(1) items:
nxrminus -> nxrplus MINUS . nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus MINUS . error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 114
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 115
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 114:
## Known stack suffix:
## nxrplus MINUS error
## LR(1) items:
nxrminus -> nxrplus MINUS error . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrminus -> nxrplus MINUS error

State 115:
## Known stack suffix:
## nxrplus MINUS nxrtimes
## LR(1) items:
nxrminus -> nxrplus MINUS nxrtimes . [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD nxapp [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . DIVIDES error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
nxrtimes -> nxrtimes . MOD error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MOD shift to state 86
-- On DIVIDES shift to state 89
## Reductions:
-- On THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrminus -> nxrplus MINUS nxrtimes

State 116:
## Known stack suffix:
## nxrminus
## LR(1) items:
nxrplus -> nxrminus . PLUS nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus . PLUS error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On PLUS shift to state 117
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrplus -> nxrminus

State 117:
## Known stack suffix:
## nxrminus PLUS
## LR(1) items:
nxrplus -> nxrminus PLUS . nxrplus [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 118
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxrtimes shift to state 111
-- On nxrplus shift to state 119
-- On nxrminus shift to state 116
-- On nxbot shift to state 58
-- On nxapp shift to state 92
## Reductions:

State 118:
## Known stack suffix:
## nxrminus PLUS error
## LR(1) items:
nxrplus -> nxrminus PLUS error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxrplus -> nxrminus PLUS error

State 119:
## Known stack suffix:
## nxrminus PLUS nxrplus
## LR(1) items:
nxrminus -> nxrplus . MINUS nxrtimes [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrminus -> nxrplus . MINUS error [ THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
nxrplus -> nxrminus PLUS nxrplus . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On MINUS shift to state 113
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
--   reduce production nxrplus -> nxrminus PLUS nxrplus

State 120:
## Known stack suffix:
## nxlplus CONS nxconcat
## LR(1) items:
nxconcat -> nxlplus CONS nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONS nxconcat

State 121:
## Known stack suffix:
## nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxun -> nxapp

State 122:
## Known stack suffix:
## nxlplus CONCAT
## LR(1) items:
nxconcat -> nxlplus CONCAT . nxconcat [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxconcat -> nxlplus CONCAT . error [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 123
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 124
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 123:
## Known stack suffix:
## nxlplus CONCAT error
## LR(1) items:
nxconcat -> nxlplus CONCAT error . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONCAT error

State 124:
## Known stack suffix:
## nxlplus CONCAT nxconcat
## LR(1) items:
nxconcat -> nxlplus CONCAT nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxconcat -> nxlplus CONCAT nxconcat

State 125:
## Known stack suffix:
## LAMBDA argvar ARROW nxlor
## LR(1) items:
nxlambda -> LAMBDA argvar ARROW nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> LAMBDA argvar ARROW nxlor

State 126:
## Known stack suffix:
## nxland
## LR(1) items:
nxlor -> nxland . LOR nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland . LOR error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LOR shift to state 127
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
--   reduce production nxlor -> nxland

State 127:
## Known stack suffix:
## nxland LOR
## LR(1) items:
nxlor -> nxland LOR . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlor -> nxland LOR . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 128
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 129
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 128:
## Known stack suffix:
## nxland LOR error
## LR(1) items:
nxlor -> nxland LOR error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlor -> nxland LOR error

State 129:
## Known stack suffix:
## nxland LOR nxlor
## LR(1) items:
nxlor -> nxland LOR nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlor -> nxland LOR nxlor

State 130:
## Known stack suffix:
## nxconcat
## LR(1) items:
nxcomp -> nxconcat . EQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . EQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . NEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . GT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat . LT error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On NEQ shift to state 131
-- On LT shift to state 134
-- On LEQ shift to state 137
-- On GT shift to state 140
-- On GEQ shift to state 143
-- On EQ shift to state 146
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
--   reduce production nxcomp -> nxconcat

State 131:
## Known stack suffix:
## nxconcat NEQ
## LR(1) items:
nxcomp -> nxconcat NEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat NEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 132
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 133
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 132:
## Known stack suffix:
## nxconcat NEQ error
## LR(1) items:
nxcomp -> nxconcat NEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat NEQ error

State 133:
## Known stack suffix:
## nxconcat NEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat NEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat NEQ nxcomp

State 134:
## Known stack suffix:
## nxconcat LT
## LR(1) items:
nxcomp -> nxconcat LT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 135
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 136
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 135:
## Known stack suffix:
## nxconcat LT error
## LR(1) items:
nxcomp -> nxconcat LT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LT error

State 136:
## Known stack suffix:
## nxconcat LT nxcomp
## LR(1) items:
nxcomp -> nxconcat LT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LT nxcomp

State 137:
## Known stack suffix:
## nxconcat LEQ
## LR(1) items:
nxcomp -> nxconcat LEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat LEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 138
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 139
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 138:
## Known stack suffix:
## nxconcat LEQ error
## LR(1) items:
nxcomp -> nxconcat LEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LEQ error

State 139:
## Known stack suffix:
## nxconcat LEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat LEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat LEQ nxcomp

State 140:
## Known stack suffix:
## nxconcat GT
## LR(1) items:
nxcomp -> nxconcat GT . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GT . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 141
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 142
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 141:
## Known stack suffix:
## nxconcat GT error
## LR(1) items:
nxcomp -> nxconcat GT error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GT error

State 142:
## Known stack suffix:
## nxconcat GT nxcomp
## LR(1) items:
nxcomp -> nxconcat GT nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GT nxcomp

State 143:
## Known stack suffix:
## nxconcat GEQ
## LR(1) items:
nxcomp -> nxconcat GEQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat GEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 144
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 145
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 144:
## Known stack suffix:
## nxconcat GEQ error
## LR(1) items:
nxcomp -> nxconcat GEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GEQ error

State 145:
## Known stack suffix:
## nxconcat GEQ nxcomp
## LR(1) items:
nxcomp -> nxconcat GEQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat GEQ nxcomp

State 146:
## Known stack suffix:
## nxconcat EQ
## LR(1) items:
nxcomp -> nxconcat EQ . nxcomp [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxcomp -> nxconcat EQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 147
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxconcat shift to state 130
-- On nxcomp shift to state 148
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 147:
## Known stack suffix:
## nxconcat EQ error
## LR(1) items:
nxcomp -> nxconcat EQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat EQ error

State 148:
## Known stack suffix:
## nxconcat EQ nxcomp
## LR(1) items:
nxcomp -> nxconcat EQ nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxcomp -> nxconcat EQ nxcomp

State 149:
## Known stack suffix:
## nxcomp
## LR(1) items:
nxland -> nxcomp . LAND nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp . LAND error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On LAND shift to state 150
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
--   reduce production nxland -> nxcomp

State 150:
## Known stack suffix:
## nxcomp LAND
## LR(1) items:
nxland -> nxcomp LAND . nxland [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxland -> nxcomp LAND . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 151
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlminus shift to state 108
-- On nxland shift to state 152
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 151:
## Known stack suffix:
## nxcomp LAND error
## LR(1) items:
nxland -> nxcomp LAND error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxland -> nxcomp LAND error

State 152:
## Known stack suffix:
## nxcomp LAND nxland
## LR(1) items:
nxland -> nxcomp LAND nxland . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxland -> nxcomp LAND nxland

State 153:
## Known stack suffix:
## IFIDISVALID
## LR(1) items:
nxif -> IFIDISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 154
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 155
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 196
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 154:
## Known stack suffix:
## IFIDISVALID error
## LR(1) items:
nxif -> IFIDISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID error

State 155:
## Known stack suffix:
## IFIDISVALID THEN
## LR(1) items:
nxif -> IFIDISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 156
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 192
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 156:
## Known stack suffix:
## IFIDISVALID THEN error
## LR(1) items:
nxif -> IFIDISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN error

State 157:
## Known stack suffix:
## IFCLASSISVALID
## LR(1) items:
nxif -> IFCLASSISVALID . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 158
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On THEN shift to state 159
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 188
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 158:
## Known stack suffix:
## IFCLASSISVALID error
## LR(1) items:
nxif -> IFCLASSISVALID error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID error

State 159:
## Known stack suffix:
## IFCLASSISVALID THEN
## LR(1) items:
nxif -> IFCLASSISVALID THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 160
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 184
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 160:
## Known stack suffix:
## IFCLASSISVALID THEN error
## LR(1) items:
nxif -> IFCLASSISVALID THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN error

State 161:
## Known stack suffix:
## IF
## LR(1) items:
nxif -> IF . nxlet THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF . nxlet THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 162
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 177
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 162:
## Known stack suffix:
## IF error
## LR(1) items:
nxif -> IF error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF error

State 163:
## Known stack suffix:
## DECGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH . nxlet OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 164
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 167
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 164:
## Known stack suffix:
## DECGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH error

State 165:
## Known stack suffix:
## nxwhl
## LR(1) items:
nxlet -> nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> nxwhl

State 166:
## Known stack suffix:
## nxlor
## LR(1) items:
nxlambda -> nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> nxlor

State 167:
## Known stack suffix:
## DECGLOBALHASH nxlet
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 169
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 170
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 169:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 170:
## Known stack suffix:
## DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> DECGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 171:
## Known stack suffix:
## nxlambda
## LR(1) items:
nxbfr -> nxlambda . BEFORE nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda . BEFORE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On BEFORE shift to state 172
## Reductions:
-- On THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM
--   reduce production nxbfr -> nxlambda

State 172:
## Known stack suffix:
## nxlambda BEFORE
## LR(1) items:
nxbfr -> nxlambda BEFORE . nxbfr [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxbfr -> nxlambda BEFORE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 173
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 174
-- On nxapp shift to state 121
## Reductions:

State 173:
## Known stack suffix:
## nxlambda BEFORE error
## LR(1) items:
nxbfr -> nxlambda BEFORE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbfr -> nxlambda BEFORE error

State 174:
## Known stack suffix:
## nxlambda BEFORE nxbfr
## LR(1) items:
nxbfr -> nxlambda BEFORE nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbfr -> nxlambda BEFORE nxbfr

State 175:
## Known stack suffix:
## nxif
## LR(1) items:
nxwhl -> nxif . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> nxif

State 176:
## Known stack suffix:
## nxbfr
## LR(1) items:
nxif -> nxbfr . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> nxbfr

State 177:
## Known stack suffix:
## IF nxlet
## LR(1) items:
nxif -> IF nxlet . THEN nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet . THEN nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On THEN shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## IF nxlet THEN
## LR(1) items:
nxif -> IF nxlet THEN . nxlet ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN . nxlet ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 179
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 180
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 179:
## Known stack suffix:
## IF nxlet THEN error
## LR(1) items:
nxif -> IF nxlet THEN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN error

State 180:
## Known stack suffix:
## IF nxlet THEN nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IF nxlet THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 182
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 183
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 182:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE error
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN nxlet ELSE error

State 183:
## Known stack suffix:
## IF nxlet THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IF nxlet THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IF nxlet THEN nxlet ELSE nxlet

State 184:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 186
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 187
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 186:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE error

State 187:
## Known stack suffix:
## IFCLASSISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID THEN nxlet ELSE nxlet

State 188:
## Known stack suffix:
## IFCLASSISVALID nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 189
## Reductions:

State 189:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFCLASSISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 190
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 191
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 190:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID nxlet ELSE error

State 191:
## Known stack suffix:
## IFCLASSISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFCLASSISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFCLASSISVALID nxlet ELSE nxlet

State 192:
## Known stack suffix:
## IFIDISVALID THEN nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID THEN nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 194
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 195
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 194:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN nxlet ELSE error

State 195:
## Known stack suffix:
## IFIDISVALID THEN nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID THEN nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID THEN nxlet ELSE nxlet

State 196:
## Known stack suffix:
## IFIDISVALID nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet . ELSE nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet . ELSE error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On ELSE shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## IFIDISVALID nxlet ELSE
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxif -> IFIDISVALID nxlet ELSE . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 198
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 199
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 198:
## Known stack suffix:
## IFIDISVALID nxlet ELSE error
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID nxlet ELSE error

State 199:
## Known stack suffix:
## IFIDISVALID nxlet ELSE nxlet
## LR(1) items:
nxif -> IFIDISVALID nxlet ELSE nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxif -> IFIDISVALID nxlet ELSE nxlet

State 200:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 214
## Reductions:
-- On IN
--   reduce production nxdec ->

State 201:
## Known stack suffix:
## LETAND
## LR(1) items:
nxdec -> LETAND . VAR argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . VAR error [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND . CTRLSEQ error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 202
-- On CTRLSEQ shift to state 208
## Reductions:

State 202:
## Known stack suffix:
## LETAND VAR
## LR(1) items:
nxdec -> LETAND VAR . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND VAR . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 203
-- On VAR shift to state 7
-- On argvar shift to state 204
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 203:
## Known stack suffix:
## LETAND VAR error
## LR(1) items:
nxdec -> LETAND VAR error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND VAR error

State 204:
## Known stack suffix:
## LETAND VAR argvar
## LR(1) items:
nxdec -> LETAND VAR argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 205
## Reductions:

State 205:
## Known stack suffix:
## LETAND VAR argvar DEFEQ
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 206
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 206:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 207
## Reductions:
-- On MUTUAL LETMUTABLE LET IN EOI
--   reduce production nxdec ->

State 207:
## Known stack suffix:
## LETAND VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND VAR argvar DEFEQ nxlet nxdec

State 208:
## Known stack suffix:
## LETAND CTRLSEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ . argvar DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
nxdec -> LETAND CTRLSEQ . error [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On error shift to state 209
-- On VAR shift to state 7
-- On argvar shift to state 210
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 209:
## Known stack suffix:
## LETAND CTRLSEQ error
## LR(1) items:
nxdec -> LETAND CTRLSEQ error . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND CTRLSEQ error

State 210:
## Known stack suffix:
## LETAND CTRLSEQ argvar
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar . DEFEQ nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 211
## Reductions:

State 211:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ . nxlet nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 212
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 212:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet . nxdec [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 213
## Reductions:
-- On MUTUAL LETMUTABLE LET IN EOI
--   reduce production nxdec ->

State 213:
## Known stack suffix:
## LETAND CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxdec -> LETAND CTRLSEQ argvar DEFEQ nxlet nxdec

State 214:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 215
## Reductions:

State 215:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 216
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 217
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 216:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN error

State 217:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 218:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 219
-- On VAR shift to state 7
-- On argvar shift to state 220
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 219:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ error

State 220:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DEFEQ shift to state 221
## Reductions:

State 221:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 222
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 223
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 222:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ error

State 223:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 224
## Reductions:
-- On IN
--   reduce production nxdec ->

State 224:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 226
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 227
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 226:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 227:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 228:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On IN shift to state 229
## Reductions:

State 229:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 230
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 231
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 230:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN error
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN error

State 231:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlet -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 232:
## Known stack suffix:
## BLIST ELIST
## LR(1) items:
nxbot -> BLIST ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST ELIST

State 233:
## Known stack suffix:
## BLIST nxlet
## LR(1) items:
nxbot -> BLIST nxlet . nxlist ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 238
## Reductions:
-- On ELIST
--   reduce production nxlist ->

State 234:
## Known stack suffix:
## LISTPUNCT
## LR(1) items:
nxlist -> LISTPUNCT . nxlet nxlist [ ELIST ]
nxlist -> LISTPUNCT . error [ ELIST ]
## Transitions:
-- On error shift to state 235
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 236
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 235:
## Known stack suffix:
## LISTPUNCT error
## LR(1) items:
nxlist -> LISTPUNCT error . [ ELIST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlist -> LISTPUNCT error

State 236:
## Known stack suffix:
## LISTPUNCT nxlet
## LR(1) items:
nxlist -> LISTPUNCT nxlet . nxlist [ ELIST ]
## Transitions:
-- On LISTPUNCT shift to state 234
-- On nxlist shift to state 237
## Reductions:
-- On ELIST
--   reduce production nxlist ->

State 237:
## Known stack suffix:
## LISTPUNCT nxlet nxlist
## LR(1) items:
nxlist -> LISTPUNCT nxlet nxlist . [ ELIST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlist -> LISTPUNCT nxlet nxlist

State 238:
## Known stack suffix:
## BLIST nxlet nxlist
## LR(1) items:
nxbot -> BLIST nxlet nxlist . ELIST [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On ELIST shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## BLIST nxlet nxlist ELIST
## LR(1) items:
nxbot -> BLIST nxlet nxlist ELIST . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> BLIST nxlet nxlist ELIST

State 240:
## Known stack suffix:
## LT
## LR(1) items:
binop -> LT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LT

State 241:
## Known stack suffix:
## LOR
## LR(1) items:
binop -> LOR . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LOR

State 242:
## Known stack suffix:
## LNOT
## LR(1) items:
binop -> LNOT . [ RPAREN ]
nxun -> LNOT . nxapp [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
nxun -> LNOT . error [ TIMES RPAREN PLUS NEQ MOD MINUS LT LOR LEQ LAND GT GEQ EQ DIVIDES CONS CONCAT BEFORE ]
## Transitions:
-- On error shift to state 62
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 58
-- On nxapp shift to state 63
## Reductions:
-- On RPAREN
--   reduce production binop -> LNOT

State 243:
## Known stack suffix:
## LEQ
## LR(1) items:
binop -> LEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LEQ

State 244:
## Known stack suffix:
## LAND
## LR(1) items:
binop -> LAND . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> LAND

State 245:
## Known stack suffix:
## GT
## LR(1) items:
binop -> GT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> GT

State 246:
## Known stack suffix:
## GEQ
## LR(1) items:
binop -> GEQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> GEQ

State 247:
## Known stack suffix:
## EQ
## LR(1) items:
binop -> EQ . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> EQ

State 248:
## Known stack suffix:
## DIVIDES
## LR(1) items:
binop -> DIVIDES . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> DIVIDES

State 249:
## Known stack suffix:
## CONCAT
## LR(1) items:
binop -> CONCAT . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> CONCAT

State 250:
## Known stack suffix:
## BEFORE
## LR(1) items:
binop -> BEFORE . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binop -> BEFORE

State 251:
## Known stack suffix:
## LPAREN nxlet
## LR(1) items:
nxbot -> LPAREN nxlet . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## LPAREN nxlet RPAREN
## LR(1) items:
nxbot -> LPAREN nxlet RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN nxlet RPAREN

State 253:
## Known stack suffix:
## LPAREN binop
## LR(1) items:
nxbot -> LPAREN binop . RPAREN [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On RPAREN shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## LPAREN binop RPAREN
## LR(1) items:
nxbot -> LPAREN binop RPAREN . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> LPAREN binop RPAREN

State 255:
## Known stack suffix:
## REFFINAL nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFFINAL nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxun -> REFFINAL nxapp

State 256:
## Known stack suffix:
## RENEWGLOBALHASH nxlet
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet . OVERWRITEGLOBALHASH error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On OVERWRITEGLOBALHASH shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . nxlor [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
-- On error shift to state 258
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 259
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxapp shift to state 121
## Reductions:

State 258:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH error

State 259:
## Known stack suffix:
## RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor
## LR(1) items:
nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> RENEWGLOBALHASH nxlet OVERWRITEGLOBALHASH nxlor

State 260:
## Known stack suffix:
## OPENNUM nxlet
## LR(1) items:
narg -> OPENNUM nxlet . CLOSENUM narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet . CLOSENUM error [ OPENQT END BGRP ]
## Transitions:
-- On CLOSENUM shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM . narg [ OPENQT END BGRP ]
narg -> OPENNUM nxlet CLOSENUM . error [ OPENQT END BGRP ]
## Transitions:
-- On error shift to state 262
-- On OPENNUM shift to state 30
-- On narg shift to state 263
## Reductions:
-- On OPENQT END BGRP
--   reduce production narg ->

State 262:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM error
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM error . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM nxlet CLOSENUM error

State 263:
## Known stack suffix:
## OPENNUM nxlet CLOSENUM narg
## LR(1) items:
narg -> OPENNUM nxlet CLOSENUM narg . [ OPENQT END BGRP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production narg -> OPENNUM nxlet CLOSENUM narg

State 264:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg . sarg [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 265
-- On END shift to state 279
-- On BGRP shift to state 280
-- On sarg shift to state 286
## Reductions:

State 265:
## Known stack suffix:
## OPENQT
## LR(1) items:
sarg -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 266
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT
--   reduce production sxblock ->

State 266:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sarg -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 278
## Reductions:
-- On VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
--   reduce production sargsub ->

State 268:
## Known stack suffix:
## OPENQT
## LR(1) items:
sargsub -> OPENQT . sxsep CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 269
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On CLOSEQT
--   reduce production sxblock ->

State 269:
## Known stack suffix:
## OPENQT sxsep
## LR(1) items:
sargsub -> OPENQT sxsep . CLOSEQT sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On CLOSEQT shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## OPENQT sxsep CLOSEQT
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 277
## Reductions:
-- On VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
--   reduce production sargsub ->

State 271:
## Known stack suffix:
## BGRP
## LR(1) items:
sargsub -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 272
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 273
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP
--   reduce production sxblock ->

State 272:
## Known stack suffix:
## BGRP error
## LR(1) items:
sargsub -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP error

State 273:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sargsub -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sargsub -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sargsub -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 275
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 276
## Reductions:
-- On VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
--   reduce production sargsub ->

State 275:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sargsub -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP sxsep EGRP error

State 276:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sargsub -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> BGRP sxsep EGRP sargsub

State 277:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sargsub -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sargsub -> OPENQT sxsep CLOSEQT sargsub

State 278:
## Known stack suffix:
## OPENQT sxsep CLOSEQT sargsub
## LR(1) items:
sarg -> OPENQT sxsep CLOSEQT sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> OPENQT sxsep CLOSEQT sargsub

State 279:
## Known stack suffix:
## END
## LR(1) items:
sarg -> END . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> END

State 280:
## Known stack suffix:
## BGRP
## LR(1) items:
sarg -> BGRP . sxsep EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP . sxsep EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 281
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On SEP shift to state 22
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsep shift to state 282
-- On sxbot shift to state 41
-- On sxblock shift to state 43
## Reductions:
-- On EGRP
--   reduce production sxblock ->

State 281:
## Known stack suffix:
## BGRP error
## LR(1) items:
sarg -> BGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP error

State 282:
## Known stack suffix:
## BGRP sxsep
## LR(1) items:
sarg -> BGRP sxsep . EGRP sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep . EGRP error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On EGRP shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## BGRP sxsep EGRP
## LR(1) items:
sarg -> BGRP sxsep EGRP . sargsub [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
sarg -> BGRP sxsep EGRP . error [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
-- On error shift to state 284
-- On OPENQT shift to state 268
-- On BGRP shift to state 271
-- On sargsub shift to state 285
## Reductions:
-- On VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
--   reduce production sargsub ->

State 284:
## Known stack suffix:
## BGRP sxsep EGRP error
## LR(1) items:
sarg -> BGRP sxsep EGRP error . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP sxsep EGRP error

State 285:
## Known stack suffix:
## BGRP sxsep EGRP sargsub
## LR(1) items:
sarg -> BGRP sxsep EGRP sargsub . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sarg -> BGRP sxsep EGRP sargsub

State 286:
## Known stack suffix:
## CTRLSEQ sxclsnm sxidnm narg sarg
## LR(1) items:
sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg . [ VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxbot -> CTRLSEQ sxclsnm sxidnm narg sarg

State 287:
## Known stack suffix:
## SEP sxsepsub
## LR(1) items:
sxsep -> SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsep -> SEP sxsepsub

State 288:
## Known stack suffix:
## sxblock
## LR(1) items:
sxsepsub -> sxblock . SEP sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock . SEP error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On SEP shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## sxblock SEP
## LR(1) items:
sxsepsub -> sxblock SEP . sxsepsub [ EGRP CLOSESTR CLOSEQT ]
sxsepsub -> sxblock SEP . error [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
-- On error shift to state 290
-- On VARINSTR shift to state 1
-- On SPACE shift to state 3
-- On CTRLSEQ shift to state 24
-- On CHAR shift to state 37
-- On BREAK shift to state 38
-- On sxsepsub shift to state 291
-- On sxbot shift to state 41
-- On sxblock shift to state 288
## Reductions:
-- On SEP
--   reduce production sxblock ->
-- On EGRP CLOSESTR CLOSEQT
--   reduce production sxsepsub ->

State 290:
## Known stack suffix:
## sxblock SEP error
## LR(1) items:
sxsepsub -> sxblock SEP error . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsepsub -> sxblock SEP error

State 291:
## Known stack suffix:
## sxblock SEP sxsepsub
## LR(1) items:
sxsepsub -> sxblock SEP sxsepsub . [ EGRP CLOSESTR CLOSEQT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sxsepsub -> sxblock SEP sxsepsub

State 292:
## Known stack suffix:
## OPENSTR sxsep
## LR(1) items:
nxbot -> OPENSTR sxsep . CLOSESTR [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
-- On CLOSESTR shift to state 293
## Reductions:

State 293:
## Known stack suffix:
## OPENSTR sxsep CLOSESTR
## LR(1) items:
nxbot -> OPENSTR sxsep CLOSESTR . [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxbot -> OPENSTR sxsep CLOSESTR

State 294:
## Known stack suffix:
## REFNOW nxapp
## LR(1) items:
nxapp -> nxapp . nxbot [ VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE ]
nxun -> REFNOW nxapp . [ TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE ]
## Transitions:
-- On VAR shift to state 15
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On LPAREN shift to state 45
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On BLIST shift to state 55
-- On nxbot shift to state 60
## Reductions:
-- On TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
--   reduce production nxun -> REFNOW nxapp

State 295:
## Known stack suffix:
## VAR OVERWRITEEQ nxlor
## LR(1) items:
nxlambda -> VAR OVERWRITEEQ nxlor . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxlambda -> VAR OVERWRITEEQ nxlor

State 296:
## Known stack suffix:
## WHILE nxlet
## LR(1) items:
nxwhl -> WHILE nxlet . DO nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet . DO error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On DO shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## WHILE nxlet DO
## LR(1) items:
nxwhl -> WHILE nxlet DO . nxwhl [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
nxwhl -> WHILE nxlet DO . error [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
-- On error shift to state 298
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 299
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 298:
## Known stack suffix:
## WHILE nxlet DO error
## LR(1) items:
nxwhl -> WHILE nxlet DO error . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE nxlet DO error

State 299:
## Known stack suffix:
## WHILE nxlet DO nxwhl
## LR(1) items:
nxwhl -> WHILE nxlet DO nxwhl . [ THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxwhl -> WHILE nxlet DO nxwhl

State 300:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 313
## Reductions:

State 301:
## Known stack suffix:
## LET
## LR(1) items:
nxmutual -> LET . VAR argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
nxmutual -> LET . CTRLSEQ argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 302
-- On CTRLSEQ shift to state 308
## Reductions:

State 302:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxmutual -> LET VAR . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 303
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 303:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxmutual -> LET VAR argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 304
## Reductions:

State 304:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 305
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 305:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 307
## Reductions:

State 306:
## Known stack suffix:
## ENDMUTUAL
## LR(1) items:
nxmutual -> ENDMUTUAL . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> ENDMUTUAL

State 307:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> LET VAR argvar DEFEQ nxlet nxmutual

State 308:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 309
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 309:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On DEFEQ shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 311
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 311:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 312
## Reductions:

State 312:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ MUTUAL LETMUTABLE LET IN EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxmutual -> LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 313:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 347
-- On nxtoplevel shift to state 349
## Reductions:
-- On EOI
--   reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual

State 314:
## Known stack suffix:
## LETMUTABLE
## LR(1) items:
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE . error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR error [ EOI ]
nxtoplevel -> LETMUTABLE . VAR OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 315
-- On VAR shift to state 316
## Reductions:

State 315:
## Known stack suffix:
## LETMUTABLE error
## LR(1) items:
nxtoplevel -> LETMUTABLE error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE error

State 316:
## Known stack suffix:
## LETMUTABLE VAR
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR . error [ EOI ]
nxtoplevel -> LETMUTABLE VAR . OVERWRITEEQ error [ EOI ]
## Transitions:
-- On error shift to state 317
-- On OVERWRITEEQ shift to state 318
## Reductions:

State 317:
## Known stack suffix:
## LETMUTABLE VAR error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR error

State 318:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . nxlet IN nxlet [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ . error [ EOI ]
## Transitions:
-- On error shift to state 319
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 320
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 319:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ error
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ error

State 320:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . nxtoplevel [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . [ EOI ]
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 344
-- On nxtoplevel shift to state 346
## Reductions:
-- On EOI
--   reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet

State 321:
## Known stack suffix:
## LET
## LR(1) items:
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET . error [ EOI ]
nxtoplevel -> LET . VAR error [ EOI ]
nxtoplevel -> LET . VAR argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ error [ EOI ]
nxtoplevel -> LET . CTRLSEQ argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 322
-- On VAR shift to state 323
-- On CTRLSEQ shift to state 333
## Reductions:

State 322:
## Known stack suffix:
## LET error
## LR(1) items:
nxtoplevel -> LET error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET error

State 323:
## Known stack suffix:
## LET VAR
## LR(1) items:
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR . error [ EOI ]
nxtoplevel -> LET VAR . argvar DEFEQ error [ EOI ]
## Transitions:
-- On error shift to state 324
-- On VAR shift to state 7
-- On argvar shift to state 325
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 324:
## Known stack suffix:
## LET VAR error
## LR(1) items:
nxtoplevel -> LET VAR error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR error

State 325:
## Known stack suffix:
## LET VAR argvar
## LR(1) items:
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar . DEFEQ error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## LET VAR argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ . error [ EOI ]
## Transitions:
-- On error shift to state 327
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 328
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 327:
## Known stack suffix:
## LET VAR argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ error

State 328:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 329
## Reductions:
-- On MUTUAL LETMUTABLE LET IN EOI
--   reduce production nxdec ->

State 329:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 330
-- On nxtoplevel shift to state 332
## Reductions:
-- On EOI
--   reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec

State 330:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 331
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 331:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec IN nxlet

State 332:
## Known stack suffix:
## LET VAR argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET VAR argvar DEFEQ nxlet nxdec nxtoplevel

State 333:
## Known stack suffix:
## LET CTRLSEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ . argvar DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 334
-- On VAR shift to state 7
-- On argvar shift to state 335
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 334:
## Known stack suffix:
## LET CTRLSEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ error

State 335:
## Known stack suffix:
## LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar . DEFEQ nxlet nxdec IN error [ EOI ]
## Transitions:
-- On DEFEQ shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . error [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ . nxlet nxdec IN error [ EOI ]
## Transitions:
-- On error shift to state 337
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 338
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 337:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ error

State 338:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet . nxdec IN error [ EOI ]
## Transitions:
-- On LETAND shift to state 201
-- On nxdec shift to state 339
## Reductions:
-- On MUTUAL LETMUTABLE LET IN EOI
--   reduce production nxdec ->

State 339:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . nxtoplevel [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec . IN error [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 340
-- On nxtoplevel shift to state 343
## Reductions:
-- On EOI
--   reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec

State 340:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . nxlet [ EOI ]
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN . error [ EOI ]
## Transitions:
-- On error shift to state 341
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 342
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 341:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN error

State 342:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec IN nxlet

State 343:
## Known stack suffix:
## LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel
## LR(1) items:
nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LET CTRLSEQ argvar DEFEQ nxlet nxdec nxtoplevel

State 344:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 345
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 345:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet IN nxlet

State 346:
## Known stack suffix:
## LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel
## LR(1) items:
nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> LETMUTABLE VAR OVERWRITEEQ nxlet nxtoplevel

State 347:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 348
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 348:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual IN nxlet

State 349:
## Known stack suffix:
## MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET VAR argvar DEFEQ nxlet nxmutual nxtoplevel

State 350:
## Known stack suffix:
## MUTUAL LET CTRLSEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ . argvar DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On VAR shift to state 7
-- On argvar shift to state 351
## Reductions:
-- On DEFEQ
--   reduce production argvar ->

State 351:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar . DEFEQ nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On DEFEQ shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ . nxlet nxmutual IN nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 353
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 353:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet . nxmutual IN nxlet [ EOI ]
## Transitions:
-- On LET shift to state 301
-- On ENDMUTUAL shift to state 306
-- On nxmutual shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . nxtoplevel [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . [ EOI ]
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual . IN nxlet [ EOI ]
## Transitions:
-- On MUTUAL shift to state 4
-- On LETMUTABLE shift to state 314
-- On LET shift to state 321
-- On IN shift to state 355
-- On nxtoplevel shift to state 357
## Reductions:
-- On EOI
--   reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual

State 355:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN . nxlet [ EOI ]
## Transitions:
-- On WHILE shift to state 11
-- On VAR shift to state 13
-- On UNITVALUE shift to state 16
-- On TRUE shift to state 17
-- On RENEWGLOBALHASH shift to state 32
-- On REFNOW shift to state 18
-- On REFFINAL shift to state 34
-- On OPENSTR shift to state 20
-- On OPENQT shift to state 36
-- On NUMCONST shift to state 44
-- On MINUS shift to state 57
-- On LPAREN shift to state 45
-- On LNOT shift to state 61
-- On LETMUTABLE shift to state 64
-- On LET shift to state 70
-- On LAMBDA shift to state 77
-- On IFIDISVALID shift to state 153
-- On IFCLASSISVALID shift to state 157
-- On IF shift to state 161
-- On FINISH shift to state 53
-- On FALSE shift to state 54
-- On DECGLOBALHASH shift to state 163
-- On BLIST shift to state 55
-- On nxwhl shift to state 165
-- On nxun shift to state 82
-- On nxltimes shift to state 96
-- On nxlplus shift to state 103
-- On nxlor shift to state 166
-- On nxlminus shift to state 108
-- On nxlet shift to state 356
-- On nxland shift to state 126
-- On nxlambda shift to state 171
-- On nxif shift to state 175
-- On nxconcat shift to state 130
-- On nxcomp shift to state 149
-- On nxbot shift to state 58
-- On nxbfr shift to state 176
-- On nxapp shift to state 121
## Reductions:

State 356:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual IN nxlet

State 357:
## Known stack suffix:
## MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel
## LR(1) items:
nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel . [ EOI ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nxtoplevel -> MUTUAL LET CTRLSEQ argvar DEFEQ nxlet nxmutual nxtoplevel

State 358:
## Known stack suffix:
## sxblock
## LR(1) items:
main -> sxblock . EOI [ # ]
## Transitions:
-- On EOI shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## sxblock EOI
## LR(1) items:
main -> sxblock EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production main -> sxblock EOI

State 360:
## Known stack suffix:
## nxtoplevel
## LR(1) items:
main -> nxtoplevel . EOI [ # ]
## Transitions:
-- On EOI shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## nxtoplevel EOI
## LR(1) items:
main -> nxtoplevel EOI . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production main -> nxtoplevel EOI

State 362:
## Known stack suffix:
## main
## LR(1) items:
main' -> main . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept main

