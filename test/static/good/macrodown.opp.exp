File "macrodown.mly", line 205, characters 7-14:
Warning: the token IGNORED is unused.
%{
  open Types

  type literal_reading_state = Normal | ReadingSpace


  (* untyped_abstract_tree -> code_range *)
  let get_range utast =
    let (rng, _) = utast in rng

  let rec append_argument_list arglsta arglstb =
    match arglsta with
    | UTEndOfArgument              -> arglstb
    | UTArgumentCons(arg, arglstl) ->
        UTArgumentCons(arg, (append_argument_list arglstl arglstb))

  (* ctrlseq_name -> untyped_abstract_tree -> untyped_abstract_tree -> untyped_argument_cons -> untyped_abstract_tree *)
  let rec convert_into_apply csutast clsnmutast idnmutast argcons =
    convert_into_apply_sub argcons ((-12, 0, 0, 0), UTApplyClassAndID(clsnmutast, idnmutast, csutast))

  (* argument_cons -> untyped_abstract_tree -> untyped_abstract_tree *)
  and convert_into_apply_sub argcons utastconstr =
    match argcons with
    | UTEndOfArgument             -> utastconstr
    | UTArgumentCons(arg, actail) ->
        convert_into_apply_sub actail (get_range arg, UTApply(utastconstr, arg))

  let class_name_to_abstract_tree clsnm =
    UTStringConstant((String.sub clsnm 1 ((String.length clsnm) - 1)))

  let id_name_to_abstract_tree idnm =
    UTStringConstant((String.sub idnm 1 ((String.length idnm) - 1)))

  let rec curry_lambda_abstract rng argvarcons utastdef =
    match argvarcons with
    | UTEndOfArgumentVariable -> utastdef
    | UTArgumentVariableCons(varrng, argvar, avtail) ->
        (rng, UTLambdaAbstract(varrng, argvar, curry_lambda_abstract (-11, 0, 0, 0) avtail utastdef))

  let error_reporting msg disp pos =
    let (pos_ln, pos_start, pos_end) = pos in
      "Syntax error: " ^ msg ^ ".\n\n    " ^ disp
        ^ "\n\n  (at line " ^ (string_of_int pos_ln) ^ ", "
        ^ (string_of_int pos_start) ^ "-" ^ (string_of_int pos_end) ^ ")"

  let rec string_of_avc argvarcons =
    match argvarcons with
    | UTEndOfArgumentVariable                   -> ""
    | UTArgumentVariableCons(_, argvar, avtail) -> argvar ^ " " ^ (string_of_avc avtail)

  let rec stringify_literal ltrl =
    let (_, ltrlmain) = ltrl in
      match ltrlmain with
      | UTConcat(utastf, utastl) -> (stringify_literal utastf) ^ (stringify_literal utastl)
      | UTStringConstant(s)      -> s
      | UTStringEmpty            -> ""
      | _  -> raise (ParseErrorDetail("illegal token in literal area; this cannot happen"))

  let rec omit_pre_spaces str =
    if String.sub str 0 1 = " "  then
      omit_pre_spaces (String.sub str 1 ((String.length str) - 1))
(*    else if String.sub str 0 1 = "\n" then
      (String.sub str 1 ((String.length str) - 1)) *)
    else
      str

  let rec omit_post_spaces str =
    if String.sub str ((String.length str) - 1) 1 = " " then
      omit_post_spaces (String.sub str 0 ((String.length str) - 1))
    else if String.sub str ((String.length str) - 1) 1 = "\n" then
      (String.sub str 0 ((String.length str) - 1))
    else
      str

  (* untyped_abstract_tree -> untyped_abstract_tree_main *)
  let rec omit_spaces ltrl =
    let str_ltrl = omit_post_spaces (omit_pre_spaces (stringify_literal ltrl)) in
      let min_indent = min_indent_space str_ltrl in
        let str_shaved = shave_indent str_ltrl min_indent in
          if str_shaved.[(String.length str_shaved) - 1] = '\n' then
            let str_no_last_break = String.sub str_shaved 0 ((String.length str_shaved) - 1) in
              UTConcat(
                ((-13, 0, 0, 0), UTStringConstant(str_no_last_break)),
                ((-14, 0, 0, 0), UTBreakAndIndent)
              )
          else
            UTStringConstant(str_shaved)

  (* string -> int *)
  and min_indent_space str_ltrl =
    min_indent_space_sub str_ltrl 0 ReadingSpace 0 (String.length str_ltrl)

  (* string -> int -> literal_reading_state -> int -> int -> int *)
  and min_indent_space_sub str_ltrl index lrstate spnum minspnum =
    if index >= (String.length str_ltrl) then
      (* ( print_string ("min_indent: " ^ (string_of_int minspnum) ^ "\n") ; *)
        minspnum
      (* ) *)
    else
      match lrstate with
      | Normal ->
          ( match str_ltrl.[index] with
            | '\n' -> min_indent_space_sub str_ltrl (index + 1) ReadingSpace 0 minspnum
            | _    -> min_indent_space_sub str_ltrl (index + 1) Normal 0 minspnum
          )
      | ReadingSpace ->
          ( match str_ltrl.[index] with
            | ' '  -> min_indent_space_sub str_ltrl (index + 1) ReadingSpace (spnum + 1) minspnum
            | '\n' -> min_indent_space_sub str_ltrl (index + 1) ReadingSpace 0 minspnum
                (* does not take space-only line into account *)
            | _    -> min_indent_space_sub str_ltrl (index + 1) Normal 0 (if spnum < minspnum then spnum else minspnum)
          )

  and shave_indent str_ltrl minspnum =
    shave_indent_sub str_ltrl minspnum 0 "" Normal 0

  and shave_indent_sub str_ltrl minspnum index str_constr lrstate spnum =
    if index >= (String.length str_ltrl) then
      str_constr
    else
      match lrstate with
      | Normal ->
          ( match str_ltrl.[index] with
            | '\n' -> shave_indent_sub str_ltrl minspnum (index + 1) (str_constr ^ "\n") ReadingSpace 0
            | ch   -> shave_indent_sub str_ltrl minspnum (index + 1) (str_constr ^ (String.make 1 ch)) Normal 0
          )
      | ReadingSpace ->
          ( match str_ltrl.[index] with
            | ' ' ->
                if spnum < minspnum then
                  shave_indent_sub str_ltrl minspnum (index + 1) str_constr ReadingSpace (spnum + 1)
                else
                  shave_indent_sub str_ltrl minspnum (index + 1) (str_constr ^ " ") ReadingSpace (spnum + 1)

            | '\n' -> shave_indent_sub str_ltrl minspnum (index + 1) (str_constr ^ "\n") ReadingSpace 0
            | ch   -> shave_indent_sub str_ltrl minspnum (index + 1) (str_constr ^ (String.make 1 ch)) Normal 0
          )

  let binary_operator opname lft op rgt =
    let (sttln, sttpos, _, _) = get_range lft in
    let (_, _, endln, endpos) = get_range rgt in
    let (opln, opstt, opend) = op in
    let oprng = (opln, opstt, opln, opend) in
    let rng = (sttln, sttpos, endln, endpos) in
      (rng, UTApply(((-15, 0, 0, 0), UTApply((oprng, UTContentOf(opname)), lft)), rgt))

  let make_let_expression lettk vartk utargcons utastdef decs utastaft =
    let (sttln, sttpos, _) = lettk in
    let ((varln, varstt, varend), varnm) = vartk in
    let (_, _, endln, endpos) = get_range utastaft in
    let rng = (sttln, sttpos, endln, endpos) in
    let varrng = (varln, varstt, varln, varend) in
    let curried = curry_lambda_abstract varrng utargcons utastdef in
      (rng, UTLetIn(UTMutualLetCons(varnm, curried, decs), utastaft))

  let make_let_mutable_expression letmuttk vartk utastdef utastaft =
    let (sttln, sttpos, _) = letmuttk in
    let ((varln, varstt, varend), vn) = vartk in
    let (_, _, endln, endpos) = get_range utastaft in
    let varrng = (varln, varstt, varln, varend) in
    let rng = (sttln, sttpos, endln, endpos) in
      (rng, UTLetMutableIn(varrng, vn, utastdef, utastaft))

%}
%start main
%token <Types.token_position> ARROW
%token <Types.token_position> BEFORE
%token <Types.token_position> BGRP
%token <Types.token_position> BLIST
%token <Types.token_position> BREAK
%token <Types.token_position * string> CHAR
%token <Types.token_position * Types.class_name> CLASSNAME
%token <Types.token_position> CLOSENUM
%token <Types.token_position> CLOSEQT
%token <Types.token_position> CLOSESTR
%token <Types.token_position> CONCAT
%token <Types.token_position> CONS
%token <Types.token_position * Types.ctrlseq_name> CTRLSEQ
%token <Types.token_position> DECGLOBALHASH
%token <Types.token_position> DEFEQ
%token <Types.token_position> DIVIDES
%token <Types.token_position> DO
%token <Types.token_position> EGRP
%token <Types.token_position> ELIST
%token <Types.token_position> ELSE
%token <Types.token_position> END
%token <Types.token_position> ENDMUTUAL
%token EOI
%token <Types.token_position> EQ
%token <Types.token_position> FALSE
%token <Types.token_position> FINISH
%token <Types.token_position> GEQ
%token <Types.token_position> GT
%token <Types.token_position * Types.id_name> IDNAME
%token <Types.token_position> IF
%token <Types.token_position> IFCLASSISVALID
%token <Types.token_position> IFIDISVALID
%token IGNORED
%token <Types.token_position> IN
%token <Types.token_position> LAMBDA
%token <Types.token_position> LAND
%token <Types.token_position> LEQ
%token <Types.token_position> LET
%token <Types.token_position> LETAND
%token <Types.token_position> LETMUTABLE
%token <Types.token_position> LISTPUNCT
%token <Types.token_position> LNOT
%token <Types.token_position> LOR
%token <Types.token_position> LPAREN
%token <Types.token_position> LT
%token <Types.token_position> MINUS
%token <Types.token_position> MOD
%token <Types.token_position> MUTUAL
%token <Types.token_position> NEQ
%token <Types.token_position * string> NUMCONST
%token <Types.token_position> OPENNUM
%token <Types.token_position> OPENQT
%token <Types.token_position> OPENSTR
%token <Types.token_position> OVERWRITEEQ
%token <Types.token_position> OVERWRITEGLOBALHASH
%token <Types.token_position> PLUS
%token <Types.token_position> REFFINAL
%token <Types.token_position> REFNOW
%token <Types.token_position> RENEWGLOBALHASH
%token <Types.token_position> RPAREN
%token <Types.token_position> SEP
%token <Types.token_position> SPACE
%token <Types.token_position> THEN
%token <Types.token_position> TIMES
%token <Types.token_position> TRUE
%token <Types.token_position> UNITVALUE
%token <Types.token_position * Types.var_name> VAR
%token <Types.token_position * Types.var_name> VARINSTR
%token <Types.token_position> WHILE
%nonassoc DEFEQ IN LET LETAND LETMUTABLE OVERWRITEEQ
%nonassoc ELSE IF THEN
%left OVERWRITEGLOBALHASH
%left BEFORE
%nonassoc WHILE
%left LOR
%left LAND
%nonassoc LNOT
%left EQ NEQ
%left GEQ GT LEQ LT
%left PLUS
%right MINUS
%left TIMES
%right DIVIDES MOD
%nonassoc VAR
%nonassoc LPAREN RPAREN
%type <Types.untyped_argument_variable_cons> argvar
%type <string> binop
%type <Types.untyped_abstract_tree> main
%type <Types.untyped_argument_cons> narg
%type <Types.untyped_abstract_tree> nxapp
%type <Types.untyped_abstract_tree> nxbfr
%type <Types.untyped_abstract_tree> nxbot
%type <Types.untyped_abstract_tree> nxcomp
%type <Types.untyped_abstract_tree> nxconcat
%type <Types.untyped_mutual_let_cons> nxdec
%type <Types.untyped_abstract_tree> nxif
%type <Types.untyped_abstract_tree> nxland
%type <Types.untyped_abstract_tree> nxlet
%type <Types.untyped_abstract_tree> nxlist
%type <Types.untyped_abstract_tree> nxlor
%type <Types.untyped_abstract_tree> nxlplus
%type <Types.untyped_abstract_tree> nxltimes
%type <Types.untyped_abstract_tree> nxrplus
%type <Types.untyped_abstract_tree> nxrtimes
%type <Types.untyped_abstract_tree> nxun
%type <Types.untyped_abstract_tree> nxwhl
%type <Types.untyped_argument_cons> sarg
%type <Types.untyped_argument_cons> sargsub
%type <Types.untyped_abstract_tree> sxblock
%type <Types.untyped_abstract_tree> sxbot
%type <Types.untyped_abstract_tree> sxclsnm
%type <Types.untyped_abstract_tree> sxidnm
%type <Types.untyped_abstract_tree> sxsep
%type <Types.untyped_abstract_tree> sxsepsub
%%

main:
  _1 = nxtoplevel _2 = EOI
    {                   ( _1 )}
| _1 = sxblock _2 = EOI
    {                ( _1 )}

nxtoplevel:
  _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = nxtoplevel
    {                                                    ( make_let_expression _1 _2 _3 _5 _6 _7 )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = nxtoplevel
    {                                                    ( make_let_expression _1 _2 _3 _5 _6 _7 )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = nxlet _5 = nxtoplevel
    {                                                    ( make_let_mutable_expression _1 _2 _4 _5 )}
| _1 = MUTUAL _2 = LET _3 = VAR _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual _8 = nxtoplevel
    {                                                              ( make_let_expression _2 _3 _4 _6 _7 _8 )}
| _1 = MUTUAL _2 = LET _3 = CTRLSEQ _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual _8 = nxtoplevel
    {                                                              ( make_let_expression _2 _3 _4 _6 _7 _8 )}
| _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec
    {                                     (
        make_let_expression _1 _2 _3 _5 _6 ((-256, 0, 0, 0), UTFinishHeaderFile)
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec
    {                                         (
        make_let_expression _1 _2 _3 _5 _6 ((-257, 0, 0, 0), UTFinishHeaderFile)
      )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = nxlet
    {                                     (
        make_let_mutable_expression _1 _2 _4 ((-258, 0, 0, 0), UTFinishHeaderFile)
      )}
| _1 = MUTUAL _2 = LET _3 = VAR _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual
    {                                                   (
        make_let_expression _2 _3 _4 _6 _7 ((-259, 0, 0, 0), UTFinishHeaderFile)
      )}
| _1 = MUTUAL _2 = LET _3 = CTRLSEQ _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual
    {                                                   (
        make_let_expression _2 _3 _4 _6 _7 ((-259, 0, 0, 0), UTFinishHeaderFile)
      )}
| _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = nxlet
    {                                                  ( make_let_expression _1 _2 _3 _5 _6 _8 )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = nxlet
    {                                                  ( make_let_expression _1 _2 _3 _5 _6 _8 )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = nxlet _5 = IN _6 = nxlet
    {                                                  ( make_let_mutable_expression _1 _2 _4 _6 )}
| _1 = MUTUAL _2 = LET _3 = VAR _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual _8 = IN _9 = nxlet
    {                                                            ( make_let_expression _2 _3 _4 _6 _7 _9 )}
| _1 = MUTUAL _2 = LET _3 = CTRLSEQ _4 = argvar _5 = DEFEQ _6 = nxlet _7 = nxmutual _8 = IN _9 = nxlet
    {                                                            ( make_let_expression _2 _3 _4 _6 _7 _9 )}
| _1 = LET _2 = error
    {              (
        raise (ParseErrorDetail(error_reporting "illegal token after 'let'" "let ..<!>.." _1))
      )}
| _1 = LET _2 = VAR _3 = error
    {                  (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'let'"
            ("let" ^ vn ^ " ..<!>..") _1))
      )}
| _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = error
    {                               (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '='"
            ("let " ^ vn ^ " " ^ (string_of_avc _3) ^ "= ..<!>..") _1))
      )}
| _1 = LET _2 = CTRLSEQ _3 = error
    {                      (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "missing '=' or illegal argument"
            ("let " ^ csname ^ " ..<!>..") ln))
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = error
    {                                   (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '='"
            ("let " ^ csname ^ " " ^ (string_of_avc _3) ^ " = ..<!>..") ln))
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = error
    {                                                  (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'in'"
            ("let " ^ csname ^ " " ^ (string_of_avc _3) ^ "= ... in ..<!>..") ln))
      )}
| _1 = LETMUTABLE _2 = error
    {                     (
        raise (ParseErrorDetail(error_reporting "missing identifier after 'let-mutable'"
          "let-mutable ..<!>.." _1))
      )}
| _1 = LETMUTABLE _2 = VAR _3 = error
    {                         (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting ("missing '<-' after '" ^ vn ^ "'")
            ("let-mutable " ^ vn ^ " ..<!>..") _1))
      )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = error
    {                                     (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '<-'"
            ("let-mutable " ^ vn ^ " <- ..<!>..") _1))
      )}

nxmutual:
  _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxmutual
    {                                        (
        let ((varln, varstt, varend), vn) = _2 in
        let varrng = (varln, varstt, varln, varend) in
        let curried = curry_lambda_abstract varrng _3 _5 in
          UTMutualLetCons(vn, curried, _6)
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxmutual
    {                                            (
        let ((csln, csstt, csend), cn) = _2 in
        let csrng = (csln, csstt, csln, csend) in
        let curried = curry_lambda_abstract csrng _3 _5 in
          UTMutualLetCons(cn, curried, _6)
      )}
| _1 = ENDMUTUAL
    {              ( UTEndOfMutualLet )}

nxlet:
  _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = nxlet
    {                                                  ( make_let_expression _1 _2 _3 _5 _6 _8 )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = nxlet
    {                                                  ( make_let_expression _1 _2 _3 _5 _6 _8 )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = nxlet _5 = IN _6 = nxlet
    {                                                  ( make_let_mutable_expression _1 _2 _4 _6 )}
| _1 = nxwhl
    {          ( _1 )}
| _1 = LET _2 = error
    {              (
        raise (ParseErrorDetail(error_reporting
          "missing identifier after 'let'" "let ..<!>.." _1))
      )}
| _1 = LET _2 = VAR _3 = error
    {                  (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "missing '=' or illegal argument"
            ("let " ^ vn ^ " ..<!>..") _1))
      )}
| _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = error
    {                               (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '='"
            ("let " ^ vn ^ " " ^ (string_of_avc _3) ^ "= ..<!>..") _1))
      )}
| _1 = LET _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = error
    {                                              (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'in'"
            ("let " ^ vn ^ " " ^ (string_of_avc _3) ^ "= ... in ..<!>..") _1))
      )}
| _1 = LET _2 = CTRLSEQ _3 = error
    {                      (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "missing '=' or illegal argument"
            ("let " ^ csname ^ " ..<!>..") ln))
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = error
    {                                   (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '='"
            ("let " ^ csname ^ " " ^ (string_of_avc _3) ^ " = ..<!>..") ln))
      )}
| _1 = LET _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec _7 = IN _8 = error
    {                                                  (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'in'"
            ("let " ^ csname ^ " " ^ (string_of_avc _3) ^ "= ... in ..<!>..") ln))
      )}
| _1 = LETMUTABLE _2 = error
    {                     (
        raise (ParseErrorDetail(error_reporting "missing identifier after 'let-mutable'"
          "let-mutable ..<!>.." _1))
      )}
| _1 = LETMUTABLE _2 = VAR _3 = error
    {                         (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting ("missing '<-' after '" ^ vn ^ "'")
            ("let-mutable " ^ vn ^ " ..<!>..") _1))
      )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = error
    {                                     (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after '<-'"
            ("let-mutable " ^ vn ^ " <- ..<!>..") _1))
      )}
| _1 = LETMUTABLE _2 = VAR _3 = OVERWRITEEQ _4 = nxlet _5 = IN _6 = error
    {                                              (
        raise (ParseErrorDetail(error_reporting "illegal token after 'in'"
          "in ..<!>.." _5))
      )}

nxdec:
  _1 = LETAND _2 = VAR _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec
    {                                        (
        let ((varln, varstt, varend), vn) = _2 in
        let varrng = (varln, varstt, varln, varend) in
        let curried = curry_lambda_abstract varrng _3 _5 in
          UTMutualLetCons(vn, curried, _6)
      )}
| _1 = LETAND _2 = CTRLSEQ _3 = argvar _4 = DEFEQ _5 = nxlet _6 = nxdec
    {                                            (
        let ((csln, csstt, csend), csname) = _2 in
        let csrng = (csln, csstt, csln, csend) in
        let curried = curry_lambda_abstract csrng _3 _5 in
          UTMutualLetCons(csname, curried, _6)
      )}
| 
    {    ( UTEndOfMutualLet )}
| _1 = LETAND _2 = VAR _3 = error
    {                     (
        let (_, vn) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'and'"
            ("and " ^ vn ^ " ..<!>..") _1))
      )}
| _1 = LETAND _2 = CTRLSEQ _3 = error
    {                         (
        let (ln, csname) = _2 in
          raise (ParseErrorDetail(error_reporting "illegal token after 'and'"
            ("and " ^ csname ^ " ..<!>..") ln))
      )}

nxwhl:
  _1 = WHILE _2 = nxlet _3 = DO _4 = nxwhl
    {                         (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTWhileDo(_2, _4))
      )}
| _1 = nxif
    {         ( _1 )}
| _1 = WHILE _2 = error
    {                (
        raise (ParseErrorDetail(error_reporting "illegal token after 'while'" "while ..<!>.." _1))
      )}
| _1 = WHILE _2 = nxlet _3 = DO _4 = error
    {                         (
        raise (ParseErrorDetail(error_reporting "illegal token after 'do'" "do ..<!>.." _3))
      )}

nxif:
  _1 = IF _2 = nxlet _3 = THEN _4 = nxlet _5 = ELSE _6 = nxlet
    {                                   (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _6 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTIfThenElse(_2, _4, _6))
      )}
| _1 = IFCLASSISVALID _2 = nxlet _3 = ELSE _4 = nxlet
    {                                    (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTIfClassIsValid(_2, _4))
      )}
| _1 = IFCLASSISVALID _2 = THEN _3 = nxlet _4 = ELSE _5 = nxlet
    {                                         (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _5 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTIfClassIsValid(_3, _5))
      )}
| _1 = IFIDISVALID _2 = nxlet _3 = ELSE _4 = nxlet
    {                                 (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTIfIDIsValid(_2, _4))
      )}
| _1 = IFIDISVALID _2 = THEN _3 = nxlet _4 = ELSE _5 = nxlet
    {                                      (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _5 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTIfIDIsValid(_3, _5))
      )}
| _1 = nxbfr
    {          ( _1 )}
| _1 = IF _2 = error
    {             (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'if'" "if ..<!>.." _1))
      )}
| _1 = IF _2 = nxlet _3 = THEN _4 = error
    {                        (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'then'" "then ..<!>.." _3))
      )}
| _1 = IF _2 = nxlet _3 = THEN _4 = nxlet _5 = ELSE _6 = error
    {                                   (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'else'" "else ..<!>.." _5))
      )}
| _1 = IFCLASSISVALID _2 = error
    {                         (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'if-class-is-valid'" "if-class-is-valid ..<!>.." _1))
      )}
| _1 = IFCLASSISVALID _2 = nxlet _3 = ELSE _4 = error
    {                                    (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'else'" "else ..<!>.." _3))
      )}
| _1 = IFCLASSISVALID _2 = THEN _3 = error
    {                              (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'then'" "then ..<!>.." _2))
      )}
| _1 = IFCLASSISVALID _2 = THEN _3 = nxlet _4 = ELSE _5 = error
    {                                         (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'else'" "else ..<!>.." _4))
      )}
| _1 = IFIDISVALID _2 = error
    {                      (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'if-id-is-valid'" "if-id-is-valid ..<!>.." _1))
      )}
| _1 = IFIDISVALID _2 = nxlet _3 = ELSE _4 = error
    {                                 (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'else'" "else ..<!>.." _3))
      )}
| _1 = IFIDISVALID _2 = THEN _3 = error
    {                           (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'then'" "then ..<!>.." _2))
      )}
| _1 = IFIDISVALID _2 = THEN _3 = nxlet _4 = ELSE _5 = error
    {                                      (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'else'" "else ..<!>.." _4))
      )}

nxbfr:
  _1 = nxlambda _2 = BEFORE _3 = nxbfr
    {                          (
        let (sttln, sttpos, _, _) = get_range _1 in
        let (_, _, endln, endpos) = get_range _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTSequential(_1, _3))
      )}
| _1 = nxlambda
    {             ( _1 )}
| _1 = nxlambda _2 = BEFORE _3 = error
    {                          (
        raise (ParseErrorDetail(error_reporting "illegal token after 'before'" "before ..<!>.." _2))
      )}

nxlambda:
  _1 = VAR _2 = OVERWRITEEQ _3 = nxlor
    {                          (
        let ((sttln, sttpos, varend), vn) = _1 in
        let (_, _, endln, endpos) = get_range _3 in
        let varrng = (sttln, sttpos, sttln, varend) in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTOverwrite(varrng, vn, _3))
      )}
| _1 = DECGLOBALHASH _2 = nxlet _3 = OVERWRITEGLOBALHASH _4 = nxlor
    {                                                  (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTDeclareGlobalHash(_2, _4))
      )}
| _1 = RENEWGLOBALHASH _2 = nxlet _3 = OVERWRITEGLOBALHASH _4 = nxlor
    {                                                    (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTOverwriteGlobalHash(_2, _4))
      )}
| _1 = LAMBDA _2 = argvar _3 = ARROW _4 = nxlor
    {                              (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          curry_lambda_abstract rng _2 _4
      )}
| _1 = nxlor
    {          ( _1 )}
| _1 = LAMBDA _2 = error
    {                 (
        raise (ParseErrorDetail(
          error_reporting "illegal token after 'function'" "function ..<!>.." _1))
      )}
| _1 = LAMBDA _2 = argvar _3 = ARROW _4 = error
    {                              (
        raise (ParseErrorDetail(
          error_reporting "illegal token after '->'" "-> ..<!>.." _3))
      )}
| _1 = DECGLOBALHASH _2 = error
    {                        (
        raise (ParseErrorDetail(error_reporting
          "illegal token after 'declare-global-hash'" "declare-global-hash ..<!>.." _1))
      )}
| _1 = DECGLOBALHASH _2 = nxlet _3 = OVERWRITEGLOBALHASH _4 = error
    {                                                  (
        raise (ParseErrorDetail(error_reporting
          "illegal token after '<<-'" "<<- ..<!>.." _3))
      )}
| _1 = RENEWGLOBALHASH _2 = error
    {                          (
        raise (ParseErrorDetail(error_reporting
          "illegal token after 'renew'" "renew ..<!>.." _1))
      )}
| _1 = RENEWGLOBALHASH _2 = nxlet _3 = OVERWRITEGLOBALHASH _4 = error
    {                                                    (
        raise (ParseErrorDetail(error_reporting
          "illegal token after '<<-'" "<<- ..<!>.." _3))
      )}

argvar:
  _1 = VAR _2 = argvar
    {               (
        let ((varln, varstt, varend), vn) = _1 in
        let varrng = (varln, varstt, varln, varend) in
          UTArgumentVariableCons(varrng, vn, _2)
      )}
| 
    {    ( UTEndOfArgumentVariable )}

nxlor:
  _1 = nxland _2 = LOR _3 = nxlor
    {                     ( binary_operator "||" _1 _2 _3 )}
| _1 = nxland
    {           ( _1 )}
| _1 = nxland _2 = LOR _3 = error
    {                     (
        raise (ParseErrorDetail(error_reporting "illegal token after '||'" "|| ..<!>.." _2))
      )}

nxland:
  _1 = nxcomp _2 = LAND _3 = nxland
    {                       ( binary_operator "&&" _1 _2 _3 )}
| _1 = nxcomp
    {           ( _1 )}
| _1 = nxcomp _2 = LAND _3 = error
    {                      (
        raise (ParseErrorDetail(error_reporting "illegal token after '&&'" "&& ..<!>.." _2))
      )}

nxcomp:
  _1 = nxconcat _2 = EQ _3 = nxcomp
    {                        ( binary_operator "==" _1 _2 _3 )}
| _1 = nxconcat _2 = NEQ _3 = nxcomp
    {                        ( binary_operator "<>" _1 _2 _3 )}
| _1 = nxconcat _2 = GEQ _3 = nxcomp
    {                        ( binary_operator ">=" _1 _2 _3 )}
| _1 = nxconcat _2 = LEQ _3 = nxcomp
    {                        ( binary_operator "<=" _1 _2 _3 )}
| _1 = nxconcat _2 = GT _3 = nxcomp
    {                        ( binary_operator ">" _1 _2 _3 )}
| _1 = nxconcat _2 = LT _3 = nxcomp
    {                        ( binary_operator "<" _1 _2 _3 )}
| _1 = nxconcat
    {             ( _1 )}
| _1 = nxconcat _2 = EQ _3 = error
    {                      (
        raise (ParseErrorDetail(error_reporting "illegal token after '=='" "== ..<!>.." _2))
      )}
| _1 = nxconcat _2 = NEQ _3 = error
    {                       (
        raise (ParseErrorDetail(error_reporting "illegal token after '<>'" "<> ..<!>.." _2))
      )}
| _1 = nxconcat _2 = GEQ _3 = error
    {                       (
        raise (ParseErrorDetail(error_reporting "illegal token after '>='" ">= ..<!>.." _2))
      )}
| _1 = nxconcat _2 = LEQ _3 = error
    {                       (
        raise (ParseErrorDetail(error_reporting "illegal token after '<='" "<= ..<!>.." _2))
      )}
| _1 = nxconcat _2 = GT _3 = error
    {                      (
        raise (ParseErrorDetail(error_reporting "illegal token after '>'" "> ..<!>.." _2))
      )}
| _1 = nxconcat _2 = LT _3 = error
    {                      (
        raise (ParseErrorDetail(error_reporting "illegal token after '<'" "< ..<!>.." _2))
      )}

nxconcat:
  _1 = nxlplus _2 = CONCAT _3 = nxconcat
    {                            ( binary_operator "^" _1 _2 _3 )}
| _1 = nxlplus _2 = CONS _3 = nxconcat
    {                            ( binary_operator "::" _1 _2 _3 )}
| _1 = nxlplus
    {            ( _1 )}
| _1 = nxlplus _2 = CONCAT _3 = error
    {                         (
        raise (ParseErrorDetail(error_reporting "illegal token after '^'" "^ ..<!>.." _2))
      )}

nxlplus:
  _1 = nxlminus _2 = PLUS _3 = nxrplus
    {                          ( binary_operator "+" _1 _2 _3 )}
| _1 = nxlminus
    {             ( _1 )}
| _1 = nxlminus _2 = PLUS _3 = error
    {                        (
        raise (ParseErrorDetail(error_reporting "illegal token after '+'" "+ ..<!>.." _2))
      )}

nxlminus:
  _1 = nxlplus _2 = MINUS _3 = nxrtimes
    {                           ( binary_operator "-" _1 _2 _3 )}
| _1 = nxltimes
    {             ( _1 )}
| _1 = nxlplus _2 = MINUS _3 = error
    {                        (
        raise (ParseErrorDetail(error_reporting "illegal token after '-'" "- ..<!>.." _2))
      )}

nxrplus:
  _1 = nxrminus _2 = PLUS _3 = nxrplus
    {                          ( binary_operator "+" _1 _2 _3 )}
| _1 = nxrminus
    {             ( _1 )}
| _1 = nxrminus _2 = PLUS _3 = error
    {                        (
        raise (ParseErrorDetail(error_reporting "illegal token after '+'" "+ ..<!>.." _2))
      )}

nxrminus:
  _1 = nxrplus _2 = MINUS _3 = nxrtimes
    {                           ( binary_operator "+" _1 _2 _3 )}
| _1 = nxrtimes
    {             ( _1 )}
| _1 = nxrplus _2 = MINUS _3 = error
    {                        (
        raise (ParseErrorDetail(error_reporting "illegal token after '-'" "- ..<!>.." _2))
      )}

nxltimes:
  _1 = nxun _2 = TIMES _3 = nxrtimes
    {                           ( binary_operator "*" _1 _2 _3 )}
| _1 = nxltimes _2 = DIVIDES _3 = nxapp
    {                           ( binary_operator "/" _1 _2 _3 )}
| _1 = nxltimes _2 = MOD _3 = nxapp
    {                           ( binary_operator "mod" _1 _2 _3 )}
| _1 = nxun
    {         ( _1 )}
| _1 = nxun _2 = TIMES _3 = error
    {                     (
        raise (ParseErrorDetail(error_reporting "illegal token after '*'" "* ..<!>.." _2))
      )}
| _1 = nxltimes _2 = DIVIDES _3 = error
    {                           (
        raise (ParseErrorDetail(error_reporting "illegal token after '/'" "/ ..<!>.." _2))
      )}
| _1 = nxltimes _2 = MOD _3 = error
    {                       (
        raise (ParseErrorDetail(error_reporting "illegal token after 'mod'" "mod ..<!>.." _2))
      )}

nxrtimes:
  _1 = nxapp _2 = TIMES _3 = nxrtimes
    {                           ( binary_operator "*" _1 _2 _3 )}
| _1 = nxrtimes _2 = DIVIDES _3 = nxapp
    {                           ( binary_operator "/" _1 _2 _3 )}
| _1 = nxrtimes _2 = MOD _3 = nxapp
    {                           ( binary_operator "mod" _1 _2 _3 )}
| _1 = nxapp
    {          ( _1 )}
| _1 = nxapp _2 = TIMES _3 = error
    {                      (
        raise (ParseErrorDetail(error_reporting "illegal token after '*'" "* ..<!>.." _2))
      )}
| _1 = nxrtimes _2 = DIVIDES _3 = error
    {                           (
        raise (ParseErrorDetail(error_reporting "illegal token after '/'" "/ ..<!>.." _2))
      )}
| _1 = nxrtimes _2 = MOD _3 = error
    {                       (
        raise (ParseErrorDetail(error_reporting "illegal token after 'mod'" "mod ..<!>.." _2))
      )}

nxun:
  _1 = MINUS _2 = nxapp
    {                ( binary_operator "-" ((-16, 0, 0, 0), UTNumericConstant(0)) _1 _2 )}
| _1 = LNOT _2 = nxapp
    {                (
        let (sttln, sttpos, lnotend) = _1 in
        let lnotrng = (sttln, sttpos, sttln, lnotend) in
        let (_, _, endln, endpos) = get_range _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTApply((lnotrng, UTContentOf("not")), _2))
      )}
| _1 = REFNOW _2 = nxapp
    {                 (
        let (sttln, sttpos, refnowend) = _1 in
        let refnowrng = (sttln, sttpos, sttln, refnowend) in
        let (_, _, endln, endpos) = get_range _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTApply((refnowrng, UTContentOf("!")), _2))
      )}
| _1 = REFFINAL _2 = nxapp
    {                   (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTReferenceFinal(_2))
      )}
| _1 = nxapp
    {          ( _1 )}
| _1 = MINUS _2 = error
    {                (
        raise (ParseErrorDetail(error_reporting "illegal token after unary '-'" "- ..<!>.." _1))
      )}
| _1 = LNOT _2 = error
    {               (
        raise (ParseErrorDetail(error_reporting "illegal token after 'not'" "not ..<!>.." _1))
      )}
| _1 = REFNOW _2 = error
    {                 (
        raise (ParseErrorDetail(error_reporting "illegal token after '!'" "! ..<!>.." _1))
      )}
| _1 = REFFINAL _2 = error
    {                   (
        raise (ParseErrorDetail(error_reporting "illegal token after '!!'" "!! ..<!>.." _1))
      )}

nxapp:
  _1 = nxapp _2 = nxbot
    {                (
        let (sttln, sttpos, _, _) = get_range _1 in
        let (_, _, endln, endpos) = get_range _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTApply(_1, _2))
      )}
| _1 = nxbot
    {          ( _1 )}

nxbot:
  _1 = VAR
    {        (
        let ((varln, varstt, varend), vn) = _1 in
        let rng = (varln, varstt, varln, varend) in
          (rng, UTContentOf(vn))
      )}
| _1 = NUMCONST
    {             (
        let ((ncln, ncstt, ncend), cs) = _1 in
        let rng = (ncln, ncstt, ncln, ncend) in
          (rng, UTNumericConstant(int_of_string cs))
      )}
| _1 = TRUE
    {          (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTBooleanConstant(true))
      )}
| _1 = FALSE
    {          (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTBooleanConstant(false))
      )}
| _1 = LPAREN _2 = nxlet _3 = RPAREN
    {                           (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let (_, utast) = _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, utast)
      )}
| _1 = OPENSTR _2 = sxsep _3 = CLOSESTR
    {                           (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let (_, utast) = _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, utast)
      )}
| _1 = OPENQT _2 = sxsep _3 = CLOSEQT
    {                         (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, omit_spaces _2)
      )}
| _1 = BLIST _2 = ELIST
    {                (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTEndOfList)
      )}
| _1 = BLIST _2 = nxlet _3 = nxlist _4 = ELIST
    {                             (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _4 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTListCons(_2, _3))
      )}
| _1 = UNITVALUE
    {              (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTUnitConstant)
      )}
| _1 = FINISH
    {           (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTFinishHeaderFile)
      )}
| _1 = LPAREN _2 = binop _3 = RPAREN
    {                        (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTContentOf(_2))
  )}
| _1 = BLIST _2 = error
    {                (
        raise (ParseErrorDetail(
          error_reporting "illegal token after '['" "[ ..<!>.." _1))
      )}
| _1 = OPENSTR _2 = error
    {                  (
        raise (ParseErrorDetail(
          error_reporting "illegal token after beginning of string area '{'" "{ ..<!>.." _1))
      )}
| _1 = LPAREN _2 = error
    {                 (
        raise (ParseErrorDetail(
          error_reporting "illegal token after '('" "( ..<!>.." _1))
      )}

binop:
  _1 = PLUS
    {            ( "+" )}
| _1 = MINUS
    {            ( "-" )}
| _1 = MOD
    {            ( "mod" )}
| _1 = TIMES
    {            ( "*" )}
| _1 = DIVIDES
    {            ( "/" )}
| _1 = CONCAT
    {            ( "^" )}
| _1 = EQ
    {            ( "==" )}
| _1 = NEQ
    {            ( "<>" )}
| _1 = GEQ
    {            ( ">=" )}
| _1 = LEQ
    {            ( "<=" )}
| _1 = GT
    {            ( ">" )}
| _1 = LT
    {            ( "<" )}
| _1 = LAND
    {            ( "&&" )}
| _1 = LOR
    {            ( "||" )}
| _1 = LNOT
    {            ( "not" )}
| _1 = BEFORE
    {            ( "before" )}

nxlist:
  _1 = LISTPUNCT _2 = nxlet _3 = nxlist
    {                           (
        let (sttln, sttpos, _) = _1 in
        let (_, _, endln, endpos) = get_range _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTListCons(_2, _3))
      )}
| 
    {    ( ((-17, 0, 0, 0), UTEndOfList) )}
| _1 = LISTPUNCT _2 = error
    {                    (
        raise (ParseErrorDetail(
          error_reporting "illegal token after ';'" "; ..<!>.." _1))
      )}

sxsep:
  _1 = SEP _2 = sxsepsub
    {                 ( _2 )}
| _1 = sxblock
    {            ( _1 )}
| _1 = SEP _2 = error
    {              (
        raise (ParseErrorDetail(
          error_reporting "illegal token after '|'" "| ..<!>.." _1))
      )}

sxsepsub:
  _1 = sxblock _2 = SEP _3 = sxsepsub
    {                         (
        let (sttln, sttpos, _, _) = get_range _1 in
        let (_, _, endln, endpos) = get_range _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTListCons(_1, _3))
      )}
| 
    {    ( ((-18, 0, 0, 0), UTEndOfList) )}
| _1 = sxblock _2 = SEP _3 = error
    {                      (
        raise (ParseErrorDetail(
          error_reporting "illegal token after '|'" "| ..<!>.." _2))
      )}

sxblock:
  _1 = sxbot _2 = sxblock
    {                  (
        let (sttln, sttpos, _, _) = get_range _1 in
        let (_, _, endln, endpos) = get_range _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTConcat(_1, _2))
      )}
| 
    {    ( ((-19, 0, 0, 0), UTStringEmpty) )}

sxbot:
  _1 = CHAR
    {          (
        let ((ln, sttpos, endpos), ch) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTStringConstant(ch))
      )}
| _1 = SPACE
    {          (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTStringConstant(" "))
      )}
| _1 = BREAK
    {          (
        let (ln, sttpos, endpos) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, UTBreakAndIndent)
      )}
| _1 = VARINSTR _2 = END
    {                 (
        let ((sttln, sttpos, _), vn) = _1 in
        let (endln, _, endpos) = _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          (rng, UTContentOf(vn))
      )}
| _1 = CTRLSEQ _2 = sxclsnm _3 = sxidnm _4 = narg _5 = sarg
    {                                     (
        let ((csln, csstt, csend), csname) = _1 in
        let csrng = (csln, csstt, csln, csend) in
          convert_into_apply (csrng, UTContentOf(csname)) _2 _3 (append_argument_list _4 _5)
      )}
| _1 = CTRLSEQ _2 = error
    {                  (
        let (ln, csname) = _1 in
        raise (ParseErrorDetail(error_reporting ("illegal token after '" ^ csname ^ "'") (csname ^ " ..<!>..") ln))
      )}

sxclsnm:
  _1 = CLASSNAME
    {              (
        let ((ln, sttpos, endpos), clsnm) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, class_name_to_abstract_tree clsnm)
      )}
| 
    {    ( ((-20, 0, 0, 0), UTNoContent) )}

sxidnm:
  _1 = IDNAME
    {           (
        let ((ln, sttpos, endpos), idnm) = _1 in
        let rng = (ln, sttpos, ln, endpos) in
          (rng, id_name_to_abstract_tree idnm)
      )}
| 
    {    ( ((-21, 0, 0, 0), UTNoContent) )}

narg:
  _1 = OPENNUM _2 = nxlet _3 = CLOSENUM _4 = narg
    {                                (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let (_, utastmain) = _2 in
        let rng = (sttln, sttpos, endln, endpos) in
          UTArgumentCons((rng, utastmain), _4)
      )}
| 
    {    ( UTEndOfArgument )}
| _1 = OPENNUM _2 = error
    {                  (
        raise (ParseErrorDetail(
          error_reporting "illegal token after beginning of program '('" "( ..<!>.." _1))
      )}
| _1 = OPENNUM _2 = nxlet _3 = CLOSENUM _4 = error
    {                                 (
        raise (ParseErrorDetail(
          error_reporting "illegal token after end of program ')'" ") ..<!>.." _3))
      )}

sarg:
  _1 = BGRP _2 = sxsep _3 = EGRP _4 = sargsub
    {                            ( UTArgumentCons(_2, _4) )}
| _1 = OPENQT _2 = sxsep _3 = CLOSEQT _4 = sargsub
    {                                 (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          UTArgumentCons((rng, omit_spaces _2), _4)
      )}
| _1 = END
    {        ( UTEndOfArgument )}
| _1 = BGRP _2 = error
    {               (
        raise (ParseErrorDetail(error_reporting "illegal token after '{'" "{ ..<!>.." _1))
      )}
| _1 = BGRP _2 = sxsep _3 = EGRP _4 = error
    {                          (
        raise (ParseErrorDetail(error_reporting "illegal token after '}'" "} ..<!>.." _3))
      )}

sargsub:
  _1 = BGRP _2 = sxsep _3 = EGRP _4 = sargsub
    {                            (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let rng = (sttln, sttpos, endln, endpos) in
        let (_, utast) = _2 in
          UTArgumentCons((rng, utast), _4)
      )}
| _1 = OPENQT _2 = sxsep _3 = CLOSEQT _4 = sargsub
    {                                 (
        let (sttln, sttpos, _) = _1 in
        let (endln, _, endpos) = _3 in
        let rng = (sttln, sttpos, endln, endpos) in
          UTArgumentCons((rng, omit_spaces _2), _4)
      )}
| 
    {    ( UTEndOfArgument )}
| _1 = BGRP _2 = error
    {               (
        raise (ParseErrorDetail(error_reporting "illegal token after '{'" "{ ..<!>.." _1))
      )}
| _1 = BGRP _2 = sxsep _3 = EGRP _4 = error
    {                          (
        raise (ParseErrorDetail(error_reporting "illegal token after '}'" "} ..<!>.." _3))
      )}

%%
