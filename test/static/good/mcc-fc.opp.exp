File "mcc-fc.mly", line 682, characters 6-12:
Warning: the token TokOp2 is unused.
%{
open Symbol

open Fc_config
open Fc_parse_type
open Fc_parse_util
open Fc_parse_state
open Fc_parse_exn

(*
 * Struct declarations have three cases:
 * structs, unions, or union enums
 *)
type struct_case =
   StructCase
 | UnionCase

(*
 * Type modifiers.
 *)
type spec =
   AutoSpec
 | RegisterSpec
 | StaticSpec
 | ExternSpec
 | ConstSpec
 | VolatileSpec
 | ShortSpec
 | LongSpec
 | SignedSpec
 | UnsignedSpec

(*
 * Builtin types.
 *)
type builtin =
   VoidType
 | CharType
 | IntType
 | FloatType
 | DoubleType
 | PolyType
 | VarType of symbol
 | ApplyType of symbol * ty list

(*
 * Well-known symbols.
 *)
let comma_sym     = Symbol.add ","
let star_sym      = Symbol.add "*"
let addr_of_sym   = Symbol.add "&"
let sizeof_sym    = Symbol.add "sizeof"
let eq_sym        = Symbol.add "="
let bang_sym      = Symbol.add "!"
let or_sym        = Symbol.add "||"
let and_sym       = Symbol.add "&&"
let subscript_sym = Symbol.add "[]"
let apply_sym     = Symbol.add "()"

let zero_expr pos =
   IntExpr (pos, Rawint.of_int Rawint.Int32 true 0)

let one_expr pos =
   IntExpr (pos, Rawint.of_int Rawint.Int32 true 1)

(*
 * Var name in a declaration.
 *)
type var_name =
   VarNameId      of pos * symbol option
 | VarNamePattern of pos * pattern
 | VarNameApply   of pos * symbol * ty list
 | VarNameArray   of pos * (pos * spec) list * var_name * expr
 | VarNamePointer of pos * (pos * spec) list * var_name
 | VarNameRef     of pos * (pos * spec) list * var_name
 | VarNameFun     of pos * var_name * (pattern option * ty) list

let pos_of_var_name = function
   VarNameId      (pos, _) -> pos
 | VarNamePattern (pos, _) -> pos
 | VarNameApply   (pos, _, _) -> pos
 | VarNameArray   (pos, _, _, _) -> pos
 | VarNamePointer (pos, _, _) -> pos
 | VarNameRef     (pos, _, _) -> pos
 | VarNameFun     (pos, _, _) -> pos

(*
 * Extract the status from the specifiers.
 *)
let status_of_spec spec =
   let collect status (_, spec) =
      match spec with
         ConstSpec -> StatusConst
       | VolatileSpec -> StatusVolatile
       | AutoSpec
       | RegisterSpec
       | StaticSpec
       | ExternSpec
       | ShortSpec
       | LongSpec
       | SignedSpec
       | UnsignedSpec -> status
   in
      List.fold_left collect StatusNormal spec

let storage_class_of_spec spec =
   let collect store (_, spec) =
      match spec with
         AutoSpec -> StoreAuto
       | RegisterSpec -> StoreRegister
       | StaticSpec -> StoreStatic
       | ExternSpec -> StoreExtern
       | ConstSpec
       | VolatileSpec
       | ShortSpec
       | LongSpec
       | SignedSpec
       | UnsignedSpec  -> store
   in
      List.fold_left collect StoreAuto spec

(*
 * Function parameter declarations.
 *)
let rec make_param_decl ty = function
   VarNameId (pos, Some id) ->
      Some (VarPattern (pos, id, id, Some ty)), ty
 | VarNameId (_, None) ->
      None, ty
 | VarNamePattern (_, p) ->
      Some p, ty
 | VarNameApply (pos, _, _) ->
      raise (ParseError (pos, "illegal parameter definition"))
 | VarNameArray (pos, spec, v, e) ->
      make_param_decl (TypeArray (pos, status_of_spec spec, ty, zero_expr pos, e)) v
 | VarNamePointer (pos, spec, v) ->
      make_param_decl (TypePointer (pos, status_of_spec spec, ty)) v
 | VarNameRef (pos, spec, v) ->
      make_param_decl (TypeRef (pos, status_of_spec spec, ty)) v
 | VarNameFun (pos, v, args) ->
      make_param_decl (TypeFun (pos, StatusNormal, make_param_decls args, ty)) v

and make_param_decls args =
   List.map snd args

let make_param_decl ty p =
   match p with
      VarNameId (pos, Some id) ->
         Some (VarPattern (pos, id, id, Some ty)), ty
    | _ ->
         make_param_decl ty p

(*
 * Build a variable declaration from the syntax.
 *)
let make_var_init_decls store ty defs =
   (* Build the declaration with an initializer *)
   let rec make_def ty e = function
      VarNameId (pos, Some n) ->
         pos, store, n, ty, e
    | VarNamePattern (pos, _)
    | VarNameId (pos, None)
    | VarNameApply (pos, _, _) ->
         raise (ParseError (pos, "illegal variable declaration"))
    | VarNameArray (pos, spec, v, e') ->
         make_def (TypeArray (pos, status_of_spec spec, ty, zero_expr pos, e')) e v
    | VarNamePointer (pos, spec, v) ->
         make_def (TypePointer (pos, status_of_spec spec, ty)) e v
    | VarNameRef (pos, spec, v) ->
         make_def (TypeRef (pos, status_of_spec spec, ty)) e v
    | VarNameFun (pos, v, args) ->
         make_def (TypeFun (pos, StatusNormal, make_param_decls args, ty)) e v
   in

   (* Initial type *)
   let make_init_def (v, e) =
      make_def ty e v
   in
      List.map make_init_def defs

let make_patt_init_decls store ty defs =
   (* Build the declaration with an initializer *)
   let rec make_def ty e = function
      VarNameId (pos, Some n) ->
         pos, store, VarPattern (pos, n, n, Some ty), ty, e
    | VarNamePattern (pos, p) ->
         pos, store, p, ty, e
    | VarNameId (pos, None)
    | VarNameApply (pos, _, _) ->
         raise (ParseError (pos, "illegal variable declaration"))
    | VarNameArray (pos, spec, v, e') ->
         make_def (TypeArray (pos, status_of_spec spec, ty, zero_expr pos, e')) e v
    | VarNamePointer (pos, spec, v) ->
         make_def (TypePointer (pos, status_of_spec spec, ty)) e v
    | VarNameRef (pos, spec, v) ->
         make_def (TypeRef (pos, status_of_spec spec, ty)) e v
    | VarNameFun (pos, v, args) ->
         make_def (TypeFun (pos, StatusNormal, make_param_decls args, ty)) e v
   in

   (* Initial type *)
   let make_init_def (v, e) =
      make_def ty e v
   in
      List.map make_init_def defs

(*
 * Build a variable declaration from the syntax.
 *)
let rec make_var_decl ty = function
   VarNameId (pos, Some n) ->
      pos, n, ty
 | VarNamePattern (pos, _)
 | VarNameId (pos, None)
 | VarNameApply (pos, _, _) ->
      raise (ParseError (pos, "illegal variable declaration"))
 | VarNameArray (pos, spec, v, e) ->
      make_var_decl (TypeArray (pos, status_of_spec spec, ty, zero_expr pos, e)) v
 | VarNamePointer (pos, spec, v) ->
      make_var_decl (TypePointer (pos, status_of_spec spec, ty)) v
 | VarNameRef (pos, spec, v) ->
      make_var_decl (TypeRef (pos, status_of_spec spec, ty)) v
 | VarNameFun (pos, v, args) ->
      make_var_decl (TypeFun (pos, StatusNormal, make_param_decls args, ty)) v

let make_var_decls ty decls =
   List.map (make_var_decl ty) decls

(*
 * Struct decls have an optional width.
 *)
let make_struct_decls (store, ty) decls =
   List.map (fun (decl, width) ->
      let pos, n, ty = make_var_decl ty decl in
         pos, n, ty, width) decls

let make_uenum_ty_decls (store, ty) decls =
   List.map (fun decl ->
      let pos, n, ty = make_var_decl ty decl in
         pos, n, Some ty) decls

(*
 * Basic enumeration declaration.
 *)
let make_enum_decl v e_opt pos =
    pos, v, e_opt

(*
 * Add some type definitions.
 *)
let make_type_lambda pos tyl ty =
   let vars =
      List.map (function
         TypeVar (_, _, v) -> v
       | _ -> raise (ParseError (pos, "not a type variable"))) tyl
   in
      TypeLambda (pos, StatusNormal, vars, ty)

let rec make_type_decl ty = function
   VarNameId (pos, Some n) ->
      pos, n, ty, []
 | VarNameId (pos, None)
 | VarNamePattern (pos, _) ->
      raise (ParseError (pos, "illegal type declaration"))
 | VarNameApply (pos, n, tyl) ->
      pos, n, ty, tyl
 | VarNameArray (pos, spec, v, e) ->
      make_type_decl (TypeArray (pos, status_of_spec spec, ty, zero_expr pos, e)) v
 | VarNamePointer (pos, spec, v) ->
      make_type_decl (TypePointer (pos, status_of_spec spec, ty)) v
 | VarNameRef (pos, spec, v) ->
      make_type_decl (TypeRef (pos, status_of_spec spec, ty)) v
 | VarNameFun (pos, v, args) ->
      make_type_decl (TypeFun (pos, StatusNormal, make_param_decls args, ty)) v

let make_type_decl ty decl =
   let pos, n, ty, tyl = make_type_decl ty decl in
   let ty = make_type_lambda pos tyl ty in
      pos, n, n, ty

let make_type_decls ty decls =
   List.map (make_type_decl ty) decls

(*
 * A function definition.
 *)
let get_fun_var (p, ty) =
   let pos = pos_of_type ty in
   let p =
      match p with
         Some p ->
            p
       | None ->
            let v = new_symbol_string "unnamed_parameter" in
               VarPattern (pos, v, v, Some ty)
   in
      pos, p, ty

let rec make_fun_def (store, ty) decl body =
   let pos = union_pos (pos_of_type ty) (pos_of_expr body) in
      match decl with
         VarNameFun (_, res, vars) ->
            let vars = List.map get_fun_var vars in
            let _, f, ty = make_var_decl ty res in
               FunDef (pos, store, f, f, vars, ty, body)
       | VarNameArray (pos', spec, decl, e) ->
            make_fun_def (store, TypeArray (pos', status_of_spec spec, ty, zero_expr pos, e)) decl body
       | VarNamePointer (pos', spec, decl) ->
            make_fun_def (store, TypePointer (pos', status_of_spec spec, ty)) decl body
       | VarNameRef (pos', spec, decl) ->
            make_fun_def (store, TypeRef (pos', status_of_spec spec, ty)) decl body
       | VarNameId _
       | VarNamePattern _
       | VarNameApply _ ->
            raise (ParseError (pos, "not a function"))

(*
 * Operators.
 *)
let make_op pos op_class v el =
   OpExpr (pos, op_class, v, v, el)

let make_unop op_class (pos, v) expr =
   make_op (union_pos pos (pos_of_expr expr)) op_class v [expr]

let make_binop (pos, v) expr1 expr2 =
   let pos = union_pos pos (pos_of_expr expr1) in
   let pos = union_pos pos (pos_of_expr expr2) in
      make_op pos PreOp v [expr1; expr2]

let make_project (pos1, v) e (pos2, label) =
   let pos = union_pos (pos_of_expr e) pos2 in
      ProjectExpr (pos, OpExpr (pos, PreOp, addr_of_sym, addr_of_sym, [e]), label)

(*
 * Boolean expressions.
 *)
let make_and_op expr1 expr2 =
   let pos = union_pos (pos_of_expr expr1) (pos_of_expr expr2) in
   let v' = new_symbol_string "and" in
   let p = VarPattern (pos, v', v', None) in
   let step1 = VarDefs (pos, [pos, StoreAuto, p, TypePoly (pos, StatusNormal), InitExpr (pos, expr1)]) in
   let test_expr = make_op pos PreOp bang_sym [VarExpr (pos, v', v')] in
   let true_expr = make_op pos PreOp and_sym [VarExpr (pos, v', v'); expr2] in
   let step2 = IfExpr (pos, test_expr, zero_expr pos, Some true_expr) in
      SeqExpr (pos, [step1; step2])

let make_or_op expr1 expr2 =
   let pos = union_pos (pos_of_expr expr1) (pos_of_expr expr2) in
   let v' = new_symbol_string "or" in
   let p = VarPattern (pos, v', v', None) in
   let step1 = VarDefs (pos, [pos, StoreAuto, p, TypePoly (pos, StatusNormal), InitExpr (pos, expr1)]) in
   let test_expr = make_op pos PreOp bang_sym [VarExpr (pos, v', v')] in
   let true_expr = make_op pos PreOp or_sym [VarExpr (pos, v', v'); expr2] in
   let step2 = IfExpr (pos, test_expr, true_expr, Some (one_expr pos)) in
      SeqExpr (pos, [step1; step2])

(*
 * Optional expression.
 *)
let make_opt_expr opt_expr def_expr =
   match opt_expr with
      Some expr -> expr
    | None -> def_expr

(*
 * Types.
 *)
let make_ty_lambda pos vars ty =
   let vars = List.map (fun (_, v) -> v) vars in
      TypeLambda (pos, StatusNormal, vars, ty)

let make_struct_or_union struct_flag fields pos =
   match struct_flag with
      StructCase ->
         TypeStruct (pos, StatusNormal, Fields fields)
    | UnionCase ->
         TypeUnion (pos, StatusNormal, Fields fields)

let make_enum fields pos =
   TypeEnum (pos, StatusConst, Fields fields)

let make_uenum label fields pos =
   TypeUEnum (pos, StatusConst, Fields (label, fields))

let make_tuple fields pos =
   TypeProduct (pos, StatusNormal, fields)

(*
 * Parse the type specification.
 *)
let parse_builtin_type spec pos =
   let pos, store, status, pre, signed =
      List.fold_left (fun (pos, store, status, pre, signed) (pos', spec) ->
         let pos =
            match pos with
               Some pos -> Some (union_pos pos pos')
             | None -> Some pos'
         in
            match spec with
               AutoSpec ->
                  pos, StoreAuto, status, pre, signed
             | RegisterSpec ->
                  pos, StoreRegister, status, pre, signed
             | StaticSpec ->
                  pos, StoreStatic, status, pre, signed
             | ExternSpec ->
                  pos, StoreExtern, status, pre, signed
             | ConstSpec ->
                  pos, store, StatusConst, pre, signed
             | VolatileSpec ->
                  pos, store, StatusVolatile, pre, signed
             | ShortSpec ->
                  pos, store, status, ShortPrecision, signed
             | LongSpec ->
                  pos, store, status, LongPrecision, signed
             | SignedSpec ->
                  pos, store, status, pre, Some true
             | UnsignedSpec ->
                  pos, store, status, pre, Some false) (pos, StoreAuto, StatusNormal, NormalPrecision, None) spec
   in
   let pos =
      match pos with
         Some pos -> pos
       | None -> current_position ()
   in
      pos, store, status, pre, signed

(*
 * Construct a builtin integer type.
 *)
let make_int_type spec =
   let pos, store, status, pre, signed = parse_builtin_type spec None in
   let pre = FCParam.int_precision pre in
   let signed =
      match signed with
         Some signed -> signed
       | None -> true
   in
      store, TypeInt (pos, status, pre, signed)

(*
 * Construct a polymorphic type.
 *)
let make_poly_type spec =
   let pos, store, status, pre, signed = parse_builtin_type spec None in
      store, TypePoly (pos, status)

(*
 * Construct a generic builtin type.
 *)
let rec make_defined_type spec (pos, ty) =
   let pos, store, status, pre, signed = parse_builtin_type spec (Some pos) in
   let ty =
      match ty with
         VoidType ->
          TypeUnit (pos, status, 1)
       | CharType ->
          let pre = FCParam.char_precision pre in
          let signed =
             match signed with
                Some signed -> signed
              | None -> false
          in
             TypeChar (pos, status, pre, signed)
       | IntType ->
          let pre = FCParam.int_precision pre in
          let signed =
             match signed with
                Some signed -> signed
              | None -> true
          in
             TypeInt (pos, status, pre, signed)
       | FloatType ->
            let pre =
               match pre with
                  ShortPrecision
                | NormalPrecision ->
                   ShortPrecision
                | LongPrecision ->
                   NormalPrecision
            in
            let pre = FCParam.float_precision pre in
               TypeFloat (pos, status, pre)
       | DoubleType ->
            let pre = FCParam.float_precision pre in
               TypeFloat (pos, status, pre)
       | VarType v ->
            TypeVar (pos, status, v)
       | ApplyType (v, args) ->
            TypeApply (pos, status, v, args)
       | PolyType ->
            TypePoly (pos, status)
   in
      store, ty

(*
 * Collect the switch cases.
 * This doesn't do any translation, it just does
 * the search.  Note, we have to be a little careful
 * because labels may be interleaved with cases.
 *)
let rec normalize_cases pos e =
   match e with
      SeqExpr (pos, el) ->
         collect_cases pos el
    | _ ->
         raise (ParseError (pos, "switch body is not a compound block"))

and collect_cases pos el =
   if el = [] then
      []
   else
      let case, el = collect_case pos el in
      let cases = collect_cases pos el in
         case :: cases

and collect_case pos el =
   match el with
      CaseExpr (_, p) :: el ->
         let el1, el2 = collect_case_list el in
            (p, el1), el2
    | DefaultExpr pos' :: el ->
         let v = new_symbol_string "_" in
         let p = VarPattern (pos', v, v, None) in
         let el1, el2 = collect_case_list el in
            (p, el1), el2
    | LabelExpr _ as e :: el ->
         let case, el = collect_case pos el in
         let p, el' = case in
         let case = p, e :: el' in
            case, el
    | _ ->
         raise (ParseError (pos, "switch body does not start with a case statement"))

and collect_case_list el =
   match el with
      CaseExpr _ :: _
    | DefaultExpr _ :: _ ->
         [], el
    | e :: el ->
         let el1, el2 = collect_case_list el in
            e :: el1, el2
    | [] ->
         [], []

(*
 * Add unit to the stmt.
 *)
let wrap_stmt e =
   let pos = pos_of_expr e in
      SeqExpr (pos, [e; UnitExpr(pos, 1, 0)])
%}
%start prog
%token <Fc_parse_type.pos * Symbol.symbol> TokAddr
%token <Fc_parse_type.pos> TokAnd
%token <Fc_parse_type.pos> TokAuto
%token <Fc_parse_type.pos> TokBreak
%token <Fc_parse_type.pos> TokCase
%token <Fc_parse_type.pos> TokCatch
%token <Fc_parse_type.pos * Rawint.rawint> TokChar
%token <Fc_parse_type.pos> TokColon
%token <Fc_parse_type.pos> TokComma
%token <Fc_parse_type.pos> TokConst
%token <Fc_parse_type.pos> TokContinue
%token <Fc_parse_type.pos> TokDefault
%token <Fc_parse_type.pos> TokDo
%token <Fc_parse_type.pos * Symbol.symbol> TokDot
%token <Fc_parse_type.pos> TokElide
%token <Fc_parse_type.pos> TokElse
%token <Fc_parse_type.pos> TokEnum
%token TokEof
%token <Fc_parse_type.pos> TokEq
%token <Fc_parse_type.pos> TokExtern
%token <Fc_parse_type.pos> TokFinally
%token <Fc_parse_type.pos * Rawfloat.rawfloat> TokFloat
%token <Fc_parse_type.pos> TokFor
%token <Fc_parse_type.pos> TokGoto
%token <Fc_parse_type.pos * Symbol.symbol> TokId
%token <Fc_parse_type.pos> TokIf
%token <Fc_parse_type.pos * Rawint.rawint> TokInt
%token <Fc_parse_type.pos> TokLeftBrace
%token <Fc_parse_type.pos> TokLeftBrack
%token <Fc_parse_type.pos> TokLeftParen
%token <Fc_parse_type.pos> TokLong
%token <Fc_parse_type.pos * Symbol.symbol> TokOp1
%token <Fc_parse_type.pos * Symbol.symbol> TokOp10
%token <Fc_parse_type.pos * Symbol.symbol> TokOp11
%token <Fc_parse_type.pos * Symbol.symbol> TokOp13
%token <Fc_parse_type.pos * Symbol.symbol> TokOp4
%token <Fc_parse_type.pos * Symbol.symbol> TokOp5
%token <Fc_parse_type.pos * Symbol.symbol> TokOp7
%token <Fc_parse_type.pos * Symbol.symbol> TokOp8
%token <Fc_parse_type.pos * Symbol.symbol> TokOp9
%token <Fc_parse_type.pos> TokOperator
%token <Fc_parse_type.pos> TokOr
%token <Fc_parse_type.pos> TokPoly
%token <Fc_parse_type.pos * Symbol.symbol> TokPreOp12
%token <Fc_parse_type.pos * Symbol.symbol> TokPrePostOp12
%token <Fc_parse_type.pos> TokQuest
%token <Fc_parse_type.pos> TokRaise
%token <Fc_parse_type.pos> TokRegister
%token <Fc_parse_type.pos> TokReturn
%token <Fc_parse_type.pos> TokRightBrace
%token <Fc_parse_type.pos> TokRightBrack
%token <Fc_parse_type.pos> TokRightParen
%token <Fc_parse_type.pos> TokSemi
%token <Fc_parse_type.pos> TokShort
%token <Fc_parse_type.pos> TokSigned
%token <Fc_parse_type.pos> TokSizeof
%token <Fc_parse_type.pos> TokStar
%token <Fc_parse_type.pos> TokStatic
%token <Fc_parse_type.pos * Fc_config.precision * int array> TokString
%token <Fc_parse_type.pos> TokStruct
%token <Fc_parse_type.pos> TokSwitch
%token <Fc_parse_type.pos> TokTry
%token <Fc_parse_type.pos> TokTuple
%token <Fc_parse_type.pos> TokTypeChar
%token <Fc_parse_type.pos> TokTypeDouble
%token <Fc_parse_type.pos> TokTypeFloat
%token <Fc_parse_type.pos * Symbol.symbol> TokTypeId
%token <Fc_parse_type.pos> TokTypeInt
%token <Fc_parse_type.pos * Symbol.symbol> TokTypeVar
%token <Fc_parse_type.pos> TokTypeVoid
%token <Fc_parse_type.pos> TokTypedef
%token <Fc_parse_type.pos> TokUnion
%token <Fc_parse_type.pos> TokUnsigned
%token <Fc_parse_type.pos> TokVolatile
%token <Fc_parse_type.pos> TokWhile
%left TokComma
%right TokEq TokOp1
%right TokColon TokQuest
%left TokOp2
%left TokAnd TokOr
%left TokOp4
%left TokOp5
%left TokAddr
%left TokOp7
%left TokOp8
%left TokOp9
%left TokOp10
%left TokOp11 TokStar
%right TokPreOp12 TokPrePostOp12 prec_cast prec_unary
%left TokDot TokLeftBrack TokLeftParen TokOp13 TokRightBrack TokRightParen prec_apply prec_subscript
%nonassoc prec_ifthen
%nonassoc TokElse prec_ifthenelse
%left TokCatch TokFinally
%nonassoc TokTry
%type <Fc_parse_type.expr list> prog
%%

prog:
  _1 = all_defs _2 = TokEof
    {          ( let defs = pop_tenv () in
            let name = current_file () in
            let pos = name, 1, 0, 1, 0 in
               match defs with
                  [] -> _1
                | _ -> TypeDefs (pos, List.rev defs) :: _1
          )}

all_defs:
  _1 = rev_all_defs
    {          ( List.rev _1 )}

rev_all_defs:
  
    {          ( [] )}
| _1 = rev_all_defs _2 = all_def
    {          ( _2 :: _1 )}

all_def:
  _1 = var_defs
    {          ( _1 )}
| _1 = fun_def
    {          ( _1 )}
| _1 = type_defs
    {          ( _1 )}

opt_type_params:
  
    {          ( [] )}
| _1 = type_params
    {          ( _1 )}

type_params:
  _1 = TokTypeVar
    {          ( [_1] )}
| _1 = TokLeftParen _2 = type_param_list _3 = TokRightParen
    {          ( List.rev _2 )}

type_param_list:
  _1 = TokTypeVar
    {          ( [_1] )}
| _1 = type_param_list _2 = TokComma _3 = TokTypeVar
    {          ( _3 :: _1 )}

decl_spec:
  _1 = simp_decl_spec
    {          ( _1 )}
| _1 = struct_decl_spec
    {          ( _1 )}

simp_decl_spec:
  _1 = decl_specifiers
    {          ( make_int_type _1 )}
| _1 = decl_specifiers_opt _2 = type_builtin _3 = decl_specifiers_opt
    {          ( make_defined_type (_1 @ _3) _2 )}
| _1 = simp_type_spec _2 = decl_type_specifiers_opt
    {          ( make_defined_type _2 _1 )}
| _1 = decl_type_specifiers _2 = simp_type_spec _3 = decl_type_specifiers_opt
    {          ( make_defined_type (_1 @ _3) _2 )}

struct_decl_spec:
  _1 = struct_type_spec _2 = decl_type_specifiers_opt
    {          ( make_defined_type _2 _1 )}
| _1 = decl_type_specifiers _2 = struct_type_spec _3 = decl_type_specifiers_opt
    {          ( make_defined_type (_1 @ _3) _2 )}

decl_specifiers_opt:
  
    {          ( [] )}
| _1 = decl_specifiers
    {          ( _1 )}
| _1 = decl_type_specifiers
    {          ( _1 )}

decl_specifiers:
  _1 = type_mod
    {          ( [_1] )}
| _1 = decl_type_specifiers _2 = type_mod
    {          ( _2 :: _1 )}
| _1 = decl_specifiers _2 = decl_specifier
    {          ( _2 :: _1 )}

decl_specifier:
  _1 = storage_class_spec
    {          ( _1 )}
| _1 = type_qual
    {          ( _1 )}
| _1 = type_mod
    {          ( _1 )}

decl_type_specifiers_opt:
  
    {          ( [] )}
| _1 = decl_type_specifiers
    {          ( _1 )}

decl_type_specifiers:
  _1 = decl_type_specifier
    {          ( [_1] )}
| _1 = decl_type_specifiers _2 = decl_type_specifier
    {          ( _2 :: _1 )}

decl_type_specifier:
  _1 = storage_class_spec
    {          ( _1 )}
| _1 = type_qual
    {          ( _1 )}

decl_struct_type_specifiers_opt:
  
    {          ( [] )}
| _1 = decl_struct_type_specifiers
    {          ( _1 )}

decl_struct_type_specifiers:
  _1 = decl_struct_type_specifier
    {          ( [_1] )}
| _1 = decl_struct_type_specifiers _2 = decl_struct_type_specifier
    {          ( _2 :: _1 )}

decl_struct_type_specifier:
  _1 = type_qual
    {          ( _1 )}

storage_class_spec:
  _1 = TokAuto
    {          ( _1, AutoSpec )}
| _1 = TokRegister
    {          ( _1, RegisterSpec )}
| _1 = TokStatic
    {          ( _1, StaticSpec )}
| _1 = TokExtern
    {          ( _1, ExternSpec )}

type_qual:
  _1 = TokConst
    {          ( _1, ConstSpec )}
| _1 = TokVolatile
    {          ( _1, VolatileSpec )}

type_mod:
  _1 = TokShort
    {          ( _1, ShortSpec )}
| _1 = TokLong
    {          ( _1, LongSpec )}
| _1 = TokSigned
    {          ( _1, SignedSpec )}
| _1 = TokUnsigned
    {          ( _1, UnsignedSpec )}

type_builtin:
  _1 = TokTypeVoid
    {          ( _1, VoidType )}
| _1 = TokTypeChar
    {          ( _1, CharType )}
| _1 = TokTypeInt
    {          ( _1, IntType )}
| _1 = TokTypeFloat
    {          ( _1, FloatType )}
| _1 = TokTypeDouble
    {          ( _1, DoubleType )}

simp_type_spec:
  _1 = TokTypeVar
    {          ( let pos, id = _1 in
               pos, VarType id
          )}
| _1 = TokTypeId
    {          ( let pos, id = _1 in
               pos, ApplyType (id, [])
          )}
| _1 = TokPoly
    {          ( let pos = _1 in
               pos, PolyType
          )}
| _1 = TokPoly _2 = TokTypeId _3 = TokLeftParen _4 = opt_param_list _5 = TokRightParen
    {          ( let _, id = _2 in
            let pos = union_pos _1 _5 in
            let args = List.map snd _4 in
               pos, ApplyType (id, args)
          )}

struct_type_spec:
  _1 = struct_spec
    {          ( let pos, id = _1 in
               pos, ApplyType (id, [])
          )}
| _1 = enum_spec
    {          ( let pos, id = _1 in
               pos, ApplyType (id, [])
          )}
| _1 = uenum_spec
    {          ( let pos, id = _1 in
               pos, ApplyType (id, [])
          )}
| _1 = tuple_spec
    {          ( let pos, id = _1 in
               pos, ApplyType (id, [])
          )}

tuple_spec:
  _1 = TokTuple _2 = opt_type_params _3 = tuple_declaration_list
    {          ( let pos2, fields = _3 in
            let pos = union_pos _1 pos2 in
            let id = new_symbol_string "tuple" in
            let ty = make_ty_lambda pos _2 (make_tuple fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = tuple_spec_id _2 = tuple_declaration_list
    {          ( let pos1, args, id = _1 in
            let pos2, fields = _2 in
            let pos = union_pos pos1 pos2 in
            let ty = make_ty_lambda pos args (make_tuple fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = tuple_spec_id
    {          ( let pos, _, id = _1 in
               pos, id
          )}

tuple_spec_id:
  _1 = TokTuple _2 = opt_type_params _3 = id
    {          ( let pos2, id = _3 in
            let pos = union_pos _1 pos2 in
               pos, _2, id
          )}

enum_spec:
  _1 = TokEnum _2 = opt_type_params _3 = enum_declaration_list
    {          ( let pos2, fields = _3 in
            let pos = union_pos _1 pos2 in
            let id = new_symbol_string "enum" in
            let ty = make_ty_lambda pos _2 (make_enum fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = enum_spec_id _2 = enum_declaration_list
    {          ( let pos1, args, id = _1 in
            let pos2, fields = _2 in
            let pos = union_pos pos1 pos2 in
            let ty = make_ty_lambda pos args (make_enum fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = enum_spec_id
    {          ( let pos, _, id = _1 in
               pos, id
          )}

enum_spec_id:
  _1 = TokEnum _2 = opt_type_params _3 = id
    {          ( let pos2, id = _3 in
            let pos = union_pos _1 pos2 in
               pos, _2, id
          )}

uenum_spec:
  _1 = union_enum _2 = opt_type_params _3 = uenum_declaration_list
    {          ( let pos1 = _1 in
            let pos2, fields = _3 in
            let pos = union_pos pos1 pos2 in
            let id = new_symbol_string "struct" in
            let ty = make_ty_lambda pos _2 (make_uenum id fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = uenum_spec_id _2 = uenum_declaration_list
    {          ( let pos1, vars, id = _1 in
            let pos2, fields = _2 in
            let pos = union_pos pos1 pos2 in
            let ty = make_ty_lambda pos vars (make_uenum id fields pos) in
            let name = String.lowercase (Symbol.to_string id) in
	       Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = uenum_spec_id
    {          ( let pos, vars, id = _1 in
               if vars <> [] then
                  raise (ParseError (pos, "illegal union enum parameters"));
               pos, id
          )}

union_enum:
  _1 = TokEnum _2 = TokUnion
    {          ( union_pos _1 _2 )}
| _1 = TokUnion _2 = TokEnum
    {          ( union_pos _1 _2 )}

uenum_spec_id:
  _1 = union_enum _2 = opt_type_params _3 = id
    {          ( let pos1 = _1 in
            let pos2, id = _3 in
            let pos = union_pos pos1 pos2 in
               Fc_parse_state.add_type id pos (TypeUEnum (pos, StatusNormal, Label (new_symbol id, id)));
               pos, _2, id
          )}

struct_spec:
  _1 = struct_or_union _2 = opt_type_params _3 = struct_declaration_list
    {          ( let pos1, struct_flag = _1 in
            let pos2, fields = _3 in
            let pos = union_pos pos1 pos2 in
            let id = new_symbol_string "struct" in
            let ty = make_ty_lambda pos _2 (make_struct_or_union struct_flag fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = struct_spec_id _2 = struct_declaration_list
    {          ( let pos1, struct_flag, vars, id = _1 in
            let pos2, fields = _2 in
            let pos = union_pos pos1 pos2 in
            let ty = make_ty_lambda pos vars (make_struct_or_union struct_flag fields pos) in
               Fc_parse_state.add_type id pos ty;
               pos, id
          )}
| _1 = struct_spec_id
    {          ( let pos, struct_flag, vars, id = _1 in
               if vars <> [] then
                  raise (ParseError (pos, "illegal struct parameters"));
               pos, id
          )}

struct_or_union:
  _1 = TokStruct
    {          ( _1, StructCase )}
| _1 = TokUnion
    {          ( _1, UnionCase )}

struct_spec_id:
  _1 = struct_or_union _2 = opt_type_params _3 = id
    {          ( let pos1, struct_flag = _1 in
            let pos2, id = _3 in
            let pos = union_pos pos1 pos2 in
            let ty =
               match struct_flag with
                  StructCase -> TypeStruct (pos, StatusNormal, Label (new_symbol id, id))
                | UnionCase -> TypeUnion (pos, StatusNormal, Label (new_symbol id, id))
            in
               Fc_parse_state.add_type id pos ty;
               pos, struct_flag, _2, id
          )}

tuple_declaration_list:
  _1 = TokLeftBrace _2 = rev_tuple_decl_list _3 = TokRightBrace
    {          ( let pos = union_pos _1 _3 in
            let fields = List.rev _2 in
               pos, fields
          )}

rev_tuple_decl_list:
  _1 = tuple_decl
    {          ( [_1] )}
| _1 = rev_tuple_decl_list _2 = tuple_decl
    {          ( _2 :: _1 )}

tuple_decl:
  _1 = simp_decl_spec _2 = TokSemi
    {          ( snd _1 )}
| _1 = struct_decl_spec _2 = TokSemi
    {          ( snd _1 )}

enum_declaration_list:
  _1 = TokLeftBrace _2 = TokRightBrace
    {          ( union_pos _1 _2, [] )}
| _1 = TokLeftBrace _2 = rev_enum_decl_list _3 = opt_comma _4 = TokRightBrace
    {          ( union_pos _1 _4, List.rev _2 )}

rev_enum_decl_list:
  _1 = enum_decl
    {          ( [_1] )}
| _1 = rev_enum_decl_list _2 = TokComma _3 = enum_decl
    {          ( _3 :: _1 )}

enum_decl:
  _1 = TokId
    {          ( let pos, id = _1 in
               make_enum_decl id None pos
          )}
| _1 = TokId _2 = TokEq _3 = nc_expr
    {          ( let pos, id = _1 in
            let pos = union_pos pos (pos_of_expr _3) in
               make_enum_decl id (Some _3) pos
          )}

uenum_declaration_list:
  _1 = TokLeftBrace _2 = uenum_declaration_list_cat _3 = TokRightBrace
    {          ( let pos = union_pos _1 _3 in
               pos, _2
          )}

uenum_declaration_list_cat:
  
    {          ( [] )}
| _1 = uenum_declaration_list_cat _2 = uenum_declaration
    {          ( _1 @ _2 )}

uenum_declaration:
  _1 = simp_decl_spec _2 = uenum_decl_list _3 = TokSemi
    {          ( make_uenum_ty_decls _1 _2 )}
| _1 = struct_decl_spec _2 = uenum_decl_list _3 = TokSemi
    {          ( make_uenum_ty_decls _1 _2 )}
| _1 = TokId _2 = TokSemi
    {          ( let pos, id = _1 in
               [pos, id, None]
          )}

uenum_decl_list:
  _1 = rev_uenum_decl_list
    {          ( List.rev _1 )}

rev_uenum_decl_list:
  _1 = id_decl
    {          ( [_1] )}
| _1 = rev_uenum_decl_list _2 = TokComma _3 = id_decl
    {          ( _3 :: _1 )}

struct_declaration_list:
  _1 = TokLeftBrace _2 = struct_declaration_list_cat _3 = TokRightBrace
    {          ( let pos = union_pos _1 _3 in
               pos, _2
          )}

struct_declaration_list_cat:
  
    {          ( [] )}
| _1 = struct_declaration_list_cat _2 = struct_declaration
    {          ( _1 @ _2  )}

struct_declaration:
  _1 = simp_decl_spec _2 = struct_decl_list _3 = TokSemi
    {          ( make_struct_decls _1 _2 )}
| _1 = struct_decl_spec _2 = struct_decl_list _3 = TokSemi
    {          ( make_struct_decls _1 _2 )}

struct_decl_list:
  _1 = rev_struct_decl_list
    {          ( List.rev _1 )}

rev_struct_decl_list:
  _1 = struct_decl
    {          ( [_1] )}
| _1 = rev_struct_decl_list _2 = TokComma _3 = struct_decl
    {          ( _3 :: _1 )}

struct_decl:
  _1 = id_decl
    {          ( _1, None )}
| _1 = TokColon _2 = nc_expr
    {          ( let id = new_symbol_string "pad" in
               VarNameId (_1, Some id), Some _2
          )}
| _1 = id_decl _2 = TokColon _3 = nc_expr
    {          ( _1, Some _3 )}

var_defs:
  _1 = struct_decl_spec _2 = id_init_decl_list _3 = TokSemi
    {          ( let store, ty = _1 in
            let pos = union_pos (pos_of_type ty) _3 in
               VarDefs (pos, make_patt_init_decls store ty _2)
          )}
| _1 = simp_decl_spec _2 = patt_init_decl_list _3 = TokSemi
    {          ( let store, ty = _1 in
            let pos = union_pos (pos_of_type ty) _3 in
               VarDefs (pos, make_patt_init_decls store ty _2)
          )}

id_init_decl_list:
  _1 = rev_id_init_decl_list
    {          ( List.rev _1 )}

rev_id_init_decl_list:
  _1 = id_init_decl
    {          ( [_1] )}
| _1 = rev_id_init_decl_list _2 = TokComma _3 = id_init_decl
    {          ( _3 :: _1 )}

id_init_decl:
  _1 = id_decl
    {          ( _1, InitNone )}
| _1 = id_decl _2 = TokEq _3 = init
    {          ( _1, _3 )}

patt_init_decl_list:
  _1 = rev_patt_init_decl_list
    {          ( List.rev _1 )}

rev_patt_init_decl_list:
  _1 = patt_init_decl
    {          ( [_1] )}
| _1 = rev_patt_init_decl_list _2 = TokComma _3 = patt_init_decl
    {          ( _3 :: _1 )}

patt_init_decl:
  _1 = patt_decl
    {          ( _1, InitNone )}
| _1 = patt_decl _2 = TokEq _3 = init
    {          ( _1, _3 )}

type_decl_list:
  _1 = rev_type_decl_list
    {          ( List.rev _1 )}

rev_type_decl_list:
  _1 = type_decl
    {          ( [_1] )}
| _1 = rev_type_decl_list _2 = TokComma _3 = type_decl
    {          ( _3 :: _1 )}

type_decl:
  _1 = type_direct_decl
    {          ( _1 )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt _3 = type_decl
    {          ( let pos = union_pos _1 (pos_of_var_name _3) in
               VarNamePointer (pos, _2, _3)
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt _3 = type_decl
    {          ( let pos, _ = _1 in
            let pos = union_pos pos (pos_of_var_name _3) in
               VarNameRef (pos, _2, _3)
          )}

type_direct_decl:
  _1 = TokId
    {          ( let pos, id = _1 in
               VarNameId (pos, Some id)
          )}
| _1 = TokPoly _2 = TokTypeId _3 = TokLeftParen _4 = param_list _5 = TokRightParen
    {          ( let pos, id = _2 in
            let pos = union_pos _1 _5 in
            let args = List.map snd _4 in
               VarNameApply (pos, id, args)
          )}
| _1 = TokLeftParen _2 = type_decl _3 = TokRightParen
    {          ( _2 )}
| _1 = type_direct_decl _2 = TokLeftBrack _3 = opt_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               match _3 with
                  Some e -> VarNameArray (pos, [], _1, e)
                | None -> VarNamePointer (pos, [], _1)
          )}
| _1 = type_direct_decl _2 = TokLeftParen _3 = opt_param_list _4 = TokRightParen %prec prec_apply
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               VarNameFun (pos, _1, _3)
          )}

patt_decl:
  _1 = pattern
    {          ( VarNamePattern (pos_of_pattern _1, _1) )}
| _1 = patt_decl2
    {          ( _1 )}

patt_decl2:
  _1 = patt_direct_decl
    {          ( _1 )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt _3 = patt_decl2
    {          ( let pos = union_pos _1 (pos_of_var_name _3) in
               VarNamePointer (pos, _2, _3)
          )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt _3 = TokId
    {          ( let pos, id = _3 in
            let id = VarNameId (pos, Some id) in
            let pos = union_pos _1 pos in
               VarNamePointer (pos, _2, id)
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt _3 = patt_decl2
    {          ( let pos, _ = _1 in
            let pos = union_pos pos (pos_of_var_name _3) in
               VarNameRef (pos, _2, _3)
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt _3 = TokId
    {          ( let pos1, _ = _1 in
            let pos2, id = _3 in
            let id = VarNameId (pos2, Some id) in
            let pos = union_pos pos1 pos2 in
               VarNameRef (pos, _2, id)
          )}

patt_direct_decl:
  _1 = TokLeftParen _2 = patt_decl2 _3 = TokRightParen
    {          ( _2 )}
| _1 = patt_direct_decl _2 = TokLeftBrack _3 = opt_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               match _3 with
                  Some e -> VarNameArray (pos, [], _1, e)
                | None -> VarNamePointer (pos, [], _1)
          )}
| _1 = patt_direct_decl _2 = TokLeftParen _3 = opt_param_list _4 = TokRightParen %prec prec_apply
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               VarNameFun (pos, _1, _3)
          )}
| _1 = TokId _2 = TokLeftBrack _3 = opt_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos, id = _1 in
            let id = VarNameId (pos, Some id) in
            let pos = union_pos pos _4 in
               match _3 with
                  Some e -> VarNameArray (pos, [], id, e)
                | None -> VarNamePointer (pos, [], id)
          )}
| _1 = TokId _2 = TokLeftParen _3 = opt_param_list _4 = TokRightParen %prec prec_apply
    {          ( let pos, id = _1 in
            let id = VarNameId (pos, Some id) in
            let pos = union_pos pos _4 in
               VarNameFun (pos, id, _3)
          )}

id_decl:
  _1 = direct_decl
    {          ( _1 )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt _3 = id_decl
    {          ( let pos = union_pos _1 (pos_of_var_name _3) in
               VarNamePointer (pos, _2, _3)
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt _3 = id_decl
    {          ( let pos, _ = _1 in
            let pos = union_pos pos (pos_of_var_name _3) in
               VarNameRef (pos, _2, _3)
          )}

direct_decl:
  _1 = TokId
    {          ( let pos, id = _1 in
               VarNameId (pos, Some id)
          )}
| _1 = TokLeftParen _2 = id_decl _3 = TokRightParen
    {          ( _2 )}
| _1 = direct_decl _2 = TokLeftBrack _3 = opt_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               match _3 with
                  Some e -> VarNameArray (pos, [], _1, e)
                | None -> VarNamePointer (pos, [], _1)
          )}
| _1 = direct_decl _2 = TokLeftParen _3 = opt_param_list _4 = TokRightParen %prec prec_apply
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               VarNameFun (pos, _1, _3)
          )}

opt_param_list:
  
    {          ( [] )}
| _1 = param_list
    {          ( _1 )}

param_list:
  _1 = rev_param_list
    {          ( List.rev _1 )}

rev_param_list:
  _1 = param_decl
    {          ( [_1] )}
| _1 = rev_param_list _2 = TokComma _3 = param_decl
    {          ( _3 :: _1 )}

param_decl:
  _1 = simp_decl_spec _2 = patt_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = struct_decl_spec _2 = id_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = simp_decl_spec _2 = abstract_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = struct_decl_spec _2 = abstract_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = simp_decl_spec
    {          ( None, snd _1 )}
| _1 = struct_decl_spec
    {          ( None, snd _1 )}
| _1 = TokElide
    {          ( None, TypeElide _1 )}

cast_decl:
  _1 = simp_decl_spec _2 = abstract_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = struct_decl_spec _2 = abstract_decl
    {          ( make_param_decl (snd _1) _2 )}
| _1 = decl_spec
    {          ( None, snd _1 )}

fun_param_list:
  _1 = TokLeftParen _2 = opt_param_list _3 = TokRightParen
    {          ( let pos = union_pos _1 _3 in
               pos, _2
          )}

abstract_decl:
  _1 = direct_abstract_decl
    {          ( _1 )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt
    {          ( let pos = _1 in
               VarNamePointer (pos, _2, VarNameId (pos, None))
          )}
| _1 = TokStar _2 = decl_struct_type_specifiers_opt _3 = abstract_decl
    {          ( let pos = union_pos _1 (pos_of_var_name _3) in
               VarNamePointer (pos, _2, _3)
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt
    {          ( let pos, _ = _1 in
               VarNameRef (pos, _2, VarNameId (pos, None))
          )}
| _1 = TokAddr _2 = decl_struct_type_specifiers_opt _3 = abstract_decl
    {          ( let pos, _ = _1 in
            let pos = union_pos pos (pos_of_var_name _3) in
               VarNameRef (pos, _2, _3)
          )}

direct_abstract_decl:
  _1 = TokLeftParen _2 = abstract_decl _3 = TokRightParen
    {          ( _2 )}
| _1 = direct_abstract_decl _2 = TokLeftBrack _3 = opt_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos (pos_of_var_name _1) _4 in
               match _3 with
                  Some e -> VarNameArray (pos, [], _1, e)
                | None -> VarNamePointer (pos, [], _1)
          )}
| _1 = TokLeftBrack _2 = opt_expr _3 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos _1 _3 in
               match _2 with
                  Some e -> VarNameArray (pos, [], VarNameId (pos, None), e)
                | None -> VarNamePointer (pos, [], VarNameId (pos, None))
          )}
| _1 = direct_abstract_decl _2 = fun_param_list %prec prec_apply
    {          ( let pos, params = _2 in
            let pos = union_pos (pos_of_var_name _1) pos in
               VarNameFun (pos, _1, params)
          )}
| _1 = fun_param_list %prec prec_apply
    {          ( let pos, params = _1 in
               VarNameFun (pos, VarNameId (pos, None), params)
          )}

fun_def:
  _1 = simp_decl_spec _2 = TokId _3 = TokLeftParen _4 = opt_param_list _5 = TokRightParen _6 = TokLeftBrace _7 = stmt_list _8 = TokRightBrace
    {          ( let pos, id = _2 in
            let id = VarNameId (pos, Some id) in
            let pos = union_pos pos _5 in
            let id = VarNameFun (pos, id, _4) in
            let pos = union_pos _6 _8 in
            let body = wrap_stmt (SeqExpr (pos, _7)) in
               make_fun_def _1 id body
          )}
| _1 = struct_decl_spec _2 = id_decl _3 = TokLeftBrace _4 = stmt_list _5 = TokRightBrace
    {          ( let pos = union_pos _3 _5 in
            let body = wrap_stmt (SeqExpr (pos, _4)) in
               make_fun_def _1 _2 body
          )}

type_defs:
  _1 = TokTypedef _2 = decl_spec _3 = type_decl_list _4 = TokSemi
    {          ( let pos = union_pos _1 _4 in
            let types = make_type_decls (snd _2) _3 in
               List.iter (fun (pos, v, _, ty) ->
                   Fc_parse_state.add_type v pos ty;
	           Fc_parse_state.add_typedef v) types;
               TypeDefs (pos, [])
          )}
| _1 = simp_decl_spec _2 = TokSemi
    {          ( (* Ignore them *)
            TypeDefs (pos_of_type (snd _1), [])
          )}
| _1 = struct_decl_spec _2 = TokSemi
    {          ( (* Ignore them *)
            TypeDefs (pos_of_type (snd _1), [])
          )}

init:
  _1 = nc_expr
    {         ( InitExpr (pos_of_expr _1, _1) )}
| _1 = TokLeftBrace _2 = rev_init_list _3 = opt_comma _4 = TokRightBrace
    {         ( let pos = union_pos _1 _4 in
              InitArray (pos, List.rev _2)
         )}

init_field:
  _1 = init
    {         ( None, _1 )}
| _1 = id _2 = TokColon _3 = init
    {         ( Some (snd _1), _3 )}

rev_init_list:
  _1 = init_field
    {         ( [_1] )}
| _1 = rev_init_list _2 = TokComma _3 = init_field
    {         ( _3 :: _1 )}

pattern:
  _1 = TokChar
    {          ( let pos, c = _1 in
               CharPattern (pos, c)
          )}
| _1 = TokInt
    {          ( let pos, i = _1 in
               IntPattern (pos, i)
          )}
| _1 = TokFloat
    {          ( let pos, x = _1 in
               FloatPattern (pos, x)
          )}
| _1 = TokString
    {          ( let pos, pre, s = _1 in
               StringPattern (pos, pre, s)
          )}
| _1 = TokLeftBrace _2 = rev_struct_field_pattern_list _3 = opt_comma _4 = TokRightBrace
    {          ( let pos = union_pos _1 _4 in
               StructPattern (pos, List.rev _2)
          )}
| _1 = TokId
    {          ( let pos, v = _1 in
               VarPattern (pos, v, v, None)
          )}
| _1 = TokId _2 = pattern
    {          ( let pos, id = _1 in
            let pos = union_pos pos (pos_of_pattern _2) in
               EnumPattern (pos, id, _2)
          )}
| _1 = TokLeftParen _2 = pattern _3 = TokRightParen
    {          ( _2 )}

rev_struct_field_pattern_list:
  _1 = struct_field_pattern
    {          ( [_1] )}
| _1 = rev_struct_field_pattern_list _2 = TokComma _3 = struct_field_pattern
    {          ( _3 :: _1 )}

struct_field_pattern:
  _1 = pattern
    {          ( None, _1 )}
| _1 = id _2 = TokColon _3 = pattern
    {          ( Some (snd _1), _3 )}

expr:
  _1 = nc_expr
    {          ( _1 )}
| _1 = expr _2 = TokComma _3 = nc_expr
    {          ( make_binop (_2, comma_sym) _1 _3 )}

nc_expr:
  _1 = TokChar
    {          ( let pos, c = _1 in
               CharExpr (pos, c)
          )}
| _1 = TokInt
    {          ( let pos, i = _1 in
               IntExpr (pos, i)
          )}
| _1 = TokFloat
    {          ( let pos, x = _1 in
               FloatExpr (pos, x)
          )}
| _1 = TokString
    {          ( let pos, pre, s = _1 in
               StringExpr (pos, pre, s)
          )}
| _1 = TokId
    {          ( let pos, v = _1 in
               VarExpr (pos, v, v)
          )}
| _1 = TokOperator _2 = operator
    {          ( let pos, v = _2 in
            let pos = union_pos _1 pos in
               VarExpr (pos, v, v)
          )}
| _1 = TokAddr _2 = nc_expr %prec prec_unary
    {          ( make_unop PreOp _1 _2 )}
| _1 = TokOp10 _2 = nc_expr %prec prec_unary
    {          ( make_unop PreOp _1 _2 )}
| _1 = TokStar _2 = nc_expr %prec prec_unary
    {          ( make_unop PreOp (_1, star_sym) _2 )}
| _1 = TokPreOp12 _2 = nc_expr %prec prec_unary
    {          ( make_unop PreOp _1 _2 )}
| _1 = TokPrePostOp12 _2 = nc_expr %prec prec_unary
    {          ( make_unop PreOp _1 _2 )}
| _1 = nc_expr _2 = TokPrePostOp12 %prec prec_unary
    {          ( make_unop PostOp _2 _1 )}
| _1 = nc_expr _2 = TokEq _3 = nc_expr
    {          ( make_binop (_2, eq_sym) _1 _3 )}
| _1 = nc_expr _2 = TokOp1 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokAnd _3 = nc_expr
    {          ( make_and_op _1 _3 )}
| _1 = nc_expr _2 = TokOr _3 = nc_expr
    {          ( make_or_op _1 _3 )}
| _1 = nc_expr _2 = TokOp4 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp5 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokAddr _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp7 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp8 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp9 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp10 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokStar _3 = nc_expr
    {          ( make_binop (_2, star_sym) _1 _3 )}
| _1 = nc_expr _2 = TokOp11 _3 = nc_expr
    {          ( make_binop _2 _1 _3 )}
| _1 = nc_expr _2 = TokDot _3 = id
    {          ( make_project _2 _1 _3 )}
| _1 = nc_expr _2 = TokOp13 _3 = id
    {          ( make_project _2 (make_unop PreOp _2 _1) _3 )}
| _1 = TokLeftParen _2 = expr _3 = TokRightParen
    {          ( _2 )}
| _1 = TokLeftParen _2 = stmt _3 = TokRightParen
    {          ( _2 )}
| _1 = TokSizeof _2 = nc_expr %prec prec_unary
    {          ( let pos = union_pos _1 (pos_of_expr _2) in
               SizeofExpr (pos, _2)
          )}
| _1 = TokSizeof _2 = TokLeftParen _3 = cast_decl _4 = TokRightParen %prec prec_unary
    {          ( let pos = union_pos _1 _4 in
            let _, ty = _3 in
               SizeofType (pos, ty)
          )}
| _1 = TokLeftParen _2 = cast_decl _3 = TokRightParen _4 = nc_expr %prec prec_cast
    {          ( let pos = union_pos _1 (pos_of_expr _4) in
            let _, ty = _2 in
               CastExpr (pos, ty, _4)
          )}
| _1 = nc_expr _2 = TokLeftBrack _3 = nc_expr _4 = TokRightBrack %prec prec_subscript
    {          ( let pos = union_pos (pos_of_expr _1) _4 in
               make_binop (_2, subscript_sym) _1 _3
          )}
| _1 = nc_expr _2 = TokLeftParen _3 = args _4 = TokRightParen %prec prec_apply
    {          ( let pos = union_pos (pos_of_expr _1) _4 in
               make_op pos PreOp apply_sym (_1 :: _1 :: _3)
          )}
| _1 = nc_expr _2 = TokQuest _3 = nc_expr _4 = TokColon _5 = nc_expr
    {          ( let pos = union_pos (pos_of_expr _1) (pos_of_expr _5) in
               IfExpr (pos, _1, _3, Some _5)
          )}

opt_expr:
  
    {          ( None )}
| _1 = expr
    {          ( Some _1 )}

stmt:
  _1 = TokSemi
    {          ( SeqExpr (_1, []) )}
| _1 = expr _2 = TokSemi
    {          ( _1 )}
| _1 = TokIf _2 = TokLeftParen _3 = expr _4 = TokRightParen _5 = stmt %prec prec_ifthen
    {          ( let pos = union_pos _1 (pos_of_expr _5) in
            let stmt = wrap_stmt _5 in
               IfExpr (pos, _3, stmt, None)
          )}
| _1 = TokIf _2 = TokLeftParen _3 = expr _4 = TokRightParen _5 = stmt _6 = TokElse _7 = stmt %prec prec_ifthenelse
    {          ( let pos = union_pos _1 (pos_of_expr _7) in
            let stmt1 = wrap_stmt _5 in
            let stmt2 = wrap_stmt _7 in
               IfExpr (pos, _3, stmt1, Some stmt2)
          )}
| _1 = TokSwitch _2 = TokLeftParen _3 = expr _4 = TokRightParen _5 = stmt
    {          ( let pos = union_pos _1 (pos_of_expr _5) in
            let cases = normalize_cases pos _5 in
               SwitchExpr (pos, _3, cases)
          )}
| _1 = TokFor _2 = TokLeftParen _3 = opt_expr _4 = TokSemi _5 = opt_expr _6 = TokSemi _7 = opt_expr _8 = TokRightParen _9 = stmt
    {          ( let pos = union_pos _1 (pos_of_expr _9) in
            let init = make_opt_expr _3 (one_expr _4) in
            let test = make_opt_expr _5 (one_expr _6) in
            let step = make_opt_expr _7 (one_expr _8) in
            let body = wrap_stmt _9 in
               ForExpr (pos, init, test, step, body)
          )}
| _1 = TokWhile _2 = TokLeftParen _3 = expr _4 = TokRightParen _5 = stmt
    {          ( let pos = union_pos _1 (pos_of_expr _5) in
            let body = wrap_stmt _5 in
               WhileExpr (pos, _3, body)
          )}
| _1 = TokDo _2 = stmt _3 = TokWhile _4 = TokLeftParen _5 = expr _6 = TokRightParen _7 = TokSemi
    {          ( let pos = union_pos _1 _7 in
            let body = wrap_stmt _2 in
               DoExpr (pos, body, _5)
          )}
| _1 = TokReturn _2 = expr _3 = TokSemi
    {          ( let pos = union_pos _1 (pos_of_expr _2) in
               ReturnExpr (pos, _2)
          )}
| _1 = TokReturn _2 = TokSemi
    {          ( let pos = union_pos _1 _2 in
            let e = SeqExpr (pos, []) in
               ReturnExpr (pos, e)
          )}
| _1 = TokRaise _2 = expr _3 = TokSemi
    {          ( let pos = union_pos _1 (pos_of_expr _2) in
               RaiseExpr (pos, _2)
          )}
| _1 = TokBreak _2 = TokSemi
    {          ( let pos = union_pos _1 _2 in
               BreakExpr pos
          )}
| _1 = TokContinue _2 = TokSemi
    {          ( let pos = union_pos _1 _2 in
               ContinueExpr pos
          )}
| _1 = TokGoto _2 = id _3 = TokSemi
    {          ( let pos2, label = _2 in
            let pos = union_pos _1 pos2 in
               GotoExpr (pos, label)
          )}
| _1 = open_block _2 = stmt_list _3 = close_block
    {          ( let pos, defs = _3 in
            let pos = union_pos _1 pos in
            let body =
               match defs with
                  [] -> _2
                | _ -> TypeDefs (pos, defs) :: _2
            in
               SeqExpr (pos, body)
          )}
| _1 = all_def
    {          ( _1 )}
| _1 = id _2 = TokColon
    {          ( let pos, id = _1 in
            let pos = union_pos pos _2 in
               LabelExpr (pos, id)
          )}
| _1 = TokCase _2 = pattern _3 = TokColon
    {          ( let pos = union_pos _1 _3 in
               CaseExpr (pos, _2)
          )}
| _1 = TokDefault _2 = TokColon
    {          ( let pos = union_pos _1 _2 in
               DefaultExpr pos
          )}
| _1 = TokTry _2 = stmt
    {          ( let pos = union_pos _1 (pos_of_expr _2) in
               TryExpr (pos, _2, [], None)
          )}
| _1 = stmt _2 = TokCatch _3 = TokLeftParen _4 = pattern _5 = TokRightParen _6 = stmt %prec TokCatch
    {          ( let pos = union_pos (pos_of_expr _1) (pos_of_expr _6) in
               match _1 with
                  TryExpr (pos, e, cases, finally) ->
                     let cases = cases @ [_4, [_6; BreakExpr pos]] in
                        TryExpr (pos, e, cases, finally)
                | _ ->
                     raise (ParseExpError (pos, "illegal catch", _1))
          )}
| _1 = stmt _2 = TokFinally _3 = stmt
    {          ( let pos = union_pos (pos_of_expr _1) (pos_of_expr _3) in
               match _1 with
                  TryExpr (pos, e, cases, finally) ->
                     let finally =
                        match finally with
                           Some _ -> raise (ParseError (pos, "duplicate finally"))
                         | None -> Some _3
                     in
                        TryExpr (pos, e, cases, finally)
                | _ ->
                     raise (ParseExpError (pos, "illegal finally", _1))
          )}

stmt_list:
  _1 = rev_stmt_list
    {          ( List.rev _1 )}

rev_stmt_list:
  
    {          ( [] )}
| _1 = rev_stmt_list _2 = stmt
    {          ( _2 :: _1 )}

open_block:
  _1 = TokLeftBrace
    {          ( Fc_parse_state.push_tenv ();
            _1
          )}

close_block:
  _1 = TokRightBrace
    {          ( _1, Fc_parse_state.pop_tenv () )}

args:
  
    {          ( [] )}
| _1 = rev_args
    {          ( List.rev _1 )}

rev_args:
  _1 = nc_expr
    {          ( [_1] )}
| _1 = rev_args _2 = TokComma _3 = nc_expr
    {          ( _3 :: _1 )}

id:
  _1 = TokId
    {          ( _1 )}
| _1 = TokTypeId
    {          ( _1 )}

operator:
  _1 = TokComma
    {          ( _1, comma_sym )}
| _1 = TokEq
    {          ( _1, eq_sym )}
| _1 = TokOp1
    {          ( _1 )}
| _1 = TokAnd
    {          ( _1, and_sym )}
| _1 = TokOr
    {          ( _1, or_sym )}
| _1 = TokOp4
    {          ( _1 )}
| _1 = TokOp5
    {          ( _1 )}
| _1 = TokAddr
    {          ( _1 )}
| _1 = TokOp7
    {          ( _1 )}
| _1 = TokOp8
    {          ( _1 )}
| _1 = TokOp9
    {          ( _1 )}
| _1 = TokOp10
    {          ( _1 )}
| _1 = TokStar
    {          ( _1, star_sym )}
| _1 = TokOp11
    {          ( _1 )}
| _1 = TokPreOp12
    {          ( _1 )}
| _1 = TokPrePostOp12
    {          ( _1 )}
| _1 = TokOp13
    {          ( _1 )}

opt_comma:
  
    {          ( () )}
| _1 = TokComma
    {          ( () )}

%%
