Grammar has 84 nonterminal symbols, among which 3 start symbols.
Grammar has 85 terminal symbols.
Grammar has 256 productions.
nullable(warn_error_list) = false
nullable(warn_error) = false
nullable(variance) = true
nullable(variable) = false
nullable(value_declaration) = false
nullable(type_parameters) = false
nullable(type_binding) = false
nullable(type_application_component) = false
nullable(separated_nonempty_list(DBLARROW,mode_constraint)) = false
nullable(separated_nonempty_list(COMMA,variable)) = false
nullable(separated_nonempty_list(COMMA,type_application_component)) = false
nullable(separated_nonempty_list(COMMA,consumes_type)) = false
nullable(separated_nonempty_list(COMMA,atomic_pattern)) = false
nullable(separated_nonempty_list(COMMA,algebraic_expression)) = false
nullable(separated_nonempty_list(AND,definition)) = false
nullable(separated_nonempty_list(AND,concrete_data_type_def)) = false
nullable(right_flexible_list(SEMI,data_field_pattern)) = true
nullable(right_flexible_list(SEMI,data_field_expression)) = true
nullable(right_flexible_list(SEMI,data_field_def)) = true
nullable(right_flexible_list(COMMA,type_binding)) = true
nullable(reverse_left_flexible_list(BAR,match_branch)) = true
nullable(reverse_left_flexible_list(BAR,data_type_def_branch)) = true
nullable(rec_flag) = true
nullable(reasonable_expression) = false
nullable(raw_very_loose_type) = false
nullable(raw_tuple_or(raw_reasonable_expression)) = false
nullable(raw_tuple_or(raw_fragile_expression)) = false
nullable(raw_tight_type) = false
nullable(raw_tight_expression) = false
nullable(raw_reasonable_expression) = false
nullable(raw_parenthetic_type) = false
nullable(raw_normal_type_no_adopts) = false
nullable(raw_normal_type) = false
nullable(raw_normal_pattern) = false
nullable(raw_loose_type) = false
nullable(raw_loose_pattern) = false
nullable(raw_fragile_expression) = false
nullable(raw_fat_type) = false
nullable(raw_consumes_type) = false
nullable(raw_atomic_type) = false
nullable(raw_atomic_pattern) = false
nullable(raw_atomic_expression) = false
nullable(raw_application_expression) = false
nullable(raw_algebraic_expression) = false
nullable(range) = false
nullable(parenthesized_tuple_components) = false
nullable(optional_preserving) = true
nullable(option(preceded(ADOPTS,arbitrary_type))) = true
nullable(nonempty_list(warn_error)) = false
nullable(mode) = false
nullable(maybe_qualified(variable)) = false
nullable(maybe_qualified(datacon)) = false
nullable(loption(type_parameters)) = true
nullable(loption(separated_nonempty_list(AND,definition))) = true
nullable(list(terminated(mode_constraint,DBLARROW))) = true
nullable(list(interface_item)) = true
nullable(list(implementation_item)) = true
nullable(list(fact)) = true
nullable(list(atomic_type_binding_with_variance)) = true
nullable(interface_item) = false
nullable(interface) = false
nullable(implementation_item) = false
nullable(implementation) = false
nullable(generic_datacon_application(right_flexible_list(SEMI,data_field_pattern))) = false
nullable(generic_datacon_application(right_flexible_list(SEMI,data_field_expression))) = false
nullable(generic_datacon_application(data_type_def_branch_content)) = false
nullable(flag) = false
nullable(fact) = false
nullable(explain) = true
nullable(existential_quantifiers) = false
nullable(direction) = false
nullable(definition_group) = false
nullable(definition) = false
nullable(data_type_def_branch_content) = true
nullable(data_field_pattern) = false
nullable(data_field_expression) = false
nullable(data_field_def) = false
nullable(concrete_data_type_def) = false
nullable(atomic_type_binding_with_variance) = false
nullable(atomic_type_binding) = false
nullable(atomic_kind) = false
nullable(anonymous_function) = false
nullable(abstract_data_type_def) = false
nullable(abbreviation_def) = false
first(warn_error_list) = PLUS MINUS AT
first(warn_error) = PLUS MINUS AT
first(variance) = PLUS MINUS
first(variable) = LPAREN LIDENT
first(value_declaration) = VAL
first(type_parameters) = LBRACKET
first(type_binding) = LPAREN LIDENT
first(type_application_component) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
first(separated_nonempty_list(DBLARROW,mode_constraint)) = EXCLUSIVE DUPLICABLE
first(separated_nonempty_list(COMMA,variable)) = LPAREN LIDENT
first(separated_nonempty_list(COMMA,type_application_component)) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
first(separated_nonempty_list(COMMA,consumes_type)) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE CONSUMES
first(separated_nonempty_list(COMMA,atomic_pattern)) = UNDERSCORE UIDENT LPAREN LIDENT
first(separated_nonempty_list(COMMA,algebraic_expression)) = UIDENT OPPREFIX MINUS MATCH LPAREN LIDENT INT FAIL BEGIN
first(separated_nonempty_list(AND,definition)) = UNDERSCORE UIDENT LPAREN LIDENT
first(separated_nonempty_list(AND,concrete_data_type_def)) = MUTABLE LPAREN LIDENT
first(right_flexible_list(SEMI,data_field_pattern)) = LPAREN LIDENT
first(right_flexible_list(SEMI,data_field_expression)) = LPAREN LIDENT
first(right_flexible_list(SEMI,data_field_def)) = LPAREN LIDENT
first(right_flexible_list(COMMA,type_binding)) = LPAREN LIDENT
first(reverse_left_flexible_list(BAR,match_branch)) = UNDERSCORE UIDENT LPAREN LIDENT BAR
first(reverse_left_flexible_list(BAR,data_type_def_branch)) = UNKNOWN UNDERSCORE UIDENT MUTABLE LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE BAR
first(rec_flag) = REC
first(reasonable_expression) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT INT IF GIVE FOR FAIL BEGIN ASSERT
first(raw_very_loose_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE CONSUMES
first(raw_tuple_or(raw_reasonable_expression)) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT INT IF GIVE FOR FAIL BEGIN ASSERT
first(raw_tuple_or(raw_fragile_expression)) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT LET INT IF GIVE FUN FOR FAIL BEGIN ASSERT
first(raw_tight_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT EQUAL EMPTY DYNAMIC
first(raw_tight_expression) = UIDENT OPPREFIX MATCH LPAREN LIDENT INT FAIL BEGIN
first(raw_reasonable_expression) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT INT IF GIVE FOR FAIL BEGIN ASSERT
first(raw_parenthetic_type) = LPAREN
first(raw_normal_type_no_adopts) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
first(raw_normal_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
first(raw_normal_pattern) = UNDERSCORE UIDENT LPAREN LIDENT
first(raw_loose_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
first(raw_loose_pattern) = UNDERSCORE UIDENT LPAREN LIDENT
first(raw_fragile_expression) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT LET INT IF GIVE FUN FOR FAIL BEGIN ASSERT
first(raw_fat_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE CONSUMES BAR
first(raw_consumes_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE CONSUMES
first(raw_atomic_type) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT EMPTY DYNAMIC
first(raw_atomic_pattern) = UNDERSCORE UIDENT LPAREN LIDENT
first(raw_atomic_expression) = UIDENT OPPREFIX MATCH LPAREN LIDENT INT FAIL BEGIN
first(raw_application_expression) = UIDENT OPPREFIX MATCH LPAREN LIDENT INT FAIL BEGIN
first(raw_algebraic_expression) = UIDENT OPPREFIX MINUS MATCH LPAREN LIDENT INT FAIL BEGIN
first(range) = INT
first(parenthesized_tuple_components) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT LET INT IF GIVE FUN FOR FAIL BEGIN ASSERT
first(optional_preserving) = PRESERVING
first(option(preceded(ADOPTS,arbitrary_type))) = ADOPTS
first(nonempty_list(warn_error)) = PLUS MINUS AT
first(mode) = EXCLUSIVE DUPLICABLE
first(maybe_qualified(variable)) = LPAREN LIDENT
first(maybe_qualified(datacon)) = UIDENT LIDENT
first(loption(type_parameters)) = LBRACKET
first(loption(separated_nonempty_list(AND,definition))) = UNDERSCORE UIDENT LPAREN LIDENT
first(list(terminated(mode_constraint,DBLARROW))) = EXCLUSIVE DUPLICABLE
first(list(interface_item)) = VAL OPEN DATA ALIAS ABSTRACT
first(list(implementation_item)) = VAL OPEN DATA ALIAS ABSTRACT
first(list(fact)) = FACT
first(list(atomic_type_binding_with_variance)) = PLUS MINUS LPAREN LIDENT
first(interface_item) = VAL OPEN DATA ALIAS ABSTRACT
first(interface) = VAL OPEN EOF DATA ALIAS ABSTRACT
first(implementation_item) = VAL OPEN DATA ALIAS ABSTRACT
first(implementation) = VAL OPEN EOF DATA ALIAS ABSTRACT
first(generic_datacon_application(right_flexible_list(SEMI,data_field_pattern))) = UIDENT LIDENT
first(generic_datacon_application(right_flexible_list(SEMI,data_field_expression))) = UIDENT LIDENT
first(generic_datacon_application(data_type_def_branch_content)) = UIDENT LIDENT
first(flag) = PLUS MINUS AT
first(fact) = FACT
first(explain) = EXPLAIN
first(existential_quantifiers) = LBRACE
first(direction) = TO DOWNTO BELOW ABOVE
first(definition_group) = VAL
first(definition) = UNDERSCORE UIDENT LPAREN LIDENT
first(data_type_def_branch_content) = LPAREN LIDENT BAR
first(data_field_pattern) = LPAREN LIDENT
first(data_field_expression) = LPAREN LIDENT
first(data_field_def) = LPAREN LIDENT
first(concrete_data_type_def) = MUTABLE LPAREN LIDENT
first(atomic_type_binding_with_variance) = PLUS MINUS LPAREN LIDENT
first(atomic_type_binding) = LPAREN LIDENT
first(atomic_kind) = VALUE TYPE PERM LPAREN
first(anonymous_function) = LPAREN LBRACKET EXCLUSIVE DUPLICABLE
first(abstract_data_type_def) = LPAREN LIDENT
first(abbreviation_def) = LPAREN LIDENT
minimal(warn_error_list) = (* 3 *) AT INT EOF
minimal(warn_error) = (* 2 *) AT INT
minimal(variance) = (* 0 *)
minimal(variable) = (* 1 *) LIDENT
minimal(value_declaration) = (* 4 *) VAL LIDENT COLON UNKNOWN
minimal(type_parameters) = (* 2 *) LBRACKET RBRACKET
minimal(type_binding) = (* 1 *) LIDENT
minimal(type_application_component) = (* 1 *) UNKNOWN
minimal(separated_nonempty_list(DBLARROW,mode_constraint)) = (* 2 *) EXCLUSIVE UNKNOWN
minimal(separated_nonempty_list(COMMA,variable)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,type_application_component)) = (* 1 *) UNKNOWN
minimal(separated_nonempty_list(COMMA,consumes_type)) = (* 1 *) UNKNOWN
minimal(separated_nonempty_list(COMMA,atomic_pattern)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,algebraic_expression)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(AND,definition)) = (* 3 *) UIDENT EQUAL LIDENT
minimal(separated_nonempty_list(AND,concrete_data_type_def)) = (* 2 *) LIDENT EQUAL
minimal(right_flexible_list(SEMI,data_field_pattern)) = (* 0 *)
minimal(right_flexible_list(SEMI,data_field_expression)) = (* 0 *)
minimal(right_flexible_list(SEMI,data_field_def)) = (* 0 *)
minimal(right_flexible_list(COMMA,type_binding)) = (* 0 *)
minimal(reverse_left_flexible_list(BAR,match_branch)) = (* 0 *)
minimal(reverse_left_flexible_list(BAR,data_type_def_branch)) = (* 0 *)
minimal(rec_flag) = (* 0 *)
minimal(reasonable_expression) = (* 1 *) LIDENT
minimal(raw_very_loose_type) = (* 1 *) UNKNOWN
minimal(raw_tuple_or(raw_reasonable_expression)) = (* 1 *) LIDENT
minimal(raw_tuple_or(raw_fragile_expression)) = (* 1 *) LIDENT
minimal(raw_tight_type) = (* 1 *) UNKNOWN
minimal(raw_tight_expression) = (* 1 *) LIDENT
minimal(raw_reasonable_expression) = (* 1 *) LIDENT
minimal(raw_parenthetic_type) = (* 2 *) LPAREN RPAREN
minimal(raw_normal_type_no_adopts) = (* 1 *) UNKNOWN
minimal(raw_normal_type) = (* 1 *) UNKNOWN
minimal(raw_normal_pattern) = (* 1 *) UIDENT
minimal(raw_loose_type) = (* 1 *) UNKNOWN
minimal(raw_loose_pattern) = (* 1 *) UIDENT
minimal(raw_fragile_expression) = (* 1 *) LIDENT
minimal(raw_fat_type) = (* 1 *) UNKNOWN
minimal(raw_consumes_type) = (* 1 *) UNKNOWN
minimal(raw_atomic_type) = (* 1 *) UNKNOWN
minimal(raw_atomic_pattern) = (* 1 *) UIDENT
minimal(raw_atomic_expression) = (* 1 *) LIDENT
minimal(raw_application_expression) = (* 1 *) LIDENT
minimal(raw_algebraic_expression) = (* 1 *) LIDENT
minimal(range) = (* 1 *) INT
minimal(parenthesized_tuple_components) = (* 1 *) LIDENT
minimal(optional_preserving) = (* 0 *)
minimal(option(preceded(ADOPTS,arbitrary_type))) = (* 0 *)
minimal(nonempty_list(warn_error)) = (* 2 *) AT INT
minimal(mode) = (* 1 *) EXCLUSIVE
minimal(maybe_qualified(variable)) = (* 1 *) LIDENT
minimal(maybe_qualified(datacon)) = (* 1 *) UIDENT
minimal(loption(type_parameters)) = (* 0 *)
minimal(loption(separated_nonempty_list(AND,definition))) = (* 0 *)
minimal(list(terminated(mode_constraint,DBLARROW))) = (* 0 *)
minimal(list(interface_item)) = (* 0 *)
minimal(list(implementation_item)) = (* 0 *)
minimal(list(fact)) = (* 0 *)
minimal(list(atomic_type_binding_with_variance)) = (* 0 *)
minimal(interface_item) = (* 2 *) ABSTRACT LIDENT
minimal(interface) = (* 1 *) EOF
minimal(implementation_item) = (* 1 *) VAL
minimal(implementation) = (* 1 *) EOF
minimal(generic_datacon_application(right_flexible_list(SEMI,data_field_pattern))) = (* 1 *) UIDENT
minimal(generic_datacon_application(right_flexible_list(SEMI,data_field_expression))) = (* 1 *) UIDENT
minimal(generic_datacon_application(data_type_def_branch_content)) = (* 1 *) UIDENT
minimal(flag) = (* 1 *) AT
minimal(fact) = (* 3 *) FACT EXCLUSIVE UNKNOWN
minimal(explain) = (* 0 *)
minimal(existential_quantifiers) = (* 2 *) LBRACE RBRACE
minimal(direction) = (* 1 *) TO
minimal(definition_group) = (* 1 *) VAL
minimal(definition) = (* 3 *) UIDENT EQUAL LIDENT
minimal(data_type_def_branch_content) = (* 0 *)
minimal(data_field_pattern) = (* 1 *) LIDENT
minimal(data_field_expression) = (* 1 *) LIDENT
minimal(data_field_def) = (* 1 *) LIDENT
minimal(concrete_data_type_def) = (* 2 *) LIDENT EQUAL
minimal(atomic_type_binding_with_variance) = (* 1 *) LIDENT
minimal(atomic_type_binding) = (* 1 *) LIDENT
minimal(atomic_kind) = (* 1 *) VALUE
minimal(anonymous_function) = (* 6 *) LPAREN RPAREN COLON UNKNOWN EQUAL LIDENT
minimal(abstract_data_type_def) = (* 1 *) LIDENT
minimal(abbreviation_def) = (* 3 *) LIDENT EQUAL UNKNOWN
maximal(warn_error_list) = infinity
maximal(warn_error) = 5
maximal(variance) = 1
maximal(variable) = 3
maximal(value_declaration) = infinity
maximal(type_parameters) = infinity
maximal(type_binding) = infinity
maximal(type_application_component) = infinity
maximal(separated_nonempty_list(DBLARROW,mode_constraint)) = infinity
maximal(separated_nonempty_list(COMMA,variable)) = infinity
maximal(separated_nonempty_list(COMMA,type_application_component)) = infinity
maximal(separated_nonempty_list(COMMA,consumes_type)) = infinity
maximal(separated_nonempty_list(COMMA,atomic_pattern)) = infinity
maximal(separated_nonempty_list(COMMA,algebraic_expression)) = infinity
maximal(separated_nonempty_list(AND,definition)) = infinity
maximal(separated_nonempty_list(AND,concrete_data_type_def)) = infinity
maximal(right_flexible_list(SEMI,data_field_pattern)) = infinity
maximal(right_flexible_list(SEMI,data_field_expression)) = infinity
maximal(right_flexible_list(SEMI,data_field_def)) = infinity
maximal(right_flexible_list(COMMA,type_binding)) = infinity
maximal(reverse_left_flexible_list(BAR,match_branch)) = infinity
maximal(reverse_left_flexible_list(BAR,data_type_def_branch)) = infinity
maximal(rec_flag) = 1
maximal(reasonable_expression) = infinity
maximal(raw_very_loose_type) = infinity
maximal(raw_tuple_or(raw_reasonable_expression)) = infinity
maximal(raw_tuple_or(raw_fragile_expression)) = infinity
maximal(raw_tight_type) = infinity
maximal(raw_tight_expression) = infinity
maximal(raw_reasonable_expression) = infinity
maximal(raw_parenthetic_type) = infinity
maximal(raw_normal_type_no_adopts) = infinity
maximal(raw_normal_type) = infinity
maximal(raw_normal_pattern) = infinity
maximal(raw_loose_type) = infinity
maximal(raw_loose_pattern) = infinity
maximal(raw_fragile_expression) = infinity
maximal(raw_fat_type) = infinity
maximal(raw_consumes_type) = infinity
maximal(raw_atomic_type) = infinity
maximal(raw_atomic_pattern) = infinity
maximal(raw_atomic_expression) = infinity
maximal(raw_application_expression) = infinity
maximal(raw_algebraic_expression) = infinity
maximal(range) = 4
maximal(parenthesized_tuple_components) = infinity
maximal(optional_preserving) = infinity
maximal(option(preceded(ADOPTS,arbitrary_type))) = infinity
maximal(nonempty_list(warn_error)) = infinity
maximal(mode) = 1
maximal(maybe_qualified(variable)) = 5
maximal(maybe_qualified(datacon)) = 3
maximal(loption(type_parameters)) = infinity
maximal(loption(separated_nonempty_list(AND,definition))) = infinity
maximal(list(terminated(mode_constraint,DBLARROW))) = infinity
maximal(list(interface_item)) = infinity
maximal(list(implementation_item)) = infinity
maximal(list(fact)) = infinity
maximal(list(atomic_type_binding_with_variance)) = infinity
maximal(interface_item) = infinity
maximal(interface) = infinity
maximal(implementation_item) = infinity
maximal(implementation) = infinity
maximal(generic_datacon_application(right_flexible_list(SEMI,data_field_pattern))) = infinity
maximal(generic_datacon_application(right_flexible_list(SEMI,data_field_expression))) = infinity
maximal(generic_datacon_application(data_type_def_branch_content)) = infinity
maximal(flag) = 1
maximal(fact) = infinity
maximal(explain) = 1
maximal(existential_quantifiers) = infinity
maximal(direction) = 1
maximal(definition_group) = infinity
maximal(definition) = infinity
maximal(data_type_def_branch_content) = infinity
maximal(data_field_pattern) = infinity
maximal(data_field_expression) = infinity
maximal(data_field_def) = infinity
maximal(concrete_data_type_def) = infinity
maximal(atomic_type_binding_with_variance) = infinity
maximal(atomic_type_binding) = infinity
maximal(atomic_kind) = infinity
maximal(anonymous_function) = infinity
maximal(abstract_data_type_def) = infinity
maximal(abbreviation_def) = infinity
follow(warn_error_list) = #
follow(warn_error) = PLUS MINUS EOF AT
follow(variance) = LPAREN LIDENT
follow(variable) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LARROW INT IN FROM FOR FAIL FACT EXCLUSIVE EQUAL EOF END EMPTY ELSE DYNAMIC DUPLICABLE DOWNTO DOT DO DBLARROW DATA COMMA COLONEQUAL COLONCOLON COLON BELOW BEGIN BAR AT AS ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(value_declaration) = VAL OPEN EOF DATA ALIAS ABSTRACT
follow(type_parameters) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
follow(type_binding) = RPAREN RBRACKET RBRACE IN COMMA
follow(type_application_component) = RBRACKET COMMA
follow(separated_nonempty_list(DBLARROW,mode_constraint)) = VAL OPEN IN FACT EOF DATA ALIAS ABSTRACT
follow(separated_nonempty_list(COMMA,variable)) = COLONCOLON COLON
follow(separated_nonempty_list(COMMA,type_application_component)) = RBRACKET
follow(separated_nonempty_list(COMMA,consumes_type)) = WITNESS WITH WHILE VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM FOR EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(separated_nonempty_list(COMMA,atomic_pattern)) = SEMI RPAREN RBRACE LPAREN LBRACKET EXCLUSIVE EQUAL DUPLICABLE COLON AS ARROW
follow(separated_nonempty_list(COMMA,algebraic_expression)) = WITH VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(separated_nonempty_list(AND,definition)) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
follow(separated_nonempty_list(AND,concrete_data_type_def)) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
follow(right_flexible_list(SEMI,data_field_pattern)) = RBRACE
follow(right_flexible_list(SEMI,data_field_expression)) = RBRACE
follow(right_flexible_list(SEMI,data_field_def)) = RBRACE BAR
follow(right_flexible_list(COMMA,type_binding)) = RBRACKET RBRACE
follow(reverse_left_flexible_list(BAR,match_branch)) = END BAR
follow(reverse_left_flexible_list(BAR,data_type_def_branch)) = VAL OPEN IN EOF DATA BAR AND ALIAS ADOPTS ABSTRACT
follow(rec_flag) = VAL UNDERSCORE UIDENT OPEN LPAREN LIDENT IN EOF DATA ALIAS ABSTRACT
follow(reasonable_expression) = WITH VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_very_loose_type) = WITNESS WITH WHILE VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM FOR EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_tuple_or(raw_reasonable_expression)) = WITH VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_tuple_or(raw_fragile_expression)) = WITH VAL TO THEN RPAREN OPEN IN FROM EOF END DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_tight_type) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE OPEN LPAREN LIDENT IN FROM FOR EQUAL EOF END EMPTY ELSE DYNAMIC DOWNTO DO DATA COMMA COLON BELOW BAR ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_tight_expression) = WITH VAL UIDENT TO THEN STAR SEMI RPAREN RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LARROW INT IN FROM FAIL EQUAL EOF END ELSE DOWNTO DOT DO DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_reasonable_expression) = WITH VAL TO THEN SEMI RPAREN RBRACE OPEN IN FROM EOF END ELSE DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_parenthetic_type) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE OPEN LPAREN LIDENT IN FROM FOR FACT EQUAL EOF END EMPTY ELSE DYNAMIC DOWNTO DO DBLARROW DATA COMMA COLON BELOW BAR ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_normal_type_no_adopts) = VAL OPEN IN EOF DATA BAR AND ALIAS ADOPTS ABSTRACT
follow(raw_normal_type) = WITNESS WITH WHILE VAL TO THEN STAR SEMI RPAREN RBRACKET RBRACE OPEN IN FROM FOR EQUAL EOF END ELSE DOWNTO DO DATA COMMA COLON BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_normal_pattern) = SEMI RPAREN RBRACE LPAREN LBRACKET EXCLUSIVE EQUAL DUPLICABLE COLON AS ARROW
follow(raw_loose_type) = WITNESS WITH WHILE VAL TO THEN STAR SEMI RPAREN RBRACE OPEN IN FROM FOR EOF END ELSE DOWNTO DO DATA COMMA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_loose_pattern) = SEMI RPAREN RBRACE COLON
follow(raw_fragile_expression) = WITH VAL TO THEN RPAREN OPEN IN FROM EOF END DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_fat_type) = WHILE VAL RPAREN OPEN IN FOR EOF DATA BAR AND ALIAS ABSTRACT
follow(raw_consumes_type) = WITNESS WITH WHILE VAL TO THEN STAR SEMI RPAREN RBRACE OPEN IN FROM FOR EOF END ELSE DOWNTO DO DATA COMMA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(raw_atomic_type) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE OPEN LPAREN LIDENT IN FROM FOR FACT EQUAL EOF END EMPTY ELSE DYNAMIC DOWNTO DO DBLARROW DATA COMMA COLON BELOW BAR ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_atomic_pattern) = SEMI RPAREN RBRACE LPAREN LBRACKET EXCLUSIVE EQUAL DUPLICABLE COMMA COLON AS ARROW
follow(raw_atomic_expression) = WITH VAL UIDENT TO THEN STAR SEMI RPAREN RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LARROW INT IN FROM FAIL EQUAL EOF END ELSE DOWNTO DOT DO DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_application_expression) = WITH VAL UIDENT TO THEN STAR SEMI RPAREN RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET INT IN FROM FAIL EQUAL EOF END ELSE DOWNTO DO DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AND ALIAS ADOPTS ABSTRACT ABOVE
follow(raw_algebraic_expression) = WITH VAL TO THEN STAR SEMI RPAREN RBRACE PLUS OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS IN FROM EQUAL EOF END ELSE DOWNTO DO DATA COMMA COLONEQUAL COLON BELOW BAR AND ALIAS ADOPTS ABSTRACT ABOVE
follow(range) = PLUS MINUS EOF AT
follow(parenthesized_tuple_components) = RPAREN END
follow(optional_preserving) = WHILE FOR
follow(option(preceded(ADOPTS,arbitrary_type))) = VAL OPEN IN EOF DATA AND ALIAS ABSTRACT
follow(nonempty_list(warn_error)) = EOF
follow(mode) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT EMPTY DYNAMIC
follow(maybe_qualified(variable)) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LARROW INT IN FROM FOR FAIL FACT EQUAL EOF END EMPTY ELSE DYNAMIC DOWNTO DOT DO DBLARROW DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AT ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(maybe_qualified(datacon)) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LBRACE LARROW INT IN FROM FOR FAIL FACT EXCLUSIVE EQUAL EOF END EMPTY ELSE DYNAMIC DUPLICABLE DOWNTO DOT DO DBLARROW DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AS ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(loption(type_parameters)) = LPAREN EXCLUSIVE DUPLICABLE
follow(loption(separated_nonempty_list(AND,definition))) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
follow(list(terminated(mode_constraint,DBLARROW))) = LPAREN
follow(list(interface_item)) = EOF
follow(list(implementation_item)) = EOF
follow(list(fact)) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
follow(list(atomic_type_binding_with_variance)) = VAL OPEN IN FACT EQUAL EOF DATA COLON ALIAS ABSTRACT
follow(interface_item) = VAL OPEN EOF DATA ALIAS ABSTRACT
follow(interface) = #
follow(implementation_item) = VAL OPEN EOF DATA ALIAS ABSTRACT
follow(implementation) = #
follow(generic_datacon_application(right_flexible_list(SEMI,data_field_pattern))) = SEMI RPAREN RBRACE LPAREN LBRACKET EXCLUSIVE EQUAL DUPLICABLE COMMA COLON AS ARROW
follow(generic_datacon_application(right_flexible_list(SEMI,data_field_expression))) = WITH VAL UIDENT TO THEN STAR SEMI RPAREN RBRACE PLUS OPPREFIX OPINFIX4 OPINFIX3 OPINFIX2 OPINFIX1 OPINFIX0d OPINFIX0c OPINFIX0b OPINFIX0a OPEN MINUS MATCH LPAREN LIDENT LBRACKET LARROW INT IN FROM FAIL EQUAL EOF END ELSE DOWNTO DOT DO DATA COMMA COLONEQUAL COLON BELOW BEGIN BAR AND ALIAS ADOPTS ABSTRACT ABOVE
follow(generic_datacon_application(data_type_def_branch_content)) = WITNESS WITH WHILE VAL UNKNOWN UNDERSCORE UIDENT TO THEN STAR SEMI RPAREN RBRACKET RBRACE OPEN LPAREN LIDENT IN FROM FOR FACT EQUAL EOF END EMPTY ELSE DYNAMIC DOWNTO DO DBLARROW DATA COMMA COLON BELOW BAR ARROW AND ALIAS ADOPTS ABSTRACT ABOVE
follow(flag) = INT
follow(fact) = VAL OPEN IN FACT EOF DATA ALIAS ABSTRACT
follow(explain) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT LET INT IF GIVE FUN FOR FAIL BEGIN ASSERT
follow(existential_quantifiers) = UNKNOWN UNDERSCORE UIDENT LPAREN LIDENT LBRACKET LBRACE EXCLUSIVE EQUAL EMPTY DYNAMIC DUPLICABLE
follow(direction) = WHILE UIDENT TAKING TAKE TAGOF PRESERVING PACK OPPREFIX MINUS MATCH LPAREN LIDENT LET INT IF GIVE FUN FOR FAIL BEGIN ASSERT
follow(definition_group) = VAL OPEN EOF DATA ALIAS ABSTRACT
follow(definition) = VAL OPEN IN EOF DATA AND ALIAS ABSTRACT
follow(data_type_def_branch_content) = RBRACE
follow(data_field_pattern) = SEMI RBRACE
follow(data_field_expression) = SEMI RBRACE
follow(data_field_def) = SEMI RBRACE BAR
follow(concrete_data_type_def) = VAL OPEN IN EOF DATA AND ALIAS ABSTRACT
follow(atomic_type_binding_with_variance) = VAL PLUS OPEN MINUS LPAREN LIDENT IN FACT EQUAL EOF DATA COLON ALIAS ABSTRACT
follow(atomic_type_binding) = VAL RPAREN RBRACKET RBRACE PLUS OPEN MINUS LPAREN LIDENT IN FACT EQUAL EOF DATA COMMA COLON ALIAS ABSTRACT
follow(atomic_kind) = VAL RPAREN RBRACKET RBRACE OPEN IN FACT EQUAL EOF DATA COMMA ALIAS ABSTRACT
follow(anonymous_function) = WITH VAL TO THEN RPAREN OPEN IN FROM EOF END DOWNTO DO DATA BELOW BAR AND ALIAS ABSTRACT ABOVE
follow(abstract_data_type_def) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
follow(abbreviation_def) = VAL OPEN IN EOF DATA ALIAS ABSTRACT
Built an LR(0) automaton with 504 states.
The grammar is not SLR(1) -- 27 states have a conflict.
The construction mode is no-pager.
Built an LR(1) automaton with 4843 states.
1970 shift/reduce conflicts were silently solved.
1983 out of 4843 states have a default reduction.
1514 out of 4843 states are represented.
69 out of 174 symbols keep track of their start position.
92 out of 174 symbols keep track of their end position.
104 out of 259 productions exploit shiftreduce optimization.
0 out of 4843 states can peek at an error.
10036 functions before inlining, 1616 functions after inlining.
