%{

open Kind
open SurfaceSyntax
open ParserUtils

%}
%start implementation
%start interface
%start warn_error_list
%token ABOVE
%token ABSTRACT
%token ADOPTS
%token ALIAS
%token AND
%token ARROW
%token AS
%token ASSERT
%token AT
%token BAR
%token BEGIN
%token BELOW
%token BUILTIN
%token COLON
%token COLONCOLON
%token <string> COLONEQUAL
%token COMMA
%token CONSUMES
%token DATA
%token DBLARROW
%token DO
%token DOT
%token DOWNTO
%token DUPLICABLE
%token DYNAMIC
%token ELSE
%token EMPTY
%token END
%token EOF
%token <string> EQUAL
%token EXCLUSIVE
%token EXPLAIN
%token FACT
%token FAIL
%token FLEX
%token FOR
%token FROM
%token FUN
%token GIVE
%token IF
%token IN
%token <int> INT
%token LARROW
%token LBRACE
%token LBRACKET
%token LET
%token <string> LIDENT
%token LPAREN
%token MATCH
%token <string> MINUS
%token MUTABLE
%token OPEN
%token <string> OPINFIX0a
%token <string> OPINFIX0b
%token <string> OPINFIX0c
%token <string> OPINFIX0d
%token <string> OPINFIX1
%token <string> OPINFIX2
%token <string> OPINFIX3
%token <string> OPINFIX4
%token <string> OPPREFIX
%token PACK
%token PERM
%token <string> PLUS
%token PRESERVING
%token RBRACE
%token RBRACKET
%token REC
%token RPAREN
%token SEMI
%token <string> STAR
%token TAGOF
%token TAKE
%token TAKING
%token THEN
%token TO
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token UNKNOWN
%token VAL
%token VALUE
%token WHILE
%token WITH
%token WITNESS
%nonassoc THEN
%nonassoc ELSE
%nonassoc ADOPTS
%nonassoc COLONEQUAL
%left OPINFIX0a
%left OPINFIX0b
%left EQUAL OPINFIX0c
%left OPINFIX0d
%right OPINFIX1
%left MINUS OPINFIX2 PLUS
%left OPINFIX3 STAR
%right OPINFIX4
%type <SurfaceSyntax.implementation> implementation
%type <SurfaceSyntax.interface> interface
%type <(ClFlags.flag * (int * int)) list> warn_error_list
%%

option_preceded_ADOPTS_arbitrary_type__:
  
    {    ( None )}
| _1 = ADOPTS x = raw_fat_type
    {let x =
  let x =
    let ty =
      let ty =
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
        ( ty )
    in
        ( ty )
  in
      ( x )
in
    ( Some x )}

loption_separated_nonempty_list_AND_definition__:
  
    {    ( [] )}
| x = separated_nonempty_list_AND_definition_
    {    ( x )}

loption_type_parameters_:
  
    {    ( [] )}
| x = type_parameters
    {    ( x )}

list_atomic_type_binding_with_variance_:
  
    {    ( [] )}
| x = atomic_type_binding_with_variance xs = list_atomic_type_binding_with_variance_
    {    ( x :: xs )}

list_fact_:
  
    {    ( [] )}
| x = fact xs = list_fact_
    {    ( x :: xs )}

list_implementation_item_:
  
    {    ( [] )}
| x = implementation_item xs = list_implementation_item_
    {    ( x :: xs )}

list_interface_item_:
  
    {    ( [] )}
| x = interface_item xs = list_interface_item_
    {    ( x :: xs )}

list_terminated_mode_constraint_DBLARROW__:
  
    {    ( [] )}
| m = mode x = raw_atomic_type _2 = DBLARROW xs = list_terminated_mode_constraint_DBLARROW__
    {let x =
  let x =
    let t =
      let ty =
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( x )
in
    ( x :: xs )}

nonempty_list_warn_error_:
  x = warn_error
    {    ( [ x ] )}
| x = warn_error xs = nonempty_list_warn_error_
    {    ( x :: xs )}

separated_nonempty_list_AND_concrete_data_type_def_:
  x = concrete_data_type_def
    {    ( [ x ] )}
| x = concrete_data_type_def _2 = AND xs = separated_nonempty_list_AND_concrete_data_type_def_
    {    ( x :: xs )}

separated_nonempty_list_AND_definition_:
  x = definition
    {    ( [ x ] )}
| x = definition _2 = AND xs = separated_nonempty_list_AND_definition_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_algebraic_expression_:
  x = raw_algebraic_expression
    {let x =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( [ x ] )}
| x = raw_algebraic_expression _2 = COMMA xs = separated_nonempty_list_COMMA_algebraic_expression_
    {let x =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_atomic_pattern_:
  x = raw_atomic_pattern
    {let x =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( [ x ] )}
| x = raw_atomic_pattern _2 = COMMA xs = separated_nonempty_list_COMMA_atomic_pattern_
    {let x =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_consumes_type_:
  x = raw_consumes_type
    {let x =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( [ x ] )}
| x = raw_consumes_type _2 = COMMA xs = separated_nonempty_list_COMMA_consumes_type_
    {let x =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_type_application_component_:
  x = type_application_component
    {    ( [ x ] )}
| x = type_application_component _2 = COMMA xs = separated_nonempty_list_COMMA_type_application_component_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_variable_:
  x = variable
    {    ( [ x ] )}
| x = variable _2 = COMMA xs = separated_nonempty_list_COMMA_variable_
    {    ( x :: xs )}

separated_nonempty_list_DBLARROW_mode_constraint_:
  m = mode x = raw_atomic_type
    {let x =
  let t =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
    ( [ x ] )}
| m = mode x = raw_atomic_type _2 = DBLARROW xs = separated_nonempty_list_DBLARROW_mode_constraint_
    {let x =
  let t =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
    ( x :: xs )}

variable:
  x = LIDENT
    {      ( Variable.register x )}
| _1 = LPAREN x = OPPREFIX _3 = RPAREN
    {      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX0a _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX0b _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX0c _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX0d _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX1 _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX2 _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX3 _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = OPINFIX4 _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = EQUAL _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = STAR _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = MINUS _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = PLUS _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}
| _1 = LPAREN o = COLONEQUAL _3 = RPAREN
    {let x =       ( o ) in
      ( Variable.register x )}

maybe_qualified_datacon_:
  datacon = UIDENT
    {let x =     ( Datacon.register datacon ) in
    ( Unqualified x )}
| name = LIDENT _2 = COLONCOLON datacon = UIDENT
    {let x =     ( Datacon.register datacon ) in
let m =     ( Module.register name ) in
    ( Qualified (m, x) )}

maybe_qualified_variable_:
  x = variable
    {    ( Unqualified x )}
| name = LIDENT _2 = COLONCOLON x = variable
    {let m =     ( Module.register name ) in
    ( Qualified (m, x) )}

right_flexible_list_COMMA_type_binding_:
  
    {    ( [] )}
| x = type_binding
    {    ( [x] )}
| x = type_binding _2 = COMMA xs = right_flexible_list_COMMA_type_binding_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_def_:
  
    {    ( [] )}
| x = data_field_def
    {    ( [x] )}
| x = data_field_def _2 = SEMI xs = right_flexible_list_SEMI_data_field_def_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_expression_:
  
    {    ( [] )}
| x = data_field_expression
    {    ( [x] )}
| x = data_field_expression _2 = SEMI xs = right_flexible_list_SEMI_data_field_expression_
    {    ( x :: xs )}

right_flexible_list_SEMI_data_field_pattern_:
  
    {    ( [] )}
| x = data_field_pattern
    {    ( [x] )}
| x = data_field_pattern _2 = SEMI xs = right_flexible_list_SEMI_data_field_pattern_
    {    ( x :: xs )}

reverse_left_flexible_list_BAR_data_type_def_branch_:
  
    {    ( [] )}
| x = raw_normal_type_no_adopts
    {let x =
  let t =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =     ( DataTypeFlavor.Immutable ) in
      (
      flavor, t
    )
in
    ( [x] )}
| _1 = MUTABLE x = raw_normal_type_no_adopts
    {let x =
  let t =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =     ( DataTypeFlavor.Mutable ) in
      (
      flavor, t
    )
in
    ( [x] )}
| xs = reverse_left_flexible_list_BAR_data_type_def_branch_ _2 = BAR x = raw_normal_type_no_adopts
    {let x =
  let t =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =     ( DataTypeFlavor.Immutable ) in
      (
      flavor, t
    )
in
    ( x :: xs )}
| xs = reverse_left_flexible_list_BAR_data_type_def_branch_ _2 = BAR _1 = MUTABLE x = raw_normal_type_no_adopts
    {let x =
  let t =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
  let flavor =     ( DataTypeFlavor.Mutable ) in
      (
      flavor, t
    )
in
    ( x :: xs )}

reverse_left_flexible_list_BAR_match_branch_:
  
    {    ( [] )}
| x = raw_normal_pattern _2 = ARROW x_inlined1 = raw_tuple_or_raw_fragile_expression_
    {let x =
  let e =
    let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
    let e =
      let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
          ( e )
    in
        ( e )
  in
  let p =
    let p =
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p, e )
in
    ( [x] )}
| xs = reverse_left_flexible_list_BAR_match_branch_ _2 = BAR x = raw_normal_pattern _2_inlined1 = ARROW x_inlined1 = raw_tuple_or_raw_fragile_expression_
    {let x =
  let e =
    let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
    let e =
      let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
          ( e )
    in
        ( e )
  in
  let p =
    let p =
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p, e )
in
    ( x :: xs )}

type_parameters:
  _1 = LBRACKET bs = right_flexible_list_COMMA_type_binding_ _3 = RBRACKET
    {    ( bs )}

existential_quantifiers:
  _1 = LBRACE bs = right_flexible_list_COMMA_type_binding_ _3 = RBRACE
    {    ( bs )}

atomic_type_binding:
  x = variable
    {let _endpos = _endpos_x_ in
    ( x, KType, (_startpos_x_, _endpos) )}
| _1 = LPAREN b = type_binding _3 = RPAREN
    {    ( b )}

variance:
  _1 = PLUS
    {    ( Covariant )}
| _1 = MINUS
    {    ( Contravariant )}
| 
    {    ( Invariant )}

atomic_type_binding_with_variance:
  v = variance b = atomic_type_binding
    {    ( v, b )}

type_binding:
  b = atomic_type_binding
    {    ( b )}
| x = variable _2 = COLON kind = atomic_kind
    {let kind =     ( kind ) in
let _endpos = _endpos_kind_ in
    ( x, kind, (_startpos_x_, _endpos) )}

atomic_kind:
  _1 = LPAREN kind = atomic_kind _3 = RPAREN
    {let kind =     ( kind ) in
    ( kind )}
| _1 = VALUE
    {    ( KValue )}
| _1 = TYPE
    {    ( KType )}
| _1 = PERM
    {    ( KPerm )}

raw_parenthetic_type:
  _1 = LPAREN _2 = RPAREN
    {    ( TyTuple [] )}
| _1 = LPAREN x = raw_fat_type _3 = RPAREN
    {let ty =
  let ty =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
    ( ty )}

raw_atomic_type:
  ty = raw_parenthetic_type
    {    ( ty )}
| _1 = UNKNOWN
    {    ( TyUnknown )}
| _1 = DYNAMIC
    {    ( TyDynamic )}
| _1 = EMPTY
    {    ( TyEmpty )}
| _1 = UNDERSCORE
    {    ( TyWildcard )}
| x = maybe_qualified_variable_
    {let x =     ( TyVar x ) in
    ( x )}
| dfs = generic_datacon_application_data_type_def_branch_content_
    {let b =     ( dfs ) in
let (_endpos_b_, _startpos_b_) = (_endpos_dfs_, _startpos_dfs_) in
let _endpos = _endpos_b_ in
    ( mk_concrete (_startpos_b_, _endpos) b None )}

raw_tight_type:
  ty = raw_atomic_type
    {    ( ty )}
| _1 = EQUAL x = maybe_qualified_variable_
    {let x =     ( TyVar x ) in
    ( TySingleton x )}
| x = raw_tight_type x_inlined1 = raw_atomic_type
    {let ty =
  let ty2 =
    let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
  let ty1 =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( mktyapp ty1 ty2 )
in
    ( ty )}

raw_normal_type_no_adopts:
  ty = raw_tight_type
    {let x =     ( ty ) in
    ( x )}
| x = raw_tight_type _2 = ARROW ty2 = raw_normal_type_no_adopts
    {let x =
  let ty1 =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( TyArrow (ty1, ty2) )
in
    ( x )}
| bs = type_parameters ty = raw_normal_type_no_adopts
    {let x =     ( List.fold_right (fun b ty -> TyForall (b, ty)) bs ty ) in
    ( x )}
| bs = existential_quantifiers ty = raw_normal_type_no_adopts
    {let x =     ( List.fold_right (fun b ty -> TyExists (b, ty)) bs ty ) in
    ( x )}
| m = mode x = raw_atomic_type _2 = DBLARROW ty = raw_normal_type_no_adopts
    {let x =
  let c =
    let t =
      let ty =
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( TyImply (c, ty) )
in
    ( x )}

raw_normal_type:
  ty = raw_tight_type
    {let t =     ( ty ) in
    ( t )}
| x = raw_tight_type _2 = ARROW ty2 = raw_normal_type
    {let t =
  let ty1 =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( TyArrow (ty1, ty2) )
in
    ( t )}
| bs = type_parameters ty = raw_normal_type
    {let t =     ( List.fold_right (fun b ty -> TyForall (b, ty)) bs ty ) in
    ( t )}
| bs = existential_quantifiers ty = raw_normal_type
    {let t =     ( List.fold_right (fun b ty -> TyExists (b, ty)) bs ty ) in
    ( t )}
| m = mode x = raw_atomic_type _2 = DBLARROW ty = raw_normal_type
    {let t =
  let c =
    let t =
      let ty =
        let _endpos = _endpos_x_ in
            ( TyLocated (x, (_startpos_x_, _endpos)) )
      in
          ( ty )
    in
        ( m, t )
  in
      ( TyImply (c, ty) )
in
    ( t )}
| dfs = generic_datacon_application_data_type_def_branch_content_ _2 = ADOPTS t = raw_normal_type
    {let b =     ( dfs ) in
let _startpos_b_ = _startpos_dfs_ in
let _endpos = _endpos_t_ in
    ( mk_concrete (_startpos_b_, _endpos) b (Some t) )}

raw_loose_type:
  ty = raw_normal_type
    {    ( ty )}
| x = maybe_qualified_variable_ _2 = AT x_inlined1 = raw_normal_type
    {let ty =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let x =     ( TyVar x ) in
    ( TyAnchoredPermission (x, ty) )}
| x = maybe_qualified_variable_ _2 = EQUAL x_inlined1 = maybe_qualified_variable_
    {let y =
  let x = x_inlined1 in
      ( TyVar x )
in
let x =     ( TyVar x ) in
    ( TyAnchoredPermission (x, TySingleton y) )}
| x = variable _2 = COLON x_inlined1 = raw_normal_type
    {let ty =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyNameIntro (x, ty) )}
| _1 = UNDERSCORE _2 = COLON x = raw_normal_type
    {let ty =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( ty )}

raw_consumes_type:
  ty = raw_loose_type
    {    ( ty )}
| _1 = CONSUMES x = raw_loose_type
    {let ty =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyConsumes ty )}

raw_very_loose_type:
  ty = raw_consumes_type
    {    ( ty )}
| x = raw_consumes_type _2 = STAR x_inlined1 = raw_very_loose_type
    {let ty2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let ty1 =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyStar (ty1, ty2) )}
| x = raw_consumes_type _2 = COMMA x2 = separated_nonempty_list_COMMA_consumes_type_
    {let tcs =
  let x1 =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( x1 :: x2 )
in
    ( TyTuple tcs )}

raw_fat_type:
  ty = raw_very_loose_type
    {    ( ty )}
| x = raw_fat_type _2 = BAR x_inlined1 = raw_very_loose_type
    {let ty2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let ty1 =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
    ( ty )
in
    ( TyBar (ty1, ty2) )}
| _1 = BAR x = raw_very_loose_type
    {let ty2 =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( TyBar (TyTuple [], ty2) )}
| x = raw_fat_type _2 = BAR m = mode x_inlined1 = raw_atomic_type
    {let c =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let t =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
        ( ty )
  in
      ( m, t )
in
let ty =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
    ( ty )
in
    ( TyAnd (c, ty) )}

mode:
  _1 = EXCLUSIVE
    {    ( Mode.ModeExclusive )}
| _1 = DUPLICABLE
    {    ( Mode.ModeDuplicable )}

generic_datacon_application_data_type_def_branch_content_:
  d = maybe_qualified_datacon_
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, [] )
in
    ( x )}
| d = maybe_qualified_datacon_ _2 = LBRACE y = data_type_def_branch_content _4 = RBRACE
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, y )
in
    ( x )}

generic_datacon_application_right_flexible_list_SEMI_data_field_expression__:
  d = maybe_qualified_datacon_
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, [] )
in
    ( x )}
| d = maybe_qualified_datacon_ _2 = LBRACE y = right_flexible_list_SEMI_data_field_expression_ _4 = RBRACE
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, y )
in
    ( x )}

generic_datacon_application_right_flexible_list_SEMI_data_field_pattern__:
  d = maybe_qualified_datacon_
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, [] )
in
    ( x )}
| d = maybe_qualified_datacon_ _2 = LBRACE y = right_flexible_list_SEMI_data_field_pattern_ _4 = RBRACE
    {let x =
  let x =     ( mk_datacon_reference d ) in
      ( x, y )
in
    ( x )}

data_field_def:
  fs = separated_nonempty_list_COMMA_variable_ _2 = COLON x = raw_normal_type
    {let ty =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( List.map (fun f -> `FieldValue (f, ty)) fs )}
| fs = separated_nonempty_list_COMMA_variable_ _2 = COLONCOLON x = raw_normal_type
    {let ty =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( List.map (fun f -> `FieldBindingValue (f, ty)) fs )}
| f = variable _2 = EQUAL x = maybe_qualified_variable_
    {let y =     ( TyVar x ) in
    ( [ `FieldValue (f, TySingleton y) ] )}
| f = variable
    {    ( [ `FieldValue (f, TySingleton (TyVar (Unqualified f))) ] )}

data_type_def_branch_content:
  fss = right_flexible_list_SEMI_data_field_def_
    {let fs =     ( List.flatten fss ) in
    ( fs )}
| fss = right_flexible_list_SEMI_data_field_def_ _2 = BAR x = raw_very_loose_type
    {let perm =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let fs =     ( List.flatten fss ) in
    ( fs @ [ `FieldPermission perm ] )}

fact:
  _1 = FACT cs = separated_nonempty_list_DBLARROW_mode_constraint_
    {    ( match List.rev cs with goal :: hypotheses -> Fact (List.rev hypotheses, goal) | [] -> assert false )}

concrete_data_type_def:
  x = variable ys = list_atomic_type_binding_with_variance_ _3 = EQUAL xs = reverse_left_flexible_list_BAR_data_type_def_branch_ a = option_preceded_ADOPTS_arbitrary_type__
    {let rhs =
  let bs =     ( List.rev xs ) in
      ( bs )
in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
let flavor =     ( DataTypeFlavor.Immutable ) in
    ( { lhs = lhs KType; rhs = Concrete (flavor, rhs, a) } )}
| _1 = MUTABLE x = variable ys = list_atomic_type_binding_with_variance_ _3 = EQUAL xs = reverse_left_flexible_list_BAR_data_type_def_branch_ a = option_preceded_ADOPTS_arbitrary_type__
    {let rhs =
  let bs =     ( List.rev xs ) in
      ( bs )
in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
let flavor =     ( DataTypeFlavor.Mutable ) in
    ( { lhs = lhs KType; rhs = Concrete (flavor, rhs, a) } )}

abstract_data_type_def:
  x = variable ys = list_atomic_type_binding_with_variance_ facts = list_fact_
    {let k =     ( KType ) in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
    ( { lhs = lhs k; rhs = Abstract facts } )}
| x = variable ys = list_atomic_type_binding_with_variance_ _1 = COLON kind = atomic_kind facts = list_fact_
    {let k =
  let k =     ( kind ) in
      ( k )
in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
    ( { lhs = lhs k; rhs = Abstract facts } )}

abbreviation_def:
  x = variable ys = list_atomic_type_binding_with_variance_ _3 = EQUAL x_inlined1 = raw_fat_type
    {let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let k =     ( KType ) in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
    ( { lhs = lhs k; rhs = Abbrev t } )}
| x = variable ys = list_atomic_type_binding_with_variance_ _1 = COLON kind = atomic_kind _3 = EQUAL x_inlined1 = raw_fat_type
    {let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let k =
  let k =     ( kind ) in
      ( k )
in
let lhs =     ( (* A little hack: we don't know the kind yet, so we abstract over it. *)
      fun kind ->
        (x, kind, (_startpos_x_, _endpos_x_)),
        ys
    ) in
    ( { lhs = lhs k; rhs = Abbrev t } )}

raw_atomic_pattern:
  _1 = LPAREN _2 = RPAREN
    {    ( PTuple [] )}
| _1 = LPAREN x = raw_loose_pattern _3 = RPAREN
    {let p =
  let p =
    let p =
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p )
in
    ( p )}
| xys = generic_datacon_application_right_flexible_list_SEMI_data_field_pattern__
    {let dc =     ( xys ) in
    ( PConstruct dc )}
| x = variable
    {    ( PVar x )}
| _1 = UNDERSCORE
    {    ( PAny )}

data_field_pattern:
  f = variable _2 = EQUAL x = raw_loose_pattern
    {let p =
  let p =
    let p =
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( p )
in
    ( f, p )}
| f = variable
    {    ( f, PVar f )}

raw_normal_pattern:
  p = raw_atomic_pattern
    {    ( p )}
| x = raw_atomic_pattern _2 = COMMA x2 = separated_nonempty_list_COMMA_atomic_pattern_
    {let ps =
  let x1 =
    let p =
      let _endpos = _endpos_x_ in
          ( PLocated (x, (_startpos_x_, _endpos)) )
    in
        ( p )
  in
      ( x1 :: x2 )
in
    ( PTuple ps )}
| x = raw_normal_pattern _2 = AS v = variable
    {let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PAs (p, v) )}

raw_loose_pattern:
  p = raw_normal_pattern
    {    ( p )}
| x = raw_loose_pattern _2 = COLON x_inlined1 = raw_normal_type
    {let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t) )}

raw_atomic_expression:
  o = OPPREFIX x = raw_atomic_expression
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkprefix o e )}
| x = maybe_qualified_variable_
    {let v =     ( EVar x ) in
    ( v )}
| i = INT
    {    ( EInt i )}
| _1 = FAIL
    {    ( EFail )}
| xys = generic_datacon_application_right_flexible_list_SEMI_data_field_expression__
    {let dc =     ( xys ) in
    ( EConstruct dc )}
| _1 = MATCH b = explain x = raw_tuple_or_raw_fragile_expression_ _4 = WITH xs = reverse_left_flexible_list_BAR_match_branch_ _6 = END
    {let bs =     ( List.rev xs ) in
let e =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( EMatch (b, e, bs) )}
| _1 = LPAREN _2 = RPAREN
    {    ( ETuple [] )}
| _1 = LPAREN es = parenthesized_tuple_components _3 = RPAREN
    {    ( match es with [ e ] -> e | _ -> ETuple es )}
| _1 = BEGIN es = parenthesized_tuple_components _3 = END
    {    ( match es with [ e ] -> e | _ -> ETuple es )}

parenthesized_tuple_components:
  x = raw_fragile_expression
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( [ e ] )}
| x = raw_algebraic_expression _2 = COMMA e2 = parenthesized_tuple_components
    {let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( e1 :: e2 )}

data_field_expression:
  f = variable _2 = EQUAL e = reasonable_expression
    {    ( f, e )}
| f = variable
    {    ( f, EVar (Unqualified f) )}

explain:
  
    {    ( false )}
| _1 = EXPLAIN
    {    ( true )}

raw_tight_expression:
  x = raw_tight_expression _2 = DOT f = variable
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EAccess (e, mk_field f) )}
| a = raw_atomic_expression
    {    ( a )}

raw_application_expression:
  x = raw_application_expression x_inlined1 = raw_tight_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EApply (e1, e2) )}
| x = raw_application_expression _2 = LBRACKET ts = separated_nonempty_list_COMMA_type_application_component_ _4 = RBRACKET
    {let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( ETApply (e1, ts) )}
| e = raw_tight_expression
    {    ( e )}

type_application_component:
  x = raw_normal_type
    {let t =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( Ordered t )}
| v = variable _2 = EQUAL x = raw_normal_type
    {let t =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( Named (v, t) )}

raw_algebraic_expression:
  x = raw_algebraic_expression o = OPINFIX0a x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX0b x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX0c x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX0d x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX1 x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX2 x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX3 x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = OPINFIX4 x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = EQUAL x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = STAR x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = MINUS x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = PLUS x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| x = raw_algebraic_expression o = COLONEQUAL x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let o =       ( o ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix e1 o e2 )}
| _1 = MINUS x = raw_application_expression
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( mkinfix (EInt 0) "-" e )}
| x = raw_algebraic_expression _2 = ADOPTS x_inlined1 = raw_algebraic_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EOwns (e1, e2) )}
| e = raw_application_expression
    {    ( e )}

raw_tuple_or_raw_fragile_expression_:
  x = raw_algebraic_expression _2 = COMMA x2 = separated_nonempty_list_COMMA_algebraic_expression_
    {let es =
  let x1 =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( x1 :: x2 )
in
    ( ETuple es )}
| e = raw_fragile_expression
    {    ( e )}

raw_tuple_or_raw_reasonable_expression_:
  x = raw_algebraic_expression _2 = COMMA x2 = separated_nonempty_list_COMMA_algebraic_expression_
    {let es =
  let x1 =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( x1 :: x2 )
in
    ( ETuple es )}
| e = raw_reasonable_expression
    {    ( e )}

reasonable_expression:
  x = raw_reasonable_expression
    {let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
    ( e )}

raw_reasonable_expression:
  _1 = IF b = explain x = raw_tuple_or_raw_fragile_expression_ _4 = THEN x_inlined1 = raw_tuple_or_raw_reasonable_expression_
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( EIfThenElse (b, e1, e2, ETuple []) )}
| _1 = IF b = explain x = raw_tuple_or_raw_fragile_expression_ _4 = THEN x_inlined1 = raw_tuple_or_raw_reasonable_expression_ _6 = ELSE x_inlined2 = raw_tuple_or_raw_reasonable_expression_
    {let e3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined2_, _startpos_x_inlined2_, x_inlined2) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( EIfThenElse (b, e1, e2, e3) )}
| p = optional_preserving _2 = WHILE x = raw_tuple_or_raw_fragile_expression_ _4 = DO e2 = reasonable_expression
    {let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( EWhile (p, e1, e2) )}
| p = optional_preserving _2 = FOR x = variable _4 = EQUAL x_inlined1 = raw_tuple_or_raw_fragile_expression_ f = direction x_inlined2 = raw_tuple_or_raw_fragile_expression_ _8 = DO e = reasonable_expression
    {let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined2_, _startpos_x_inlined2_, x_inlined2) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let e1 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let x =
  let _endpos = _endpos_x_ in
      ( x, KValue, (_startpos_x_, _endpos) )
in
    ( EFor (p, x, e1, f, e2, e) )}
| x = raw_tight_expression _2 = DOT f = variable _4 = LARROW e2 = reasonable_expression
    {let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EAssign (e1, mk_field f, e2) )}
| _1 = TAGOF x = raw_tight_expression _3 = LARROW d = maybe_qualified_datacon_
    {let d =     ( mk_datacon_reference d ) in
let e1 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EAssignTag (e1, d, mk_tag_update_info ()) )}
| _1 = TAKE x = raw_tuple_or_raw_fragile_expression_ _3 = FROM e2 = reasonable_expression
    {let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( ETake (e1, e2) )}
| _1 = GIVE x = raw_tuple_or_raw_fragile_expression_ _3 = TO e2 = reasonable_expression
    {let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    ( EGive (e1, e2) )}
| taking = TAKING x = raw_tuple_or_raw_fragile_expression_ _3 = FROM x_inlined1 = raw_tight_expression _5 = BEGIN x_inlined2 = raw_tuple_or_raw_fragile_expression_ fin = END
    {let e =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined2_, _startpos_x_inlined2_, x_inlined2) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let e2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let _endpos_e2_ = _endpos_x_inlined1_ in
let e1 =
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
    (
      taking; fin; (* avoid ocaml warnings about unused variables *)
      let eval_e1, v1 = name "adoptee" e1
      and eval_e2, v2 = name "adopter" e2
      and eval_e , v  = name "result"  e in
      eval_e1 (
      eval_e2 (
      ESequence (
      ELocated (ETake (v1, v2), (_startpos_taking_, _endpos_e2_)),
      eval_e (
      ESequence (
      ELocated (EGive (v1, v2), (_startpos_fin_, _endpos_fin_)),
      v
      )))))
    )}
| _1 = ASSERT x = raw_very_loose_type
    {let t =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( EAssert t )}
| _1 = PACK x = raw_very_loose_type _3 = WITNESS x_inlined1 = raw_very_loose_type
    {let t2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let t1 =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
    ( EPack (t1, t2) )}
| x = raw_algebraic_expression _2 = COLON x_inlined1 = raw_very_loose_type
    {let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( EConstraint (e, t) )}
| e = raw_algebraic_expression
    {    ( e )}

optional_preserving:
  _1 = PRESERVING x = raw_fat_type
    {let p =
  let ty =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
    ( p )}
| 
    {    ( TyEmpty )}

raw_fragile_expression:
  e1 = reasonable_expression _2 = SEMI x = raw_tuple_or_raw_fragile_expression_
    {let e2 =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( ESequence (e1, e2) )}
| e1 = reasonable_expression _2 = SEMI
    {    ( e1 )}
| _1 = LET flag = rec_flag xs = loption_separated_nonempty_list_AND_definition__ _3 = IN x = raw_tuple_or_raw_fragile_expression_
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let flag_defs =
  let defs =     ( xs ) in
      ( flag, defs )
in
    ( let flag, defs = flag_defs in ELet (flag, defs, e) )}
| _1 = LET _2 = FLEX v = type_binding _4 = IN x = raw_tuple_or_raw_fragile_expression_
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
    ( ELetFlex (v, e) )}
| _1 = LET _1_inlined1 = DATA defs = separated_nonempty_list_AND_concrete_data_type_def_ _3 = IN x = raw_tuple_or_raw_fragile_expression_
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let d =
  let _endpos = _endpos_defs_ in
      ( (_startpos_defs_, _endpos), Recursive, defs )
in
    ( ELocalType (d, e) )}
| _1 = LET _1_inlined1 = ABSTRACT def = abstract_data_type_def _3 = IN x = raw_tuple_or_raw_fragile_expression_
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let d =
  let _endpos = _endpos_def_ in
      ( (_startpos_def_, _endpos), Nonrecursive, [def] )
in
    ( ELocalType (d, e) )}
| _1 = LET _1_inlined1 = ALIAS def = abbreviation_def _3 = IN x = raw_tuple_or_raw_fragile_expression_
    {let e =
  let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
      ( e )
in
let d =
  let _endpos = _endpos_def_ in
      ( (_startpos_def_, _endpos), Nonrecursive, [def] )
in
    ( ELocalType (d, e) )}
| _1 = FUN e = anonymous_function
    {    ( e )}
| e = raw_reasonable_expression
    {    ( e )}

rec_flag:
  _1 = REC
    {    ( Recursive )}
| 
    {    ( Nonrecursive )}

direction:
  _1 = TO
    {    ( To )}
| _1 = DOWNTO
    {    ( Downto )}
| _1 = BELOW
    {    ( Below )}
| _1 = ABOVE
    {    ( Above )}

definition:
  x = raw_normal_pattern _2 = EQUAL x_inlined1 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( p, e )}
| x = raw_normal_pattern _2 = COLON x_inlined1 = raw_normal_type _4 = EQUAL x_inlined2 = raw_tuple_or_raw_fragile_expression_
    {let e =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined2_, _startpos_x_inlined2_, x_inlined2) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t), e )}
| x = raw_normal_pattern e = anonymous_function
    {let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( p, e )}
| x = raw_normal_pattern _2 = COLON x_inlined1 = raw_normal_type _4 = EQUAL bb = BUILTIN b = LIDENT
    {let t =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let p =
  let p =
    let _endpos = _endpos_x_ in
        ( PLocated (x, (_startpos_x_, _endpos)) )
  in
      ( p )
in
    ( PConstraint (p, t), ELocated (EBuiltin b, (_startpos_bb_, _endpos_bb_)) )}

anonymous_function:
  type_parameters = loption_type_parameters_ cs = list_terminated_mode_constraint_DBLARROW__ x = raw_parenthetic_type _4 = COLON x_inlined1 = raw_normal_type _6 = EQUAL x_inlined2 = raw_tuple_or_raw_fragile_expression_
    {let body =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined2_, _startpos_x_inlined2_, x_inlined2) in
  let e =
    let e =     ( ELocated (x, (_startpos_x_, _endpos_x_)) ) in
        ( e )
  in
      ( e )
in
let result =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let formal =
  let ty =
    let _endpos = _endpos_x_ in
        ( TyLocated (x, (_startpos_x_, _endpos)) )
  in
      ( ty )
in
let (_endpos_formal_, _startpos_formal_) = (_endpos_x_, _startpos_x_) in
    ( let formal = List.fold_right (fun c ty -> TyAnd (c, ty)) cs formal in
      let formal = TyLocated (formal, (_startpos_formal_, _endpos_formal_)) in
      EFun (type_parameters, formal, result, body) )}

definition_group:
  v = VAL flag = rec_flag xs = loption_separated_nonempty_list_AND_definition__
    {let flag_defs =
  let defs =     ( xs ) in
      ( flag, defs )
in
let _endpos_flag_defs_ = _endpos_xs_ in
let _endpos = _endpos_flag_defs_ in
    ( let flag, defs = flag_defs in
      let loc = (_startpos_v_, _endpos) in
      ValueDefinitions (loc, flag, defs) )}

value_declaration:
  _1 = VAL x = variable _3 = COLON x_inlined1 = raw_fat_type
    {let ty =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let ty =
    let ty =
      let _endpos = _endpos_x_ in
          ( TyLocated (x, (_startpos_x_, _endpos)) )
    in
      ( ty )
  in
      ( ty )
in
let x =
  let _endpos = _endpos_x_ in
      ( x, KValue, (_startpos_x_, _endpos) )
in
    ( ValueDeclaration (x, ty) )}

implementation_item:
  _1 = DATA defs = separated_nonempty_list_AND_concrete_data_type_def_
    {let item =
  let g =
    let _endpos = _endpos_defs_ in
        ( (_startpos_defs_, _endpos), Recursive, defs )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _1 = ABSTRACT def = abstract_data_type_def
    {let item =
  let g =
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _1 = ALIAS def = abbreviation_def
    {let item =
  let g =
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| item = definition_group
    {    ( item )}
| _1 = OPEN name = LIDENT
    {let item =
  let m =     ( Module.register name ) in
      ( OpenDirective m )
in
    ( item )}

implementation:
  items = list_implementation_item_ _2 = EOF
    {    ( items )}

interface_item:
  _1 = DATA defs = separated_nonempty_list_AND_concrete_data_type_def_
    {let item =
  let g =
    let _endpos = _endpos_defs_ in
        ( (_startpos_defs_, _endpos), Recursive, defs )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _1 = ABSTRACT def = abstract_data_type_def
    {let item =
  let g =
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| _1 = ALIAS def = abbreviation_def
    {let item =
  let g =
    let _endpos = _endpos_def_ in
        ( (_startpos_def_, _endpos), Nonrecursive, [def] )
  in
      ( DataTypeGroup g )
in
    ( item )}
| item = value_declaration
    {    ( item )}
| _1 = OPEN name = LIDENT
    {let item =
  let m =     ( Module.register name ) in
      ( OpenDirective m )
in
    ( item )}

interface:
  items = list_interface_item_ _2 = EOF
    {  ( items )}

warn_error_list:
  ws = nonempty_list_warn_error_ _2 = EOF
    {  ( ws )}

warn_error:
  f = flag r = range
    {  ( f, r )}

flag:
  _1 = AT
    {  ( ClFlags.CError )}
| _1 = MINUS
    {  ( ClFlags.CSilent )}
| _1 = PLUS
    {  ( ClFlags.CWarning )}

range:
  i = INT
    {  ( i, i )}
| i = INT _2 = DOT _3 = DOT j = INT
    {  ( i, j )}

%%


