State 0:
## Known stack suffix:
##
## LR(1) items:
modelica_definitions' -> . modelica_definitions [ # ]
## Transitions:
-- On FINAL shift to state 1
-- On type_prefix shift to state 2
-- On modelica_definitions shift to state 285
-- On flag(FINAL) shift to state 286
-- On component_clauses shift to state 289
-- On component_clause shift to state 291
## Reductions:
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->

State 1:
## Known stack suffix:
## FINAL
## LR(1) items:
flag(FINAL) -> FINAL . [ TYPE STREAM REPLACEABLE RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW EXPANDABLE ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production flag(FINAL) -> FINAL

State 2:
## Known stack suffix:
## type_prefix
## LR(1) items:
component_clause -> type_prefix . type_expression separated_nonempty_list(COMMA,declaration) option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 184
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 3:
## Known stack suffix:
## STREAM
## LR(1) items:
connectivity -> STREAM . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production connectivity -> STREAM

State 4:
## Known stack suffix:
## PARAMETER
## LR(1) items:
variability -> PARAMETER . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variability -> PARAMETER

State 5:
## Known stack suffix:
## OUTPUT
## LR(1) items:
causality -> OUTPUT . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production causality -> OUTPUT

State 6:
## Known stack suffix:
## INPUT
## LR(1) items:
causality -> INPUT . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production causality -> INPUT

State 7:
## Known stack suffix:
## IDENT
## LR(1) items:
ident -> IDENT . [ TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD RBRACE PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LOOP LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IN IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOTTIMES DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production ident -> IDENT

State 8:
## Known stack suffix:
## FLOW
## LR(1) items:
connectivity -> FLOW . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production connectivity -> FLOW

State 9:
## Known stack suffix:
## DOT
## LR(1) items:
type_expression -> DOT . separated_nonempty_list(DOT,ident) [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 10
-- On ident shift to state 11
## Reductions:

State 10:
## Known stack suffix:
## DOT separated_nonempty_list(DOT,ident)
## LR(1) items:
type_expression -> DOT separated_nonempty_list(DOT,ident) . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_expression -> DOT separated_nonempty_list(DOT,ident)

State 11:
## Known stack suffix:
## ident
## LR(1) items:
separated_nonempty_list(DOT,ident) -> ident . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EQ EOF DOTTIMES CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
separated_nonempty_list(DOT,ident) -> ident . DOT separated_nonempty_list(DOT,ident) [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EQ EOF DOTTIMES CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
-- On DOT shift to state 12
## Reductions:
-- On STRING reduce production separated_nonempty_list(DOT,ident) -> ident
-- On SEMICOLON reduce production separated_nonempty_list(DOT,ident) -> ident
-- On RPAREN reduce production separated_nonempty_list(DOT,ident) -> ident
-- On LPAREN reduce production separated_nonempty_list(DOT,ident) -> ident
-- On LBRACKET reduce production separated_nonempty_list(DOT,ident) -> ident
-- On IDENT reduce production separated_nonempty_list(DOT,ident) -> ident
-- On EQ reduce production separated_nonempty_list(DOT,ident) -> ident
-- On EOF reduce production separated_nonempty_list(DOT,ident) -> ident
-- On DOTTIMES reduce production separated_nonempty_list(DOT,ident) -> ident
-- On CONSTRAINEDBY reduce production separated_nonempty_list(DOT,ident) -> ident
-- On COMMA reduce production separated_nonempty_list(DOT,ident) -> ident
-- On COLONEQ reduce production separated_nonempty_list(DOT,ident) -> ident
-- On ANNOTATION reduce production separated_nonempty_list(DOT,ident) -> ident

State 12:
## Known stack suffix:
## ident DOT
## LR(1) items:
separated_nonempty_list(DOT,ident) -> ident DOT . separated_nonempty_list(DOT,ident) [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EQ EOF DOTTIMES CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 13
-- On ident shift to state 11
## Reductions:

State 13:
## Known stack suffix:
## ident DOT separated_nonempty_list(DOT,ident)
## LR(1) items:
separated_nonempty_list(DOT,ident) -> ident DOT separated_nonempty_list(DOT,ident) . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EQ EOF DOTTIMES CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(DOT,ident) -> ident DOT separated_nonempty_list(DOT,ident)

State 14:
## Known stack suffix:
## DISCRETE
## LR(1) items:
variability -> DISCRETE . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variability -> DISCRETE

State 15:
## Known stack suffix:
## CONSTANT
## LR(1) items:
variability -> CONSTANT . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variability -> CONSTANT

State 16:
## Known stack suffix:
## variability
## LR(1) items:
type_expression -> variability . type_expression [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 17
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 17:
## Known stack suffix:
## variability type_expression
## LR(1) items:
type_expression -> variability type_expression . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . array_subscripts [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On LBRACKET shift to state 18
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On STRING reduce production type_expression -> variability type_expression
-- On SEMICOLON reduce production type_expression -> variability type_expression
-- On RPAREN reduce production type_expression -> variability type_expression
-- On LPAREN reduce production type_expression -> variability type_expression
-- On IDENT reduce production type_expression -> variability type_expression
-- On EOF reduce production type_expression -> variability type_expression
-- On CONSTRAINEDBY reduce production type_expression -> variability type_expression
-- On COMMA reduce production type_expression -> variability type_expression
-- On ANNOTATION reduce production type_expression -> variability type_expression

State 18:
## Known stack suffix:
## LBRACKET
## LR(1) items:
array_subscripts -> LBRACKET . loption(separated_nonempty_list(COMMA,expr)) RBRACKET [ STRING SEMICOLON RPAREN LPAREN LBRACKET IF IDENT EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 133
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 175
-- On expr shift to state 116
## Reductions:
-- On RBRACKET reduce production loption(separated_nonempty_list(COMMA,expr)) ->

State 19:
## Known stack suffix:
## TRUE
## LR(1) items:
simple_expr -> TRUE . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> TRUE

State 20:
## Known stack suffix:
## STRING
## LR(1) items:
simple_expr -> STRING . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> STRING

State 21:
## Known stack suffix:
## PLUS
## LR(1) items:
simple_expr -> PLUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 174
## Reductions:

State 22:
## Known stack suffix:
## NOT
## LR(1) items:
simple_expr -> NOT . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 173
## Reductions:

State 23:
## Known stack suffix:
## MINUS
## LR(1) items:
simple_expr -> MINUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 172
## Reductions:

State 24:
## Known stack suffix:
## LPAREN
## LR(1) items:
simple_expr -> LPAREN . expr RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> LPAREN . RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> LPAREN . expr COMMA patterns RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> LPAREN . COMMA patterns RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On RPAREN shift to state 25
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COMMA shift to state 145
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 167
## Reductions:

State 25:
## Known stack suffix:
## LPAREN RPAREN
## LR(1) items:
simple_expr -> LPAREN RPAREN . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LPAREN RPAREN

State 26:
## Known stack suffix:
## LBRACKET
## LR(1) items:
simple_expr -> LBRACKET . separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) shift to state 140
-- On separated_nonempty_list(COMMA,expr) shift to state 142
-- On expr shift to state 116
## Reductions:

State 27:
## Known stack suffix:
## LBRACE
## LR(1) items:
simple_expr -> LBRACE . array_args RBRACE [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 133
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 134
-- On expr shift to state 135
-- On array_args shift to state 138
## Reductions:
-- On RBRACE reduce production loption(separated_nonempty_list(COMMA,expr)) ->

State 28:
## Known stack suffix:
## INT
## LR(1) items:
simple_expr -> INT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> INT

State 29:
## Known stack suffix:
## INITIAL
## LR(1) items:
simple_expr -> INITIAL . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> INITIAL

State 30:
## Known stack suffix:
## IF
## LR(1) items:
expr -> IF . expr THEN expr list(else_if) ELSE expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 121
## Reductions:

State 31:
## Known stack suffix:
## IDENT
## LR(1) items:
simple_expr -> IDENT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> IDENT

State 32:
## Known stack suffix:
## FUNCTION
## LR(1) items:
simple_expr -> FUNCTION . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 120
## Reductions:

State 33:
## Known stack suffix:
## FLOAT
## LR(1) items:
simple_expr -> FLOAT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> FLOAT

State 34:
## Known stack suffix:
## FALSE
## LR(1) items:
simple_expr -> FALSE . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> FALSE

State 35:
## Known stack suffix:
## END
## LR(1) items:
simple_expr -> END . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> END

State 36:
## Known stack suffix:
## DOTPLUS
## LR(1) items:
simple_expr -> DOTPLUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 119
## Reductions:

State 37:
## Known stack suffix:
## DOTMINUS
## LR(1) items:
simple_expr -> DOTMINUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 43
## Reductions:

State 38:
## Known stack suffix:
## DOT
## LR(1) items:
simple_expr -> DOT . IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On IDENT shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## DOT IDENT
## LR(1) items:
simple_expr -> DOT IDENT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> DOT IDENT

State 40:
## Known stack suffix:
## DER
## LR(1) items:
simple_expr -> DER . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> DER

State 41:
## Known stack suffix:
## COLON
## LR(1) items:
simple_expr -> COLON . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> COLON

State 42:
## Known stack suffix:
## ASSERT
## LR(1) items:
simple_expr -> ASSERT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> ASSERT

State 43:
## Known stack suffix:
## DOTMINUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> DOTMINUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> DOTMINUS simple_expr
-- On STRING reduce production simple_expr -> DOTMINUS simple_expr
-- On SEMICOLON reduce production simple_expr -> DOTMINUS simple_expr
-- On RPAREN reduce production simple_expr -> DOTMINUS simple_expr
-- On RBRACKET reduce production simple_expr -> DOTMINUS simple_expr
-- On RBRACE reduce production simple_expr -> DOTMINUS simple_expr
-- On PLUS reduce production simple_expr -> DOTMINUS simple_expr
-- On OR reduce production simple_expr -> DOTMINUS simple_expr
-- On NEQ reduce production simple_expr -> DOTMINUS simple_expr
-- On MINUS reduce production simple_expr -> DOTMINUS simple_expr
-- On LT reduce production simple_expr -> DOTMINUS simple_expr
-- On LPAREN reduce production simple_expr -> DOTMINUS simple_expr
-- On LOOP reduce production simple_expr -> DOTMINUS simple_expr
-- On LEQ reduce production simple_expr -> DOTMINUS simple_expr
-- On IF reduce production simple_expr -> DOTMINUS simple_expr
-- On IDENT reduce production simple_expr -> DOTMINUS simple_expr
-- On GT reduce production simple_expr -> DOTMINUS simple_expr
-- On GEQ reduce production simple_expr -> DOTMINUS simple_expr
-- On FOR reduce production simple_expr -> DOTMINUS simple_expr
-- On EQEQ reduce production simple_expr -> DOTMINUS simple_expr
-- On EQ reduce production simple_expr -> DOTMINUS simple_expr
-- On EOF reduce production simple_expr -> DOTMINUS simple_expr
-- On ELSEIF reduce production simple_expr -> DOTMINUS simple_expr
-- On ELSE reduce production simple_expr -> DOTMINUS simple_expr
-- On DOTPLUS reduce production simple_expr -> DOTMINUS simple_expr
-- On DOTMINUS reduce production simple_expr -> DOTMINUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> DOTMINUS simple_expr
-- On COMMA reduce production simple_expr -> DOTMINUS simple_expr
-- On COLON reduce production simple_expr -> DOTMINUS simple_expr
-- On ANNOTATION reduce production simple_expr -> DOTMINUS simple_expr
-- On AND reduce production simple_expr -> DOTMINUS simple_expr

State 44:
## Known stack suffix:
## simple_expr TIMES
## LR(1) items:
simple_expr -> simple_expr TIMES . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## simple_expr TIMES simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr TIMES simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTPOWER shift to state 54
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr TIMES simple_expr
-- On THEN reduce production simple_expr -> simple_expr TIMES simple_expr
-- On STRING reduce production simple_expr -> simple_expr TIMES simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr TIMES simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr TIMES simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr TIMES simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr TIMES simple_expr
-- On PLUS reduce production simple_expr -> simple_expr TIMES simple_expr
-- On OR reduce production simple_expr -> simple_expr TIMES simple_expr
-- On NEQ reduce production simple_expr -> simple_expr TIMES simple_expr
-- On MINUS reduce production simple_expr -> simple_expr TIMES simple_expr
-- On LT reduce production simple_expr -> simple_expr TIMES simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr TIMES simple_expr
-- On LOOP reduce production simple_expr -> simple_expr TIMES simple_expr
-- On LEQ reduce production simple_expr -> simple_expr TIMES simple_expr
-- On IF reduce production simple_expr -> simple_expr TIMES simple_expr
-- On IDENT reduce production simple_expr -> simple_expr TIMES simple_expr
-- On GT reduce production simple_expr -> simple_expr TIMES simple_expr
-- On GEQ reduce production simple_expr -> simple_expr TIMES simple_expr
-- On FOR reduce production simple_expr -> simple_expr TIMES simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr TIMES simple_expr
-- On EQ reduce production simple_expr -> simple_expr TIMES simple_expr
-- On EOF reduce production simple_expr -> simple_expr TIMES simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr TIMES simple_expr
-- On ELSE reduce production simple_expr -> simple_expr TIMES simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr TIMES simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr TIMES simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr TIMES simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr TIMES simple_expr
-- On DIV reduce production simple_expr -> simple_expr TIMES simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr TIMES simple_expr
-- On COMMA reduce production simple_expr -> simple_expr TIMES simple_expr
-- On COLON reduce production simple_expr -> simple_expr TIMES simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr TIMES simple_expr
-- On AND reduce production simple_expr -> simple_expr TIMES simple_expr

State 46:
## Known stack suffix:
## simple_expr POWER
## LR(1) items:
simple_expr -> simple_expr POWER . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 47
## Reductions:

State 47:
## Known stack suffix:
## simple_expr POWER simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr POWER simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On LBRACKET shift to state 48
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr POWER simple_expr
-- On THEN reduce production simple_expr -> simple_expr POWER simple_expr
-- On STRING reduce production simple_expr -> simple_expr POWER simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr POWER simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr POWER simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr POWER simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr POWER simple_expr
-- On POWER reduce production simple_expr -> simple_expr POWER simple_expr
-- On PLUS reduce production simple_expr -> simple_expr POWER simple_expr
-- On OR reduce production simple_expr -> simple_expr POWER simple_expr
-- On NEQ reduce production simple_expr -> simple_expr POWER simple_expr
-- On MINUS reduce production simple_expr -> simple_expr POWER simple_expr
-- On LT reduce production simple_expr -> simple_expr POWER simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr POWER simple_expr
-- On LOOP reduce production simple_expr -> simple_expr POWER simple_expr
-- On LEQ reduce production simple_expr -> simple_expr POWER simple_expr
-- On IF reduce production simple_expr -> simple_expr POWER simple_expr
-- On IDENT reduce production simple_expr -> simple_expr POWER simple_expr
-- On GT reduce production simple_expr -> simple_expr POWER simple_expr
-- On GEQ reduce production simple_expr -> simple_expr POWER simple_expr
-- On FOR reduce production simple_expr -> simple_expr POWER simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr POWER simple_expr
-- On EQ reduce production simple_expr -> simple_expr POWER simple_expr
-- On EOF reduce production simple_expr -> simple_expr POWER simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr POWER simple_expr
-- On ELSE reduce production simple_expr -> simple_expr POWER simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr POWER simple_expr
-- On DOTPOWER reduce production simple_expr -> simple_expr POWER simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr POWER simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr POWER simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr POWER simple_expr
-- On DIV reduce production simple_expr -> simple_expr POWER simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr POWER simple_expr
-- On COMMA reduce production simple_expr -> simple_expr POWER simple_expr
-- On COLON reduce production simple_expr -> simple_expr POWER simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr POWER simple_expr
-- On AND reduce production simple_expr -> simple_expr POWER simple_expr

State 48:
## Known stack suffix:
## simple_expr LBRACKET
## LR(1) items:
simple_expr -> simple_expr LBRACKET . separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 114
-- On expr shift to state 116
## Reductions:

State 49:
## Known stack suffix:
## simple_expr
## LR(1) items:
expr -> simple_expr . [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
expr -> simple_expr . COLON simple_expr option(preceded(COLON,simple_expr)) [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On OR shift to state 62
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LPAREN shift to state 82
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
-- On COLON shift to state 107
-- On AND shift to state 111
## Reductions:
-- On THEN reduce production expr -> simple_expr
-- On STRING reduce production expr -> simple_expr
-- On SEMICOLON reduce production expr -> simple_expr
-- On RPAREN reduce production expr -> simple_expr
-- On RBRACKET reduce production expr -> simple_expr
-- On RBRACE reduce production expr -> simple_expr
-- On LOOP reduce production expr -> simple_expr
-- On IF reduce production expr -> simple_expr
-- On IDENT reduce production expr -> simple_expr
-- On FOR reduce production expr -> simple_expr
-- On EOF reduce production expr -> simple_expr
-- On ELSEIF reduce production expr -> simple_expr
-- On ELSE reduce production expr -> simple_expr
-- On CONSTRAINEDBY reduce production expr -> simple_expr
-- On COMMA reduce production expr -> simple_expr
-- On ANNOTATION reduce production expr -> simple_expr

State 50:
## Known stack suffix:
## simple_expr PLUS
## LR(1) items:
simple_expr -> simple_expr PLUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 51
## Reductions:

State 51:
## Known stack suffix:
## simple_expr PLUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr PLUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr PLUS simple_expr
-- On STRING reduce production simple_expr -> simple_expr PLUS simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr PLUS simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr PLUS simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr PLUS simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr PLUS simple_expr
-- On PLUS reduce production simple_expr -> simple_expr PLUS simple_expr
-- On OR reduce production simple_expr -> simple_expr PLUS simple_expr
-- On NEQ reduce production simple_expr -> simple_expr PLUS simple_expr
-- On MINUS reduce production simple_expr -> simple_expr PLUS simple_expr
-- On LT reduce production simple_expr -> simple_expr PLUS simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr PLUS simple_expr
-- On LOOP reduce production simple_expr -> simple_expr PLUS simple_expr
-- On LEQ reduce production simple_expr -> simple_expr PLUS simple_expr
-- On IF reduce production simple_expr -> simple_expr PLUS simple_expr
-- On IDENT reduce production simple_expr -> simple_expr PLUS simple_expr
-- On GT reduce production simple_expr -> simple_expr PLUS simple_expr
-- On GEQ reduce production simple_expr -> simple_expr PLUS simple_expr
-- On FOR reduce production simple_expr -> simple_expr PLUS simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr PLUS simple_expr
-- On EQ reduce production simple_expr -> simple_expr PLUS simple_expr
-- On EOF reduce production simple_expr -> simple_expr PLUS simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr PLUS simple_expr
-- On ELSE reduce production simple_expr -> simple_expr PLUS simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr PLUS simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr PLUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr PLUS simple_expr
-- On COMMA reduce production simple_expr -> simple_expr PLUS simple_expr
-- On COLON reduce production simple_expr -> simple_expr PLUS simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr PLUS simple_expr
-- On AND reduce production simple_expr -> simple_expr PLUS simple_expr

State 52:
## Known stack suffix:
## simple_expr DOTTIMES
## LR(1) items:
simple_expr -> simple_expr DOTTIMES . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## simple_expr DOTTIMES simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DOTTIMES simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTPOWER shift to state 54
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On THEN reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On STRING reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On OR reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On LT reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On IF reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On GT reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On FOR reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On EQ reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On EOF reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On DIV reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On COLON reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DOTTIMES simple_expr
-- On AND reduce production simple_expr -> simple_expr DOTTIMES simple_expr

State 54:
## Known stack suffix:
## simple_expr DOTPOWER
## LR(1) items:
simple_expr -> simple_expr DOTPOWER . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 55
## Reductions:

State 55:
## Known stack suffix:
## simple_expr DOTPOWER simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DOTPOWER simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On LBRACKET shift to state 48
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On THEN reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On STRING reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On POWER reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On OR reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On LT reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On IF reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On GT reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On FOR reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On EQ reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On EOF reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DOTPOWER reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On DIV reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On COLON reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DOTPOWER simple_expr
-- On AND reduce production simple_expr -> simple_expr DOTPOWER simple_expr

State 56:
## Known stack suffix:
## simple_expr DOT
## LR(1) items:
simple_expr -> simple_expr DOT . IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On IDENT shift to state 57
## Reductions:

State 57:
## Known stack suffix:
## simple_expr DOT IDENT
## LR(1) items:
simple_expr -> simple_expr DOT IDENT . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> simple_expr DOT IDENT

State 58:
## Known stack suffix:
## simple_expr DOTDIV
## LR(1) items:
simple_expr -> simple_expr DOTDIV . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 59
## Reductions:

State 59:
## Known stack suffix:
## simple_expr DOTDIV simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DOTDIV simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTPOWER shift to state 54
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On THEN reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On STRING reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On OR reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On LT reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On IF reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On GT reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On FOR reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On EQ reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On EOF reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On DIV reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On COLON reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DOTDIV simple_expr
-- On AND reduce production simple_expr -> simple_expr DOTDIV simple_expr

State 60:
## Known stack suffix:
## simple_expr DIV
## LR(1) items:
simple_expr -> simple_expr DIV . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## simple_expr DIV simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DIV simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTPOWER shift to state 54
-- On DOT shift to state 56
## Reductions:
-- On TIMES reduce production simple_expr -> simple_expr DIV simple_expr
-- On THEN reduce production simple_expr -> simple_expr DIV simple_expr
-- On STRING reduce production simple_expr -> simple_expr DIV simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DIV simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DIV simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DIV simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DIV simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DIV simple_expr
-- On OR reduce production simple_expr -> simple_expr DIV simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DIV simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DIV simple_expr
-- On LT reduce production simple_expr -> simple_expr DIV simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DIV simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DIV simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DIV simple_expr
-- On IF reduce production simple_expr -> simple_expr DIV simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DIV simple_expr
-- On GT reduce production simple_expr -> simple_expr DIV simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DIV simple_expr
-- On FOR reduce production simple_expr -> simple_expr DIV simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DIV simple_expr
-- On EQ reduce production simple_expr -> simple_expr DIV simple_expr
-- On EOF reduce production simple_expr -> simple_expr DIV simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DIV simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DIV simple_expr
-- On DOTTIMES reduce production simple_expr -> simple_expr DIV simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DIV simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DIV simple_expr
-- On DOTDIV reduce production simple_expr -> simple_expr DIV simple_expr
-- On DIV reduce production simple_expr -> simple_expr DIV simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DIV simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DIV simple_expr
-- On COLON reduce production simple_expr -> simple_expr DIV simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DIV simple_expr
-- On AND reduce production simple_expr -> simple_expr DIV simple_expr

State 62:
## Known stack suffix:
## simple_expr OR
## LR(1) items:
simple_expr -> simple_expr OR . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 63
## Reductions:

State 63:
## Known stack suffix:
## simple_expr OR simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr OR simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr OR simple_expr
-- On STRING reduce production simple_expr -> simple_expr OR simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr OR simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr OR simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr OR simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr OR simple_expr
-- On OR reduce production simple_expr -> simple_expr OR simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr OR simple_expr
-- On LOOP reduce production simple_expr -> simple_expr OR simple_expr
-- On IF reduce production simple_expr -> simple_expr OR simple_expr
-- On IDENT reduce production simple_expr -> simple_expr OR simple_expr
-- On FOR reduce production simple_expr -> simple_expr OR simple_expr
-- On EQ reduce production simple_expr -> simple_expr OR simple_expr
-- On EOF reduce production simple_expr -> simple_expr OR simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr OR simple_expr
-- On ELSE reduce production simple_expr -> simple_expr OR simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr OR simple_expr
-- On COMMA reduce production simple_expr -> simple_expr OR simple_expr
-- On COLON reduce production simple_expr -> simple_expr OR simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr OR simple_expr
-- On AND reduce production simple_expr -> simple_expr OR simple_expr

State 64:
## Known stack suffix:
## simple_expr NEQ
## LR(1) items:
simple_expr -> simple_expr NEQ . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## simple_expr NEQ simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr NEQ simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr NEQ simple_expr
-- On STRING reduce production simple_expr -> simple_expr NEQ simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr NEQ simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr NEQ simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr NEQ simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr NEQ simple_expr
-- On OR reduce production simple_expr -> simple_expr NEQ simple_expr
-- On NEQ reduce production simple_expr -> simple_expr NEQ simple_expr
-- On LT reduce production simple_expr -> simple_expr NEQ simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr NEQ simple_expr
-- On LOOP reduce production simple_expr -> simple_expr NEQ simple_expr
-- On LEQ reduce production simple_expr -> simple_expr NEQ simple_expr
-- On IF reduce production simple_expr -> simple_expr NEQ simple_expr
-- On IDENT reduce production simple_expr -> simple_expr NEQ simple_expr
-- On GT reduce production simple_expr -> simple_expr NEQ simple_expr
-- On GEQ reduce production simple_expr -> simple_expr NEQ simple_expr
-- On FOR reduce production simple_expr -> simple_expr NEQ simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr NEQ simple_expr
-- On EQ reduce production simple_expr -> simple_expr NEQ simple_expr
-- On EOF reduce production simple_expr -> simple_expr NEQ simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr NEQ simple_expr
-- On ELSE reduce production simple_expr -> simple_expr NEQ simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr NEQ simple_expr
-- On COMMA reduce production simple_expr -> simple_expr NEQ simple_expr
-- On COLON reduce production simple_expr -> simple_expr NEQ simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr NEQ simple_expr
-- On AND reduce production simple_expr -> simple_expr NEQ simple_expr

State 66:
## Known stack suffix:
## simple_expr MINUS
## LR(1) items:
simple_expr -> simple_expr MINUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 67
## Reductions:

State 67:
## Known stack suffix:
## simple_expr MINUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr MINUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr MINUS simple_expr
-- On STRING reduce production simple_expr -> simple_expr MINUS simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr MINUS simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr MINUS simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr MINUS simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr MINUS simple_expr
-- On PLUS reduce production simple_expr -> simple_expr MINUS simple_expr
-- On OR reduce production simple_expr -> simple_expr MINUS simple_expr
-- On NEQ reduce production simple_expr -> simple_expr MINUS simple_expr
-- On MINUS reduce production simple_expr -> simple_expr MINUS simple_expr
-- On LT reduce production simple_expr -> simple_expr MINUS simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr MINUS simple_expr
-- On LOOP reduce production simple_expr -> simple_expr MINUS simple_expr
-- On LEQ reduce production simple_expr -> simple_expr MINUS simple_expr
-- On IF reduce production simple_expr -> simple_expr MINUS simple_expr
-- On IDENT reduce production simple_expr -> simple_expr MINUS simple_expr
-- On GT reduce production simple_expr -> simple_expr MINUS simple_expr
-- On GEQ reduce production simple_expr -> simple_expr MINUS simple_expr
-- On FOR reduce production simple_expr -> simple_expr MINUS simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr MINUS simple_expr
-- On EQ reduce production simple_expr -> simple_expr MINUS simple_expr
-- On EOF reduce production simple_expr -> simple_expr MINUS simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr MINUS simple_expr
-- On ELSE reduce production simple_expr -> simple_expr MINUS simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr MINUS simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr MINUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr MINUS simple_expr
-- On COMMA reduce production simple_expr -> simple_expr MINUS simple_expr
-- On COLON reduce production simple_expr -> simple_expr MINUS simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr MINUS simple_expr
-- On AND reduce production simple_expr -> simple_expr MINUS simple_expr

State 68:
## Known stack suffix:
## simple_expr DOTPLUS
## LR(1) items:
simple_expr -> simple_expr DOTPLUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 69
## Reductions:

State 69:
## Known stack suffix:
## simple_expr DOTPLUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DOTPLUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On STRING reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On OR reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On LT reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On IF reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On GT reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On FOR reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On EQ reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On EOF reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On COLON reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DOTPLUS simple_expr
-- On AND reduce production simple_expr -> simple_expr DOTPLUS simple_expr

State 70:
## Known stack suffix:
## simple_expr DOTMINUS
## LR(1) items:
simple_expr -> simple_expr DOTMINUS . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 71
## Reductions:

State 71:
## Known stack suffix:
## simple_expr DOTMINUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr DOTMINUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On STRING reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On PLUS reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On OR reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On NEQ reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On MINUS reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On LT reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On LOOP reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On LEQ reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On IF reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On IDENT reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On GT reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On GEQ reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On FOR reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On EQ reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On EOF reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On ELSE reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On DOTPLUS reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On DOTMINUS reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On COMMA reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On COLON reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr DOTMINUS simple_expr
-- On AND reduce production simple_expr -> simple_expr DOTMINUS simple_expr

State 72:
## Known stack suffix:
## simple_expr LT
## LR(1) items:
simple_expr -> simple_expr LT . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 73
## Reductions:

State 73:
## Known stack suffix:
## simple_expr LT simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr LT simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr LT simple_expr
-- On STRING reduce production simple_expr -> simple_expr LT simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr LT simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr LT simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr LT simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr LT simple_expr
-- On OR reduce production simple_expr -> simple_expr LT simple_expr
-- On NEQ reduce production simple_expr -> simple_expr LT simple_expr
-- On LT reduce production simple_expr -> simple_expr LT simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr LT simple_expr
-- On LOOP reduce production simple_expr -> simple_expr LT simple_expr
-- On LEQ reduce production simple_expr -> simple_expr LT simple_expr
-- On IF reduce production simple_expr -> simple_expr LT simple_expr
-- On IDENT reduce production simple_expr -> simple_expr LT simple_expr
-- On GT reduce production simple_expr -> simple_expr LT simple_expr
-- On GEQ reduce production simple_expr -> simple_expr LT simple_expr
-- On FOR reduce production simple_expr -> simple_expr LT simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr LT simple_expr
-- On EQ reduce production simple_expr -> simple_expr LT simple_expr
-- On EOF reduce production simple_expr -> simple_expr LT simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr LT simple_expr
-- On ELSE reduce production simple_expr -> simple_expr LT simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr LT simple_expr
-- On COMMA reduce production simple_expr -> simple_expr LT simple_expr
-- On COLON reduce production simple_expr -> simple_expr LT simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr LT simple_expr
-- On AND reduce production simple_expr -> simple_expr LT simple_expr

State 74:
## Known stack suffix:
## simple_expr LEQ
## LR(1) items:
simple_expr -> simple_expr LEQ . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## simple_expr LEQ simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr LEQ simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr LEQ simple_expr
-- On STRING reduce production simple_expr -> simple_expr LEQ simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr LEQ simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr LEQ simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr LEQ simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr LEQ simple_expr
-- On OR reduce production simple_expr -> simple_expr LEQ simple_expr
-- On NEQ reduce production simple_expr -> simple_expr LEQ simple_expr
-- On LT reduce production simple_expr -> simple_expr LEQ simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr LEQ simple_expr
-- On LOOP reduce production simple_expr -> simple_expr LEQ simple_expr
-- On LEQ reduce production simple_expr -> simple_expr LEQ simple_expr
-- On IF reduce production simple_expr -> simple_expr LEQ simple_expr
-- On IDENT reduce production simple_expr -> simple_expr LEQ simple_expr
-- On GT reduce production simple_expr -> simple_expr LEQ simple_expr
-- On GEQ reduce production simple_expr -> simple_expr LEQ simple_expr
-- On FOR reduce production simple_expr -> simple_expr LEQ simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr LEQ simple_expr
-- On EQ reduce production simple_expr -> simple_expr LEQ simple_expr
-- On EOF reduce production simple_expr -> simple_expr LEQ simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr LEQ simple_expr
-- On ELSE reduce production simple_expr -> simple_expr LEQ simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr LEQ simple_expr
-- On COMMA reduce production simple_expr -> simple_expr LEQ simple_expr
-- On COLON reduce production simple_expr -> simple_expr LEQ simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr LEQ simple_expr
-- On AND reduce production simple_expr -> simple_expr LEQ simple_expr

State 76:
## Known stack suffix:
## simple_expr GT
## LR(1) items:
simple_expr -> simple_expr GT . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 77
## Reductions:

State 77:
## Known stack suffix:
## simple_expr GT simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr GT simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr GT simple_expr
-- On STRING reduce production simple_expr -> simple_expr GT simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr GT simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr GT simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr GT simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr GT simple_expr
-- On OR reduce production simple_expr -> simple_expr GT simple_expr
-- On NEQ reduce production simple_expr -> simple_expr GT simple_expr
-- On LT reduce production simple_expr -> simple_expr GT simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr GT simple_expr
-- On LOOP reduce production simple_expr -> simple_expr GT simple_expr
-- On LEQ reduce production simple_expr -> simple_expr GT simple_expr
-- On IF reduce production simple_expr -> simple_expr GT simple_expr
-- On IDENT reduce production simple_expr -> simple_expr GT simple_expr
-- On GT reduce production simple_expr -> simple_expr GT simple_expr
-- On GEQ reduce production simple_expr -> simple_expr GT simple_expr
-- On FOR reduce production simple_expr -> simple_expr GT simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr GT simple_expr
-- On EQ reduce production simple_expr -> simple_expr GT simple_expr
-- On EOF reduce production simple_expr -> simple_expr GT simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr GT simple_expr
-- On ELSE reduce production simple_expr -> simple_expr GT simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr GT simple_expr
-- On COMMA reduce production simple_expr -> simple_expr GT simple_expr
-- On COLON reduce production simple_expr -> simple_expr GT simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr GT simple_expr
-- On AND reduce production simple_expr -> simple_expr GT simple_expr

State 78:
## Known stack suffix:
## simple_expr GEQ
## LR(1) items:
simple_expr -> simple_expr GEQ . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 79
## Reductions:

State 79:
## Known stack suffix:
## simple_expr GEQ simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr GEQ simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr GEQ simple_expr
-- On STRING reduce production simple_expr -> simple_expr GEQ simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr GEQ simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr GEQ simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr GEQ simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr GEQ simple_expr
-- On OR reduce production simple_expr -> simple_expr GEQ simple_expr
-- On NEQ reduce production simple_expr -> simple_expr GEQ simple_expr
-- On LT reduce production simple_expr -> simple_expr GEQ simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr GEQ simple_expr
-- On LOOP reduce production simple_expr -> simple_expr GEQ simple_expr
-- On LEQ reduce production simple_expr -> simple_expr GEQ simple_expr
-- On IF reduce production simple_expr -> simple_expr GEQ simple_expr
-- On IDENT reduce production simple_expr -> simple_expr GEQ simple_expr
-- On GT reduce production simple_expr -> simple_expr GEQ simple_expr
-- On GEQ reduce production simple_expr -> simple_expr GEQ simple_expr
-- On FOR reduce production simple_expr -> simple_expr GEQ simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr GEQ simple_expr
-- On EQ reduce production simple_expr -> simple_expr GEQ simple_expr
-- On EOF reduce production simple_expr -> simple_expr GEQ simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr GEQ simple_expr
-- On ELSE reduce production simple_expr -> simple_expr GEQ simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr GEQ simple_expr
-- On COMMA reduce production simple_expr -> simple_expr GEQ simple_expr
-- On COLON reduce production simple_expr -> simple_expr GEQ simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr GEQ simple_expr
-- On AND reduce production simple_expr -> simple_expr GEQ simple_expr

State 80:
## Known stack suffix:
## simple_expr EQEQ
## LR(1) items:
simple_expr -> simple_expr EQEQ . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 81
## Reductions:

State 81:
## Known stack suffix:
## simple_expr EQEQ simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr EQEQ simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On MINUS shift to state 66
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On STRING reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On OR reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On NEQ reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On LT reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On LOOP reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On LEQ reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On IF reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On IDENT reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On GT reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On GEQ reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On FOR reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On EQEQ reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On EQ reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On EOF reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On ELSE reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On COMMA reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On COLON reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr EQEQ simple_expr
-- On AND reduce production simple_expr -> simple_expr EQEQ simple_expr

State 82:
## Known stack suffix:
## simple_expr LPAREN
## LR(1) items:
simple_expr -> simple_expr LPAREN . function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 83
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,named_argument) shift to state 84
-- On named_function_args shift to state 85
-- On named_argument shift to state 86
-- On ident shift to state 89
-- On function_args shift to state 92
-- On expr shift to state 94
## Reductions:
-- On RPAREN reduce production named_function_args ->

State 83:
## Known stack suffix:
## IDENT
## LR(1) items:
ident -> IDENT . [ EQ ]
simple_expr -> IDENT . [ TIMES RPAREN POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ FOR EQEQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV COMMA COLON AND ]
## Transitions:
## Reductions:
-- On TIMES reduce production simple_expr -> IDENT
-- On RPAREN reduce production simple_expr -> IDENT
-- On POWER reduce production simple_expr -> IDENT
-- On PLUS reduce production simple_expr -> IDENT
-- On OR reduce production simple_expr -> IDENT
-- On NEQ reduce production simple_expr -> IDENT
-- On MINUS reduce production simple_expr -> IDENT
-- On LT reduce production simple_expr -> IDENT
-- On LPAREN reduce production simple_expr -> IDENT
-- On LEQ reduce production simple_expr -> IDENT
-- On LBRACKET reduce production simple_expr -> IDENT
-- On GT reduce production simple_expr -> IDENT
-- On GEQ reduce production simple_expr -> IDENT
-- On FOR reduce production simple_expr -> IDENT
-- On EQEQ reduce production simple_expr -> IDENT
-- On EQ reduce production ident -> IDENT
-- On DOTTIMES reduce production simple_expr -> IDENT
-- On DOTPOWER reduce production simple_expr -> IDENT
-- On DOTPLUS reduce production simple_expr -> IDENT
-- On DOTMINUS reduce production simple_expr -> IDENT
-- On DOTDIV reduce production simple_expr -> IDENT
-- On DOT reduce production simple_expr -> IDENT
-- On DIV reduce production simple_expr -> IDENT
-- On COMMA reduce production simple_expr -> IDENT
-- On COLON reduce production simple_expr -> IDENT
-- On AND reduce production simple_expr -> IDENT

State 84:
## Known stack suffix:
## separated_nonempty_list(COMMA,named_argument)
## LR(1) items:
named_function_args -> separated_nonempty_list(COMMA,named_argument) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production named_function_args -> separated_nonempty_list(COMMA,named_argument)

State 85:
## Known stack suffix:
## named_function_args
## LR(1) items:
function_args -> named_function_args . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_args -> named_function_args

State 86:
## Known stack suffix:
## named_argument
## LR(1) items:
separated_nonempty_list(COMMA,named_argument) -> named_argument . [ RPAREN ]
separated_nonempty_list(COMMA,named_argument) -> named_argument . COMMA separated_nonempty_list(COMMA,named_argument) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 87
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,named_argument) -> named_argument

State 87:
## Known stack suffix:
## named_argument COMMA
## LR(1) items:
separated_nonempty_list(COMMA,named_argument) -> named_argument COMMA . separated_nonempty_list(COMMA,named_argument) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,named_argument) shift to state 88
-- On named_argument shift to state 86
-- On ident shift to state 89
## Reductions:

State 88:
## Known stack suffix:
## named_argument COMMA separated_nonempty_list(COMMA,named_argument)
## LR(1) items:
separated_nonempty_list(COMMA,named_argument) -> named_argument COMMA separated_nonempty_list(COMMA,named_argument) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,named_argument) -> named_argument COMMA separated_nonempty_list(COMMA,named_argument)

State 89:
## Known stack suffix:
## ident
## LR(1) items:
named_argument -> ident . EQ expr [ RPAREN COMMA ]
## Transitions:
-- On EQ shift to state 90
## Reductions:

State 90:
## Known stack suffix:
## ident EQ
## LR(1) items:
named_argument -> ident EQ . expr [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## ident EQ expr
## LR(1) items:
named_argument -> ident EQ expr . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production named_argument -> ident EQ expr

State 92:
## Known stack suffix:
## simple_expr LPAREN function_args
## LR(1) items:
simple_expr -> simple_expr LPAREN function_args . RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RPAREN shift to state 93
## Reductions:

State 93:
## Known stack suffix:
## simple_expr LPAREN function_args RPAREN
## LR(1) items:
simple_expr -> simple_expr LPAREN function_args RPAREN . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> simple_expr LPAREN function_args RPAREN

State 94:
## Known stack suffix:
## expr
## LR(1) items:
function_args -> expr . COMMA function_args [ RPAREN ]
function_args -> expr . [ RPAREN ]
function_args -> expr . FOR separated_nonempty_list(COMMA,index) [ RPAREN ]
## Transitions:
-- On FOR shift to state 95
-- On COMMA shift to state 105
## Reductions:
-- On RPAREN reduce production function_args -> expr

State 95:
## Known stack suffix:
## expr FOR
## LR(1) items:
function_args -> expr FOR . separated_nonempty_list(COMMA,index) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,index) shift to state 96
-- On index shift to state 97
-- On ident shift to state 100
## Reductions:

State 96:
## Known stack suffix:
## expr FOR separated_nonempty_list(COMMA,index)
## LR(1) items:
function_args -> expr FOR separated_nonempty_list(COMMA,index) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_args -> expr FOR separated_nonempty_list(COMMA,index)

State 97:
## Known stack suffix:
## index
## LR(1) items:
separated_nonempty_list(COMMA,index) -> index . [ RPAREN RBRACE ]
separated_nonempty_list(COMMA,index) -> index . COMMA separated_nonempty_list(COMMA,index) [ RPAREN RBRACE ]
## Transitions:
-- On COMMA shift to state 98
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,index) -> index
-- On RBRACE reduce production separated_nonempty_list(COMMA,index) -> index

State 98:
## Known stack suffix:
## index COMMA
## LR(1) items:
separated_nonempty_list(COMMA,index) -> index COMMA . separated_nonempty_list(COMMA,index) [ RPAREN RBRACE ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,index) shift to state 99
-- On index shift to state 97
-- On ident shift to state 100
## Reductions:

State 99:
## Known stack suffix:
## index COMMA separated_nonempty_list(COMMA,index)
## LR(1) items:
separated_nonempty_list(COMMA,index) -> index COMMA separated_nonempty_list(COMMA,index) . [ RPAREN RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,index) -> index COMMA separated_nonempty_list(COMMA,index)

State 100:
## Known stack suffix:
## ident
## LR(1) items:
index -> ident . option(index_range) [ RPAREN RBRACE LOOP IDENT COMMA ]
## Transitions:
-- On IN shift to state 101
-- On option(index_range) shift to state 103
-- On index_range shift to state 104
## Reductions:
-- On RPAREN reduce production option(index_range) ->
-- On RBRACE reduce production option(index_range) ->
-- On LOOP reduce production option(index_range) ->
-- On IDENT reduce production option(index_range) ->
-- On COMMA reduce production option(index_range) ->

State 101:
## Known stack suffix:
## IN
## LR(1) items:
index_range -> IN . expr [ RPAREN RBRACE LOOP IDENT COMMA ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 102
## Reductions:

State 102:
## Known stack suffix:
## IN expr
## LR(1) items:
index_range -> IN expr . [ RPAREN RBRACE LOOP IDENT COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_range -> IN expr

State 103:
## Known stack suffix:
## ident option(index_range)
## LR(1) items:
index -> ident option(index_range) . [ RPAREN RBRACE LOOP IDENT COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index -> ident option(index_range)

State 104:
## Known stack suffix:
## index_range
## LR(1) items:
option(index_range) -> index_range . [ RPAREN RBRACE LOOP IDENT COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(index_range) -> index_range

State 105:
## Known stack suffix:
## expr COMMA
## LR(1) items:
function_args -> expr COMMA . function_args [ RPAREN ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 83
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,named_argument) shift to state 84
-- On named_function_args shift to state 85
-- On named_argument shift to state 86
-- On ident shift to state 89
-- On function_args shift to state 106
-- On expr shift to state 94
## Reductions:
-- On RPAREN reduce production named_function_args ->

State 106:
## Known stack suffix:
## expr COMMA function_args
## LR(1) items:
function_args -> expr COMMA function_args . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production function_args -> expr COMMA function_args

State 107:
## Known stack suffix:
## simple_expr COLON
## LR(1) items:
expr -> simple_expr COLON . simple_expr option(preceded(COLON,simple_expr)) [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 108
## Reductions:

State 108:
## Known stack suffix:
## simple_expr COLON simple_expr
## LR(1) items:
expr -> simple_expr COLON simple_expr . option(preceded(COLON,simple_expr)) [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On OR shift to state 62
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LPAREN shift to state 82
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
-- On COLON shift to state 109
-- On AND shift to state 111
-- On option(preceded(COLON,simple_expr)) shift to state 113
## Reductions:
-- On THEN reduce production option(preceded(COLON,simple_expr)) ->
-- On STRING reduce production option(preceded(COLON,simple_expr)) ->
-- On SEMICOLON reduce production option(preceded(COLON,simple_expr)) ->
-- On RPAREN reduce production option(preceded(COLON,simple_expr)) ->
-- On RBRACKET reduce production option(preceded(COLON,simple_expr)) ->
-- On RBRACE reduce production option(preceded(COLON,simple_expr)) ->
-- On LOOP reduce production option(preceded(COLON,simple_expr)) ->
-- On IF reduce production option(preceded(COLON,simple_expr)) ->
-- On IDENT reduce production option(preceded(COLON,simple_expr)) ->
-- On FOR reduce production option(preceded(COLON,simple_expr)) ->
-- On EOF reduce production option(preceded(COLON,simple_expr)) ->
-- On ELSEIF reduce production option(preceded(COLON,simple_expr)) ->
-- On ELSE reduce production option(preceded(COLON,simple_expr)) ->
-- On CONSTRAINEDBY reduce production option(preceded(COLON,simple_expr)) ->
-- On COMMA reduce production option(preceded(COLON,simple_expr)) ->
-- On ANNOTATION reduce production option(preceded(COLON,simple_expr)) ->

State 109:
## Known stack suffix:
## COLON
## LR(1) items:
option(preceded(COLON,simple_expr)) -> COLON . simple_expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 110
## Reductions:

State 110:
## Known stack suffix:
## COLON simple_expr
## LR(1) items:
option(preceded(COLON,simple_expr)) -> COLON simple_expr . [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On OR shift to state 62
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LPAREN shift to state 82
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
-- On AND shift to state 111
## Reductions:
-- On THEN reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On STRING reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On SEMICOLON reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On RPAREN reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On RBRACKET reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On RBRACE reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On LOOP reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On IF reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On IDENT reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On FOR reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On EOF reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On ELSEIF reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On ELSE reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On CONSTRAINEDBY reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On COMMA reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr
-- On ANNOTATION reduce production option(preceded(COLON,simple_expr)) -> COLON simple_expr

State 111:
## Known stack suffix:
## simple_expr AND
## LR(1) items:
simple_expr -> simple_expr AND . simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 112
## Reductions:

State 112:
## Known stack suffix:
## simple_expr AND simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr AND simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> simple_expr AND simple_expr
-- On STRING reduce production simple_expr -> simple_expr AND simple_expr
-- On SEMICOLON reduce production simple_expr -> simple_expr AND simple_expr
-- On RPAREN reduce production simple_expr -> simple_expr AND simple_expr
-- On RBRACKET reduce production simple_expr -> simple_expr AND simple_expr
-- On RBRACE reduce production simple_expr -> simple_expr AND simple_expr
-- On OR reduce production simple_expr -> simple_expr AND simple_expr
-- On LPAREN reduce production simple_expr -> simple_expr AND simple_expr
-- On LOOP reduce production simple_expr -> simple_expr AND simple_expr
-- On IF reduce production simple_expr -> simple_expr AND simple_expr
-- On IDENT reduce production simple_expr -> simple_expr AND simple_expr
-- On FOR reduce production simple_expr -> simple_expr AND simple_expr
-- On EQ reduce production simple_expr -> simple_expr AND simple_expr
-- On EOF reduce production simple_expr -> simple_expr AND simple_expr
-- On ELSEIF reduce production simple_expr -> simple_expr AND simple_expr
-- On ELSE reduce production simple_expr -> simple_expr AND simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> simple_expr AND simple_expr
-- On COMMA reduce production simple_expr -> simple_expr AND simple_expr
-- On COLON reduce production simple_expr -> simple_expr AND simple_expr
-- On ANNOTATION reduce production simple_expr -> simple_expr AND simple_expr
-- On AND reduce production simple_expr -> simple_expr AND simple_expr

State 113:
## Known stack suffix:
## simple_expr COLON simple_expr option(preceded(COLON,simple_expr))
## LR(1) items:
expr -> simple_expr COLON simple_expr option(preceded(COLON,simple_expr)) . [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> simple_expr COLON simple_expr option(preceded(COLON,simple_expr))

State 114:
## Known stack suffix:
## simple_expr LBRACKET separated_nonempty_list(COMMA,expr)
## LR(1) items:
simple_expr -> simple_expr LBRACKET separated_nonempty_list(COMMA,expr) . RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RBRACKET shift to state 115
## Reductions:

State 115:
## Known stack suffix:
## simple_expr LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET
## LR(1) items:
simple_expr -> simple_expr LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> simple_expr LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET

State 116:
## Known stack suffix:
## expr
## LR(1) items:
separated_nonempty_list(COMMA,expr) -> expr . [ SEMICOLON RPAREN RBRACKET RBRACE ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ SEMICOLON RPAREN RBRACKET RBRACE ]
## Transitions:
-- On COMMA shift to state 117
## Reductions:
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On RBRACKET reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On RBRACE reduce production separated_nonempty_list(COMMA,expr) -> expr

State 117:
## Known stack suffix:
## expr COMMA
## LR(1) items:
separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ SEMICOLON RPAREN RBRACKET RBRACE ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 118
-- On expr shift to state 116
## Reductions:

State 118:
## Known stack suffix:
## expr COMMA separated_nonempty_list(COMMA,expr)
## LR(1) items:
separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) . [ SEMICOLON RPAREN RBRACKET RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr)

State 119:
## Known stack suffix:
## DOTPLUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> DOTPLUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> DOTPLUS simple_expr
-- On STRING reduce production simple_expr -> DOTPLUS simple_expr
-- On SEMICOLON reduce production simple_expr -> DOTPLUS simple_expr
-- On RPAREN reduce production simple_expr -> DOTPLUS simple_expr
-- On RBRACKET reduce production simple_expr -> DOTPLUS simple_expr
-- On RBRACE reduce production simple_expr -> DOTPLUS simple_expr
-- On PLUS reduce production simple_expr -> DOTPLUS simple_expr
-- On OR reduce production simple_expr -> DOTPLUS simple_expr
-- On NEQ reduce production simple_expr -> DOTPLUS simple_expr
-- On MINUS reduce production simple_expr -> DOTPLUS simple_expr
-- On LT reduce production simple_expr -> DOTPLUS simple_expr
-- On LPAREN reduce production simple_expr -> DOTPLUS simple_expr
-- On LOOP reduce production simple_expr -> DOTPLUS simple_expr
-- On LEQ reduce production simple_expr -> DOTPLUS simple_expr
-- On IF reduce production simple_expr -> DOTPLUS simple_expr
-- On IDENT reduce production simple_expr -> DOTPLUS simple_expr
-- On GT reduce production simple_expr -> DOTPLUS simple_expr
-- On GEQ reduce production simple_expr -> DOTPLUS simple_expr
-- On FOR reduce production simple_expr -> DOTPLUS simple_expr
-- On EQEQ reduce production simple_expr -> DOTPLUS simple_expr
-- On EQ reduce production simple_expr -> DOTPLUS simple_expr
-- On EOF reduce production simple_expr -> DOTPLUS simple_expr
-- On ELSEIF reduce production simple_expr -> DOTPLUS simple_expr
-- On ELSE reduce production simple_expr -> DOTPLUS simple_expr
-- On DOTPLUS reduce production simple_expr -> DOTPLUS simple_expr
-- On DOTMINUS reduce production simple_expr -> DOTPLUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> DOTPLUS simple_expr
-- On COMMA reduce production simple_expr -> DOTPLUS simple_expr
-- On COLON reduce production simple_expr -> DOTPLUS simple_expr
-- On ANNOTATION reduce production simple_expr -> DOTPLUS simple_expr
-- On AND reduce production simple_expr -> DOTPLUS simple_expr

State 120:
## Known stack suffix:
## FUNCTION simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> FUNCTION simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> FUNCTION simple_expr
-- On STRING reduce production simple_expr -> FUNCTION simple_expr
-- On SEMICOLON reduce production simple_expr -> FUNCTION simple_expr
-- On RPAREN reduce production simple_expr -> FUNCTION simple_expr
-- On RBRACKET reduce production simple_expr -> FUNCTION simple_expr
-- On RBRACE reduce production simple_expr -> FUNCTION simple_expr
-- On PLUS reduce production simple_expr -> FUNCTION simple_expr
-- On OR reduce production simple_expr -> FUNCTION simple_expr
-- On NEQ reduce production simple_expr -> FUNCTION simple_expr
-- On MINUS reduce production simple_expr -> FUNCTION simple_expr
-- On LT reduce production simple_expr -> FUNCTION simple_expr
-- On LPAREN reduce production simple_expr -> FUNCTION simple_expr
-- On LOOP reduce production simple_expr -> FUNCTION simple_expr
-- On LEQ reduce production simple_expr -> FUNCTION simple_expr
-- On IF reduce production simple_expr -> FUNCTION simple_expr
-- On IDENT reduce production simple_expr -> FUNCTION simple_expr
-- On GT reduce production simple_expr -> FUNCTION simple_expr
-- On GEQ reduce production simple_expr -> FUNCTION simple_expr
-- On FOR reduce production simple_expr -> FUNCTION simple_expr
-- On EQEQ reduce production simple_expr -> FUNCTION simple_expr
-- On EQ reduce production simple_expr -> FUNCTION simple_expr
-- On EOF reduce production simple_expr -> FUNCTION simple_expr
-- On ELSEIF reduce production simple_expr -> FUNCTION simple_expr
-- On ELSE reduce production simple_expr -> FUNCTION simple_expr
-- On DOTPLUS reduce production simple_expr -> FUNCTION simple_expr
-- On DOTMINUS reduce production simple_expr -> FUNCTION simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> FUNCTION simple_expr
-- On COMMA reduce production simple_expr -> FUNCTION simple_expr
-- On COLON reduce production simple_expr -> FUNCTION simple_expr
-- On ANNOTATION reduce production simple_expr -> FUNCTION simple_expr
-- On AND reduce production simple_expr -> FUNCTION simple_expr

State 121:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> IF expr . THEN expr list(else_if) ELSE expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On THEN shift to state 122
## Reductions:

State 122:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
expr -> IF expr THEN . expr list(else_if) ELSE expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 123
## Reductions:

State 123:
## Known stack suffix:
## IF expr THEN expr
## LR(1) items:
expr -> IF expr THEN expr . list(else_if) ELSE expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On ELSEIF shift to state 124
-- On list(else_if) shift to state 128
-- On else_if shift to state 131
## Reductions:
-- On ELSE reduce production list(else_if) ->

State 124:
## Known stack suffix:
## ELSEIF
## LR(1) items:
else_if -> ELSEIF . expr THEN expr [ ELSEIF ELSE ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 125
## Reductions:

State 125:
## Known stack suffix:
## ELSEIF expr
## LR(1) items:
else_if -> ELSEIF expr . THEN expr [ ELSEIF ELSE ]
## Transitions:
-- On THEN shift to state 126
## Reductions:

State 126:
## Known stack suffix:
## ELSEIF expr THEN
## LR(1) items:
else_if -> ELSEIF expr THEN . expr [ ELSEIF ELSE ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 127
## Reductions:

State 127:
## Known stack suffix:
## ELSEIF expr THEN expr
## LR(1) items:
else_if -> ELSEIF expr THEN expr . [ ELSEIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production else_if -> ELSEIF expr THEN expr

State 128:
## Known stack suffix:
## IF expr THEN expr list(else_if)
## LR(1) items:
expr -> IF expr THEN expr list(else_if) . ELSE expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On ELSE shift to state 129
## Reductions:

State 129:
## Known stack suffix:
## IF expr THEN expr list(else_if) ELSE
## LR(1) items:
expr -> IF expr THEN expr list(else_if) ELSE . expr [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 130
## Reductions:

State 130:
## Known stack suffix:
## IF expr THEN expr list(else_if) ELSE expr
## LR(1) items:
expr -> IF expr THEN expr list(else_if) ELSE expr . [ THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> IF expr THEN expr list(else_if) ELSE expr

State 131:
## Known stack suffix:
## else_if
## LR(1) items:
list(else_if) -> else_if . list(else_if) [ ELSE ]
## Transitions:
-- On ELSEIF shift to state 124
-- On list(else_if) shift to state 132
-- On else_if shift to state 131
## Reductions:
-- On ELSE reduce production list(else_if) ->

State 132:
## Known stack suffix:
## else_if list(else_if)
## LR(1) items:
list(else_if) -> else_if list(else_if) . [ ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(else_if) -> else_if list(else_if)

State 133:
## Known stack suffix:
## separated_nonempty_list(COMMA,expr)
## LR(1) items:
loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) . [ RPAREN RBRACKET RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr)

State 134:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,expr))
## LR(1) items:
array_args -> loption(separated_nonempty_list(COMMA,expr)) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_args -> loption(separated_nonempty_list(COMMA,expr))

State 135:
## Known stack suffix:
## expr
## LR(1) items:
array_args -> expr . FOR separated_nonempty_list(COMMA,index) [ RBRACE ]
separated_nonempty_list(COMMA,expr) -> expr . [ RBRACE ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RBRACE ]
## Transitions:
-- On FOR shift to state 136
-- On COMMA shift to state 117
## Reductions:
-- On RBRACE reduce production separated_nonempty_list(COMMA,expr) -> expr

State 136:
## Known stack suffix:
## expr FOR
## LR(1) items:
array_args -> expr FOR . separated_nonempty_list(COMMA,index) [ RBRACE ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,index) shift to state 137
-- On index shift to state 97
-- On ident shift to state 100
## Reductions:

State 137:
## Known stack suffix:
## expr FOR separated_nonempty_list(COMMA,index)
## LR(1) items:
array_args -> expr FOR separated_nonempty_list(COMMA,index) . [ RBRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_args -> expr FOR separated_nonempty_list(COMMA,index)

State 138:
## Known stack suffix:
## LBRACE array_args
## LR(1) items:
simple_expr -> LBRACE array_args . RBRACE [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RBRACE shift to state 139
## Reductions:

State 139:
## Known stack suffix:
## LBRACE array_args RBRACE
## LR(1) items:
simple_expr -> LBRACE array_args RBRACE . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LBRACE array_args RBRACE

State 140:
## Known stack suffix:
## LBRACKET separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))
## LR(1) items:
simple_expr -> LBRACKET separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) . RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RBRACKET shift to state 141
## Reductions:

State 141:
## Known stack suffix:
## LBRACKET separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) RBRACKET
## LR(1) items:
simple_expr -> LBRACKET separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) RBRACKET . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LBRACKET separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) RBRACKET

State 142:
## Known stack suffix:
## separated_nonempty_list(COMMA,expr)
## LR(1) items:
separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) . [ RBRACKET ]
separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) . SEMICOLON separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) [ RBRACKET ]
## Transitions:
-- On SEMICOLON shift to state 143
## Reductions:
-- On RBRACKET reduce production separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr)

State 143:
## Known stack suffix:
## separated_nonempty_list(COMMA,expr) SEMICOLON
## LR(1) items:
separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) SEMICOLON . separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) [ RBRACKET ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) shift to state 144
-- On separated_nonempty_list(COMMA,expr) shift to state 142
-- On expr shift to state 116
## Reductions:

State 144:
## Known stack suffix:
## separated_nonempty_list(COMMA,expr) SEMICOLON separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))
## LR(1) items:
separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) SEMICOLON separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) . [ RBRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) SEMICOLON separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))

State 145:
## Known stack suffix:
## LPAREN COMMA
## LR(1) items:
simple_expr -> LPAREN COMMA . patterns RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On LPAREN shift to state 146
-- On IDENT shift to state 147
-- On DOT shift to state 148
-- On ASSERT shift to state 150
-- On patterns shift to state 165
-- On option(lexpr) shift to state 153
-- On lexpr shift to state 157
-- On component_reference shift to state 158
## Reductions:
-- On RPAREN reduce production option(lexpr) ->
-- On COMMA reduce production option(lexpr) ->

State 146:
## Known stack suffix:
## LPAREN
## LR(1) items:
lexpr -> LPAREN . patterns RPAREN [ RPAREN COMMA COLONEQ ]
## Transitions:
-- On LPAREN shift to state 146
-- On IDENT shift to state 147
-- On DOT shift to state 148
-- On ASSERT shift to state 150
-- On patterns shift to state 151
-- On option(lexpr) shift to state 153
-- On lexpr shift to state 157
-- On component_reference shift to state 158
## Reductions:
-- On RPAREN reduce production option(lexpr) ->
-- On COMMA reduce production option(lexpr) ->

State 147:
## Known stack suffix:
## IDENT
## LR(1) items:
component_reference -> IDENT . [ RPAREN LPAREN LBRACKET DOT COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_reference -> IDENT

State 148:
## Known stack suffix:
## DOT
## LR(1) items:
component_reference -> DOT . IDENT [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
-- On IDENT shift to state 149
## Reductions:

State 149:
## Known stack suffix:
## DOT IDENT
## LR(1) items:
component_reference -> DOT IDENT . [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_reference -> DOT IDENT

State 150:
## Known stack suffix:
## ASSERT
## LR(1) items:
component_reference -> ASSERT . [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_reference -> ASSERT

State 151:
## Known stack suffix:
## LPAREN patterns
## LR(1) items:
lexpr -> LPAREN patterns . RPAREN [ RPAREN COMMA COLONEQ ]
## Transitions:
-- On RPAREN shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## LPAREN patterns RPAREN
## LR(1) items:
lexpr -> LPAREN patterns RPAREN . [ RPAREN COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lexpr -> LPAREN patterns RPAREN

State 153:
## Known stack suffix:
## option(lexpr)
## LR(1) items:
patterns -> option(lexpr) . list(preceded(COMMA,option(lexpr))) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 154
-- On list(preceded(COMMA,option(lexpr))) shift to state 164
## Reductions:
-- On RPAREN reduce production list(preceded(COMMA,option(lexpr))) ->

State 154:
## Known stack suffix:
## COMMA
## LR(1) items:
list(preceded(COMMA,option(lexpr))) -> COMMA . option(lexpr) list(preceded(COMMA,option(lexpr))) [ RPAREN ]
## Transitions:
-- On LPAREN shift to state 146
-- On IDENT shift to state 147
-- On DOT shift to state 148
-- On ASSERT shift to state 150
-- On option(lexpr) shift to state 155
-- On lexpr shift to state 157
-- On component_reference shift to state 158
## Reductions:
-- On RPAREN reduce production option(lexpr) ->
-- On COMMA reduce production option(lexpr) ->

State 155:
## Known stack suffix:
## COMMA option(lexpr)
## LR(1) items:
list(preceded(COMMA,option(lexpr))) -> COMMA option(lexpr) . list(preceded(COMMA,option(lexpr))) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 154
-- On list(preceded(COMMA,option(lexpr))) shift to state 156
## Reductions:
-- On RPAREN reduce production list(preceded(COMMA,option(lexpr))) ->

State 156:
## Known stack suffix:
## COMMA option(lexpr) list(preceded(COMMA,option(lexpr)))
## LR(1) items:
list(preceded(COMMA,option(lexpr))) -> COMMA option(lexpr) list(preceded(COMMA,option(lexpr))) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(preceded(COMMA,option(lexpr))) -> COMMA option(lexpr) list(preceded(COMMA,option(lexpr)))

State 157:
## Known stack suffix:
## lexpr
## LR(1) items:
option(lexpr) -> lexpr . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(lexpr) -> lexpr

State 158:
## Known stack suffix:
## component_reference
## LR(1) items:
component_reference -> component_reference . DOT IDENT [ RPAREN LBRACKET DOT COMMA ]
component_reference -> component_reference . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ RPAREN LBRACKET DOT COMMA ]
lexpr -> component_reference . [ RPAREN COMMA ]
## Transitions:
-- On LBRACKET shift to state 159
-- On DOT shift to state 162
## Reductions:
-- On RPAREN reduce production lexpr -> component_reference
-- On COMMA reduce production lexpr -> component_reference

State 159:
## Known stack suffix:
## component_reference LBRACKET
## LR(1) items:
component_reference -> component_reference LBRACKET . separated_nonempty_list(COMMA,expr) RBRACKET [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 160
-- On expr shift to state 116
## Reductions:

State 160:
## Known stack suffix:
## component_reference LBRACKET separated_nonempty_list(COMMA,expr)
## LR(1) items:
component_reference -> component_reference LBRACKET separated_nonempty_list(COMMA,expr) . RBRACKET [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
-- On RBRACKET shift to state 161
## Reductions:

State 161:
## Known stack suffix:
## component_reference LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET
## LR(1) items:
component_reference -> component_reference LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET . [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_reference -> component_reference LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET

State 162:
## Known stack suffix:
## component_reference DOT
## LR(1) items:
component_reference -> component_reference DOT . IDENT [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
-- On IDENT shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## component_reference DOT IDENT
## LR(1) items:
component_reference -> component_reference DOT IDENT . [ RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_reference -> component_reference DOT IDENT

State 164:
## Known stack suffix:
## option(lexpr) list(preceded(COMMA,option(lexpr)))
## LR(1) items:
patterns -> option(lexpr) list(preceded(COMMA,option(lexpr))) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production patterns -> option(lexpr) list(preceded(COMMA,option(lexpr)))

State 165:
## Known stack suffix:
## LPAREN COMMA patterns
## LR(1) items:
simple_expr -> LPAREN COMMA patterns . RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RPAREN shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## LPAREN COMMA patterns RPAREN
## LR(1) items:
simple_expr -> LPAREN COMMA patterns RPAREN . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LPAREN COMMA patterns RPAREN

State 167:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
simple_expr -> LPAREN expr . RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> LPAREN expr . COMMA patterns RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RPAREN shift to state 168
-- On COMMA shift to state 169
## Reductions:

State 168:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
simple_expr -> LPAREN expr RPAREN . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LPAREN expr RPAREN

State 169:
## Known stack suffix:
## LPAREN expr COMMA
## LR(1) items:
simple_expr -> LPAREN expr COMMA . patterns RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On LPAREN shift to state 146
-- On IDENT shift to state 147
-- On DOT shift to state 148
-- On ASSERT shift to state 150
-- On patterns shift to state 170
-- On option(lexpr) shift to state 153
-- On lexpr shift to state 157
-- On component_reference shift to state 158
## Reductions:
-- On RPAREN reduce production option(lexpr) ->
-- On COMMA reduce production option(lexpr) ->

State 170:
## Known stack suffix:
## LPAREN expr COMMA patterns
## LR(1) items:
simple_expr -> LPAREN expr COMMA patterns . RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On RPAREN shift to state 171
## Reductions:

State 171:
## Known stack suffix:
## LPAREN expr COMMA patterns RPAREN
## LR(1) items:
simple_expr -> LPAREN expr COMMA patterns RPAREN . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simple_expr -> LPAREN expr COMMA patterns RPAREN

State 172:
## Known stack suffix:
## MINUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> MINUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> MINUS simple_expr
-- On STRING reduce production simple_expr -> MINUS simple_expr
-- On SEMICOLON reduce production simple_expr -> MINUS simple_expr
-- On RPAREN reduce production simple_expr -> MINUS simple_expr
-- On RBRACKET reduce production simple_expr -> MINUS simple_expr
-- On RBRACE reduce production simple_expr -> MINUS simple_expr
-- On PLUS reduce production simple_expr -> MINUS simple_expr
-- On OR reduce production simple_expr -> MINUS simple_expr
-- On NEQ reduce production simple_expr -> MINUS simple_expr
-- On MINUS reduce production simple_expr -> MINUS simple_expr
-- On LT reduce production simple_expr -> MINUS simple_expr
-- On LPAREN reduce production simple_expr -> MINUS simple_expr
-- On LOOP reduce production simple_expr -> MINUS simple_expr
-- On LEQ reduce production simple_expr -> MINUS simple_expr
-- On IF reduce production simple_expr -> MINUS simple_expr
-- On IDENT reduce production simple_expr -> MINUS simple_expr
-- On GT reduce production simple_expr -> MINUS simple_expr
-- On GEQ reduce production simple_expr -> MINUS simple_expr
-- On FOR reduce production simple_expr -> MINUS simple_expr
-- On EQEQ reduce production simple_expr -> MINUS simple_expr
-- On EQ reduce production simple_expr -> MINUS simple_expr
-- On EOF reduce production simple_expr -> MINUS simple_expr
-- On ELSEIF reduce production simple_expr -> MINUS simple_expr
-- On ELSE reduce production simple_expr -> MINUS simple_expr
-- On DOTPLUS reduce production simple_expr -> MINUS simple_expr
-- On DOTMINUS reduce production simple_expr -> MINUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> MINUS simple_expr
-- On COMMA reduce production simple_expr -> MINUS simple_expr
-- On COLON reduce production simple_expr -> MINUS simple_expr
-- On ANNOTATION reduce production simple_expr -> MINUS simple_expr
-- On AND reduce production simple_expr -> MINUS simple_expr

State 173:
## Known stack suffix:
## NOT simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> NOT simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On OR shift to state 62
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
-- On AND shift to state 111
## Reductions:
-- On THEN reduce production simple_expr -> NOT simple_expr
-- On STRING reduce production simple_expr -> NOT simple_expr
-- On SEMICOLON reduce production simple_expr -> NOT simple_expr
-- On RPAREN reduce production simple_expr -> NOT simple_expr
-- On RBRACKET reduce production simple_expr -> NOT simple_expr
-- On RBRACE reduce production simple_expr -> NOT simple_expr
-- On LPAREN reduce production simple_expr -> NOT simple_expr
-- On LOOP reduce production simple_expr -> NOT simple_expr
-- On IF reduce production simple_expr -> NOT simple_expr
-- On IDENT reduce production simple_expr -> NOT simple_expr
-- On FOR reduce production simple_expr -> NOT simple_expr
-- On EQ reduce production simple_expr -> NOT simple_expr
-- On EOF reduce production simple_expr -> NOT simple_expr
-- On ELSEIF reduce production simple_expr -> NOT simple_expr
-- On ELSE reduce production simple_expr -> NOT simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> NOT simple_expr
-- On COMMA reduce production simple_expr -> NOT simple_expr
-- On COLON reduce production simple_expr -> NOT simple_expr
-- On ANNOTATION reduce production simple_expr -> NOT simple_expr

State 174:
## Known stack suffix:
## PLUS simple_expr
## LR(1) items:
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
simple_expr -> PLUS simple_expr . [ TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On LBRACKET shift to state 48
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
## Reductions:
-- On THEN reduce production simple_expr -> PLUS simple_expr
-- On STRING reduce production simple_expr -> PLUS simple_expr
-- On SEMICOLON reduce production simple_expr -> PLUS simple_expr
-- On RPAREN reduce production simple_expr -> PLUS simple_expr
-- On RBRACKET reduce production simple_expr -> PLUS simple_expr
-- On RBRACE reduce production simple_expr -> PLUS simple_expr
-- On PLUS reduce production simple_expr -> PLUS simple_expr
-- On OR reduce production simple_expr -> PLUS simple_expr
-- On NEQ reduce production simple_expr -> PLUS simple_expr
-- On MINUS reduce production simple_expr -> PLUS simple_expr
-- On LT reduce production simple_expr -> PLUS simple_expr
-- On LPAREN reduce production simple_expr -> PLUS simple_expr
-- On LOOP reduce production simple_expr -> PLUS simple_expr
-- On LEQ reduce production simple_expr -> PLUS simple_expr
-- On IF reduce production simple_expr -> PLUS simple_expr
-- On IDENT reduce production simple_expr -> PLUS simple_expr
-- On GT reduce production simple_expr -> PLUS simple_expr
-- On GEQ reduce production simple_expr -> PLUS simple_expr
-- On FOR reduce production simple_expr -> PLUS simple_expr
-- On EQEQ reduce production simple_expr -> PLUS simple_expr
-- On EQ reduce production simple_expr -> PLUS simple_expr
-- On EOF reduce production simple_expr -> PLUS simple_expr
-- On ELSEIF reduce production simple_expr -> PLUS simple_expr
-- On ELSE reduce production simple_expr -> PLUS simple_expr
-- On DOTPLUS reduce production simple_expr -> PLUS simple_expr
-- On DOTMINUS reduce production simple_expr -> PLUS simple_expr
-- On CONSTRAINEDBY reduce production simple_expr -> PLUS simple_expr
-- On COMMA reduce production simple_expr -> PLUS simple_expr
-- On COLON reduce production simple_expr -> PLUS simple_expr
-- On ANNOTATION reduce production simple_expr -> PLUS simple_expr
-- On AND reduce production simple_expr -> PLUS simple_expr

State 175:
## Known stack suffix:
## LBRACKET loption(separated_nonempty_list(COMMA,expr))
## LR(1) items:
array_subscripts -> LBRACKET loption(separated_nonempty_list(COMMA,expr)) . RBRACKET [ STRING SEMICOLON RPAREN LPAREN LBRACKET IF IDENT EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
-- On RBRACKET shift to state 176
## Reductions:

State 176:
## Known stack suffix:
## LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET
## LR(1) items:
array_subscripts -> LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IF IDENT EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production array_subscripts -> LBRACKET loption(separated_nonempty_list(COMMA,expr)) RBRACKET

State 177:
## Known stack suffix:
## type_expression class_modification
## LR(1) items:
type_expression -> type_expression class_modification . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_expression -> type_expression class_modification

State 178:
## Known stack suffix:
## type_expression array_subscripts
## LR(1) items:
type_expression -> type_expression array_subscripts . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_expression -> type_expression array_subscripts

State 179:
## Known stack suffix:
## separated_nonempty_list(DOT,ident)
## LR(1) items:
type_expression -> separated_nonempty_list(DOT,ident) . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_expression -> separated_nonempty_list(DOT,ident)

State 180:
## Known stack suffix:
## connectivity
## LR(1) items:
type_expression -> connectivity . type_expression [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 181
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 181:
## Known stack suffix:
## connectivity type_expression
## LR(1) items:
type_expression -> connectivity type_expression . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . array_subscripts [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On LBRACKET shift to state 18
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On STRING reduce production type_expression -> connectivity type_expression
-- On SEMICOLON reduce production type_expression -> connectivity type_expression
-- On RPAREN reduce production type_expression -> connectivity type_expression
-- On LPAREN reduce production type_expression -> connectivity type_expression
-- On IDENT reduce production type_expression -> connectivity type_expression
-- On EOF reduce production type_expression -> connectivity type_expression
-- On CONSTRAINEDBY reduce production type_expression -> connectivity type_expression
-- On COMMA reduce production type_expression -> connectivity type_expression
-- On ANNOTATION reduce production type_expression -> connectivity type_expression

State 182:
## Known stack suffix:
## causality
## LR(1) items:
type_expression -> causality . type_expression [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 183
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 183:
## Known stack suffix:
## causality type_expression
## LR(1) items:
type_expression -> causality type_expression . [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . array_subscripts [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On LBRACKET shift to state 18
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On STRING reduce production type_expression -> causality type_expression
-- On SEMICOLON reduce production type_expression -> causality type_expression
-- On RPAREN reduce production type_expression -> causality type_expression
-- On LPAREN reduce production type_expression -> causality type_expression
-- On IDENT reduce production type_expression -> causality type_expression
-- On EOF reduce production type_expression -> causality type_expression
-- On CONSTRAINEDBY reduce production type_expression -> causality type_expression
-- On COMMA reduce production type_expression -> causality type_expression
-- On ANNOTATION reduce production type_expression -> causality type_expression

State 184:
## Known stack suffix:
## type_prefix type_expression
## LR(1) items:
component_clause -> type_prefix type_expression . separated_nonempty_list(COMMA,declaration) option(constraining_clause) [ SEMICOLON EOF ]
type_expression -> type_expression . array_subscripts [ LPAREN LBRACKET IDENT ]
type_expression -> type_expression . class_modification [ LPAREN LBRACKET IDENT ]
## Transitions:
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On IDENT shift to state 198
-- On separated_nonempty_list(COMMA,declaration) shift to state 280
-- On declaration shift to state 282
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:

State 185:
## Known stack suffix:
## LPAREN
## LR(1) items:
class_modification -> LPAREN . modification_arguments_head RPAREN [ TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
-- On REDECLARE shift to state 186
-- On EACH shift to state 187
-- On modification_arguments_head shift to state 277
-- On modification_arguments shift to state 279
-- On flag(EACH) shift to state 230
## Reductions:
-- On RPAREN reduce production modification_arguments_head ->
-- On REPLACEABLE reduce production flag(EACH) ->
-- On IDENT reduce production flag(EACH) ->
-- On FINAL reduce production flag(EACH) ->

State 186:
## Known stack suffix:
## REDECLARE
## LR(1) items:
modification_arguments -> REDECLARE . flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> REDECLARE . flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause modification_arguments_tail [ RPAREN ]
## Transitions:
-- On EACH shift to state 187
-- On flag(EACH) shift to state 188
## Reductions:
-- On TYPE reduce production flag(EACH) ->
-- On STREAM reduce production flag(EACH) ->
-- On REPLACEABLE reduce production flag(EACH) ->
-- On RECORD reduce production flag(EACH) ->
-- On PARTIAL reduce production flag(EACH) ->
-- On PARAMETER reduce production flag(EACH) ->
-- On PACKAGE reduce production flag(EACH) ->
-- On OUTPUT reduce production flag(EACH) ->
-- On OUTER reduce production flag(EACH) ->
-- On OPERATOR reduce production flag(EACH) ->
-- On MODEL reduce production flag(EACH) ->
-- On INPUT reduce production flag(EACH) ->
-- On INNER reduce production flag(EACH) ->
-- On IDENT reduce production flag(EACH) ->
-- On FUNCTION reduce production flag(EACH) ->
-- On FLOW reduce production flag(EACH) ->
-- On FINAL reduce production flag(EACH) ->
-- On EXPANDABLE reduce production flag(EACH) ->
-- On DOT reduce production flag(EACH) ->
-- On DISCRETE reduce production flag(EACH) ->
-- On CONSTANT reduce production flag(EACH) ->
-- On CONNECTOR reduce production flag(EACH) ->
-- On CLASS reduce production flag(EACH) ->
-- On BLOCK reduce production flag(EACH) ->

State 187:
## Known stack suffix:
## EACH
## LR(1) items:
flag(EACH) -> EACH . [ TYPE STREAM REPLACEABLE RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW FINAL EXPANDABLE DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production flag(EACH) -> EACH

State 188:
## Known stack suffix:
## REDECLARE flag(EACH)
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) . flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> REDECLARE flag(EACH) . flag(FINAL) flag(REPLACEABLE) mod_component_clause modification_arguments_tail [ RPAREN ]
## Transitions:
-- On FINAL shift to state 1
-- On flag(FINAL) shift to state 189
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 189:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL)
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) . flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) . flag(REPLACEABLE) mod_component_clause modification_arguments_tail [ RPAREN ]
## Transitions:
-- On REPLACEABLE shift to state 190
-- On flag(REPLACEABLE) shift to state 191
## Reductions:
-- On TYPE reduce production flag(REPLACEABLE) ->
-- On STREAM reduce production flag(REPLACEABLE) ->
-- On RECORD reduce production flag(REPLACEABLE) ->
-- On PARTIAL reduce production flag(REPLACEABLE) ->
-- On PARAMETER reduce production flag(REPLACEABLE) ->
-- On PACKAGE reduce production flag(REPLACEABLE) ->
-- On OUTPUT reduce production flag(REPLACEABLE) ->
-- On OUTER reduce production flag(REPLACEABLE) ->
-- On OPERATOR reduce production flag(REPLACEABLE) ->
-- On MODEL reduce production flag(REPLACEABLE) ->
-- On INPUT reduce production flag(REPLACEABLE) ->
-- On INNER reduce production flag(REPLACEABLE) ->
-- On IDENT reduce production flag(REPLACEABLE) ->
-- On FUNCTION reduce production flag(REPLACEABLE) ->
-- On FLOW reduce production flag(REPLACEABLE) ->
-- On EXPANDABLE reduce production flag(REPLACEABLE) ->
-- On DOT reduce production flag(REPLACEABLE) ->
-- On DISCRETE reduce production flag(REPLACEABLE) ->
-- On CONSTANT reduce production flag(REPLACEABLE) ->
-- On CONNECTOR reduce production flag(REPLACEABLE) ->
-- On CLASS reduce production flag(REPLACEABLE) ->
-- On BLOCK reduce production flag(REPLACEABLE) ->

State 190:
## Known stack suffix:
## REPLACEABLE
## LR(1) items:
flag(REPLACEABLE) -> REPLACEABLE . [ TYPE STREAM RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW EXPANDABLE ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production flag(REPLACEABLE) -> REPLACEABLE

State 191:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE)
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) . flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) . mod_component_clause modification_arguments_tail [ RPAREN ]
## Transitions:
-- On PARTIAL shift to state 192
-- On OUTER shift to state 193
-- On INNER shift to state 194
-- On scope shift to state 196
-- On mod_component_clause shift to state 227
-- On flag(PARTIAL) shift to state 269
## Reductions:
-- On TYPE reduce production flag(PARTIAL) ->
-- On STREAM reduce production scope ->
-- On RECORD reduce production flag(PARTIAL) ->
-- On PARAMETER reduce production scope ->
-- On PACKAGE reduce production flag(PARTIAL) ->
-- On OUTPUT reduce production scope ->
-- On OPERATOR reduce production flag(PARTIAL) ->
-- On MODEL reduce production flag(PARTIAL) ->
-- On INPUT reduce production scope ->
-- On IDENT reduce production scope ->
-- On FUNCTION reduce production flag(PARTIAL) ->
-- On FLOW reduce production scope ->
-- On EXPANDABLE reduce production flag(PARTIAL) ->
-- On DOT reduce production scope ->
-- On DISCRETE reduce production scope ->
-- On CONSTANT reduce production scope ->
-- On CONNECTOR reduce production flag(PARTIAL) ->
-- On CLASS reduce production flag(PARTIAL) ->
-- On BLOCK reduce production flag(PARTIAL) ->

State 192:
## Known stack suffix:
## PARTIAL
## LR(1) items:
flag(PARTIAL) -> PARTIAL . [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production flag(PARTIAL) -> PARTIAL

State 193:
## Known stack suffix:
## OUTER
## LR(1) items:
scope -> OUTER . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production scope -> OUTER

State 194:
## Known stack suffix:
## INNER
## LR(1) items:
scope -> INNER . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
scope -> INNER . OUTER [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
-- On OUTER shift to state 195
## Reductions:
-- On STREAM reduce production scope -> INNER
-- On PARAMETER reduce production scope -> INNER
-- On OUTPUT reduce production scope -> INNER
-- On INPUT reduce production scope -> INNER
-- On IDENT reduce production scope -> INNER
-- On FLOW reduce production scope -> INNER
-- On DOT reduce production scope -> INNER
-- On DISCRETE reduce production scope -> INNER
-- On CONSTANT reduce production scope -> INNER

State 195:
## Known stack suffix:
## INNER OUTER
## LR(1) items:
scope -> INNER OUTER . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production scope -> INNER OUTER

State 196:
## Known stack suffix:
## scope
## LR(1) items:
mod_component_clause -> scope . type_expression declaration option(constraining_clause) [ RPAREN COMMA ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 197
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 197:
## Known stack suffix:
## scope type_expression
## LR(1) items:
mod_component_clause -> scope type_expression . declaration option(constraining_clause) [ RPAREN COMMA ]
type_expression -> type_expression . array_subscripts [ LPAREN LBRACKET IDENT ]
type_expression -> type_expression . class_modification [ LPAREN LBRACKET IDENT ]
## Transitions:
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On IDENT shift to state 198
-- On declaration shift to state 221
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:

State 198:
## Known stack suffix:
## IDENT
## LR(1) items:
declaration -> IDENT . option(array_subscripts) decl_modification option(decl_condition) comment [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On LBRACKET shift to state 18
-- On option(array_subscripts) shift to state 199
-- On array_subscripts shift to state 220
## Reductions:
-- On STRING reduce production option(array_subscripts) ->
-- On SEMICOLON reduce production option(array_subscripts) ->
-- On RPAREN reduce production option(array_subscripts) ->
-- On LPAREN reduce production option(array_subscripts) ->
-- On IF reduce production option(array_subscripts) ->
-- On EQ reduce production option(array_subscripts) ->
-- On EOF reduce production option(array_subscripts) ->
-- On CONSTRAINEDBY reduce production option(array_subscripts) ->
-- On COMMA reduce production option(array_subscripts) ->
-- On COLONEQ reduce production option(array_subscripts) ->
-- On ANNOTATION reduce production option(array_subscripts) ->

State 199:
## Known stack suffix:
## IDENT option(array_subscripts)
## LR(1) items:
declaration -> IDENT option(array_subscripts) . decl_modification option(decl_condition) comment [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On LPAREN shift to state 185
-- On option(class_modification) shift to state 200
-- On decl_modification shift to state 206
-- On class_modification shift to state 219
## Reductions:
-- On STRING reduce production option(class_modification) ->
-- On SEMICOLON reduce production option(class_modification) ->
-- On RPAREN reduce production option(class_modification) ->
-- On IF reduce production option(class_modification) ->
-- On EQ reduce production option(class_modification) ->
-- On EOF reduce production option(class_modification) ->
-- On CONSTRAINEDBY reduce production option(class_modification) ->
-- On COMMA reduce production option(class_modification) ->
-- On COLONEQ reduce production option(class_modification) ->
-- On ANNOTATION reduce production option(class_modification) ->

State 200:
## Known stack suffix:
## option(class_modification)
## LR(1) items:
decl_modification -> option(class_modification) . option(preceded(binder,expr)) [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On EQ shift to state 201
-- On COLONEQ shift to state 203
-- On option(preceded(binder,expr)) shift to state 205
## Reductions:
-- On STRING reduce production option(preceded(binder,expr)) ->
-- On SEMICOLON reduce production option(preceded(binder,expr)) ->
-- On RPAREN reduce production option(preceded(binder,expr)) ->
-- On IF reduce production option(preceded(binder,expr)) ->
-- On EOF reduce production option(preceded(binder,expr)) ->
-- On CONSTRAINEDBY reduce production option(preceded(binder,expr)) ->
-- On COMMA reduce production option(preceded(binder,expr)) ->
-- On ANNOTATION reduce production option(preceded(binder,expr)) ->

State 201:
## Known stack suffix:
## EQ
## LR(1) items:
option(preceded(binder,expr)) -> EQ . expr [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 202
## Reductions:

State 202:
## Known stack suffix:
## EQ expr
## LR(1) items:
option(preceded(binder,expr)) -> EQ expr . [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(preceded(binder,expr)) -> EQ expr

State 203:
## Known stack suffix:
## COLONEQ
## LR(1) items:
option(preceded(binder,expr)) -> COLONEQ . expr [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 204
## Reductions:

State 204:
## Known stack suffix:
## COLONEQ expr
## LR(1) items:
option(preceded(binder,expr)) -> COLONEQ expr . [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(preceded(binder,expr)) -> COLONEQ expr

State 205:
## Known stack suffix:
## option(class_modification) option(preceded(binder,expr))
## LR(1) items:
decl_modification -> option(class_modification) option(preceded(binder,expr)) . [ STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl_modification -> option(class_modification) option(preceded(binder,expr))

State 206:
## Known stack suffix:
## IDENT option(array_subscripts) decl_modification
## LR(1) items:
declaration -> IDENT option(array_subscripts) decl_modification . option(decl_condition) comment [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On IF shift to state 207
-- On option(decl_condition) shift to state 209
-- On decl_condition shift to state 218
## Reductions:
-- On STRING reduce production option(decl_condition) ->
-- On SEMICOLON reduce production option(decl_condition) ->
-- On RPAREN reduce production option(decl_condition) ->
-- On EOF reduce production option(decl_condition) ->
-- On CONSTRAINEDBY reduce production option(decl_condition) ->
-- On COMMA reduce production option(decl_condition) ->
-- On ANNOTATION reduce production option(decl_condition) ->

State 207:
## Known stack suffix:
## IF
## LR(1) items:
decl_condition -> IF . expr [ STRING SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 208
## Reductions:

State 208:
## Known stack suffix:
## IF expr
## LR(1) items:
decl_condition -> IF expr . [ STRING SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production decl_condition -> IF expr

State 209:
## Known stack suffix:
## IDENT option(array_subscripts) decl_modification option(decl_condition)
## LR(1) items:
declaration -> IDENT option(array_subscripts) decl_modification option(decl_condition) . comment [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 217
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On RPAREN reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 210:
## Known stack suffix:
## STRING
## LR(1) items:
str -> STRING . [ TYPE STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production str -> STRING

State 211:
## Known stack suffix:
## str
## LR(1) items:
option(str) -> str . [ TYPE STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(str) -> str

State 212:
## Known stack suffix:
## option(str)
## LR(1) items:
comment -> option(str) . option(annotation) [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On ANNOTATION shift to state 213
-- On option(annotation) shift to state 215
-- On annotation shift to state 216
## Reductions:
-- On SEMICOLON reduce production option(annotation) ->
-- On RPAREN reduce production option(annotation) ->
-- On EOF reduce production option(annotation) ->
-- On CONSTRAINEDBY reduce production option(annotation) ->
-- On COMMA reduce production option(annotation) ->

State 213:
## Known stack suffix:
## ANNOTATION
## LR(1) items:
annotation -> ANNOTATION . class_modification [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
-- On LPAREN shift to state 185
-- On class_modification shift to state 214
## Reductions:

State 214:
## Known stack suffix:
## ANNOTATION class_modification
## LR(1) items:
annotation -> ANNOTATION class_modification . [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> ANNOTATION class_modification

State 215:
## Known stack suffix:
## option(str) option(annotation)
## LR(1) items:
comment -> option(str) option(annotation) . [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comment -> option(str) option(annotation)

State 216:
## Known stack suffix:
## annotation
## LR(1) items:
option(annotation) -> annotation . [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(annotation) -> annotation

State 217:
## Known stack suffix:
## IDENT option(array_subscripts) decl_modification option(decl_condition) comment
## LR(1) items:
declaration -> IDENT option(array_subscripts) decl_modification option(decl_condition) comment . [ SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production declaration -> IDENT option(array_subscripts) decl_modification option(decl_condition) comment

State 218:
## Known stack suffix:
## decl_condition
## LR(1) items:
option(decl_condition) -> decl_condition . [ STRING SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(decl_condition) -> decl_condition

State 219:
## Known stack suffix:
## class_modification
## LR(1) items:
option(class_modification) -> class_modification . [ TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(class_modification) -> class_modification

State 220:
## Known stack suffix:
## array_subscripts
## LR(1) items:
option(array_subscripts) -> array_subscripts . [ STRING SEMICOLON RPAREN LPAREN IF EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(array_subscripts) -> array_subscripts

State 221:
## Known stack suffix:
## scope type_expression declaration
## LR(1) items:
mod_component_clause -> scope type_expression declaration . option(constraining_clause) [ RPAREN COMMA ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 225
-- On constraining_clause shift to state 226
## Reductions:
-- On RPAREN reduce production option(constraining_clause) ->
-- On COMMA reduce production option(constraining_clause) ->

State 222:
## Known stack suffix:
## CONSTRAINEDBY
## LR(1) items:
constraining_clause -> CONSTRAINEDBY . type_expression comment [ SEMICOLON RPAREN EOF COMMA ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 223
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 223:
## Known stack suffix:
## CONSTRAINEDBY type_expression
## LR(1) items:
constraining_clause -> CONSTRAINEDBY type_expression . comment [ SEMICOLON RPAREN EOF COMMA ]
type_expression -> type_expression . array_subscripts [ STRING SEMICOLON RPAREN LPAREN LBRACKET EOF COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING SEMICOLON RPAREN LPAREN LBRACKET EOF COMMA ANNOTATION ]
## Transitions:
-- On STRING shift to state 210
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 224
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On RPAREN reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 224:
## Known stack suffix:
## CONSTRAINEDBY type_expression comment
## LR(1) items:
constraining_clause -> CONSTRAINEDBY type_expression comment . [ SEMICOLON RPAREN EOF COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constraining_clause -> CONSTRAINEDBY type_expression comment

State 225:
## Known stack suffix:
## scope type_expression declaration option(constraining_clause)
## LR(1) items:
mod_component_clause -> scope type_expression declaration option(constraining_clause) . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mod_component_clause -> scope type_expression declaration option(constraining_clause)

State 226:
## Known stack suffix:
## constraining_clause
## LR(1) items:
option(constraining_clause) -> constraining_clause . [ SEMICOLON RPAREN EOF COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(constraining_clause) -> constraining_clause

State 227:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause . modification_arguments_tail [ RPAREN ]
## Transitions:
-- On COMMA shift to state 228
-- On modification_arguments_tail shift to state 268
## Reductions:
-- On RPAREN reduce production modification_arguments_tail ->

State 228:
## Known stack suffix:
## COMMA
## LR(1) items:
modification_arguments_tail -> COMMA . modification_arguments [ RPAREN ]
## Transitions:
-- On REDECLARE shift to state 186
-- On EACH shift to state 187
-- On modification_arguments shift to state 229
-- On flag(EACH) shift to state 230
## Reductions:
-- On REPLACEABLE reduce production flag(EACH) ->
-- On IDENT reduce production flag(EACH) ->
-- On FINAL reduce production flag(EACH) ->

State 229:
## Known stack suffix:
## COMMA modification_arguments
## LR(1) items:
modification_arguments_tail -> COMMA modification_arguments . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments_tail -> COMMA modification_arguments

State 230:
## Known stack suffix:
## flag(EACH)
## LR(1) items:
modification_arguments -> flag(EACH) . flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> flag(EACH) . flag(FINAL) REPLACEABLE mod_component_clause modification_arguments_tail [ RPAREN ]
modification_arguments -> flag(EACH) . flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment modification_arguments_tail [ RPAREN ]
## Transitions:
-- On FINAL shift to state 1
-- On flag(FINAL) shift to state 231
## Reductions:
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->

State 231:
## Known stack suffix:
## flag(EACH) flag(FINAL)
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) . REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> flag(EACH) flag(FINAL) . REPLACEABLE mod_component_clause modification_arguments_tail [ RPAREN ]
modification_arguments -> flag(EACH) flag(FINAL) . separated_nonempty_list(DOT,ident) option(modification) comment modification_arguments_tail [ RPAREN ]
## Transitions:
-- On REPLACEABLE shift to state 232
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 256
-- On ident shift to state 11
## Reductions:

State 232:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE . flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE . mod_component_clause modification_arguments_tail [ RPAREN ]
## Transitions:
-- On PARTIAL shift to state 192
-- On OUTER shift to state 193
-- On INNER shift to state 194
-- On scope shift to state 196
-- On mod_component_clause shift to state 233
-- On flag(PARTIAL) shift to state 235
## Reductions:
-- On TYPE reduce production flag(PARTIAL) ->
-- On STREAM reduce production scope ->
-- On RECORD reduce production flag(PARTIAL) ->
-- On PARAMETER reduce production scope ->
-- On PACKAGE reduce production flag(PARTIAL) ->
-- On OUTPUT reduce production scope ->
-- On OPERATOR reduce production flag(PARTIAL) ->
-- On MODEL reduce production flag(PARTIAL) ->
-- On INPUT reduce production scope ->
-- On IDENT reduce production scope ->
-- On FUNCTION reduce production flag(PARTIAL) ->
-- On FLOW reduce production scope ->
-- On EXPANDABLE reduce production flag(PARTIAL) ->
-- On DOT reduce production scope ->
-- On DISCRETE reduce production scope ->
-- On CONSTANT reduce production scope ->
-- On CONNECTOR reduce production flag(PARTIAL) ->
-- On CLASS reduce production flag(PARTIAL) ->
-- On BLOCK reduce production flag(PARTIAL) ->

State 233:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE mod_component_clause
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE mod_component_clause . modification_arguments_tail [ RPAREN ]
## Transitions:
-- On COMMA shift to state 228
-- On modification_arguments_tail shift to state 234
## Reductions:
-- On RPAREN reduce production modification_arguments_tail ->

State 234:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE mod_component_clause modification_arguments_tail
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE mod_component_clause modification_arguments_tail . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE mod_component_clause modification_arguments_tail

State 235:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL)
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) . type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On TYPE shift to state 236
-- On RECORD shift to state 237
-- On PACKAGE shift to state 238
-- On OPERATOR shift to state 239
-- On MODEL shift to state 242
-- On FUNCTION shift to state 243
-- On EXPANDABLE shift to state 244
-- On CONNECTOR shift to state 246
-- On CLASS shift to state 247
-- On BLOCK shift to state 248
-- On type_sort shift to state 249
## Reductions:

State 236:
## Known stack suffix:
## TYPE
## LR(1) items:
type_sort -> TYPE . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> TYPE

State 237:
## Known stack suffix:
## RECORD
## LR(1) items:
type_sort -> RECORD . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> RECORD

State 238:
## Known stack suffix:
## PACKAGE
## LR(1) items:
type_sort -> PACKAGE . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> PACKAGE

State 239:
## Known stack suffix:
## OPERATOR
## LR(1) items:
type_sort -> OPERATOR . [ IDENT EXTENDS ]
type_sort -> OPERATOR . RECORD [ IDENT EXTENDS ]
type_sort -> OPERATOR . FUNCTION [ IDENT EXTENDS ]
## Transitions:
-- On RECORD shift to state 240
-- On FUNCTION shift to state 241
## Reductions:
-- On IDENT reduce production type_sort -> OPERATOR
-- On EXTENDS reduce production type_sort -> OPERATOR

State 240:
## Known stack suffix:
## OPERATOR RECORD
## LR(1) items:
type_sort -> OPERATOR RECORD . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> OPERATOR RECORD

State 241:
## Known stack suffix:
## OPERATOR FUNCTION
## LR(1) items:
type_sort -> OPERATOR FUNCTION . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> OPERATOR FUNCTION

State 242:
## Known stack suffix:
## MODEL
## LR(1) items:
type_sort -> MODEL . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> MODEL

State 243:
## Known stack suffix:
## FUNCTION
## LR(1) items:
type_sort -> FUNCTION . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> FUNCTION

State 244:
## Known stack suffix:
## EXPANDABLE
## LR(1) items:
type_sort -> EXPANDABLE . CONNECTOR [ IDENT EXTENDS ]
## Transitions:
-- On CONNECTOR shift to state 245
## Reductions:

State 245:
## Known stack suffix:
## EXPANDABLE CONNECTOR
## LR(1) items:
type_sort -> EXPANDABLE CONNECTOR . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> EXPANDABLE CONNECTOR

State 246:
## Known stack suffix:
## CONNECTOR
## LR(1) items:
type_sort -> CONNECTOR . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> CONNECTOR

State 247:
## Known stack suffix:
## CLASS
## LR(1) items:
type_sort -> CLASS . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> CLASS

State 248:
## Known stack suffix:
## BLOCK
## LR(1) items:
type_sort -> BLOCK . [ IDENT EXTENDS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_sort -> BLOCK

State 249:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort . ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On IDENT shift to state 7
-- On ident shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident . EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On EQ shift to state 251
## Reductions:

State 251:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ . type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 252
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 252:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression . comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
type_expression -> type_expression . array_subscripts [ STRING RPAREN LPAREN LBRACKET CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING RPAREN LPAREN LBRACKET CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On STRING shift to state 210
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 253
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On RPAREN reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 253:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment . option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 254
-- On constraining_clause shift to state 226
## Reductions:
-- On RPAREN reduce production option(constraining_clause) ->
-- On COMMA reduce production option(constraining_clause) ->

State 254:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause)
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) . modification_arguments_tail [ RPAREN ]
## Transitions:
-- On COMMA shift to state 228
-- On modification_arguments_tail shift to state 255
## Reductions:
-- On RPAREN reduce production modification_arguments_tail ->

State 255:
## Known stack suffix:
## flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments -> flag(EACH) flag(FINAL) REPLACEABLE flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail

State 256:
## Known stack suffix:
## flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident)
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) . option(modification) comment modification_arguments_tail [ RPAREN ]
## Transitions:
-- On LPAREN shift to state 185
-- On EQ shift to state 257
-- On COLONEQ shift to state 259
-- On option(modification) shift to state 261
-- On modification shift to state 264
-- On class_modification shift to state 265
## Reductions:
-- On STRING reduce production option(modification) ->
-- On RPAREN reduce production option(modification) ->
-- On COMMA reduce production option(modification) ->
-- On ANNOTATION reduce production option(modification) ->

State 257:
## Known stack suffix:
## EQ
## LR(1) items:
modification -> EQ . expr [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## EQ expr
## LR(1) items:
modification -> EQ expr . [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification -> EQ expr

State 259:
## Known stack suffix:
## COLONEQ
## LR(1) items:
modification -> COLONEQ . expr [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## COLONEQ expr
## LR(1) items:
modification -> COLONEQ expr . [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification -> COLONEQ expr

State 261:
## Known stack suffix:
## flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification)
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) . comment modification_arguments_tail [ RPAREN ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 262
## Reductions:
-- On RPAREN reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 262:
## Known stack suffix:
## flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment . modification_arguments_tail [ RPAREN ]
## Transitions:
-- On COMMA shift to state 228
-- On modification_arguments_tail shift to state 263
## Reductions:
-- On RPAREN reduce production modification_arguments_tail ->

State 263:
## Known stack suffix:
## flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment modification_arguments_tail
## LR(1) items:
modification_arguments -> flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment modification_arguments_tail . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments -> flag(EACH) flag(FINAL) separated_nonempty_list(DOT,ident) option(modification) comment modification_arguments_tail

State 264:
## Known stack suffix:
## modification
## LR(1) items:
option(modification) -> modification . [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(modification) -> modification

State 265:
## Known stack suffix:
## class_modification
## LR(1) items:
modification -> class_modification . [ STRING RPAREN COMMA ANNOTATION ]
modification -> class_modification . EQ expr [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
-- On EQ shift to state 266
## Reductions:
-- On STRING reduce production modification -> class_modification
-- On RPAREN reduce production modification -> class_modification
-- On COMMA reduce production modification -> class_modification
-- On ANNOTATION reduce production modification -> class_modification

State 266:
## Known stack suffix:
## class_modification EQ
## LR(1) items:
modification -> class_modification EQ . expr [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## class_modification EQ expr
## LR(1) items:
modification -> class_modification EQ expr . [ STRING RPAREN COMMA ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification -> class_modification EQ expr

State 268:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause modification_arguments_tail
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause modification_arguments_tail . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) mod_component_clause modification_arguments_tail

State 269:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL)
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) . type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On TYPE shift to state 236
-- On RECORD shift to state 237
-- On PACKAGE shift to state 238
-- On OPERATOR shift to state 239
-- On MODEL shift to state 242
-- On FUNCTION shift to state 243
-- On EXPANDABLE shift to state 244
-- On CONNECTOR shift to state 246
-- On CLASS shift to state 247
-- On BLOCK shift to state 248
-- On type_sort shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort . ident EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On IDENT shift to state 7
-- On ident shift to state 271
## Reductions:

State 271:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident . EQ type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On EQ shift to state 272
## Reductions:

State 272:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ . type_expression comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 273
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 273:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression . comment option(constraining_clause) modification_arguments_tail [ RPAREN ]
type_expression -> type_expression . array_subscripts [ STRING RPAREN LPAREN LBRACKET CONSTRAINEDBY COMMA ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING RPAREN LPAREN LBRACKET CONSTRAINEDBY COMMA ANNOTATION ]
## Transitions:
-- On STRING shift to state 210
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 274
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On RPAREN reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 274:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment . option(constraining_clause) modification_arguments_tail [ RPAREN ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 275
-- On constraining_clause shift to state 226
## Reductions:
-- On RPAREN reduce production option(constraining_clause) ->
-- On COMMA reduce production option(constraining_clause) ->

State 275:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause)
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) . modification_arguments_tail [ RPAREN ]
## Transitions:
-- On COMMA shift to state 228
-- On modification_arguments_tail shift to state 276
## Reductions:
-- On RPAREN reduce production modification_arguments_tail ->

State 276:
## Known stack suffix:
## REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail
## LR(1) items:
modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments -> REDECLARE flag(EACH) flag(FINAL) flag(REPLACEABLE) flag(PARTIAL) type_sort ident EQ type_expression comment option(constraining_clause) modification_arguments_tail

State 277:
## Known stack suffix:
## LPAREN modification_arguments_head
## LR(1) items:
class_modification -> LPAREN modification_arguments_head . RPAREN [ TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
-- On RPAREN shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## LPAREN modification_arguments_head RPAREN
## LR(1) items:
class_modification -> LPAREN modification_arguments_head RPAREN . [ TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production class_modification -> LPAREN modification_arguments_head RPAREN

State 279:
## Known stack suffix:
## modification_arguments
## LR(1) items:
modification_arguments_head -> modification_arguments . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production modification_arguments_head -> modification_arguments

State 280:
## Known stack suffix:
## type_prefix type_expression separated_nonempty_list(COMMA,declaration)
## LR(1) items:
component_clause -> type_prefix type_expression separated_nonempty_list(COMMA,declaration) . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 281
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 281:
## Known stack suffix:
## type_prefix type_expression separated_nonempty_list(COMMA,declaration) option(constraining_clause)
## LR(1) items:
component_clause -> type_prefix type_expression separated_nonempty_list(COMMA,declaration) option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_clause -> type_prefix type_expression separated_nonempty_list(COMMA,declaration) option(constraining_clause)

State 282:
## Known stack suffix:
## declaration
## LR(1) items:
separated_nonempty_list(COMMA,declaration) -> declaration . [ SEMICOLON EOF CONSTRAINEDBY ]
separated_nonempty_list(COMMA,declaration) -> declaration . COMMA separated_nonempty_list(COMMA,declaration) [ SEMICOLON EOF CONSTRAINEDBY ]
## Transitions:
-- On COMMA shift to state 283
## Reductions:
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,declaration) -> declaration
-- On EOF reduce production separated_nonempty_list(COMMA,declaration) -> declaration
-- On CONSTRAINEDBY reduce production separated_nonempty_list(COMMA,declaration) -> declaration

State 283:
## Known stack suffix:
## declaration COMMA
## LR(1) items:
separated_nonempty_list(COMMA,declaration) -> declaration COMMA . separated_nonempty_list(COMMA,declaration) [ SEMICOLON EOF CONSTRAINEDBY ]
## Transitions:
-- On IDENT shift to state 198
-- On separated_nonempty_list(COMMA,declaration) shift to state 284
-- On declaration shift to state 282
## Reductions:

State 284:
## Known stack suffix:
## declaration COMMA separated_nonempty_list(COMMA,declaration)
## LR(1) items:
separated_nonempty_list(COMMA,declaration) -> declaration COMMA separated_nonempty_list(COMMA,declaration) . [ SEMICOLON EOF CONSTRAINEDBY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,declaration) -> declaration COMMA separated_nonempty_list(COMMA,declaration)

State 285:
## Known stack suffix:
## modelica_definitions
## LR(1) items:
modelica_definitions' -> modelica_definitions . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_definitions

State 286:
## Known stack suffix:
## flag(FINAL)
## LR(1) items:
type_prefix -> flag(FINAL) . flag(REPLACEABLE) scope [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
-- On REPLACEABLE shift to state 190
-- On flag(REPLACEABLE) shift to state 287
## Reductions:
-- On STREAM reduce production flag(REPLACEABLE) ->
-- On PARAMETER reduce production flag(REPLACEABLE) ->
-- On OUTPUT reduce production flag(REPLACEABLE) ->
-- On OUTER reduce production flag(REPLACEABLE) ->
-- On INPUT reduce production flag(REPLACEABLE) ->
-- On INNER reduce production flag(REPLACEABLE) ->
-- On IDENT reduce production flag(REPLACEABLE) ->
-- On FLOW reduce production flag(REPLACEABLE) ->
-- On DOT reduce production flag(REPLACEABLE) ->
-- On DISCRETE reduce production flag(REPLACEABLE) ->
-- On CONSTANT reduce production flag(REPLACEABLE) ->

State 287:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE)
## LR(1) items:
type_prefix -> flag(FINAL) flag(REPLACEABLE) . scope [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
-- On OUTER shift to state 193
-- On INNER shift to state 194
-- On scope shift to state 288
## Reductions:
-- On STREAM reduce production scope ->
-- On PARAMETER reduce production scope ->
-- On OUTPUT reduce production scope ->
-- On INPUT reduce production scope ->
-- On IDENT reduce production scope ->
-- On FLOW reduce production scope ->
-- On DOT reduce production scope ->
-- On DISCRETE reduce production scope ->
-- On CONSTANT reduce production scope ->

State 288:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE) scope
## LR(1) items:
type_prefix -> flag(FINAL) flag(REPLACEABLE) scope . [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_prefix -> flag(FINAL) flag(REPLACEABLE) scope

State 289:
## Known stack suffix:
## component_clauses
## LR(1) items:
modelica_definitions -> component_clauses . EOF [ # ]
## Transitions:
-- On EOF shift to state 290
## Reductions:

State 290:
## Known stack suffix:
## component_clauses EOF
## LR(1) items:
modelica_definitions -> component_clauses EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_definitions -> component_clauses EOF

State 291:
## Known stack suffix:
## component_clause
## LR(1) items:
component_clauses -> component_clause . [ EOF ]
component_clauses -> component_clause . SEMICOLON component_clauses [ EOF ]
## Transitions:
-- On SEMICOLON shift to state 292
## Reductions:
-- On EOF reduce production component_clauses -> component_clause

State 292:
## Known stack suffix:
## component_clause SEMICOLON
## LR(1) items:
component_clauses -> component_clause SEMICOLON . component_clauses [ EOF ]
## Transitions:
-- On FINAL shift to state 1
-- On type_prefix shift to state 2
-- On flag(FINAL) shift to state 286
-- On component_clauses shift to state 293
-- On component_clause shift to state 291
## Reductions:
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->

State 293:
## Known stack suffix:
## component_clause SEMICOLON component_clauses
## LR(1) items:
component_clauses -> component_clause SEMICOLON component_clauses . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production component_clauses -> component_clause SEMICOLON component_clauses

State 294:
## Known stack suffix:
##
## LR(1) items:
modelica_eq' -> . modelica_eq [ # ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On modelica_eq shift to state 337
-- On equation_body shift to state 309
-- On equation shift to state 338
## Reductions:

State 295:
## Known stack suffix:
## WHEN
## LR(1) items:
equation_body -> WHEN . expr THEN list(equation) list(elsewhen_equation) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## WHEN expr
## LR(1) items:
equation_body -> WHEN expr . THEN list(equation) list(elsewhen_equation) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On THEN shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## WHEN expr THEN
## LR(1) items:
equation_body -> WHEN expr THEN . list(equation) list(elsewhen_equation) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 328
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDWHEN reduce production list(equation) ->
-- On ELSEWHEN reduce production list(equation) ->

State 298:
## Known stack suffix:
## IF
## LR(1) items:
equation_body -> IF . expr THEN list(equation) list(elseif_equation) else_equations ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 299
## Reductions:

State 299:
## Known stack suffix:
## IF expr
## LR(1) items:
equation_body -> IF expr . THEN list(equation) list(elseif_equation) else_equations ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On THEN shift to state 300
## Reductions:

State 300:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
equation_body -> IF expr THEN . list(equation) list(elseif_equation) else_equations ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 316
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDIF reduce production list(equation) ->
-- On ELSEIF reduce production list(equation) ->
-- On ELSE reduce production list(equation) ->

State 301:
## Known stack suffix:
## FOR
## LR(1) items:
equation_body -> FOR . list(index) LOOP list(equation) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On IDENT shift to state 7
-- On list(index) shift to state 302
-- On index shift to state 314
-- On ident shift to state 100
## Reductions:
-- On LOOP reduce production list(index) ->

State 302:
## Known stack suffix:
## FOR list(index)
## LR(1) items:
equation_body -> FOR list(index) . LOOP list(equation) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On LOOP shift to state 303
## Reductions:

State 303:
## Known stack suffix:
## FOR list(index) LOOP
## LR(1) items:
equation_body -> FOR list(index) LOOP . list(equation) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 307
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDFOR reduce production list(equation) ->

State 304:
## Known stack suffix:
## simple_expr
## LR(1) items:
equation_body -> simple_expr . [ STRING SEMICOLON ANNOTATION ]
equation_body -> simple_expr . EQ expr [ STRING SEMICOLON ANNOTATION ]
simple_expr -> simple_expr . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . LPAREN function_args RPAREN [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . PLUS simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . MINUS simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . TIMES simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DIV simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . POWER simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOTPLUS simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOTMINUS simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOTTIMES simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOTDIV simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOTPOWER simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . LT simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . GT simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . GEQ simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . LEQ simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . NEQ simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . EQEQ simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . AND simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . OR simple_expr [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
simple_expr -> simple_expr . DOT IDENT [ TIMES STRING SEMICOLON POWER PLUS OR NEQ MINUS LT LPAREN LEQ LBRACKET GT GEQ EQEQ EQ DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV ANNOTATION AND ]
## Transitions:
-- On TIMES shift to state 44
-- On POWER shift to state 46
-- On PLUS shift to state 50
-- On OR shift to state 62
-- On NEQ shift to state 64
-- On MINUS shift to state 66
-- On LT shift to state 72
-- On LPAREN shift to state 82
-- On LEQ shift to state 74
-- On LBRACKET shift to state 48
-- On GT shift to state 76
-- On GEQ shift to state 78
-- On EQEQ shift to state 80
-- On EQ shift to state 305
-- On DOTTIMES shift to state 52
-- On DOTPOWER shift to state 54
-- On DOTPLUS shift to state 68
-- On DOTMINUS shift to state 70
-- On DOTDIV shift to state 58
-- On DOT shift to state 56
-- On DIV shift to state 60
-- On AND shift to state 111
## Reductions:
-- On STRING reduce production equation_body -> simple_expr
-- On SEMICOLON reduce production equation_body -> simple_expr
-- On ANNOTATION reduce production equation_body -> simple_expr

State 305:
## Known stack suffix:
## simple_expr EQ
## LR(1) items:
equation_body -> simple_expr EQ . expr [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## simple_expr EQ expr
## LR(1) items:
equation_body -> simple_expr EQ expr . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_body -> simple_expr EQ expr

State 307:
## Known stack suffix:
## FOR list(index) LOOP list(equation)
## LR(1) items:
equation_body -> FOR list(index) LOOP list(equation) . ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDFOR shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## FOR list(index) LOOP list(equation) ENDFOR
## LR(1) items:
equation_body -> FOR list(index) LOOP list(equation) ENDFOR . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_body -> FOR list(index) LOOP list(equation) ENDFOR

State 309:
## Known stack suffix:
## equation_body
## LR(1) items:
equation -> equation_body . comment SEMICOLON [ WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION EOF END_IDENT ENDWHEN ENDIF ENDFOR END ELSEWHEN ELSEIF ELSE DOTPLUS DOTMINUS DOT DER COLON ASSERT ANNOTATION ALGORITHM ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 310
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 310:
## Known stack suffix:
## equation_body comment
## LR(1) items:
equation -> equation_body comment . SEMICOLON [ WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION EOF END_IDENT ENDWHEN ENDIF ENDFOR END ELSEWHEN ELSEIF ELSE DOTPLUS DOTMINUS DOT DER COLON ASSERT ANNOTATION ALGORITHM ]
## Transitions:
-- On SEMICOLON shift to state 311
## Reductions:

State 311:
## Known stack suffix:
## equation_body comment SEMICOLON
## LR(1) items:
equation -> equation_body comment SEMICOLON . [ WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION EOF END_IDENT ENDWHEN ENDIF ENDFOR END ELSEWHEN ELSEIF ELSE DOTPLUS DOTMINUS DOT DER COLON ASSERT ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation -> equation_body comment SEMICOLON

State 312:
## Known stack suffix:
## equation
## LR(1) items:
list(equation) -> equation . list(equation) [ ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 313
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDWHEN reduce production list(equation) ->
-- On ENDIF reduce production list(equation) ->
-- On ENDFOR reduce production list(equation) ->
-- On ELSEWHEN reduce production list(equation) ->
-- On ELSEIF reduce production list(equation) ->
-- On ELSE reduce production list(equation) ->

State 313:
## Known stack suffix:
## equation list(equation)
## LR(1) items:
list(equation) -> equation list(equation) . [ ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(equation) -> equation list(equation)

State 314:
## Known stack suffix:
## index
## LR(1) items:
list(index) -> index . list(index) [ LOOP ]
## Transitions:
-- On IDENT shift to state 7
-- On list(index) shift to state 315
-- On index shift to state 314
-- On ident shift to state 100
## Reductions:
-- On LOOP reduce production list(index) ->

State 315:
## Known stack suffix:
## index list(index)
## LR(1) items:
list(index) -> index list(index) . [ LOOP ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(index) -> index list(index)

State 316:
## Known stack suffix:
## IF expr THEN list(equation)
## LR(1) items:
equation_body -> IF expr THEN list(equation) . list(elseif_equation) else_equations ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSEIF shift to state 317
-- On list(elseif_equation) shift to state 321
-- On elseif_equation shift to state 326
## Reductions:
-- On ENDIF reduce production list(elseif_equation) ->
-- On ELSE reduce production list(elseif_equation) ->

State 317:
## Known stack suffix:
## ELSEIF
## LR(1) items:
elseif_equation -> ELSEIF . expr THEN list(equation) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 318
## Reductions:

State 318:
## Known stack suffix:
## ELSEIF expr
## LR(1) items:
elseif_equation -> ELSEIF expr . THEN list(equation) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On THEN shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## ELSEIF expr THEN
## LR(1) items:
elseif_equation -> ELSEIF expr THEN . list(equation) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 320
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDIF reduce production list(equation) ->
-- On ELSEIF reduce production list(equation) ->
-- On ELSE reduce production list(equation) ->

State 320:
## Known stack suffix:
## ELSEIF expr THEN list(equation)
## LR(1) items:
elseif_equation -> ELSEIF expr THEN list(equation) . [ ENDIF ELSEIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elseif_equation -> ELSEIF expr THEN list(equation)

State 321:
## Known stack suffix:
## IF expr THEN list(equation) list(elseif_equation)
## LR(1) items:
equation_body -> IF expr THEN list(equation) list(elseif_equation) . else_equations ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSE shift to state 322
-- On else_equations shift to state 324
## Reductions:
-- On ENDIF reduce production else_equations ->

State 322:
## Known stack suffix:
## ELSE
## LR(1) items:
else_equations -> ELSE . list(equation) [ ENDIF ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 323
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDIF reduce production list(equation) ->

State 323:
## Known stack suffix:
## ELSE list(equation)
## LR(1) items:
else_equations -> ELSE list(equation) . [ ENDIF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production else_equations -> ELSE list(equation)

State 324:
## Known stack suffix:
## IF expr THEN list(equation) list(elseif_equation) else_equations
## LR(1) items:
equation_body -> IF expr THEN list(equation) list(elseif_equation) else_equations . ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDIF shift to state 325
## Reductions:

State 325:
## Known stack suffix:
## IF expr THEN list(equation) list(elseif_equation) else_equations ENDIF
## LR(1) items:
equation_body -> IF expr THEN list(equation) list(elseif_equation) else_equations ENDIF . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_body -> IF expr THEN list(equation) list(elseif_equation) else_equations ENDIF

State 326:
## Known stack suffix:
## elseif_equation
## LR(1) items:
list(elseif_equation) -> elseif_equation . list(elseif_equation) [ ENDIF ELSE ]
## Transitions:
-- On ELSEIF shift to state 317
-- On list(elseif_equation) shift to state 327
-- On elseif_equation shift to state 326
## Reductions:
-- On ENDIF reduce production list(elseif_equation) ->
-- On ELSE reduce production list(elseif_equation) ->

State 327:
## Known stack suffix:
## elseif_equation list(elseif_equation)
## LR(1) items:
list(elseif_equation) -> elseif_equation list(elseif_equation) . [ ENDIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(elseif_equation) -> elseif_equation list(elseif_equation)

State 328:
## Known stack suffix:
## WHEN expr THEN list(equation)
## LR(1) items:
equation_body -> WHEN expr THEN list(equation) . list(elsewhen_equation) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSEWHEN shift to state 329
-- On list(elsewhen_equation) shift to state 333
-- On elsewhen_equation shift to state 335
## Reductions:
-- On ENDWHEN reduce production list(elsewhen_equation) ->

State 329:
## Known stack suffix:
## ELSEWHEN
## LR(1) items:
elsewhen_equation -> ELSEWHEN . expr THEN list(equation) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## ELSEWHEN expr
## LR(1) items:
elsewhen_equation -> ELSEWHEN expr . THEN list(equation) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On THEN shift to state 331
## Reductions:

State 331:
## Known stack suffix:
## ELSEWHEN expr THEN
## LR(1) items:
elsewhen_equation -> ELSEWHEN expr THEN . list(equation) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 304
-- On list(equation) shift to state 332
-- On equation_body shift to state 309
-- On equation shift to state 312
## Reductions:
-- On ENDWHEN reduce production list(equation) ->
-- On ELSEWHEN reduce production list(equation) ->

State 332:
## Known stack suffix:
## ELSEWHEN expr THEN list(equation)
## LR(1) items:
elsewhen_equation -> ELSEWHEN expr THEN list(equation) . [ ENDWHEN ELSEWHEN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elsewhen_equation -> ELSEWHEN expr THEN list(equation)

State 333:
## Known stack suffix:
## WHEN expr THEN list(equation) list(elsewhen_equation)
## LR(1) items:
equation_body -> WHEN expr THEN list(equation) list(elsewhen_equation) . ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDWHEN shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## WHEN expr THEN list(equation) list(elsewhen_equation) ENDWHEN
## LR(1) items:
equation_body -> WHEN expr THEN list(equation) list(elsewhen_equation) ENDWHEN . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_body -> WHEN expr THEN list(equation) list(elsewhen_equation) ENDWHEN

State 335:
## Known stack suffix:
## elsewhen_equation
## LR(1) items:
list(elsewhen_equation) -> elsewhen_equation . list(elsewhen_equation) [ ENDWHEN ]
## Transitions:
-- On ELSEWHEN shift to state 329
-- On list(elsewhen_equation) shift to state 336
-- On elsewhen_equation shift to state 335
## Reductions:
-- On ENDWHEN reduce production list(elsewhen_equation) ->

State 336:
## Known stack suffix:
## elsewhen_equation list(elsewhen_equation)
## LR(1) items:
list(elsewhen_equation) -> elsewhen_equation list(elsewhen_equation) . [ ENDWHEN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(elsewhen_equation) -> elsewhen_equation list(elsewhen_equation)

State 337:
## Known stack suffix:
## modelica_eq
## LR(1) items:
modelica_eq' -> modelica_eq . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_eq

State 338:
## Known stack suffix:
## equation
## LR(1) items:
modelica_eq -> equation . EOF [ # ]
## Transitions:
-- On EOF shift to state 339
## Reductions:

State 339:
## Known stack suffix:
## equation EOF
## LR(1) items:
modelica_eq -> equation EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_eq -> equation EOF

State 340:
## Known stack suffix:
##
## LR(1) items:
modelica_expr' -> . modelica_expr [ # ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On modelica_expr shift to state 341
-- On expr shift to state 342
## Reductions:

State 341:
## Known stack suffix:
## modelica_expr
## LR(1) items:
modelica_expr' -> modelica_expr . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_expr

State 342:
## Known stack suffix:
## expr
## LR(1) items:
modelica_expr -> expr . EOF [ # ]
## Transitions:
-- On EOF shift to state 343
## Reductions:

State 343:
## Known stack suffix:
## expr EOF
## LR(1) items:
modelica_expr -> expr EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_expr -> expr EOF

State 344:
## Known stack suffix:
##
## LR(1) items:
modelica_extends' -> . modelica_extends [ # ]
## Transitions:
-- On EXTENDS shift to state 345
-- On modelica_extends shift to state 348
-- On extends shift to state 349
## Reductions:

State 345:
## Known stack suffix:
## EXTENDS
## LR(1) items:
extends -> EXTENDS . type_expression option(annotation) [ SEMICOLON EOF ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 346
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 346:
## Known stack suffix:
## EXTENDS type_expression
## LR(1) items:
extends -> EXTENDS type_expression . option(annotation) [ SEMICOLON EOF ]
type_expression -> type_expression . array_subscripts [ SEMICOLON LPAREN LBRACKET EOF ANNOTATION ]
type_expression -> type_expression . class_modification [ SEMICOLON LPAREN LBRACKET EOF ANNOTATION ]
## Transitions:
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On ANNOTATION shift to state 213
-- On option(annotation) shift to state 347
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
-- On annotation shift to state 216
## Reductions:
-- On SEMICOLON reduce production option(annotation) ->
-- On EOF reduce production option(annotation) ->

State 347:
## Known stack suffix:
## EXTENDS type_expression option(annotation)
## LR(1) items:
extends -> EXTENDS type_expression option(annotation) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production extends -> EXTENDS type_expression option(annotation)

State 348:
## Known stack suffix:
## modelica_extends
## LR(1) items:
modelica_extends' -> modelica_extends . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_extends

State 349:
## Known stack suffix:
## extends
## LR(1) items:
modelica_extends -> extends . EOF [ # ]
## Transitions:
-- On EOF shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## extends EOF
## LR(1) items:
modelica_extends -> extends EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_extends -> extends EOF

State 351:
## Known stack suffix:
##
## LR(1) items:
modelica_import' -> . modelica_import [ # ]
## Transitions:
-- On IMPORT shift to state 352
-- On modelica_import shift to state 361
-- On import shift to state 362
## Reductions:

State 352:
## Known stack suffix:
## IMPORT
## LR(1) items:
import -> IMPORT . separated_nonempty_list(DOT,ident) comment [ SEMICOLON EOF ]
import -> IMPORT . ident EQ separated_nonempty_list(DOT,ident) comment [ SEMICOLON EOF ]
import -> IMPORT . separated_nonempty_list(DOT,ident) DOTTIMES comment [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 353
-- On ident shift to state 357
## Reductions:

State 353:
## Known stack suffix:
## IMPORT separated_nonempty_list(DOT,ident)
## LR(1) items:
import -> IMPORT separated_nonempty_list(DOT,ident) . comment [ SEMICOLON EOF ]
import -> IMPORT separated_nonempty_list(DOT,ident) . DOTTIMES comment [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On DOTTIMES shift to state 354
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 356
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 354:
## Known stack suffix:
## IMPORT separated_nonempty_list(DOT,ident) DOTTIMES
## LR(1) items:
import -> IMPORT separated_nonempty_list(DOT,ident) DOTTIMES . comment [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 355
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 355:
## Known stack suffix:
## IMPORT separated_nonempty_list(DOT,ident) DOTTIMES comment
## LR(1) items:
import -> IMPORT separated_nonempty_list(DOT,ident) DOTTIMES comment . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import -> IMPORT separated_nonempty_list(DOT,ident) DOTTIMES comment

State 356:
## Known stack suffix:
## IMPORT separated_nonempty_list(DOT,ident) comment
## LR(1) items:
import -> IMPORT separated_nonempty_list(DOT,ident) comment . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import -> IMPORT separated_nonempty_list(DOT,ident) comment

State 357:
## Known stack suffix:
## IMPORT ident
## LR(1) items:
import -> IMPORT ident . EQ separated_nonempty_list(DOT,ident) comment [ SEMICOLON EOF ]
separated_nonempty_list(DOT,ident) -> ident . [ STRING SEMICOLON EOF DOTTIMES ANNOTATION ]
separated_nonempty_list(DOT,ident) -> ident . DOT separated_nonempty_list(DOT,ident) [ STRING SEMICOLON EOF DOTTIMES ANNOTATION ]
## Transitions:
-- On EQ shift to state 358
-- On DOT shift to state 12
## Reductions:
-- On STRING reduce production separated_nonempty_list(DOT,ident) -> ident
-- On SEMICOLON reduce production separated_nonempty_list(DOT,ident) -> ident
-- On EOF reduce production separated_nonempty_list(DOT,ident) -> ident
-- On DOTTIMES reduce production separated_nonempty_list(DOT,ident) -> ident
-- On ANNOTATION reduce production separated_nonempty_list(DOT,ident) -> ident

State 358:
## Known stack suffix:
## IMPORT ident EQ
## LR(1) items:
import -> IMPORT ident EQ . separated_nonempty_list(DOT,ident) comment [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 359
-- On ident shift to state 11
## Reductions:

State 359:
## Known stack suffix:
## IMPORT ident EQ separated_nonempty_list(DOT,ident)
## LR(1) items:
import -> IMPORT ident EQ separated_nonempty_list(DOT,ident) . comment [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 360
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 360:
## Known stack suffix:
## IMPORT ident EQ separated_nonempty_list(DOT,ident) comment
## LR(1) items:
import -> IMPORT ident EQ separated_nonempty_list(DOT,ident) comment . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production import -> IMPORT ident EQ separated_nonempty_list(DOT,ident) comment

State 361:
## Known stack suffix:
## modelica_import
## LR(1) items:
modelica_import' -> modelica_import . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_import

State 362:
## Known stack suffix:
## import
## LR(1) items:
modelica_import -> import . EOF [ # ]
## Transitions:
-- On EOF shift to state 363
## Reductions:

State 363:
## Known stack suffix:
## import EOF
## LR(1) items:
modelica_import -> import EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_import -> import EOF

State 364:
## Known stack suffix:
##
## LR(1) items:
modelica_stmt' -> . modelica_stmt [ # ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 416
-- On modelica_stmt shift to state 418
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:

State 365:
## Known stack suffix:
## WHILE
## LR(1) items:
statement_body -> WHILE . expr LOOP list(statement) ENDWHILE [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 366
## Reductions:

State 366:
## Known stack suffix:
## WHILE expr
## LR(1) items:
statement_body -> WHILE expr . LOOP list(statement) ENDWHILE [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On LOOP shift to state 367
## Reductions:

State 367:
## Known stack suffix:
## WHILE expr LOOP
## LR(1) items:
statement_body -> WHILE expr LOOP . list(statement) ENDWHILE [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 414
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDWHILE reduce production list(statement) ->

State 368:
## Known stack suffix:
## WHEN
## LR(1) items:
statement_body -> WHEN . expr THEN list(statement) list(elsewhen_statement) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 369
## Reductions:

State 369:
## Known stack suffix:
## WHEN expr
## LR(1) items:
statement_body -> WHEN expr . THEN list(statement) list(elsewhen_statement) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On THEN shift to state 370
## Reductions:

State 370:
## Known stack suffix:
## WHEN expr THEN
## LR(1) items:
statement_body -> WHEN expr THEN . list(statement) list(elsewhen_statement) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 405
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDWHEN reduce production list(statement) ->
-- On ELSEWHEN reduce production list(statement) ->

State 371:
## Known stack suffix:
## RETURN
## LR(1) items:
statement_body -> RETURN . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> RETURN

State 372:
## Known stack suffix:
## IF
## LR(1) items:
statement_body -> IF . expr THEN list(statement) list(elseif_statement) else_statements ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 373
## Reductions:

State 373:
## Known stack suffix:
## IF expr
## LR(1) items:
statement_body -> IF expr . THEN list(statement) list(elseif_statement) else_statements ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On THEN shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
statement_body -> IF expr THEN . list(statement) list(elseif_statement) else_statements ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 393
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDIF reduce production list(statement) ->
-- On ELSEIF reduce production list(statement) ->
-- On ELSE reduce production list(statement) ->

State 375:
## Known stack suffix:
## FOR
## LR(1) items:
statement_body -> FOR . list(index) LOOP list(statement) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On IDENT shift to state 7
-- On list(index) shift to state 376
-- On index shift to state 314
-- On ident shift to state 100
## Reductions:
-- On LOOP reduce production list(index) ->

State 376:
## Known stack suffix:
## FOR list(index)
## LR(1) items:
statement_body -> FOR list(index) . LOOP list(statement) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On LOOP shift to state 377
## Reductions:

State 377:
## Known stack suffix:
## FOR list(index) LOOP
## LR(1) items:
statement_body -> FOR list(index) LOOP . list(statement) ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 391
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDFOR reduce production list(statement) ->

State 378:
## Known stack suffix:
## BREAK
## LR(1) items:
statement_body -> BREAK . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> BREAK

State 379:
## Known stack suffix:
## statement_body
## LR(1) items:
statement -> statement_body . comment SEMICOLON [ WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION EOF END_IDENT ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE DOT BREAK ASSERT ANNOTATION ALGORITHM ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 380
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 380:
## Known stack suffix:
## statement_body comment
## LR(1) items:
statement -> statement_body comment . SEMICOLON [ WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION EOF END_IDENT ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE DOT BREAK ASSERT ANNOTATION ALGORITHM ]
## Transitions:
-- On SEMICOLON shift to state 381
## Reductions:

State 381:
## Known stack suffix:
## statement_body comment SEMICOLON
## LR(1) items:
statement -> statement_body comment SEMICOLON . [ WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION EOF END_IDENT ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE DOT BREAK ASSERT ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> statement_body comment SEMICOLON

State 382:
## Known stack suffix:
## statement
## LR(1) items:
list(statement) -> statement . list(statement) [ ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 383
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDWHILE reduce production list(statement) ->
-- On ENDWHEN reduce production list(statement) ->
-- On ENDIF reduce production list(statement) ->
-- On ENDFOR reduce production list(statement) ->
-- On ELSEWHEN reduce production list(statement) ->
-- On ELSEIF reduce production list(statement) ->
-- On ELSE reduce production list(statement) ->

State 383:
## Known stack suffix:
## statement list(statement)
## LR(1) items:
list(statement) -> statement list(statement) . [ ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(statement) -> statement list(statement)

State 384:
## Known stack suffix:
## lexpr
## LR(1) items:
statement_body -> lexpr . COLONEQ expr [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On COLONEQ shift to state 385
## Reductions:

State 385:
## Known stack suffix:
## lexpr COLONEQ
## LR(1) items:
statement_body -> lexpr COLONEQ . expr [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## lexpr COLONEQ expr
## LR(1) items:
statement_body -> lexpr COLONEQ expr . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> lexpr COLONEQ expr

State 387:
## Known stack suffix:
## component_reference
## LR(1) items:
component_reference -> component_reference . DOT IDENT [ LPAREN LBRACKET DOT COLONEQ ]
component_reference -> component_reference . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ LPAREN LBRACKET DOT COLONEQ ]
lexpr -> component_reference . [ COLONEQ ]
statement_body -> component_reference . LPAREN function_args RPAREN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On LPAREN shift to state 388
-- On LBRACKET shift to state 159
-- On DOT shift to state 162
## Reductions:
-- On COLONEQ reduce production lexpr -> component_reference

State 388:
## Known stack suffix:
## component_reference LPAREN
## LR(1) items:
statement_body -> component_reference LPAREN . function_args RPAREN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 83
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,named_argument) shift to state 84
-- On named_function_args shift to state 85
-- On named_argument shift to state 86
-- On ident shift to state 89
-- On function_args shift to state 389
-- On expr shift to state 94
## Reductions:
-- On RPAREN reduce production named_function_args ->

State 389:
## Known stack suffix:
## component_reference LPAREN function_args
## LR(1) items:
statement_body -> component_reference LPAREN function_args . RPAREN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On RPAREN shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## component_reference LPAREN function_args RPAREN
## LR(1) items:
statement_body -> component_reference LPAREN function_args RPAREN . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> component_reference LPAREN function_args RPAREN

State 391:
## Known stack suffix:
## FOR list(index) LOOP list(statement)
## LR(1) items:
statement_body -> FOR list(index) LOOP list(statement) . ENDFOR [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDFOR shift to state 392
## Reductions:

State 392:
## Known stack suffix:
## FOR list(index) LOOP list(statement) ENDFOR
## LR(1) items:
statement_body -> FOR list(index) LOOP list(statement) ENDFOR . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> FOR list(index) LOOP list(statement) ENDFOR

State 393:
## Known stack suffix:
## IF expr THEN list(statement)
## LR(1) items:
statement_body -> IF expr THEN list(statement) . list(elseif_statement) else_statements ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSEIF shift to state 394
-- On list(elseif_statement) shift to state 398
-- On elseif_statement shift to state 403
## Reductions:
-- On ENDIF reduce production list(elseif_statement) ->
-- On ELSE reduce production list(elseif_statement) ->

State 394:
## Known stack suffix:
## ELSEIF
## LR(1) items:
elseif_statement -> ELSEIF . expr THEN list(statement) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 395
## Reductions:

State 395:
## Known stack suffix:
## ELSEIF expr
## LR(1) items:
elseif_statement -> ELSEIF expr . THEN list(statement) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On THEN shift to state 396
## Reductions:

State 396:
## Known stack suffix:
## ELSEIF expr THEN
## LR(1) items:
elseif_statement -> ELSEIF expr THEN . list(statement) [ ENDIF ELSEIF ELSE ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 397
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDIF reduce production list(statement) ->
-- On ELSEIF reduce production list(statement) ->
-- On ELSE reduce production list(statement) ->

State 397:
## Known stack suffix:
## ELSEIF expr THEN list(statement)
## LR(1) items:
elseif_statement -> ELSEIF expr THEN list(statement) . [ ENDIF ELSEIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elseif_statement -> ELSEIF expr THEN list(statement)

State 398:
## Known stack suffix:
## IF expr THEN list(statement) list(elseif_statement)
## LR(1) items:
statement_body -> IF expr THEN list(statement) list(elseif_statement) . else_statements ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSE shift to state 399
-- On else_statements shift to state 401
## Reductions:
-- On ENDIF reduce production else_statements ->

State 399:
## Known stack suffix:
## ELSE
## LR(1) items:
else_statements -> ELSE . list(statement) [ ENDIF ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 400
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDIF reduce production list(statement) ->

State 400:
## Known stack suffix:
## ELSE list(statement)
## LR(1) items:
else_statements -> ELSE list(statement) . [ ENDIF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production else_statements -> ELSE list(statement)

State 401:
## Known stack suffix:
## IF expr THEN list(statement) list(elseif_statement) else_statements
## LR(1) items:
statement_body -> IF expr THEN list(statement) list(elseif_statement) else_statements . ENDIF [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDIF shift to state 402
## Reductions:

State 402:
## Known stack suffix:
## IF expr THEN list(statement) list(elseif_statement) else_statements ENDIF
## LR(1) items:
statement_body -> IF expr THEN list(statement) list(elseif_statement) else_statements ENDIF . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> IF expr THEN list(statement) list(elseif_statement) else_statements ENDIF

State 403:
## Known stack suffix:
## elseif_statement
## LR(1) items:
list(elseif_statement) -> elseif_statement . list(elseif_statement) [ ENDIF ELSE ]
## Transitions:
-- On ELSEIF shift to state 394
-- On list(elseif_statement) shift to state 404
-- On elseif_statement shift to state 403
## Reductions:
-- On ENDIF reduce production list(elseif_statement) ->
-- On ELSE reduce production list(elseif_statement) ->

State 404:
## Known stack suffix:
## elseif_statement list(elseif_statement)
## LR(1) items:
list(elseif_statement) -> elseif_statement list(elseif_statement) . [ ENDIF ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(elseif_statement) -> elseif_statement list(elseif_statement)

State 405:
## Known stack suffix:
## WHEN expr THEN list(statement)
## LR(1) items:
statement_body -> WHEN expr THEN list(statement) . list(elsewhen_statement) ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ELSEWHEN shift to state 406
-- On list(elsewhen_statement) shift to state 410
-- On elsewhen_statement shift to state 412
## Reductions:
-- On ENDWHEN reduce production list(elsewhen_statement) ->

State 406:
## Known stack suffix:
## ELSEWHEN
## LR(1) items:
elsewhen_statement -> ELSEWHEN . expr THEN list(statement) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On expr shift to state 407
## Reductions:

State 407:
## Known stack suffix:
## ELSEWHEN expr
## LR(1) items:
elsewhen_statement -> ELSEWHEN expr . THEN list(statement) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On THEN shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## ELSEWHEN expr THEN
## LR(1) items:
elsewhen_statement -> ELSEWHEN expr THEN . list(statement) [ ENDWHEN ELSEWHEN ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 382
-- On list(statement) shift to state 409
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On ENDWHEN reduce production list(statement) ->
-- On ELSEWHEN reduce production list(statement) ->

State 409:
## Known stack suffix:
## ELSEWHEN expr THEN list(statement)
## LR(1) items:
elsewhen_statement -> ELSEWHEN expr THEN list(statement) . [ ENDWHEN ELSEWHEN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production elsewhen_statement -> ELSEWHEN expr THEN list(statement)

State 410:
## Known stack suffix:
## WHEN expr THEN list(statement) list(elsewhen_statement)
## LR(1) items:
statement_body -> WHEN expr THEN list(statement) list(elsewhen_statement) . ENDWHEN [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDWHEN shift to state 411
## Reductions:

State 411:
## Known stack suffix:
## WHEN expr THEN list(statement) list(elsewhen_statement) ENDWHEN
## LR(1) items:
statement_body -> WHEN expr THEN list(statement) list(elsewhen_statement) ENDWHEN . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> WHEN expr THEN list(statement) list(elsewhen_statement) ENDWHEN

State 412:
## Known stack suffix:
## elsewhen_statement
## LR(1) items:
list(elsewhen_statement) -> elsewhen_statement . list(elsewhen_statement) [ ENDWHEN ]
## Transitions:
-- On ELSEWHEN shift to state 406
-- On list(elsewhen_statement) shift to state 413
-- On elsewhen_statement shift to state 412
## Reductions:
-- On ENDWHEN reduce production list(elsewhen_statement) ->

State 413:
## Known stack suffix:
## elsewhen_statement list(elsewhen_statement)
## LR(1) items:
list(elsewhen_statement) -> elsewhen_statement list(elsewhen_statement) . [ ENDWHEN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(elsewhen_statement) -> elsewhen_statement list(elsewhen_statement)

State 414:
## Known stack suffix:
## WHILE expr LOOP list(statement)
## LR(1) items:
statement_body -> WHILE expr LOOP list(statement) . ENDWHILE [ STRING SEMICOLON ANNOTATION ]
## Transitions:
-- On ENDWHILE shift to state 415
## Reductions:

State 415:
## Known stack suffix:
## WHILE expr LOOP list(statement) ENDWHILE
## LR(1) items:
statement_body -> WHILE expr LOOP list(statement) ENDWHILE . [ STRING SEMICOLON ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement_body -> WHILE expr LOOP list(statement) ENDWHILE

State 416:
## Known stack suffix:
## statement
## LR(1) items:
modelica_stmt -> statement . EOF [ # ]
## Transitions:
-- On EOF shift to state 417
## Reductions:

State 417:
## Known stack suffix:
## statement EOF
## LR(1) items:
modelica_stmt -> statement EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_stmt -> statement EOF

State 418:
## Known stack suffix:
## modelica_stmt
## LR(1) items:
modelica_stmt' -> modelica_stmt . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_stmt

State 419:
## Known stack suffix:
##
## LR(1) items:
modelica_stored_definition' -> . modelica_stored_definition [ # ]
## Transitions:
-- On WITHIN shift to state 420
-- On within_clause shift to state 424
-- On option(within_clause) shift to state 425
-- On modelica_stored_definition shift to state 603
## Reductions:
-- On TYPE reduce production option(within_clause) ->
-- On REPLACEABLE reduce production option(within_clause) ->
-- On RECORD reduce production option(within_clause) ->
-- On PARTIAL reduce production option(within_clause) ->
-- On PACKAGE reduce production option(within_clause) ->
-- On OPERATOR reduce production option(within_clause) ->
-- On MODEL reduce production option(within_clause) ->
-- On FUNCTION reduce production option(within_clause) ->
-- On FINAL reduce production option(within_clause) ->
-- On EXPANDABLE reduce production option(within_clause) ->
-- On EOF reduce production option(within_clause) ->
-- On ENCAPSULATED reduce production option(within_clause) ->
-- On CONNECTOR reduce production option(within_clause) ->
-- On CLASS reduce production option(within_clause) ->
-- On BLOCK reduce production option(within_clause) ->

State 420:
## Known stack suffix:
## WITHIN
## LR(1) items:
within_clause -> WITHIN . loption(separated_nonempty_list(DOT,ident)) SEMICOLON [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 421
-- On loption(separated_nonempty_list(DOT,ident)) shift to state 422
-- On ident shift to state 11
## Reductions:
-- On SEMICOLON reduce production loption(separated_nonempty_list(DOT,ident)) ->

State 421:
## Known stack suffix:
## separated_nonempty_list(DOT,ident)
## LR(1) items:
loption(separated_nonempty_list(DOT,ident)) -> separated_nonempty_list(DOT,ident) . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(separated_nonempty_list(DOT,ident)) -> separated_nonempty_list(DOT,ident)

State 422:
## Known stack suffix:
## WITHIN loption(separated_nonempty_list(DOT,ident))
## LR(1) items:
within_clause -> WITHIN loption(separated_nonempty_list(DOT,ident)) . SEMICOLON [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
-- On SEMICOLON shift to state 423
## Reductions:

State 423:
## Known stack suffix:
## WITHIN loption(separated_nonempty_list(DOT,ident)) SEMICOLON
## LR(1) items:
within_clause -> WITHIN loption(separated_nonempty_list(DOT,ident)) SEMICOLON . [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production within_clause -> WITHIN loption(separated_nonempty_list(DOT,ident)) SEMICOLON

State 424:
## Known stack suffix:
## within_clause
## LR(1) items:
option(within_clause) -> within_clause . [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(within_clause) -> within_clause

State 425:
## Known stack suffix:
## option(within_clause)
## LR(1) items:
modelica_stored_definition -> option(within_clause) . list(type_definition_clause) EOF [ # ]
## Transitions:
-- On FINAL shift to state 1
-- On typedef_prefix shift to state 426
-- On type_definition_clause shift to state 595
-- On type_definition shift to state 596
-- On list(type_definition_clause) shift to state 601
-- On flag(FINAL) shift to state 599
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On EOF reduce production list(type_definition_clause) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 426:
## Known stack suffix:
## typedef_prefix
## LR(1) items:
type_definition -> typedef_prefix . type_sort ident EQ type_expression comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix . type_sort ident option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix . type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix . type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix . type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix . type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On TYPE shift to state 236
-- On RECORD shift to state 237
-- On PACKAGE shift to state 238
-- On OPERATOR shift to state 239
-- On MODEL shift to state 242
-- On FUNCTION shift to state 243
-- On EXPANDABLE shift to state 244
-- On CONNECTOR shift to state 246
-- On CLASS shift to state 247
-- On BLOCK shift to state 248
-- On type_sort shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## typedef_prefix type_sort
## LR(1) items:
type_definition -> typedef_prefix type_sort . ident EQ type_expression comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort . ident option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort . EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort . ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort . ident EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort . ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On EXTENDS shift to state 428
-- On ident shift to state 559
## Reductions:

State 428:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS . ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On ident shift to state 429
## Reductions:

State 429:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident . option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On LPAREN shift to state 185
-- On option(class_modification) shift to state 430
-- On class_modification shift to state 219
## Reductions:
-- On TYPE reduce production option(class_modification) ->
-- On STRING reduce production option(class_modification) ->
-- On STREAM reduce production option(class_modification) ->
-- On REPLACEABLE reduce production option(class_modification) ->
-- On REDECLARE reduce production option(class_modification) ->
-- On RECORD reduce production option(class_modification) ->
-- On PUBLIC reduce production option(class_modification) ->
-- On PROTECTED reduce production option(class_modification) ->
-- On PARTIAL reduce production option(class_modification) ->
-- On PARAMETER reduce production option(class_modification) ->
-- On PACKAGE reduce production option(class_modification) ->
-- On OUTPUT reduce production option(class_modification) ->
-- On OUTER reduce production option(class_modification) ->
-- On OPERATOR reduce production option(class_modification) ->
-- On MODEL reduce production option(class_modification) ->
-- On INPUT reduce production option(class_modification) ->
-- On INNER reduce production option(class_modification) ->
-- On INITIAL_EQUATION reduce production option(class_modification) ->
-- On INITIAL_ALGORITHM reduce production option(class_modification) ->
-- On IMPORT reduce production option(class_modification) ->
-- On IDENT reduce production option(class_modification) ->
-- On FUNCTION reduce production option(class_modification) ->
-- On FLOW reduce production option(class_modification) ->
-- On FINAL reduce production option(class_modification) ->
-- On EXTERNAL reduce production option(class_modification) ->
-- On EXTENDS reduce production option(class_modification) ->
-- On EXPANDABLE reduce production option(class_modification) ->
-- On EQUATION reduce production option(class_modification) ->
-- On END_IDENT reduce production option(class_modification) ->
-- On ENCAPSULATED reduce production option(class_modification) ->
-- On DOT reduce production option(class_modification) ->
-- On DISCRETE reduce production option(class_modification) ->
-- On CONSTANT reduce production option(class_modification) ->
-- On CONNECTOR reduce production option(class_modification) ->
-- On CLASS reduce production option(class_modification) ->
-- On BLOCK reduce production option(class_modification) ->
-- On ANNOTATION reduce production option(class_modification) ->
-- On ALGORITHM reduce production option(class_modification) ->

State 430:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification)
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) . option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 431
## Reductions:
-- On TYPE reduce production option(str) ->
-- On STREAM reduce production option(str) ->
-- On REPLACEABLE reduce production option(str) ->
-- On REDECLARE reduce production option(str) ->
-- On RECORD reduce production option(str) ->
-- On PUBLIC reduce production option(str) ->
-- On PROTECTED reduce production option(str) ->
-- On PARTIAL reduce production option(str) ->
-- On PARAMETER reduce production option(str) ->
-- On PACKAGE reduce production option(str) ->
-- On OUTPUT reduce production option(str) ->
-- On OUTER reduce production option(str) ->
-- On OPERATOR reduce production option(str) ->
-- On MODEL reduce production option(str) ->
-- On INPUT reduce production option(str) ->
-- On INNER reduce production option(str) ->
-- On INITIAL_EQUATION reduce production option(str) ->
-- On INITIAL_ALGORITHM reduce production option(str) ->
-- On IMPORT reduce production option(str) ->
-- On IDENT reduce production option(str) ->
-- On FUNCTION reduce production option(str) ->
-- On FLOW reduce production option(str) ->
-- On FINAL reduce production option(str) ->
-- On EXTERNAL reduce production option(str) ->
-- On EXTENDS reduce production option(str) ->
-- On EXPANDABLE reduce production option(str) ->
-- On EQUATION reduce production option(str) ->
-- On END_IDENT reduce production option(str) ->
-- On ENCAPSULATED reduce production option(str) ->
-- On DOT reduce production option(str) ->
-- On DISCRETE reduce production option(str) ->
-- On CONSTANT reduce production option(str) ->
-- On CONNECTOR reduce production option(str) ->
-- On CLASS reduce production option(str) ->
-- On BLOCK reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->
-- On ALGORITHM reduce production option(str) ->

State 431:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification) option(str)
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) . composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 551
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On composition shift to state 552
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 432:
## Known stack suffix:
## REDECLARE
## LR(1) items:
public_composition_elements -> REDECLARE . component_clause SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
public_composition_elements -> REDECLARE . type_definition SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On FINAL shift to state 1
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 433
-- On flag(FINAL) shift to state 473
-- On component_clause shift to state 548
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 433:
## Known stack suffix:
## REDECLARE type_definition
## LR(1) items:
public_composition_elements -> REDECLARE type_definition . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## REDECLARE type_definition SEMICOLON
## LR(1) items:
public_composition_elements -> REDECLARE type_definition SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 547
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 435:
## Known stack suffix:
## PUBLIC
## LR(1) items:
public_composition_elements -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 546
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 436:
## Known stack suffix:
## PROTECTED
## LR(1) items:
public_composition_elements -> PROTECTED . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 545
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 437:
## Known stack suffix:
## REDECLARE
## LR(1) items:
protected_composition_elements -> REDECLARE . component_clause SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
protected_composition_elements -> REDECLARE . type_definition SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On FINAL shift to state 1
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 438
-- On flag(FINAL) shift to state 473
-- On component_clause shift to state 542
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 438:
## Known stack suffix:
## REDECLARE type_definition
## LR(1) items:
protected_composition_elements -> REDECLARE type_definition . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 439
## Reductions:

State 439:
## Known stack suffix:
## REDECLARE type_definition SEMICOLON
## LR(1) items:
protected_composition_elements -> REDECLARE type_definition SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 541
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 440:
## Known stack suffix:
## PUBLIC
## LR(1) items:
protected_composition_elements -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 525
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 441:
## Known stack suffix:
## INITIAL_EQUATION
## LR(1) items:
cargo_sections -> INITIAL_EQUATION . initial_equation_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PUBLIC shift to state 442
-- On PROTECTED shift to state 519
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On ALGORITHM shift to state 464
-- On simple_expr shift to state 304
-- On option(composition_external) shift to state 469
-- On initial_equation_section shift to state 521
-- On equation_body shift to state 309
-- On equation shift to state 522
-- On composition_external shift to state 481
-- On cargo_sections shift to state 524
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 442:
## Known stack suffix:
## PUBLIC
## LR(1) items:
initial_equation_section -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 518
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 443:
## Known stack suffix:
## INITIAL_ALGORITHM
## LR(1) items:
cargo_sections -> INITIAL_ALGORITHM . initial_algorithm_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On PUBLIC shift to state 444
-- On PROTECTED shift to state 508
-- On LPAREN shift to state 146
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On ALGORITHM shift to state 464
-- On statement_body shift to state 379
-- On statement shift to state 489
-- On option(composition_external) shift to state 469
-- On nonempty_list(statement) shift to state 491
-- On lexpr shift to state 384
-- On initial_algorithm_section shift to state 510
-- On composition_external shift to state 481
-- On component_reference shift to state 387
-- On cargo_sections shift to state 511
-- On algorithm shift to state 512
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 444:
## Known stack suffix:
## PUBLIC
## LR(1) items:
initial_algorithm_section -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 507
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 445:
## Known stack suffix:
## EXTERNAL
## LR(1) items:
composition_external -> EXTERNAL . STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
composition_external -> EXTERNAL . STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On STRING shift to state 446
## Reductions:

State 446:
## Known stack suffix:
## EXTERNAL STRING
## LR(1) items:
composition_external -> EXTERNAL STRING . external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
composition_external -> EXTERNAL STRING . IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On IDENT shift to state 447
-- On DOT shift to state 148
-- On ASSERT shift to state 150
-- On external_lhs shift to state 453
-- On component_reference shift to state 460
## Reductions:

State 447:
## Known stack suffix:
## EXTERNAL STRING IDENT
## LR(1) items:
component_reference -> IDENT . [ LBRACKET EQ DOT ]
composition_external -> EXTERNAL STRING IDENT . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On LPAREN shift to state 448
## Reductions:
-- On LBRACKET reduce production component_reference -> IDENT
-- On EQ reduce production component_reference -> IDENT
-- On DOT reduce production component_reference -> IDENT

State 448:
## Known stack suffix:
## EXTERNAL STRING IDENT LPAREN
## LR(1) items:
composition_external -> EXTERNAL STRING IDENT LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 133
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 449
-- On expr shift to state 116
## Reductions:
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) ->

State 449:
## Known stack suffix:
## EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr))
## LR(1) items:
composition_external -> EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) . RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On RPAREN shift to state 450
## Reductions:

State 450:
## Known stack suffix:
## EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN
## LR(1) items:
composition_external -> EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN . option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On ANNOTATION shift to state 213
-- On option(annotation) shift to state 451
-- On annotation shift to state 216
## Reductions:
-- On SEMICOLON reduce production option(annotation) ->

State 451:
## Known stack suffix:
## EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation)
## LR(1) items:
composition_external -> EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) . SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON
## LR(1) items:
composition_external -> EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production composition_external -> EXTERNAL STRING IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON

State 453:
## Known stack suffix:
## EXTERNAL STRING external_lhs
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs . IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On IDENT shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT . LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On LPAREN shift to state 455
## Reductions:

State 455:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT LPAREN
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL shift to state 29
-- On IF shift to state 30
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On simple_expr shift to state 49
-- On separated_nonempty_list(COMMA,expr) shift to state 133
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 456
-- On expr shift to state 116
## Reductions:
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) ->

State 456:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr))
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) . RPAREN option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On RPAREN shift to state 457
## Reductions:

State 457:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN . option(annotation) SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On ANNOTATION shift to state 213
-- On option(annotation) shift to state 458
-- On annotation shift to state 216
## Reductions:
-- On SEMICOLON reduce production option(annotation) ->

State 458:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation)
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) . SEMICOLON [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 459
## Reductions:

State 459:
## Known stack suffix:
## EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON
## LR(1) items:
composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production composition_external -> EXTERNAL STRING external_lhs IDENT LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN option(annotation) SEMICOLON

State 460:
## Known stack suffix:
## component_reference
## LR(1) items:
component_reference -> component_reference . DOT IDENT [ LBRACKET EQ DOT ]
component_reference -> component_reference . LBRACKET separated_nonempty_list(COMMA,expr) RBRACKET [ LBRACKET EQ DOT ]
external_lhs -> component_reference . EQ [ IDENT ]
## Transitions:
-- On LBRACKET shift to state 159
-- On EQ shift to state 461
-- On DOT shift to state 162
## Reductions:

State 461:
## Known stack suffix:
## component_reference EQ
## LR(1) items:
external_lhs -> component_reference EQ . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production external_lhs -> component_reference EQ

State 462:
## Known stack suffix:
## EQUATION
## LR(1) items:
cargo_sections -> EQUATION . equation_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PUBLIC shift to state 463
-- On PROTECTED shift to state 501
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On ALGORITHM shift to state 464
-- On simple_expr shift to state 304
-- On option(composition_external) shift to state 469
-- On equation_section shift to state 503
-- On equation_body shift to state 309
-- On equation shift to state 504
-- On composition_external shift to state 481
-- On cargo_sections shift to state 506
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 463:
## Known stack suffix:
## PUBLIC
## LR(1) items:
equation_section -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 500
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 464:
## Known stack suffix:
## ALGORITHM
## LR(1) items:
cargo_sections -> ALGORITHM . algorithm_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On PUBLIC shift to state 465
-- On PROTECTED shift to state 487
-- On LPAREN shift to state 146
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On ALGORITHM shift to state 464
-- On statement_body shift to state 379
-- On statement shift to state 489
-- On option(composition_external) shift to state 469
-- On nonempty_list(statement) shift to state 491
-- On lexpr shift to state 384
-- On composition_external shift to state 481
-- On component_reference shift to state 387
-- On cargo_sections shift to state 492
-- On algorithm_section shift to state 493
-- On algorithm shift to state 494
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 465:
## Known stack suffix:
## PUBLIC
## LR(1) items:
algorithm_section -> PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 486
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 466:
## Known stack suffix:
## type_definition
## LR(1) items:
public_composition_elements -> type_definition . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 467
## Reductions:

State 467:
## Known stack suffix:
## type_definition SEMICOLON
## LR(1) items:
public_composition_elements -> type_definition SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 468
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 468:
## Known stack suffix:
## type_definition SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> type_definition SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> type_definition SEMICOLON public_composition_elements

State 469:
## Known stack suffix:
## option(composition_external)
## LR(1) items:
cargo_sections -> option(composition_external) . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cargo_sections -> option(composition_external)

State 470:
## Known stack suffix:
## import
## LR(1) items:
public_composition_elements -> import . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 471
## Reductions:

State 471:
## Known stack suffix:
## import SEMICOLON
## LR(1) items:
public_composition_elements -> import SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 472
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 472:
## Known stack suffix:
## import SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> import SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> import SEMICOLON public_composition_elements

State 473:
## Known stack suffix:
## flag(FINAL)
## LR(1) items:
type_prefix -> flag(FINAL) . flag(REPLACEABLE) scope [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
typedef_prefix -> flag(FINAL) . flag(REPLACEABLE) flag(ENCAPSULATED) flag(PARTIAL) [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
-- On REPLACEABLE shift to state 190
-- On flag(REPLACEABLE) shift to state 474
## Reductions:
-- On TYPE reduce production flag(REPLACEABLE) ->
-- On STREAM reduce production flag(REPLACEABLE) ->
-- On RECORD reduce production flag(REPLACEABLE) ->
-- On PARTIAL reduce production flag(REPLACEABLE) ->
-- On PARAMETER reduce production flag(REPLACEABLE) ->
-- On PACKAGE reduce production flag(REPLACEABLE) ->
-- On OUTPUT reduce production flag(REPLACEABLE) ->
-- On OUTER reduce production flag(REPLACEABLE) ->
-- On OPERATOR reduce production flag(REPLACEABLE) ->
-- On MODEL reduce production flag(REPLACEABLE) ->
-- On INPUT reduce production flag(REPLACEABLE) ->
-- On INNER reduce production flag(REPLACEABLE) ->
-- On IDENT reduce production flag(REPLACEABLE) ->
-- On FUNCTION reduce production flag(REPLACEABLE) ->
-- On FLOW reduce production flag(REPLACEABLE) ->
-- On EXPANDABLE reduce production flag(REPLACEABLE) ->
-- On ENCAPSULATED reduce production flag(REPLACEABLE) ->
-- On DOT reduce production flag(REPLACEABLE) ->
-- On DISCRETE reduce production flag(REPLACEABLE) ->
-- On CONSTANT reduce production flag(REPLACEABLE) ->
-- On CONNECTOR reduce production flag(REPLACEABLE) ->
-- On CLASS reduce production flag(REPLACEABLE) ->
-- On BLOCK reduce production flag(REPLACEABLE) ->

State 474:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE)
## LR(1) items:
type_prefix -> flag(FINAL) flag(REPLACEABLE) . scope [ STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT ]
typedef_prefix -> flag(FINAL) flag(REPLACEABLE) . flag(ENCAPSULATED) flag(PARTIAL) [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
-- On OUTER shift to state 193
-- On INNER shift to state 194
-- On ENCAPSULATED shift to state 475
-- On scope shift to state 288
-- On flag(ENCAPSULATED) shift to state 476
## Reductions:
-- On TYPE reduce production flag(ENCAPSULATED) ->
-- On STREAM reduce production scope ->
-- On RECORD reduce production flag(ENCAPSULATED) ->
-- On PARTIAL reduce production flag(ENCAPSULATED) ->
-- On PARAMETER reduce production scope ->
-- On PACKAGE reduce production flag(ENCAPSULATED) ->
-- On OUTPUT reduce production scope ->
-- On OPERATOR reduce production flag(ENCAPSULATED) ->
-- On MODEL reduce production flag(ENCAPSULATED) ->
-- On INPUT reduce production scope ->
-- On IDENT reduce production scope ->
-- On FUNCTION reduce production flag(ENCAPSULATED) ->
-- On FLOW reduce production scope ->
-- On EXPANDABLE reduce production flag(ENCAPSULATED) ->
-- On DOT reduce production scope ->
-- On DISCRETE reduce production scope ->
-- On CONSTANT reduce production scope ->
-- On CONNECTOR reduce production flag(ENCAPSULATED) ->
-- On CLASS reduce production flag(ENCAPSULATED) ->
-- On BLOCK reduce production flag(ENCAPSULATED) ->

State 475:
## Known stack suffix:
## ENCAPSULATED
## LR(1) items:
flag(ENCAPSULATED) -> ENCAPSULATED . [ TYPE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production flag(ENCAPSULATED) -> ENCAPSULATED

State 476:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE) flag(ENCAPSULATED)
## LR(1) items:
typedef_prefix -> flag(FINAL) flag(REPLACEABLE) flag(ENCAPSULATED) . flag(PARTIAL) [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
-- On PARTIAL shift to state 192
-- On flag(PARTIAL) shift to state 477
## Reductions:
-- On TYPE reduce production flag(PARTIAL) ->
-- On RECORD reduce production flag(PARTIAL) ->
-- On PACKAGE reduce production flag(PARTIAL) ->
-- On OPERATOR reduce production flag(PARTIAL) ->
-- On MODEL reduce production flag(PARTIAL) ->
-- On FUNCTION reduce production flag(PARTIAL) ->
-- On EXPANDABLE reduce production flag(PARTIAL) ->
-- On CONNECTOR reduce production flag(PARTIAL) ->
-- On CLASS reduce production flag(PARTIAL) ->
-- On BLOCK reduce production flag(PARTIAL) ->

State 477:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE) flag(ENCAPSULATED) flag(PARTIAL)
## LR(1) items:
typedef_prefix -> flag(FINAL) flag(REPLACEABLE) flag(ENCAPSULATED) flag(PARTIAL) . [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedef_prefix -> flag(FINAL) flag(REPLACEABLE) flag(ENCAPSULATED) flag(PARTIAL)

State 478:
## Known stack suffix:
## extends
## LR(1) items:
public_composition_elements -> extends . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 479
## Reductions:

State 479:
## Known stack suffix:
## extends SEMICOLON
## LR(1) items:
public_composition_elements -> extends SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 480
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 480:
## Known stack suffix:
## extends SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> extends SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> extends SEMICOLON public_composition_elements

State 481:
## Known stack suffix:
## composition_external
## LR(1) items:
option(composition_external) -> composition_external . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(composition_external) -> composition_external

State 482:
## Known stack suffix:
## component_clause
## LR(1) items:
public_composition_elements -> component_clause . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 483
## Reductions:

State 483:
## Known stack suffix:
## component_clause SEMICOLON
## LR(1) items:
public_composition_elements -> component_clause SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 484
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 484:
## Known stack suffix:
## component_clause SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> component_clause SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> component_clause SEMICOLON public_composition_elements

State 485:
## Known stack suffix:
## cargo_sections
## LR(1) items:
public_composition_elements -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> cargo_sections

State 486:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
algorithm_section -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> PUBLIC public_composition_elements

State 487:
## Known stack suffix:
## PROTECTED
## LR(1) items:
algorithm_section -> PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 488
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 488:
## Known stack suffix:
## PROTECTED public_composition_elements
## LR(1) items:
algorithm_section -> PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> PROTECTED public_composition_elements

State 489:
## Known stack suffix:
## statement
## LR(1) items:
nonempty_list(statement) -> statement . [ PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM ]
nonempty_list(statement) -> statement . nonempty_list(statement) [ PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM ]
## Transitions:
-- On WHILE shift to state 365
-- On WHEN shift to state 368
-- On RETURN shift to state 371
-- On LPAREN shift to state 146
-- On IF shift to state 372
-- On IDENT shift to state 147
-- On FOR shift to state 375
-- On DOT shift to state 148
-- On BREAK shift to state 378
-- On ASSERT shift to state 150
-- On statement_body shift to state 379
-- On statement shift to state 489
-- On nonempty_list(statement) shift to state 490
-- On lexpr shift to state 384
-- On component_reference shift to state 387
## Reductions:
-- On PUBLIC reduce production nonempty_list(statement) -> statement
-- On PROTECTED reduce production nonempty_list(statement) -> statement
-- On INITIAL_EQUATION reduce production nonempty_list(statement) -> statement
-- On INITIAL_ALGORITHM reduce production nonempty_list(statement) -> statement
-- On EXTERNAL reduce production nonempty_list(statement) -> statement
-- On EQUATION reduce production nonempty_list(statement) -> statement
-- On END_IDENT reduce production nonempty_list(statement) -> statement
-- On ANNOTATION reduce production nonempty_list(statement) -> statement
-- On ALGORITHM reduce production nonempty_list(statement) -> statement

State 490:
## Known stack suffix:
## statement nonempty_list(statement)
## LR(1) items:
nonempty_list(statement) -> statement nonempty_list(statement) . [ PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(statement) -> statement nonempty_list(statement)

State 491:
## Known stack suffix:
## nonempty_list(statement)
## LR(1) items:
algorithm -> nonempty_list(statement) . [ PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm -> nonempty_list(statement)

State 492:
## Known stack suffix:
## cargo_sections
## LR(1) items:
algorithm_section -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> cargo_sections

State 493:
## Known stack suffix:
## ALGORITHM algorithm_section
## LR(1) items:
cargo_sections -> ALGORITHM algorithm_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cargo_sections -> ALGORITHM algorithm_section

State 494:
## Known stack suffix:
## algorithm
## LR(1) items:
algorithm_section -> algorithm . PUBLIC public_composition_elements [ END_IDENT ANNOTATION ]
algorithm_section -> algorithm . PROTECTED public_composition_elements [ END_IDENT ANNOTATION ]
algorithm_section -> algorithm . cargo_sections [ END_IDENT ANNOTATION ]
## Transitions:
-- On PUBLIC shift to state 495
-- On PROTECTED shift to state 497
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On option(composition_external) shift to state 469
-- On composition_external shift to state 481
-- On cargo_sections shift to state 499
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 495:
## Known stack suffix:
## algorithm PUBLIC
## LR(1) items:
algorithm_section -> algorithm PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 496
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 496:
## Known stack suffix:
## algorithm PUBLIC public_composition_elements
## LR(1) items:
algorithm_section -> algorithm PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> algorithm PUBLIC public_composition_elements

State 497:
## Known stack suffix:
## algorithm PROTECTED
## LR(1) items:
algorithm_section -> algorithm PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 498
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 498:
## Known stack suffix:
## algorithm PROTECTED public_composition_elements
## LR(1) items:
algorithm_section -> algorithm PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> algorithm PROTECTED public_composition_elements

State 499:
## Known stack suffix:
## algorithm cargo_sections
## LR(1) items:
algorithm_section -> algorithm cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production algorithm_section -> algorithm cargo_sections

State 500:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
equation_section -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_section -> PUBLIC public_composition_elements

State 501:
## Known stack suffix:
## PROTECTED
## LR(1) items:
equation_section -> PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 502
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 502:
## Known stack suffix:
## PROTECTED public_composition_elements
## LR(1) items:
equation_section -> PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_section -> PROTECTED public_composition_elements

State 503:
## Known stack suffix:
## EQUATION equation_section
## LR(1) items:
cargo_sections -> EQUATION equation_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cargo_sections -> EQUATION equation_section

State 504:
## Known stack suffix:
## equation
## LR(1) items:
equation_section -> equation . equation_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PUBLIC shift to state 463
-- On PROTECTED shift to state 501
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On ALGORITHM shift to state 464
-- On simple_expr shift to state 304
-- On option(composition_external) shift to state 469
-- On equation_section shift to state 505
-- On equation_body shift to state 309
-- On equation shift to state 504
-- On composition_external shift to state 481
-- On cargo_sections shift to state 506
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 505:
## Known stack suffix:
## equation equation_section
## LR(1) items:
equation_section -> equation equation_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_section -> equation equation_section

State 506:
## Known stack suffix:
## cargo_sections
## LR(1) items:
equation_section -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production equation_section -> cargo_sections

State 507:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
initial_algorithm_section -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> PUBLIC public_composition_elements

State 508:
## Known stack suffix:
## PROTECTED
## LR(1) items:
initial_algorithm_section -> PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 509
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 509:
## Known stack suffix:
## PROTECTED public_composition_elements
## LR(1) items:
initial_algorithm_section -> PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> PROTECTED public_composition_elements

State 510:
## Known stack suffix:
## INITIAL_ALGORITHM initial_algorithm_section
## LR(1) items:
cargo_sections -> INITIAL_ALGORITHM initial_algorithm_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cargo_sections -> INITIAL_ALGORITHM initial_algorithm_section

State 511:
## Known stack suffix:
## cargo_sections
## LR(1) items:
initial_algorithm_section -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> cargo_sections

State 512:
## Known stack suffix:
## algorithm
## LR(1) items:
initial_algorithm_section -> algorithm . PUBLIC public_composition_elements [ END_IDENT ANNOTATION ]
initial_algorithm_section -> algorithm . PROTECTED public_composition_elements [ END_IDENT ANNOTATION ]
initial_algorithm_section -> algorithm . cargo_sections [ END_IDENT ANNOTATION ]
## Transitions:
-- On PUBLIC shift to state 513
-- On PROTECTED shift to state 515
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On option(composition_external) shift to state 469
-- On composition_external shift to state 481
-- On cargo_sections shift to state 517
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 513:
## Known stack suffix:
## algorithm PUBLIC
## LR(1) items:
initial_algorithm_section -> algorithm PUBLIC . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 514
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 514:
## Known stack suffix:
## algorithm PUBLIC public_composition_elements
## LR(1) items:
initial_algorithm_section -> algorithm PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> algorithm PUBLIC public_composition_elements

State 515:
## Known stack suffix:
## algorithm PROTECTED
## LR(1) items:
initial_algorithm_section -> algorithm PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 516
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 516:
## Known stack suffix:
## algorithm PROTECTED public_composition_elements
## LR(1) items:
initial_algorithm_section -> algorithm PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> algorithm PROTECTED public_composition_elements

State 517:
## Known stack suffix:
## algorithm cargo_sections
## LR(1) items:
initial_algorithm_section -> algorithm cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_algorithm_section -> algorithm cargo_sections

State 518:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
initial_equation_section -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_equation_section -> PUBLIC public_composition_elements

State 519:
## Known stack suffix:
## PROTECTED
## LR(1) items:
initial_equation_section -> PROTECTED . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 520
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 520:
## Known stack suffix:
## PROTECTED public_composition_elements
## LR(1) items:
initial_equation_section -> PROTECTED public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_equation_section -> PROTECTED public_composition_elements

State 521:
## Known stack suffix:
## INITIAL_EQUATION initial_equation_section
## LR(1) items:
cargo_sections -> INITIAL_EQUATION initial_equation_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production cargo_sections -> INITIAL_EQUATION initial_equation_section

State 522:
## Known stack suffix:
## equation
## LR(1) items:
initial_equation_section -> equation . initial_equation_section [ END_IDENT ANNOTATION ]
## Transitions:
-- On WHEN shift to state 295
-- On TRUE shift to state 19
-- On STRING shift to state 20
-- On PUBLIC shift to state 442
-- On PROTECTED shift to state 519
-- On PLUS shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 23
-- On LPAREN shift to state 24
-- On LBRACKET shift to state 26
-- On LBRACE shift to state 27
-- On INT shift to state 28
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On INITIAL shift to state 29
-- On IF shift to state 298
-- On IDENT shift to state 31
-- On FUNCTION shift to state 32
-- On FOR shift to state 301
-- On FLOAT shift to state 33
-- On FALSE shift to state 34
-- On EXTERNAL shift to state 445
-- On EQUATION shift to state 462
-- On END shift to state 35
-- On DOTPLUS shift to state 36
-- On DOTMINUS shift to state 37
-- On DOT shift to state 38
-- On DER shift to state 40
-- On COLON shift to state 41
-- On ASSERT shift to state 42
-- On ALGORITHM shift to state 464
-- On simple_expr shift to state 304
-- On option(composition_external) shift to state 469
-- On initial_equation_section shift to state 523
-- On equation_body shift to state 309
-- On equation shift to state 522
-- On composition_external shift to state 481
-- On cargo_sections shift to state 524
## Reductions:
-- On END_IDENT reduce production option(composition_external) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 523:
## Known stack suffix:
## equation initial_equation_section
## LR(1) items:
initial_equation_section -> equation initial_equation_section . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_equation_section -> equation initial_equation_section

State 524:
## Known stack suffix:
## cargo_sections
## LR(1) items:
initial_equation_section -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production initial_equation_section -> cargo_sections

State 525:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
protected_composition_elements -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> PUBLIC public_composition_elements

State 526:
## Known stack suffix:
## PROTECTED
## LR(1) items:
protected_composition_elements -> PROTECTED . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 540
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 527:
## Known stack suffix:
## type_definition
## LR(1) items:
protected_composition_elements -> type_definition . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 528
## Reductions:

State 528:
## Known stack suffix:
## type_definition SEMICOLON
## LR(1) items:
protected_composition_elements -> type_definition SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 529
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 529:
## Known stack suffix:
## type_definition SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> type_definition SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> type_definition SEMICOLON protected_composition_elements

State 530:
## Known stack suffix:
## import
## LR(1) items:
protected_composition_elements -> import . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 531
## Reductions:

State 531:
## Known stack suffix:
## import SEMICOLON
## LR(1) items:
protected_composition_elements -> import SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 532
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 532:
## Known stack suffix:
## import SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> import SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> import SEMICOLON protected_composition_elements

State 533:
## Known stack suffix:
## extends
## LR(1) items:
protected_composition_elements -> extends . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 534
## Reductions:

State 534:
## Known stack suffix:
## extends SEMICOLON
## LR(1) items:
protected_composition_elements -> extends SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 535
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 535:
## Known stack suffix:
## extends SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> extends SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> extends SEMICOLON protected_composition_elements

State 536:
## Known stack suffix:
## component_clause
## LR(1) items:
protected_composition_elements -> component_clause . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 537
## Reductions:

State 537:
## Known stack suffix:
## component_clause SEMICOLON
## LR(1) items:
protected_composition_elements -> component_clause SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 538
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 538:
## Known stack suffix:
## component_clause SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> component_clause SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> component_clause SEMICOLON protected_composition_elements

State 539:
## Known stack suffix:
## cargo_sections
## LR(1) items:
protected_composition_elements -> cargo_sections . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> cargo_sections

State 540:
## Known stack suffix:
## PROTECTED protected_composition_elements
## LR(1) items:
protected_composition_elements -> PROTECTED protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> PROTECTED protected_composition_elements

State 541:
## Known stack suffix:
## REDECLARE type_definition SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> REDECLARE type_definition SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> REDECLARE type_definition SEMICOLON protected_composition_elements

State 542:
## Known stack suffix:
## REDECLARE component_clause
## LR(1) items:
protected_composition_elements -> REDECLARE component_clause . SEMICOLON protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 543
## Reductions:

State 543:
## Known stack suffix:
## REDECLARE component_clause SEMICOLON
## LR(1) items:
protected_composition_elements -> REDECLARE component_clause SEMICOLON . protected_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 437
-- On PUBLIC shift to state 440
-- On PROTECTED shift to state 526
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 527
-- On protected_composition_elements shift to state 544
-- On option(composition_external) shift to state 469
-- On import shift to state 530
-- On flag(FINAL) shift to state 473
-- On extends shift to state 533
-- On composition_external shift to state 481
-- On component_clause shift to state 536
-- On cargo_sections shift to state 539
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 544:
## Known stack suffix:
## REDECLARE component_clause SEMICOLON protected_composition_elements
## LR(1) items:
protected_composition_elements -> REDECLARE component_clause SEMICOLON protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production protected_composition_elements -> REDECLARE component_clause SEMICOLON protected_composition_elements

State 545:
## Known stack suffix:
## PROTECTED protected_composition_elements
## LR(1) items:
public_composition_elements -> PROTECTED protected_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> PROTECTED protected_composition_elements

State 546:
## Known stack suffix:
## PUBLIC public_composition_elements
## LR(1) items:
public_composition_elements -> PUBLIC public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> PUBLIC public_composition_elements

State 547:
## Known stack suffix:
## REDECLARE type_definition SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> REDECLARE type_definition SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> REDECLARE type_definition SEMICOLON public_composition_elements

State 548:
## Known stack suffix:
## REDECLARE component_clause
## LR(1) items:
public_composition_elements -> REDECLARE component_clause . SEMICOLON public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On SEMICOLON shift to state 549
## Reductions:

State 549:
## Known stack suffix:
## REDECLARE component_clause SEMICOLON
## LR(1) items:
public_composition_elements -> REDECLARE component_clause SEMICOLON . public_composition_elements [ END_IDENT ANNOTATION ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 550
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 550:
## Known stack suffix:
## REDECLARE component_clause SEMICOLON public_composition_elements
## LR(1) items:
public_composition_elements -> REDECLARE component_clause SEMICOLON public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production public_composition_elements -> REDECLARE component_clause SEMICOLON public_composition_elements

State 551:
## Known stack suffix:
## public_composition_elements
## LR(1) items:
composition -> public_composition_elements . [ END_IDENT ANNOTATION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production composition -> public_composition_elements

State 552:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition . option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On ANNOTATION shift to state 213
-- On option(composition_annotation) shift to state 553
-- On composition_annotation shift to state 556
-- On annotation shift to state 557
## Reductions:
-- On END_IDENT reduce production option(composition_annotation) ->

State 553:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation)
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) . END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On END_IDENT shift to state 554
## Reductions:

State 554:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 555
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 555:
## Known stack suffix:
## typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort EXTENDS ident option(class_modification) option(str) composition option(composition_annotation) END_IDENT option(constraining_clause)

State 556:
## Known stack suffix:
## composition_annotation
## LR(1) items:
option(composition_annotation) -> composition_annotation . [ END_IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(composition_annotation) -> composition_annotation

State 557:
## Known stack suffix:
## annotation
## LR(1) items:
composition_annotation -> annotation . SEMICOLON [ END_IDENT ]
## Transitions:
-- On SEMICOLON shift to state 558
## Reductions:

State 558:
## Known stack suffix:
## annotation SEMICOLON
## LR(1) items:
composition_annotation -> annotation SEMICOLON . [ END_IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production composition_annotation -> annotation SEMICOLON

State 559:
## Known stack suffix:
## typedef_prefix type_sort ident
## LR(1) items:
type_definition -> typedef_prefix type_sort ident . EQ type_expression comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident . option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident . EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident . EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident . EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On EQ shift to state 560
-- On str shift to state 211
-- On option(str) shift to state 590
## Reductions:
-- On TYPE reduce production option(str) ->
-- On STREAM reduce production option(str) ->
-- On REPLACEABLE reduce production option(str) ->
-- On REDECLARE reduce production option(str) ->
-- On RECORD reduce production option(str) ->
-- On PUBLIC reduce production option(str) ->
-- On PROTECTED reduce production option(str) ->
-- On PARTIAL reduce production option(str) ->
-- On PARAMETER reduce production option(str) ->
-- On PACKAGE reduce production option(str) ->
-- On OUTPUT reduce production option(str) ->
-- On OUTER reduce production option(str) ->
-- On OPERATOR reduce production option(str) ->
-- On MODEL reduce production option(str) ->
-- On INPUT reduce production option(str) ->
-- On INNER reduce production option(str) ->
-- On INITIAL_EQUATION reduce production option(str) ->
-- On INITIAL_ALGORITHM reduce production option(str) ->
-- On IMPORT reduce production option(str) ->
-- On IDENT reduce production option(str) ->
-- On FUNCTION reduce production option(str) ->
-- On FLOW reduce production option(str) ->
-- On FINAL reduce production option(str) ->
-- On EXTERNAL reduce production option(str) ->
-- On EXTENDS reduce production option(str) ->
-- On EXPANDABLE reduce production option(str) ->
-- On EQUATION reduce production option(str) ->
-- On END_IDENT reduce production option(str) ->
-- On ENCAPSULATED reduce production option(str) ->
-- On DOT reduce production option(str) ->
-- On DISCRETE reduce production option(str) ->
-- On CONSTANT reduce production option(str) ->
-- On CONNECTOR reduce production option(str) ->
-- On CLASS reduce production option(str) ->
-- On BLOCK reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->
-- On ALGORITHM reduce production option(str) ->

State 560:
## Known stack suffix:
## typedef_prefix type_sort ident EQ
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ . type_expression comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident EQ . ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident EQ . ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident EQ . DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On ENUMERATION shift to state 561
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On DER shift to state 576
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 587
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 561:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION . LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION . LPAREN COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On LPAREN shift to state 562
## Reductions:

State 562:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN . separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN . COLON RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 563
-- On COLON shift to state 565
-- On separated_nonempty_list(COMMA,enum_literal) shift to state 569
-- On enum_literal shift to state 573
## Reductions:

State 563:
## Known stack suffix:
## IDENT
## LR(1) items:
enum_literal -> IDENT . comment [ RPAREN COMMA ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 564
## Reductions:
-- On RPAREN reduce production option(str) ->
-- On COMMA reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 564:
## Known stack suffix:
## IDENT comment
## LR(1) items:
enum_literal -> IDENT comment . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enum_literal -> IDENT comment

State 565:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON . RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On RPAREN shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN . comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 567
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 567:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 568
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 568:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN COLON RPAREN comment option(constraining_clause)

State 569:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) . RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On RPAREN shift to state 570
## Reductions:

State 570:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN . comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 571
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 571:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 572
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 572:
## Known stack suffix:
## typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort ident EQ ENUMERATION LPAREN separated_nonempty_list(COMMA,enum_literal) RPAREN comment option(constraining_clause)

State 573:
## Known stack suffix:
## enum_literal
## LR(1) items:
separated_nonempty_list(COMMA,enum_literal) -> enum_literal . [ RPAREN ]
separated_nonempty_list(COMMA,enum_literal) -> enum_literal . COMMA separated_nonempty_list(COMMA,enum_literal) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 574
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,enum_literal) -> enum_literal

State 574:
## Known stack suffix:
## enum_literal COMMA
## LR(1) items:
separated_nonempty_list(COMMA,enum_literal) -> enum_literal COMMA . separated_nonempty_list(COMMA,enum_literal) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 563
-- On separated_nonempty_list(COMMA,enum_literal) shift to state 575
-- On enum_literal shift to state 573
## Reductions:

State 575:
## Known stack suffix:
## enum_literal COMMA separated_nonempty_list(COMMA,enum_literal)
## LR(1) items:
separated_nonempty_list(COMMA,enum_literal) -> enum_literal COMMA separated_nonempty_list(COMMA,enum_literal) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,enum_literal) -> enum_literal COMMA separated_nonempty_list(COMMA,enum_literal)

State 576:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER . LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On LPAREN shift to state 577
## Reductions:

State 577:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN . separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(DOT,ident) shift to state 578
-- On ident shift to state 11
## Reductions:

State 578:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) . COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On COMMA shift to state 579
## Reductions:

State 579:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA . separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,ident) shift to state 580
-- On ident shift to state 584
## Reductions:

State 580:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) . RPAREN comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On RPAREN shift to state 581
## Reductions:

State 581:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN . comment option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On STRING shift to state 210
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 582
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 582:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 583
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 583:
## Known stack suffix:
## typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort ident EQ DER LPAREN separated_nonempty_list(DOT,ident) COMMA separated_nonempty_list(COMMA,ident) RPAREN comment option(constraining_clause)

State 584:
## Known stack suffix:
## ident
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident . [ RPAREN ]
separated_nonempty_list(COMMA,ident) -> ident . COMMA separated_nonempty_list(COMMA,ident) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 585
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,ident) -> ident

State 585:
## Known stack suffix:
## ident COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA . separated_nonempty_list(COMMA,ident) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 7
-- On separated_nonempty_list(COMMA,ident) shift to state 586
-- On ident shift to state 584
## Reductions:

State 586:
## Known stack suffix:
## ident COMMA separated_nonempty_list(COMMA,ident)
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident)

State 587:
## Known stack suffix:
## typedef_prefix type_sort ident EQ type_expression
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ type_expression . comment option(constraining_clause) [ SEMICOLON EOF ]
type_expression -> type_expression . array_subscripts [ STRING SEMICOLON LPAREN LBRACKET EOF CONSTRAINEDBY ANNOTATION ]
type_expression -> type_expression . class_modification [ STRING SEMICOLON LPAREN LBRACKET EOF CONSTRAINEDBY ANNOTATION ]
## Transitions:
-- On STRING shift to state 210
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On str shift to state 211
-- On option(str) shift to state 212
-- On comment shift to state 588
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:
-- On SEMICOLON reduce production option(str) ->
-- On EOF reduce production option(str) ->
-- On CONSTRAINEDBY reduce production option(str) ->
-- On ANNOTATION reduce production option(str) ->

State 588:
## Known stack suffix:
## typedef_prefix type_sort ident EQ type_expression comment
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ type_expression comment . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 589
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 589:
## Known stack suffix:
## typedef_prefix type_sort ident EQ type_expression comment option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident EQ type_expression comment option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort ident EQ type_expression comment option(constraining_clause)

State 590:
## Known stack suffix:
## typedef_prefix type_sort ident option(str)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident option(str) . composition option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On REDECLARE shift to state 432
-- On PUBLIC shift to state 435
-- On PROTECTED shift to state 436
-- On INITIAL_EQUATION shift to state 441
-- On INITIAL_ALGORITHM shift to state 443
-- On IMPORT shift to state 352
-- On FINAL shift to state 1
-- On EXTERNAL shift to state 445
-- On EXTENDS shift to state 345
-- On EQUATION shift to state 462
-- On ALGORITHM shift to state 464
-- On typedef_prefix shift to state 426
-- On type_prefix shift to state 2
-- On type_definition shift to state 466
-- On public_composition_elements shift to state 551
-- On option(composition_external) shift to state 469
-- On import shift to state 470
-- On flag(FINAL) shift to state 473
-- On extends shift to state 478
-- On composition_external shift to state 481
-- On composition shift to state 591
-- On component_clause shift to state 482
-- On cargo_sections shift to state 485
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On STREAM reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PARAMETER reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OUTPUT reduce production flag(FINAL) ->
-- On OUTER reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On INPUT reduce production flag(FINAL) ->
-- On INNER reduce production flag(FINAL) ->
-- On IDENT reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On FLOW reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On END_IDENT reduce production option(composition_external) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On DOT reduce production flag(FINAL) ->
-- On DISCRETE reduce production flag(FINAL) ->
-- On CONSTANT reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->
-- On ANNOTATION reduce production option(composition_external) ->

State 591:
## Known stack suffix:
## typedef_prefix type_sort ident option(str) composition
## LR(1) items:
type_definition -> typedef_prefix type_sort ident option(str) composition . option(composition_annotation) END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On ANNOTATION shift to state 213
-- On option(composition_annotation) shift to state 592
-- On composition_annotation shift to state 556
-- On annotation shift to state 557
## Reductions:
-- On END_IDENT reduce production option(composition_annotation) ->

State 592:
## Known stack suffix:
## typedef_prefix type_sort ident option(str) composition option(composition_annotation)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident option(str) composition option(composition_annotation) . END_IDENT option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On END_IDENT shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## typedef_prefix type_sort ident option(str) composition option(composition_annotation) END_IDENT
## LR(1) items:
type_definition -> typedef_prefix type_sort ident option(str) composition option(composition_annotation) END_IDENT . option(constraining_clause) [ SEMICOLON EOF ]
## Transitions:
-- On CONSTRAINEDBY shift to state 222
-- On option(constraining_clause) shift to state 594
-- On constraining_clause shift to state 226
## Reductions:
-- On SEMICOLON reduce production option(constraining_clause) ->
-- On EOF reduce production option(constraining_clause) ->

State 594:
## Known stack suffix:
## typedef_prefix type_sort ident option(str) composition option(composition_annotation) END_IDENT option(constraining_clause)
## LR(1) items:
type_definition -> typedef_prefix type_sort ident option(str) composition option(composition_annotation) END_IDENT option(constraining_clause) . [ SEMICOLON EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition -> typedef_prefix type_sort ident option(str) composition option(composition_annotation) END_IDENT option(constraining_clause)

State 595:
## Known stack suffix:
## type_definition_clause
## LR(1) items:
list(type_definition_clause) -> type_definition_clause . list(type_definition_clause) [ EOF ]
## Transitions:
-- On FINAL shift to state 1
-- On typedef_prefix shift to state 426
-- On type_definition_clause shift to state 595
-- On type_definition shift to state 596
-- On list(type_definition_clause) shift to state 598
-- On flag(FINAL) shift to state 599
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On EOF reduce production list(type_definition_clause) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 596:
## Known stack suffix:
## type_definition
## LR(1) items:
type_definition_clause -> type_definition . SEMICOLON [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
-- On SEMICOLON shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## type_definition SEMICOLON
## LR(1) items:
type_definition_clause -> type_definition SEMICOLON . [ TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production type_definition_clause -> type_definition SEMICOLON

State 598:
## Known stack suffix:
## type_definition_clause list(type_definition_clause)
## LR(1) items:
list(type_definition_clause) -> type_definition_clause list(type_definition_clause) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(type_definition_clause) -> type_definition_clause list(type_definition_clause)

State 599:
## Known stack suffix:
## flag(FINAL)
## LR(1) items:
typedef_prefix -> flag(FINAL) . flag(REPLACEABLE) flag(ENCAPSULATED) flag(PARTIAL) [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
-- On REPLACEABLE shift to state 190
-- On flag(REPLACEABLE) shift to state 600
## Reductions:
-- On TYPE reduce production flag(REPLACEABLE) ->
-- On RECORD reduce production flag(REPLACEABLE) ->
-- On PARTIAL reduce production flag(REPLACEABLE) ->
-- On PACKAGE reduce production flag(REPLACEABLE) ->
-- On OPERATOR reduce production flag(REPLACEABLE) ->
-- On MODEL reduce production flag(REPLACEABLE) ->
-- On FUNCTION reduce production flag(REPLACEABLE) ->
-- On EXPANDABLE reduce production flag(REPLACEABLE) ->
-- On ENCAPSULATED reduce production flag(REPLACEABLE) ->
-- On CONNECTOR reduce production flag(REPLACEABLE) ->
-- On CLASS reduce production flag(REPLACEABLE) ->
-- On BLOCK reduce production flag(REPLACEABLE) ->

State 600:
## Known stack suffix:
## flag(FINAL) flag(REPLACEABLE)
## LR(1) items:
typedef_prefix -> flag(FINAL) flag(REPLACEABLE) . flag(ENCAPSULATED) flag(PARTIAL) [ TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK ]
## Transitions:
-- On ENCAPSULATED shift to state 475
-- On flag(ENCAPSULATED) shift to state 476
## Reductions:
-- On TYPE reduce production flag(ENCAPSULATED) ->
-- On RECORD reduce production flag(ENCAPSULATED) ->
-- On PARTIAL reduce production flag(ENCAPSULATED) ->
-- On PACKAGE reduce production flag(ENCAPSULATED) ->
-- On OPERATOR reduce production flag(ENCAPSULATED) ->
-- On MODEL reduce production flag(ENCAPSULATED) ->
-- On FUNCTION reduce production flag(ENCAPSULATED) ->
-- On EXPANDABLE reduce production flag(ENCAPSULATED) ->
-- On CONNECTOR reduce production flag(ENCAPSULATED) ->
-- On CLASS reduce production flag(ENCAPSULATED) ->
-- On BLOCK reduce production flag(ENCAPSULATED) ->

State 601:
## Known stack suffix:
## option(within_clause) list(type_definition_clause)
## LR(1) items:
modelica_stored_definition -> option(within_clause) list(type_definition_clause) . EOF [ # ]
## Transitions:
-- On EOF shift to state 602
## Reductions:

State 602:
## Known stack suffix:
## option(within_clause) list(type_definition_clause) EOF
## LR(1) items:
modelica_stored_definition -> option(within_clause) list(type_definition_clause) EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_stored_definition -> option(within_clause) list(type_definition_clause) EOF

State 603:
## Known stack suffix:
## modelica_stored_definition
## LR(1) items:
modelica_stored_definition' -> modelica_stored_definition . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_stored_definition

State 604:
## Known stack suffix:
##
## LR(1) items:
modelica_texpr' -> . modelica_texpr [ # ]
## Transitions:
-- On STREAM shift to state 3
-- On PARAMETER shift to state 4
-- On OUTPUT shift to state 5
-- On INPUT shift to state 6
-- On IDENT shift to state 7
-- On FLOW shift to state 8
-- On DOT shift to state 9
-- On DISCRETE shift to state 14
-- On CONSTANT shift to state 15
-- On variability shift to state 16
-- On type_expression shift to state 605
-- On separated_nonempty_list(DOT,ident) shift to state 179
-- On modelica_texpr shift to state 607
-- On ident shift to state 11
-- On connectivity shift to state 180
-- On causality shift to state 182
## Reductions:

State 605:
## Known stack suffix:
## type_expression
## LR(1) items:
modelica_texpr -> type_expression . EOF [ # ]
type_expression -> type_expression . array_subscripts [ LPAREN LBRACKET EOF ]
type_expression -> type_expression . class_modification [ LPAREN LBRACKET EOF ]
## Transitions:
-- On LPAREN shift to state 185
-- On LBRACKET shift to state 18
-- On EOF shift to state 606
-- On class_modification shift to state 177
-- On array_subscripts shift to state 178
## Reductions:

State 606:
## Known stack suffix:
## type_expression EOF
## LR(1) items:
modelica_texpr -> type_expression EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_texpr -> type_expression EOF

State 607:
## Known stack suffix:
## modelica_texpr
## LR(1) items:
modelica_texpr' -> modelica_texpr . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_texpr

State 608:
## Known stack suffix:
##
## LR(1) items:
modelica_type_definition' -> . modelica_type_definition [ # ]
## Transitions:
-- On FINAL shift to state 1
-- On typedef_prefix shift to state 426
-- On type_definition shift to state 609
-- On modelica_type_definition shift to state 611
-- On flag(FINAL) shift to state 599
## Reductions:
-- On TYPE reduce production flag(FINAL) ->
-- On REPLACEABLE reduce production flag(FINAL) ->
-- On RECORD reduce production flag(FINAL) ->
-- On PARTIAL reduce production flag(FINAL) ->
-- On PACKAGE reduce production flag(FINAL) ->
-- On OPERATOR reduce production flag(FINAL) ->
-- On MODEL reduce production flag(FINAL) ->
-- On FUNCTION reduce production flag(FINAL) ->
-- On EXPANDABLE reduce production flag(FINAL) ->
-- On ENCAPSULATED reduce production flag(FINAL) ->
-- On CONNECTOR reduce production flag(FINAL) ->
-- On CLASS reduce production flag(FINAL) ->
-- On BLOCK reduce production flag(FINAL) ->

State 609:
## Known stack suffix:
## type_definition
## LR(1) items:
modelica_type_definition -> type_definition . EOF [ # ]
## Transitions:
-- On EOF shift to state 610
## Reductions:

State 610:
## Known stack suffix:
## type_definition EOF
## LR(1) items:
modelica_type_definition -> type_definition EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production modelica_type_definition -> type_definition EOF

State 611:
## Known stack suffix:
## modelica_type_definition
## LR(1) items:
modelica_type_definition' -> modelica_type_definition . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept modelica_type_definition

