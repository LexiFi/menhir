File "modelica.mly", line 40, characters 83-89:
Warning: the token IMPURE is unused.
File "modelica.mly", line 38, characters 37-41:
Warning: the token PURE is unused.
File "modelica.mly", line 61, characters 6-14:
Warning: the token app_prec is unused.
File "modelica.mly", line 60, characters 10-19:
Warning: the token below_app is unused.
File "modelica.mly", line 46, characters 7-13:
Warning: the token lowest is unused.
File "modelica.mly", line 68, characters 6-15:
Warning: the token type_proj is unused.
Grammar has 114 nonterminal symbols, among which 9 start symbols.
Grammar has 99 terminal symbols.
Grammar has 302 productions.
nullable(within_clause) = false
nullable(variability) = false
nullable(typedef_prefix) = true
nullable(type_sort) = false
nullable(type_prefix) = true
nullable(type_expression) = false
nullable(type_definition_clause) = false
nullable(type_definition) = false
nullable(str) = false
nullable(statement_body) = false
nullable(statement) = false
nullable(simple_expr) = false
nullable(separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))) = false
nullable(separated_nonempty_list(DOT,ident)) = false
nullable(separated_nonempty_list(COMMA,named_argument)) = false
nullable(separated_nonempty_list(COMMA,index)) = false
nullable(separated_nonempty_list(COMMA,ident)) = false
nullable(separated_nonempty_list(COMMA,expr)) = false
nullable(separated_nonempty_list(COMMA,enum_literal)) = false
nullable(separated_nonempty_list(COMMA,declaration)) = false
nullable(scope) = true
nullable(public_composition_elements) = true
nullable(protected_composition_elements) = true
nullable(patterns) = true
nullable(option(within_clause)) = true
nullable(option(str)) = true
nullable(option(preceded(binder,expr))) = true
nullable(option(preceded(COLON,simple_expr))) = true
nullable(option(modification)) = true
nullable(option(lexpr)) = true
nullable(option(index_range)) = true
nullable(option(decl_condition)) = true
nullable(option(constraining_clause)) = true
nullable(option(composition_external)) = true
nullable(option(composition_annotation)) = true
nullable(option(class_modification)) = true
nullable(option(array_subscripts)) = true
nullable(option(annotation)) = true
nullable(nonempty_list(statement)) = false
nullable(named_function_args) = true
nullable(named_argument) = false
nullable(modification_arguments_tail) = true
nullable(modification_arguments_head) = true
nullable(modification_arguments) = false
nullable(modification) = false
nullable(modelica_type_definition) = false
nullable(modelica_texpr) = false
nullable(modelica_stored_definition) = false
nullable(modelica_stmt) = false
nullable(modelica_import) = false
nullable(modelica_extends) = false
nullable(modelica_expr) = false
nullable(modelica_eq) = false
nullable(modelica_definitions) = false
nullable(mod_component_clause) = false
nullable(loption(separated_nonempty_list(DOT,ident))) = true
nullable(loption(separated_nonempty_list(COMMA,expr))) = true
nullable(list(type_definition_clause)) = true
nullable(list(statement)) = true
nullable(list(preceded(COMMA,option(lexpr)))) = true
nullable(list(index)) = true
nullable(list(equation)) = true
nullable(list(elsewhen_statement)) = true
nullable(list(elsewhen_equation)) = true
nullable(list(elseif_statement)) = true
nullable(list(elseif_equation)) = true
nullable(list(else_if)) = true
nullable(lexpr) = false
nullable(initial_equation_section) = true
nullable(initial_algorithm_section) = true
nullable(index_range) = false
nullable(index) = false
nullable(import) = false
nullable(ident) = false
nullable(function_args) = true
nullable(flag(REPLACEABLE)) = true
nullable(flag(PARTIAL)) = true
nullable(flag(FINAL)) = true
nullable(flag(ENCAPSULATED)) = true
nullable(flag(EACH)) = true
nullable(external_lhs) = false
nullable(extends) = false
nullable(expr) = false
nullable(equation_section) = true
nullable(equation_body) = false
nullable(equation) = false
nullable(enum_literal) = false
nullable(elsewhen_statement) = false
nullable(elsewhen_equation) = false
nullable(elseif_statement) = false
nullable(elseif_equation) = false
nullable(else_statements) = true
nullable(else_if) = false
nullable(else_equations) = true
nullable(declaration) = false
nullable(decl_modification) = true
nullable(decl_condition) = false
nullable(constraining_clause) = false
nullable(connectivity) = false
nullable(composition_external) = false
nullable(composition_annotation) = false
nullable(composition) = true
nullable(component_reference) = false
nullable(component_clauses) = false
nullable(component_clause) = false
nullable(comment) = true
nullable(class_modification) = false
nullable(causality) = false
nullable(cargo_sections) = true
nullable(array_subscripts) = false
nullable(array_args) = true
nullable(annotation) = false
nullable(algorithm_section) = true
nullable(algorithm) = false
first(within_clause) = WITHIN
first(variability) = PARAMETER DISCRETE CONSTANT
first(typedef_prefix) = REPLACEABLE PARTIAL FINAL ENCAPSULATED
first(type_sort) = TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK
first(type_prefix) = REPLACEABLE OUTER INNER FINAL
first(type_expression) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
first(type_definition_clause) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE ENCAPSULATED CONNECTOR CLASS BLOCK
first(type_definition) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE ENCAPSULATED CONNECTOR CLASS BLOCK
first(str) = STRING
first(statement_body) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
first(statement) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
first(simple_expr) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(separated_nonempty_list(DOT,ident)) = IDENT
first(separated_nonempty_list(COMMA,named_argument)) = IDENT
first(separated_nonempty_list(COMMA,index)) = IDENT
first(separated_nonempty_list(COMMA,ident)) = IDENT
first(separated_nonempty_list(COMMA,expr)) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(separated_nonempty_list(COMMA,enum_literal)) = IDENT
first(separated_nonempty_list(COMMA,declaration)) = IDENT
first(scope) = OUTER INNER
first(public_composition_elements) = TYPE STREAM REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ALGORITHM
first(protected_composition_elements) = TYPE STREAM REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ALGORITHM
first(patterns) = LPAREN IDENT DOT COMMA ASSERT
first(option(within_clause)) = WITHIN
first(option(str)) = STRING
first(option(preceded(binder,expr))) = EQ COLONEQ
first(option(preceded(COLON,simple_expr))) = COLON
first(option(modification)) = LPAREN EQ COLONEQ
first(option(lexpr)) = LPAREN IDENT DOT ASSERT
first(option(index_range)) = IN
first(option(decl_condition)) = IF
first(option(constraining_clause)) = CONSTRAINEDBY
first(option(composition_external)) = EXTERNAL
first(option(composition_annotation)) = ANNOTATION
first(option(class_modification)) = LPAREN
first(option(array_subscripts)) = LBRACKET
first(option(annotation)) = ANNOTATION
first(nonempty_list(statement)) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
first(named_function_args) = IDENT
first(named_argument) = IDENT
first(modification_arguments_tail) = COMMA
first(modification_arguments_head) = REPLACEABLE REDECLARE IDENT FINAL EACH
first(modification_arguments) = REPLACEABLE REDECLARE IDENT FINAL EACH
first(modification) = LPAREN EQ COLONEQ
first(modelica_type_definition) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE ENCAPSULATED CONNECTOR CLASS BLOCK
first(modelica_texpr) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
first(modelica_stored_definition) = WITHIN TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK
first(modelica_stmt) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
first(modelica_import) = IMPORT
first(modelica_extends) = EXTENDS
first(modelica_expr) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(modelica_eq) = WHEN TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FOR FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(modelica_definitions) = STREAM REPLACEABLE PARAMETER OUTPUT OUTER INPUT INNER IDENT FLOW FINAL DOT DISCRETE CONSTANT
first(mod_component_clause) = STREAM PARAMETER OUTPUT OUTER INPUT INNER IDENT FLOW DOT DISCRETE CONSTANT
first(loption(separated_nonempty_list(DOT,ident))) = IDENT
first(loption(separated_nonempty_list(COMMA,expr))) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(list(type_definition_clause)) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE ENCAPSULATED CONNECTOR CLASS BLOCK
first(list(statement)) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
first(list(preceded(COMMA,option(lexpr)))) = COMMA
first(list(index)) = IDENT
first(list(equation)) = WHEN TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FOR FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(list(elsewhen_statement)) = ELSEWHEN
first(list(elsewhen_equation)) = ELSEWHEN
first(list(elseif_statement)) = ELSEIF
first(list(elseif_equation)) = ELSEIF
first(list(else_if)) = ELSEIF
first(lexpr) = LPAREN IDENT DOT ASSERT
first(initial_equation_section) = WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION END DOTPLUS DOTMINUS DOT DER COLON ASSERT ALGORITHM
first(initial_algorithm_section) = WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION DOT BREAK ASSERT ALGORITHM
first(index_range) = IN
first(index) = IDENT
first(import) = IMPORT
first(ident) = IDENT
first(function_args) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(flag(REPLACEABLE)) = REPLACEABLE
first(flag(PARTIAL)) = PARTIAL
first(flag(FINAL)) = FINAL
first(flag(ENCAPSULATED)) = ENCAPSULATED
first(flag(EACH)) = EACH
first(external_lhs) = IDENT DOT ASSERT
first(extends) = EXTENDS
first(expr) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(equation_section) = WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION END DOTPLUS DOTMINUS DOT DER COLON ASSERT ALGORITHM
first(equation_body) = WHEN TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FOR FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(equation) = WHEN TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FOR FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(enum_literal) = IDENT
first(elsewhen_statement) = ELSEWHEN
first(elsewhen_equation) = ELSEWHEN
first(elseif_statement) = ELSEIF
first(elseif_equation) = ELSEIF
first(else_statements) = ELSE
first(else_if) = ELSEIF
first(else_equations) = ELSE
first(declaration) = IDENT
first(decl_modification) = LPAREN EQ COLONEQ
first(decl_condition) = IF
first(constraining_clause) = CONSTRAINEDBY
first(connectivity) = STREAM FLOW
first(composition_external) = EXTERNAL
first(composition_annotation) = ANNOTATION
first(composition) = TYPE STREAM REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK ALGORITHM
first(component_reference) = IDENT DOT ASSERT
first(component_clauses) = STREAM REPLACEABLE PARAMETER OUTPUT OUTER INPUT INNER IDENT FLOW FINAL DOT DISCRETE CONSTANT
first(component_clause) = STREAM REPLACEABLE PARAMETER OUTPUT OUTER INPUT INNER IDENT FLOW FINAL DOT DISCRETE CONSTANT
first(comment) = STRING ANNOTATION
first(class_modification) = LPAREN
first(causality) = OUTPUT INPUT
first(cargo_sections) = INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION ALGORITHM
first(array_subscripts) = LBRACKET
first(array_args) = TRUE STRING PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL IF IDENT FUNCTION FLOAT FALSE END DOTPLUS DOTMINUS DOT DER COLON ASSERT
first(annotation) = ANNOTATION
first(algorithm_section) = WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION DOT BREAK ASSERT ALGORITHM
first(algorithm) = WHILE WHEN RETURN LPAREN IF IDENT FOR DOT BREAK ASSERT
minimal(within_clause) = (* 2 *) WITHIN SEMICOLON
minimal(variability) = (* 1 *) CONSTANT
minimal(typedef_prefix) = (* 0 *)
minimal(type_sort) = (* 1 *) CLASS
minimal(type_prefix) = (* 0 *)
minimal(type_expression) = (* 1 *) IDENT
minimal(type_definition_clause) = (* 4 *) CLASS IDENT END_IDENT SEMICOLON
minimal(type_definition) = (* 3 *) CLASS IDENT END_IDENT
minimal(str) = (* 1 *) STRING
minimal(statement_body) = (* 1 *) BREAK
minimal(statement) = (* 2 *) BREAK SEMICOLON
minimal(simple_expr) = (* 1 *) TRUE
minimal(separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))) = (* 1 *) TRUE
minimal(separated_nonempty_list(DOT,ident)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,named_argument)) = (* 3 *) IDENT EQ TRUE
minimal(separated_nonempty_list(COMMA,index)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,ident)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,expr)) = (* 1 *) TRUE
minimal(separated_nonempty_list(COMMA,enum_literal)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,declaration)) = (* 1 *) IDENT
minimal(scope) = (* 0 *)
minimal(public_composition_elements) = (* 0 *)
minimal(protected_composition_elements) = (* 0 *)
minimal(patterns) = (* 0 *)
minimal(option(within_clause)) = (* 0 *)
minimal(option(str)) = (* 0 *)
minimal(option(preceded(binder,expr))) = (* 0 *)
minimal(option(preceded(COLON,simple_expr))) = (* 0 *)
minimal(option(modification)) = (* 0 *)
minimal(option(lexpr)) = (* 0 *)
minimal(option(index_range)) = (* 0 *)
minimal(option(decl_condition)) = (* 0 *)
minimal(option(constraining_clause)) = (* 0 *)
minimal(option(composition_external)) = (* 0 *)
minimal(option(composition_annotation)) = (* 0 *)
minimal(option(class_modification)) = (* 0 *)
minimal(option(array_subscripts)) = (* 0 *)
minimal(option(annotation)) = (* 0 *)
minimal(nonempty_list(statement)) = (* 2 *) BREAK SEMICOLON
minimal(named_function_args) = (* 0 *)
minimal(named_argument) = (* 3 *) IDENT EQ TRUE
minimal(modification_arguments_tail) = (* 0 *)
minimal(modification_arguments_head) = (* 0 *)
minimal(modification_arguments) = (* 1 *) IDENT
minimal(modification) = (* 2 *) EQ TRUE
minimal(modelica_type_definition) = (* 4 *) CLASS IDENT END_IDENT EOF
minimal(modelica_texpr) = (* 2 *) IDENT EOF
minimal(modelica_stored_definition) = (* 1 *) EOF
minimal(modelica_stmt) = (* 3 *) BREAK SEMICOLON EOF
minimal(modelica_import) = (* 3 *) IMPORT IDENT EOF
minimal(modelica_extends) = (* 3 *) EXTENDS IDENT EOF
minimal(modelica_expr) = (* 2 *) TRUE EOF
minimal(modelica_eq) = (* 3 *) TRUE SEMICOLON EOF
minimal(modelica_definitions) = (* 3 *) IDENT IDENT EOF
minimal(mod_component_clause) = (* 2 *) IDENT IDENT
minimal(loption(separated_nonempty_list(DOT,ident))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,expr))) = (* 0 *)
minimal(list(type_definition_clause)) = (* 0 *)
minimal(list(statement)) = (* 0 *)
minimal(list(preceded(COMMA,option(lexpr)))) = (* 0 *)
minimal(list(index)) = (* 0 *)
minimal(list(equation)) = (* 0 *)
minimal(list(elsewhen_statement)) = (* 0 *)
minimal(list(elsewhen_equation)) = (* 0 *)
minimal(list(elseif_statement)) = (* 0 *)
minimal(list(elseif_equation)) = (* 0 *)
minimal(list(else_if)) = (* 0 *)
minimal(lexpr) = (* 1 *) IDENT
minimal(initial_equation_section) = (* 0 *)
minimal(initial_algorithm_section) = (* 0 *)
minimal(index_range) = (* 2 *) IN TRUE
minimal(index) = (* 1 *) IDENT
minimal(import) = (* 2 *) IMPORT IDENT
minimal(ident) = (* 1 *) IDENT
minimal(function_args) = (* 0 *)
minimal(flag(REPLACEABLE)) = (* 0 *)
minimal(flag(PARTIAL)) = (* 0 *)
minimal(flag(FINAL)) = (* 0 *)
minimal(flag(ENCAPSULATED)) = (* 0 *)
minimal(flag(EACH)) = (* 0 *)
minimal(external_lhs) = (* 2 *) IDENT EQ
minimal(extends) = (* 2 *) EXTENDS IDENT
minimal(expr) = (* 1 *) TRUE
minimal(equation_section) = (* 0 *)
minimal(equation_body) = (* 1 *) TRUE
minimal(equation) = (* 2 *) TRUE SEMICOLON
minimal(enum_literal) = (* 1 *) IDENT
minimal(elsewhen_statement) = (* 3 *) ELSEWHEN TRUE THEN
minimal(elsewhen_equation) = (* 3 *) ELSEWHEN TRUE THEN
minimal(elseif_statement) = (* 3 *) ELSEIF TRUE THEN
minimal(elseif_equation) = (* 3 *) ELSEIF TRUE THEN
minimal(else_statements) = (* 0 *)
minimal(else_if) = (* 4 *) ELSEIF TRUE THEN TRUE
minimal(else_equations) = (* 0 *)
minimal(declaration) = (* 1 *) IDENT
minimal(decl_modification) = (* 0 *)
minimal(decl_condition) = (* 2 *) IF TRUE
minimal(constraining_clause) = (* 2 *) CONSTRAINEDBY IDENT
minimal(connectivity) = (* 1 *) FLOW
minimal(composition_external) = (* 6 *) EXTERNAL STRING IDENT LPAREN RPAREN SEMICOLON
minimal(composition_annotation) = (* 4 *) ANNOTATION LPAREN RPAREN SEMICOLON
minimal(composition) = (* 0 *)
minimal(component_reference) = (* 1 *) IDENT
minimal(component_clauses) = (* 2 *) IDENT IDENT
minimal(component_clause) = (* 2 *) IDENT IDENT
minimal(comment) = (* 0 *)
minimal(class_modification) = (* 2 *) LPAREN RPAREN
minimal(causality) = (* 1 *) INPUT
minimal(cargo_sections) = (* 0 *)
minimal(array_subscripts) = (* 2 *) LBRACKET RBRACKET
minimal(array_args) = (* 0 *)
minimal(annotation) = (* 3 *) ANNOTATION LPAREN RPAREN
minimal(algorithm_section) = (* 0 *)
minimal(algorithm) = (* 2 *) BREAK SEMICOLON
maximal(within_clause) = infinity
maximal(variability) = 1
maximal(typedef_prefix) = 4
maximal(type_sort) = 2
maximal(type_prefix) = 4
maximal(type_expression) = infinity
maximal(type_definition_clause) = infinity
maximal(type_definition) = infinity
maximal(str) = 1
maximal(statement_body) = infinity
maximal(statement) = infinity
maximal(simple_expr) = infinity
maximal(separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))) = infinity
maximal(separated_nonempty_list(DOT,ident)) = infinity
maximal(separated_nonempty_list(COMMA,named_argument)) = infinity
maximal(separated_nonempty_list(COMMA,index)) = infinity
maximal(separated_nonempty_list(COMMA,ident)) = infinity
maximal(separated_nonempty_list(COMMA,expr)) = infinity
maximal(separated_nonempty_list(COMMA,enum_literal)) = infinity
maximal(separated_nonempty_list(COMMA,declaration)) = infinity
maximal(scope) = 2
maximal(public_composition_elements) = infinity
maximal(protected_composition_elements) = infinity
maximal(patterns) = infinity
maximal(option(within_clause)) = infinity
maximal(option(str)) = 1
maximal(option(preceded(binder,expr))) = infinity
maximal(option(preceded(COLON,simple_expr))) = infinity
maximal(option(modification)) = infinity
maximal(option(lexpr)) = infinity
maximal(option(index_range)) = infinity
maximal(option(decl_condition)) = infinity
maximal(option(constraining_clause)) = infinity
maximal(option(composition_external)) = infinity
maximal(option(composition_annotation)) = infinity
maximal(option(class_modification)) = infinity
maximal(option(array_subscripts)) = infinity
maximal(option(annotation)) = infinity
maximal(nonempty_list(statement)) = infinity
maximal(named_function_args) = infinity
maximal(named_argument) = infinity
maximal(modification_arguments_tail) = infinity
maximal(modification_arguments_head) = infinity
maximal(modification_arguments) = infinity
maximal(modification) = infinity
maximal(modelica_type_definition) = infinity
maximal(modelica_texpr) = infinity
maximal(modelica_stored_definition) = infinity
maximal(modelica_stmt) = infinity
maximal(modelica_import) = infinity
maximal(modelica_extends) = infinity
maximal(modelica_expr) = infinity
maximal(modelica_eq) = infinity
maximal(modelica_definitions) = infinity
maximal(mod_component_clause) = infinity
maximal(loption(separated_nonempty_list(DOT,ident))) = infinity
maximal(loption(separated_nonempty_list(COMMA,expr))) = infinity
maximal(list(type_definition_clause)) = infinity
maximal(list(statement)) = infinity
maximal(list(preceded(COMMA,option(lexpr)))) = infinity
maximal(list(index)) = infinity
maximal(list(equation)) = infinity
maximal(list(elsewhen_statement)) = infinity
maximal(list(elsewhen_equation)) = infinity
maximal(list(elseif_statement)) = infinity
maximal(list(elseif_equation)) = infinity
maximal(list(else_if)) = infinity
maximal(lexpr) = infinity
maximal(initial_equation_section) = infinity
maximal(initial_algorithm_section) = infinity
maximal(index_range) = infinity
maximal(index) = infinity
maximal(import) = infinity
maximal(ident) = 1
maximal(function_args) = infinity
maximal(flag(REPLACEABLE)) = 1
maximal(flag(PARTIAL)) = 1
maximal(flag(FINAL)) = 1
maximal(flag(ENCAPSULATED)) = 1
maximal(flag(EACH)) = 1
maximal(external_lhs) = infinity
maximal(extends) = infinity
maximal(expr) = infinity
maximal(equation_section) = infinity
maximal(equation_body) = infinity
maximal(equation) = infinity
maximal(enum_literal) = infinity
maximal(elsewhen_statement) = infinity
maximal(elsewhen_equation) = infinity
maximal(elseif_statement) = infinity
maximal(elseif_equation) = infinity
maximal(else_statements) = infinity
maximal(else_if) = infinity
maximal(else_equations) = infinity
maximal(declaration) = infinity
maximal(decl_modification) = infinity
maximal(decl_condition) = infinity
maximal(constraining_clause) = infinity
maximal(connectivity) = 1
maximal(composition_external) = infinity
maximal(composition_annotation) = infinity
maximal(composition) = infinity
maximal(component_reference) = infinity
maximal(component_clauses) = infinity
maximal(component_clause) = infinity
maximal(comment) = infinity
maximal(class_modification) = infinity
maximal(causality) = 1
maximal(cargo_sections) = infinity
maximal(array_subscripts) = infinity
maximal(array_args) = infinity
maximal(annotation) = infinity
maximal(algorithm_section) = infinity
maximal(algorithm) = infinity
follow(within_clause) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK
follow(variability) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
follow(typedef_prefix) = TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK
follow(type_sort) = IDENT EXTENDS
follow(type_prefix) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
follow(type_expression) = STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EOF CONSTRAINEDBY COMMA ANNOTATION
follow(type_definition_clause) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK
follow(type_definition) = SEMICOLON EOF
follow(str) = TYPE STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA CLASS BLOCK ANNOTATION ALGORITHM
follow(statement_body) = STRING SEMICOLON ANNOTATION
follow(statement) = WHILE WHEN RETURN PUBLIC PROTECTED LPAREN INITIAL_EQUATION INITIAL_ALGORITHM IF IDENT FOR EXTERNAL EQUATION EOF END_IDENT ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE DOT BREAK ASSERT ANNOTATION ALGORITHM
follow(simple_expr) = TIMES THEN STRING SEMICOLON RPAREN RBRACKET RBRACE POWER PLUS OR NEQ MINUS LT LPAREN LOOP LEQ LBRACKET IF IDENT GT GEQ FOR EQEQ EQ EOF ELSEIF ELSE DOTTIMES DOTPOWER DOTPLUS DOTMINUS DOTDIV DOT DIV CONSTRAINEDBY COMMA COLON ANNOTATION AND
follow(separated_nonempty_list(SEMICOLON,separated_nonempty_list(COMMA,expr))) = RBRACKET
follow(separated_nonempty_list(DOT,ident)) = STRING SEMICOLON RPAREN LPAREN LBRACKET IDENT EQ EOF DOTTIMES CONSTRAINEDBY COMMA COLONEQ ANNOTATION
follow(separated_nonempty_list(COMMA,named_argument)) = RPAREN
follow(separated_nonempty_list(COMMA,index)) = RPAREN RBRACE
follow(separated_nonempty_list(COMMA,ident)) = RPAREN
follow(separated_nonempty_list(COMMA,expr)) = SEMICOLON RPAREN RBRACKET RBRACE
follow(separated_nonempty_list(COMMA,enum_literal)) = RPAREN
follow(separated_nonempty_list(COMMA,declaration)) = SEMICOLON EOF CONSTRAINEDBY
follow(scope) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
follow(public_composition_elements) = END_IDENT ANNOTATION
follow(protected_composition_elements) = END_IDENT ANNOTATION
follow(patterns) = RPAREN
follow(option(within_clause)) = TYPE REPLACEABLE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION FINAL EXPANDABLE EOF ENCAPSULATED CONNECTOR CLASS BLOCK
follow(option(str)) = TYPE STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA CLASS BLOCK ANNOTATION ALGORITHM
follow(option(preceded(binder,expr))) = STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION
follow(option(preceded(COLON,simple_expr))) = THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION
follow(option(modification)) = STRING RPAREN COMMA ANNOTATION
follow(option(lexpr)) = RPAREN COMMA
follow(option(index_range)) = RPAREN RBRACE LOOP IDENT COMMA
follow(option(decl_condition)) = STRING SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ANNOTATION
follow(option(constraining_clause)) = SEMICOLON RPAREN EOF COMMA
follow(option(composition_external)) = END_IDENT ANNOTATION
follow(option(composition_annotation)) = END_IDENT
follow(option(class_modification)) = TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM
follow(option(array_subscripts)) = STRING SEMICOLON RPAREN LPAREN IF EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION
follow(option(annotation)) = SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA
follow(nonempty_list(statement)) = PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM
follow(named_function_args) = RPAREN
follow(named_argument) = RPAREN COMMA
follow(modification_arguments_tail) = RPAREN
follow(modification_arguments_head) = RPAREN
follow(modification_arguments) = RPAREN
follow(modification) = STRING RPAREN COMMA ANNOTATION
follow(modelica_type_definition) = #
follow(modelica_texpr) = #
follow(modelica_stored_definition) = #
follow(modelica_stmt) = #
follow(modelica_import) = #
follow(modelica_extends) = #
follow(modelica_expr) = #
follow(modelica_eq) = #
follow(modelica_definitions) = #
follow(mod_component_clause) = RPAREN COMMA
follow(loption(separated_nonempty_list(DOT,ident))) = SEMICOLON
follow(loption(separated_nonempty_list(COMMA,expr))) = RPAREN RBRACKET RBRACE
follow(list(type_definition_clause)) = EOF
follow(list(statement)) = ENDWHILE ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE
follow(list(preceded(COMMA,option(lexpr)))) = RPAREN
follow(list(index)) = LOOP
follow(list(equation)) = ENDWHEN ENDIF ENDFOR ELSEWHEN ELSEIF ELSE
follow(list(elsewhen_statement)) = ENDWHEN
follow(list(elsewhen_equation)) = ENDWHEN
follow(list(elseif_statement)) = ENDIF ELSE
follow(list(elseif_equation)) = ENDIF ELSE
follow(list(else_if)) = ELSE
follow(lexpr) = RPAREN COMMA COLONEQ
follow(initial_equation_section) = END_IDENT ANNOTATION
follow(initial_algorithm_section) = END_IDENT ANNOTATION
follow(index_range) = RPAREN RBRACE LOOP IDENT COMMA
follow(index) = RPAREN RBRACE LOOP IDENT COMMA
follow(import) = SEMICOLON EOF
follow(ident) = TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD RBRACE PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LOOP LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IN IMPORT IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOTTIMES DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM
follow(function_args) = RPAREN
follow(flag(REPLACEABLE)) = TYPE STREAM RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW EXPANDABLE ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK
follow(flag(PARTIAL)) = TYPE RECORD PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK
follow(flag(FINAL)) = TYPE STREAM REPLACEABLE RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW EXPANDABLE ENCAPSULATED DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK
follow(flag(ENCAPSULATED)) = TYPE RECORD PARTIAL PACKAGE OPERATOR MODEL FUNCTION EXPANDABLE CONNECTOR CLASS BLOCK
follow(flag(EACH)) = TYPE STREAM REPLACEABLE RECORD PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL INPUT INNER IDENT FUNCTION FLOW FINAL EXPANDABLE DOT DISCRETE CONSTANT CONNECTOR CLASS BLOCK
follow(external_lhs) = IDENT
follow(extends) = SEMICOLON EOF
follow(expr) = THEN STRING SEMICOLON RPAREN RBRACKET RBRACE LOOP IF IDENT FOR EOF ELSEIF ELSE CONSTRAINEDBY COMMA ANNOTATION
follow(equation_section) = END_IDENT ANNOTATION
follow(equation_body) = STRING SEMICOLON ANNOTATION
follow(equation) = WHEN TRUE STRING PUBLIC PROTECTED PLUS NOT MINUS LPAREN LBRACKET LBRACE INT INITIAL_EQUATION INITIAL_ALGORITHM INITIAL IF IDENT FUNCTION FOR FLOAT FALSE EXTERNAL EQUATION EOF END_IDENT ENDWHEN ENDIF ENDFOR END ELSEWHEN ELSEIF ELSE DOTPLUS DOTMINUS DOT DER COLON ASSERT ANNOTATION ALGORITHM
follow(enum_literal) = RPAREN COMMA
follow(elsewhen_statement) = ENDWHEN ELSEWHEN
follow(elsewhen_equation) = ENDWHEN ELSEWHEN
follow(elseif_statement) = ENDIF ELSEIF ELSE
follow(elseif_equation) = ENDIF ELSEIF ELSE
follow(else_statements) = ENDIF
follow(else_if) = ELSEIF ELSE
follow(else_equations) = ENDIF
follow(declaration) = SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA
follow(decl_modification) = STRING SEMICOLON RPAREN IF EOF CONSTRAINEDBY COMMA ANNOTATION
follow(decl_condition) = STRING SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA ANNOTATION
follow(constraining_clause) = SEMICOLON RPAREN EOF COMMA
follow(connectivity) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
follow(composition_external) = END_IDENT ANNOTATION
follow(composition_annotation) = END_IDENT
follow(composition) = END_IDENT ANNOTATION
follow(component_reference) = RPAREN LPAREN LBRACKET EQ DOT COMMA COLONEQ
follow(component_clauses) = EOF
follow(component_clause) = SEMICOLON EOF
follow(comment) = SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA
follow(class_modification) = TYPE STRING STREAM SEMICOLON RPAREN REPLACEABLE REDECLARE RECORD PUBLIC PROTECTED PARTIAL PARAMETER PACKAGE OUTPUT OUTER OPERATOR MODEL LPAREN LBRACKET INPUT INNER INITIAL_EQUATION INITIAL_ALGORITHM IMPORT IF IDENT FUNCTION FLOW FINAL EXTERNAL EXTENDS EXPANDABLE EQUATION EQ EOF END_IDENT ENCAPSULATED DOT DISCRETE CONSTRAINEDBY CONSTANT CONNECTOR COMMA COLONEQ CLASS BLOCK ANNOTATION ALGORITHM
follow(causality) = STREAM PARAMETER OUTPUT INPUT IDENT FLOW DOT DISCRETE CONSTANT
follow(cargo_sections) = END_IDENT ANNOTATION
follow(array_subscripts) = STRING SEMICOLON RPAREN LPAREN LBRACKET IF IDENT EQ EOF CONSTRAINEDBY COMMA COLONEQ ANNOTATION
follow(array_args) = RBRACE
follow(annotation) = SEMICOLON RPAREN EOF CONSTRAINEDBY COMMA
follow(algorithm_section) = END_IDENT ANNOTATION
follow(algorithm) = PUBLIC PROTECTED INITIAL_EQUATION INITIAL_ALGORITHM EXTERNAL EQUATION END_IDENT ANNOTATION ALGORITHM
Built an LR(0) automaton with 612 states.
The grammar is not SLR(1) -- 30 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 612 states.
510 shift/reduce conflicts were silently solved.
File "modelica.mly", line 51, characters 0-5:
Warning: the precedence level assigned to COLON is never useful.
File "modelica.mly", line 49, characters 0-5:
Warning: the precedence level assigned to COMMA is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to FLOAT is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to IDENT is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to INT is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to LBRACE is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to RBRACE is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to RBRACKET is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to RPAREN is never useful.
File "modelica.mly", line 50, characters 0-5:
Warning: the precedence level assigned to SEMICOLON is never useful.
File "modelica.mly", line 47, characters 0-9:
Warning: the precedence level assigned to STRING is never useful.
File "modelica.mly", line 61, characters 0-5:
Warning: the precedence level assigned to app_prec is never useful.
File "modelica.mly", line 60, characters 0-9:
Warning: the precedence level assigned to below_app is never useful.
File "modelica.mly", line 46, characters 0-6:
Warning: the precedence level assigned to lowest is never useful.
File "modelica.mly", line 67, characters 0-5:
Warning: the precedence level assigned to type_array is never useful.
File "modelica.mly", line 63, characters 0-5:
Warning: the precedence level assigned to type_mod is never useful.
File "modelica.mly", line 68, characters 0-5:
Warning: the precedence level assigned to type_proj is never useful.
File "modelica.mly", line 174, characters 32-35:
Warning: this %prec declaration is never useful.
File "modelica.mly", line 325, characters 108-118:
Warning: this %prec declaration is never useful.
File "modelica.mly", line 326, characters 122-130:
Warning: this %prec declaration is never useful.
229 out of 612 states have a default reduction.
247 out of 612 states are represented.
2 out of 224 symbols keep track of their start position.
2 out of 224 symbols keep track of their end position.
163 out of 311 productions exploit shiftreduce optimization.
0 out of 612 states can peek at an error.
1662 functions before inlining, 235 functions after inlining.
