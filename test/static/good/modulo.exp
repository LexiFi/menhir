File "modulo.mly", line 61, characters 7-13:
Warning: the token ASSUME is unused.
File "modulo.mly", line 65, characters 7-11:
Warning: the token BANG is unused.
File "modulo.mly", line 42, characters 7-15:
Warning: the token LBRACKET is unused.
File "modulo.mly", line 43, characters 7-15:
Warning: the token RBRACKET is unused.
File "modulo.mly", line 68, characters 7-12:
Warning: the token SLASH is unused.
File "modulo.mly", line 64, characters 7-12:
Warning: the token SOLVE is unused.
Grammar has 47 nonterminal symbols, among which 1 start symbols.
Grammar has 56 terminal symbols.
Grammar has 132 productions.
nullable(value_definitions) = false
nullable(value_definition) = false
nullable(types) = false
nullable(type_definitions) = false
nullable(type_definition) = false
nullable(type2) = false
nullable(type1) = false
nullable(type0) = false
nullable(typ) = false
nullable(scheme) = false
nullable(row_pattern) = true
nullable(row_entry) = false
nullable(row) = true
nullable(record_fields) = false
nullable(quantifiers) = false
nullable(quantifier) = false
nullable(program) = false
nullable(patterns) = false
nullable(pattern3) = false
nullable(pattern2) = false
nullable(pattern1) = false
nullable(pattern0s) = true
nullable(pattern0) = false
nullable(pattern) = false
nullable(opt_bar) = true
nullable(kind) = false
nullable(formals) = true
nullable(formal) = false
nullable(forall) = true
nullable(expressions) = false
nullable(expression400) = false
nullable(expression300) = false
nullable(expression200) = false
nullable(expression100) = false
nullable(expression0) = false
nullable(expression) = false
nullable(equal_expression) = false
nullable(declarations) = true
nullable(declaration) = false
nullable(data_params) = true
nullable(data_cases) = false
nullable(data_case) = false
nullable(cases) = false
nullable(case) = false
nullable(bindings) = true
nullable(binding) = false
nullable(actuals) = true
first(value_definitions) = WILD LPAREN LID LBRACE INTEGER FORALL EXPORT
first(value_definition) = WILD LPAREN LID LBRACE INTEGER FORALL EXPORT
first(types) = LPAREN LID LBRACE LANGLE INT BACKSLASH
first(type_definitions) = LID
first(type_definition) = LID
first(type2) = LPAREN LID LBRACE LANGLE INT BACKSLASH
first(type1) = LPAREN LID LBRACE LANGLE INT
first(type0) = LPAREN LID LBRACE LANGLE INT
first(typ) = LPAREN LID LBRACE LANGLE INT BACKSLASH
first(scheme) = LPAREN LID LBRACE LANGLE INT FORALL BACKSLASH
first(row_pattern) = VALUE
first(row_entry) = PLUS MINUS
first(row) = PLUS MINUS LID
first(record_fields) = LID
first(quantifiers) = LPAREN LID
first(quantifier) = LPAREN LID
first(program) = PROG FIELD DATA
first(patterns) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(pattern3) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(pattern2) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(pattern1) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(pattern0s) = WILD LPAREN LID LBRACE INTEGER EXPORT
first(pattern0) = WILD LPAREN LID LBRACE INTEGER EXPORT
first(pattern) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(opt_bar) = BAR
first(kind) = STAR
first(formals) = LPAREN LID
first(formal) = LPAREN LID
first(forall) = FORALL
first(expressions) = UID TYPE MATCH LPAREN LID LET LBRACE INTEGER EXISTS DISPLAY BACKSLASH
first(expression400) = UID TYPE MATCH LPAREN LID LET LBRACE INTEGER EXISTS DISPLAY BACKSLASH
first(expression300) = UID MATCH LPAREN LID LBRACE INTEGER DISPLAY
first(expression200) = UID MATCH LPAREN LID LBRACE INTEGER DISPLAY
first(expression100) = UID MATCH LPAREN LID LBRACE INTEGER DISPLAY
first(expression0) = UID MATCH LPAREN LID LBRACE INTEGER
first(expression) = UID TYPE MATCH LPAREN LID LET LBRACE INTEGER EXISTS DISPLAY BACKSLASH
first(equal_expression) = WILD LPAREN LID LBRACE INTEGER EXPORT EQUAL COLONCOLON
first(declarations) = FIELD DATA
first(declaration) = FIELD DATA
first(data_params) = LPAREN LID LBRACE LANGLE INT
first(data_cases) = UID
first(data_case) = UID
first(cases) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(case) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
first(bindings) = TYPE LET
first(binding) = TYPE LET
first(actuals) = LPAREN LID LBRACE LANGLE INT
minimal(value_definitions) = (* 3 *) LID EQUAL LID
minimal(value_definition) = (* 3 *) LID EQUAL LID
minimal(types) = (* 1 *) LID
minimal(type_definitions) = (* 3 *) LID EQUAL LID
minimal(type_definition) = (* 3 *) LID EQUAL LID
minimal(type2) = (* 1 *) LID
minimal(type1) = (* 1 *) LID
minimal(type0) = (* 1 *) LID
minimal(typ) = (* 1 *) LID
minimal(scheme) = (* 1 *) LID
minimal(row_pattern) = (* 0 *)
minimal(row_entry) = (* 2 *) MINUS LID
minimal(row) = (* 0 *)
minimal(record_fields) = (* 1 *) LID
minimal(quantifiers) = (* 1 *) LID
minimal(quantifier) = (* 1 *) LID
minimal(program) = (* 3 *) PROG LID EOF
minimal(patterns) = (* 1 *) UID
minimal(pattern3) = (* 1 *) UID
minimal(pattern2) = (* 1 *) UID
minimal(pattern1) = (* 1 *) UID
minimal(pattern0s) = (* 0 *)
minimal(pattern0) = (* 1 *) LID
minimal(pattern) = (* 1 *) UID
minimal(opt_bar) = (* 0 *)
minimal(kind) = (* 1 *) STAR
minimal(formals) = (* 0 *)
minimal(formal) = (* 1 *) LID
minimal(forall) = (* 0 *)
minimal(expressions) = (* 1 *) LID
minimal(expression400) = (* 1 *) LID
minimal(expression300) = (* 1 *) LID
minimal(expression200) = (* 1 *) LID
minimal(expression100) = (* 1 *) LID
minimal(expression0) = (* 1 *) LID
minimal(expression) = (* 1 *) LID
minimal(equal_expression) = (* 2 *) EQUAL LID
minimal(declarations) = (* 0 *)
minimal(declaration) = (* 2 *) DATA LID
minimal(data_params) = (* 0 *)
minimal(data_cases) = (* 1 *) UID
minimal(data_case) = (* 1 *) UID
minimal(cases) = (* 3 *) UID ARROW LID
minimal(case) = (* 3 *) UID ARROW LID
minimal(bindings) = (* 0 *)
minimal(binding) = (* 4 *) TYPE LID EQUAL LID
minimal(actuals) = (* 0 *)
follow(value_definitions) = TYPE RBRACE LET IN AND
follow(value_definition) = TYPE RBRACE LET IN AND
follow(types) = RPAREN
follow(type_definitions) = TYPE RBRACE LET IN AND
follow(type_definition) = TYPE RBRACE LET IN AND
follow(type2) = VALUE TYPE RPAREN RBRACE PROG LET IN FIELD EQUAL DOT DATA COMMA COLONCOLON AND
follow(type1) = VALUE TYPE RPAREN RBRACE PROG LPAREN LID LET LBRACE LANGLE INT IN FIELD EQUAL DOT DATA COMMA COLONCOLON ARROW AND
follow(type0) = VALUE TYPE SEMI RPAREN RBRACE RANGLE PROG LPAREN LID LET LBRACE LANGLE INT IN FIELD EQUAL DOT DATA COMMA COLONCOLON BAR ARROW AND
follow(typ) = VALUE TYPE RPAREN RBRACE PROG LET IN FIELD EQUAL DOT DATA COMMA COLONCOLON AND
follow(scheme) = PROG FIELD DATA
follow(row_pattern) = RBRACE
follow(row_entry) = SEMI RANGLE
follow(row) = RANGLE
follow(record_fields) = FROM COMMA
follow(quantifiers) = LPAREN LID DOT
follow(quantifier) = LPAREN LID DOT
follow(program) = #
follow(patterns) = RPAREN
follow(pattern3) = VALUE RPAREN RBRACE DOT COMMA COLONCOLON
follow(pattern2) = VALUE RPAREN RBRACE DOT COMMA COLONCOLON ARROW
follow(pattern1) = VALUE RPAREN RBRACE DOT COMMA COLONCOLON ARROW
follow(pattern0s) = WILD VALUE RPAREN RBRACE LPAREN LID LBRACE INTEGER EXPORT DOT COMMA COLONCOLON ARROW
follow(pattern0) = WILD VALUE RPAREN RBRACE LPAREN LID LBRACE INTEGER EXPORT EQUAL DOT COMMA COLONCOLON ARROW
follow(pattern) = VALUE RPAREN RBRACE DOT COMMA
follow(opt_bar) = WILD UID LPAREN LID LBRACE INTEGER EXPORT
follow(kind) = RPAREN
follow(formals) = EQUAL
follow(formal) = LPAREN LID EQUAL DOT
follow(forall) = WILD LPAREN LID LBRACE LANGLE INTEGER INT EXPORT BACKSLASH
follow(expressions) = RPAREN
follow(expression400) = WITH TYPE RPAREN RBRACE LET IN EOF END COMMA COLONCOLON BAR AND
follow(expression300) = WITH TYPE SEMI RPAREN RBRACE LET IN EOF END COMMA COLONCOLON BAR AND
follow(expression200) = WITH TYPE SEMI RPAREN RBRACE PLUS MINUS LET INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END COMMA COLONCOLON BAR AND
follow(expression100) = WITH UID TYPE SEMI RPAREN RBRACE PLUS MINUS MATCH LPAREN LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END COMMA COLONCOLON BAR AND
follow(expression0) = WITH UID TYPE SEMI RPAREN RBRACE PLUS MINUS MATCH LPAREN LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END DOT COMMA COLONCOLON BAR AND
follow(expression) = WITH TYPE RPAREN RBRACE LET IN EOF END COMMA COLONCOLON BAR AND
follow(equal_expression) = TYPE RBRACE LET IN AND
follow(declarations) = PROG
follow(declaration) = PROG FIELD DATA
follow(data_params) = PROG FIELD DATA BAR
follow(data_cases) = PROG FIELD DATA BAR
follow(data_case) = PROG FIELD DATA BAR
follow(cases) = END BAR
follow(case) = END BAR
follow(bindings) = RBRACE
follow(binding) = TYPE RBRACE LET IN
follow(actuals) = SEMI RANGLE
Built an LR(0) automaton with 272 states.
The grammar is not SLR(1) -- 8 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 272 states.
64 shift/reduce conflicts were silently solved.
96 out of 272 states have a default reduction.
98 out of 272 states are represented.
0 out of 106 symbols keep track of their start position.
0 out of 106 symbols keep track of their end position.
62 out of 133 productions exploit shiftreduce optimization.
457 functions before inlining, 110 functions after inlining.
