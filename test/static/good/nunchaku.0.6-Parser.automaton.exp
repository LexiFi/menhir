State 0:
parse_statement' -> . parse_statement [ # ]
-- On error shift to state 1
-- On VAL shift to state 2
-- On SPEC shift to state 129
-- On REC shift to state 144
-- On PRED shift to state 154
-- On INCLUDE shift to state 170
-- On GOAL shift to state 173
-- On DATA shift to state 176
-- On COPY shift to state 198
-- On COPRED shift to state 215
-- On CODATA shift to state 219
-- On AXIOM shift to state 222
-- On statement shift to state 225
-- On parse_statement shift to state 227

State 1:
statement -> error . [ EOI ]
-- On EOI reduce production statement -> error

State 2:
statement -> VAL . raw_var COLON term decl_attributes DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 5

State 3:
raw_var -> UPPER_WORD . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT CONCRETE COLON AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production raw_var -> UPPER_WORD
-- On WILDCARD reduce production raw_var -> UPPER_WORD
-- On VERTICAL_BAR reduce production raw_var -> UPPER_WORD
-- On UPPER_WORD reduce production raw_var -> UPPER_WORD
-- On TYPE reduce production raw_var -> UPPER_WORD
-- On THEN reduce production raw_var -> UPPER_WORD
-- On SUBSET reduce production raw_var -> UPPER_WORD
-- On SEMI_COLON reduce production raw_var -> UPPER_WORD
-- On RIGHT_PAREN reduce production raw_var -> UPPER_WORD
-- On QUOTIENT reduce production raw_var -> UPPER_WORD
-- On PROP reduce production raw_var -> UPPER_WORD
-- On PARTIAL_QUOTIENT reduce production raw_var -> UPPER_WORD
-- On META_VAR reduce production raw_var -> UPPER_WORD
-- On MATCH reduce production raw_var -> UPPER_WORD
-- On LOWER_WORD reduce production raw_var -> UPPER_WORD
-- On LOGIC_TRUE reduce production raw_var -> UPPER_WORD
-- On LOGIC_OR reduce production raw_var -> UPPER_WORD
-- On LOGIC_NEQ reduce production raw_var -> UPPER_WORD
-- On LOGIC_IMPLY reduce production raw_var -> UPPER_WORD
-- On LOGIC_FALSE reduce production raw_var -> UPPER_WORD
-- On LOGIC_EQ reduce production raw_var -> UPPER_WORD
-- On LOGIC_AND reduce production raw_var -> UPPER_WORD
-- On LEFT_PAREN reduce production raw_var -> UPPER_WORD
-- On LEFT_BRACKET reduce production raw_var -> UPPER_WORD
-- On IN reduce production raw_var -> UPPER_WORD
-- On EQDEF reduce production raw_var -> UPPER_WORD
-- On EOI reduce production raw_var -> UPPER_WORD
-- On END reduce production raw_var -> UPPER_WORD
-- On ELSE reduce production raw_var -> UPPER_WORD
-- On DOT reduce production raw_var -> UPPER_WORD
-- On CONCRETE reduce production raw_var -> UPPER_WORD
-- On COLON reduce production raw_var -> UPPER_WORD
-- On AT reduce production raw_var -> UPPER_WORD
-- On ASSERTING reduce production raw_var -> UPPER_WORD
-- On ARROW reduce production raw_var -> UPPER_WORD
-- On AND reduce production raw_var -> UPPER_WORD
-- On ABSTRACT reduce production raw_var -> UPPER_WORD

State 4:
raw_var -> LOWER_WORD . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT CONCRETE COLON AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production raw_var -> LOWER_WORD
-- On WILDCARD reduce production raw_var -> LOWER_WORD
-- On VERTICAL_BAR reduce production raw_var -> LOWER_WORD
-- On UPPER_WORD reduce production raw_var -> LOWER_WORD
-- On TYPE reduce production raw_var -> LOWER_WORD
-- On THEN reduce production raw_var -> LOWER_WORD
-- On SUBSET reduce production raw_var -> LOWER_WORD
-- On SEMI_COLON reduce production raw_var -> LOWER_WORD
-- On RIGHT_PAREN reduce production raw_var -> LOWER_WORD
-- On QUOTIENT reduce production raw_var -> LOWER_WORD
-- On PROP reduce production raw_var -> LOWER_WORD
-- On PARTIAL_QUOTIENT reduce production raw_var -> LOWER_WORD
-- On META_VAR reduce production raw_var -> LOWER_WORD
-- On MATCH reduce production raw_var -> LOWER_WORD
-- On LOWER_WORD reduce production raw_var -> LOWER_WORD
-- On LOGIC_TRUE reduce production raw_var -> LOWER_WORD
-- On LOGIC_OR reduce production raw_var -> LOWER_WORD
-- On LOGIC_NEQ reduce production raw_var -> LOWER_WORD
-- On LOGIC_IMPLY reduce production raw_var -> LOWER_WORD
-- On LOGIC_FALSE reduce production raw_var -> LOWER_WORD
-- On LOGIC_EQ reduce production raw_var -> LOWER_WORD
-- On LOGIC_AND reduce production raw_var -> LOWER_WORD
-- On LEFT_PAREN reduce production raw_var -> LOWER_WORD
-- On LEFT_BRACKET reduce production raw_var -> LOWER_WORD
-- On IN reduce production raw_var -> LOWER_WORD
-- On EQDEF reduce production raw_var -> LOWER_WORD
-- On EOI reduce production raw_var -> LOWER_WORD
-- On END reduce production raw_var -> LOWER_WORD
-- On ELSE reduce production raw_var -> LOWER_WORD
-- On DOT reduce production raw_var -> LOWER_WORD
-- On CONCRETE reduce production raw_var -> LOWER_WORD
-- On COLON reduce production raw_var -> LOWER_WORD
-- On AT reduce production raw_var -> LOWER_WORD
-- On ASSERTING reduce production raw_var -> LOWER_WORD
-- On ARROW reduce production raw_var -> LOWER_WORD
-- On AND reduce production raw_var -> LOWER_WORD
-- On ABSTRACT reduce production raw_var -> LOWER_WORD

State 5:
statement -> VAL raw_var . COLON term decl_attributes DOT [ EOI ]
-- On COLON shift to state 6

State 6:
statement -> VAL raw_var COLON . term decl_attributes DOT [ EOI ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 115
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 7:
term -> error . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> error
-- On VERTICAL_BAR reduce production term -> error
-- On THEN reduce production term -> error
-- On SUBSET reduce production term -> error
-- On SEMI_COLON reduce production term -> error
-- On RIGHT_PAREN reduce production term -> error
-- On QUOTIENT reduce production term -> error
-- On PARTIAL_QUOTIENT reduce production term -> error
-- On LEFT_BRACKET reduce production term -> error
-- On IN reduce production term -> error
-- On EQDEF reduce production term -> error
-- On EOI reduce production term -> error
-- On END reduce production term -> error
-- On ELSE reduce production term -> error
-- On DOT reduce production term -> error
-- On AND reduce production term -> error
-- On ABSTRACT reduce production term -> error

State 8:
var -> WILDCARD . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production var -> WILDCARD
-- On WILDCARD reduce production var -> WILDCARD
-- On VERTICAL_BAR reduce production var -> WILDCARD
-- On UPPER_WORD reduce production var -> WILDCARD
-- On TYPE reduce production var -> WILDCARD
-- On THEN reduce production var -> WILDCARD
-- On SUBSET reduce production var -> WILDCARD
-- On SEMI_COLON reduce production var -> WILDCARD
-- On RIGHT_PAREN reduce production var -> WILDCARD
-- On QUOTIENT reduce production var -> WILDCARD
-- On PROP reduce production var -> WILDCARD
-- On PARTIAL_QUOTIENT reduce production var -> WILDCARD
-- On META_VAR reduce production var -> WILDCARD
-- On MATCH reduce production var -> WILDCARD
-- On LOWER_WORD reduce production var -> WILDCARD
-- On LOGIC_TRUE reduce production var -> WILDCARD
-- On LOGIC_OR reduce production var -> WILDCARD
-- On LOGIC_NEQ reduce production var -> WILDCARD
-- On LOGIC_IMPLY reduce production var -> WILDCARD
-- On LOGIC_FALSE reduce production var -> WILDCARD
-- On LOGIC_EQ reduce production var -> WILDCARD
-- On LOGIC_AND reduce production var -> WILDCARD
-- On LEFT_PAREN reduce production var -> WILDCARD
-- On LEFT_BRACKET reduce production var -> WILDCARD
-- On IN reduce production var -> WILDCARD
-- On EQDEF reduce production var -> WILDCARD
-- On EOI reduce production var -> WILDCARD
-- On END reduce production var -> WILDCARD
-- On ELSE reduce production var -> WILDCARD
-- On DOT reduce production var -> WILDCARD
-- On AT reduce production var -> WILDCARD
-- On ASSERTING reduce production var -> WILDCARD
-- On ARROW reduce production var -> WILDCARD
-- On AND reduce production var -> WILDCARD
-- On ABSTRACT reduce production var -> WILDCARD

State 9:
const -> TYPE . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production const -> TYPE
-- On WILDCARD reduce production const -> TYPE
-- On VERTICAL_BAR reduce production const -> TYPE
-- On UPPER_WORD reduce production const -> TYPE
-- On TYPE reduce production const -> TYPE
-- On THEN reduce production const -> TYPE
-- On SUBSET reduce production const -> TYPE
-- On SEMI_COLON reduce production const -> TYPE
-- On RIGHT_PAREN reduce production const -> TYPE
-- On QUOTIENT reduce production const -> TYPE
-- On PROP reduce production const -> TYPE
-- On PARTIAL_QUOTIENT reduce production const -> TYPE
-- On META_VAR reduce production const -> TYPE
-- On MATCH reduce production const -> TYPE
-- On LOWER_WORD reduce production const -> TYPE
-- On LOGIC_TRUE reduce production const -> TYPE
-- On LOGIC_OR reduce production const -> TYPE
-- On LOGIC_NEQ reduce production const -> TYPE
-- On LOGIC_IMPLY reduce production const -> TYPE
-- On LOGIC_FALSE reduce production const -> TYPE
-- On LOGIC_EQ reduce production const -> TYPE
-- On LOGIC_AND reduce production const -> TYPE
-- On LEFT_PAREN reduce production const -> TYPE
-- On LEFT_BRACKET reduce production const -> TYPE
-- On IN reduce production const -> TYPE
-- On EQDEF reduce production const -> TYPE
-- On EOI reduce production const -> TYPE
-- On END reduce production const -> TYPE
-- On ELSE reduce production const -> TYPE
-- On DOT reduce production const -> TYPE
-- On AT reduce production const -> TYPE
-- On ASSERTING reduce production const -> TYPE
-- On ARROW reduce production const -> TYPE
-- On AND reduce production const -> TYPE
-- On ABSTRACT reduce production const -> TYPE

State 10:
const -> PROP . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production const -> PROP
-- On WILDCARD reduce production const -> PROP
-- On VERTICAL_BAR reduce production const -> PROP
-- On UPPER_WORD reduce production const -> PROP
-- On TYPE reduce production const -> PROP
-- On THEN reduce production const -> PROP
-- On SUBSET reduce production const -> PROP
-- On SEMI_COLON reduce production const -> PROP
-- On RIGHT_PAREN reduce production const -> PROP
-- On QUOTIENT reduce production const -> PROP
-- On PROP reduce production const -> PROP
-- On PARTIAL_QUOTIENT reduce production const -> PROP
-- On META_VAR reduce production const -> PROP
-- On MATCH reduce production const -> PROP
-- On LOWER_WORD reduce production const -> PROP
-- On LOGIC_TRUE reduce production const -> PROP
-- On LOGIC_OR reduce production const -> PROP
-- On LOGIC_NEQ reduce production const -> PROP
-- On LOGIC_IMPLY reduce production const -> PROP
-- On LOGIC_FALSE reduce production const -> PROP
-- On LOGIC_EQ reduce production const -> PROP
-- On LOGIC_AND reduce production const -> PROP
-- On LEFT_PAREN reduce production const -> PROP
-- On LEFT_BRACKET reduce production const -> PROP
-- On IN reduce production const -> PROP
-- On EQDEF reduce production const -> PROP
-- On EOI reduce production const -> PROP
-- On END reduce production const -> PROP
-- On ELSE reduce production const -> PROP
-- On DOT reduce production const -> PROP
-- On AT reduce production const -> PROP
-- On ASSERTING reduce production const -> PROP
-- On ARROW reduce production const -> PROP
-- On AND reduce production const -> PROP
-- On ABSTRACT reduce production const -> PROP

State 11:
term -> PI . nonempty_list(typed_ty_var) DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 12
-- On typed_ty_var shift to state 17
-- On raw_var shift to state 18
-- On nonempty_list(typed_ty_var) shift to state 22

State 12:
typed_ty_var -> LEFT_PAREN . raw_var COLON TYPE RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 13

State 13:
typed_ty_var -> LEFT_PAREN raw_var . COLON TYPE RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 14

State 14:
typed_ty_var -> LEFT_PAREN raw_var COLON . TYPE RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On TYPE shift to state 15

State 15:
typed_ty_var -> LEFT_PAREN raw_var COLON TYPE . RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On RIGHT_PAREN shift to state 16

State 16:
typed_ty_var -> LEFT_PAREN raw_var COLON TYPE RIGHT_PAREN . [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_ty_var -> LEFT_PAREN raw_var COLON TYPE RIGHT_PAREN
-- On LOWER_WORD reduce production typed_ty_var -> LEFT_PAREN raw_var COLON TYPE RIGHT_PAREN
-- On LEFT_PAREN reduce production typed_ty_var -> LEFT_PAREN raw_var COLON TYPE RIGHT_PAREN
-- On DOT reduce production typed_ty_var -> LEFT_PAREN raw_var COLON TYPE RIGHT_PAREN

State 17:
nonempty_list(typed_ty_var) -> typed_ty_var . [ DOT ]
nonempty_list(typed_ty_var) -> typed_ty_var . nonempty_list(typed_ty_var) [ DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 12
-- On typed_ty_var shift to state 17
-- On raw_var shift to state 18
-- On nonempty_list(typed_ty_var) shift to state 21
-- On DOT reduce production nonempty_list(typed_ty_var) -> typed_ty_var

State 18:
typed_ty_var -> raw_var . [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
typed_ty_var -> raw_var . COLON TYPE [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 19
-- On UPPER_WORD reduce production typed_ty_var -> raw_var
-- On LOWER_WORD reduce production typed_ty_var -> raw_var
-- On LEFT_PAREN reduce production typed_ty_var -> raw_var
-- On DOT reduce production typed_ty_var -> raw_var

State 19:
typed_ty_var -> raw_var COLON . TYPE [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On TYPE shift to state 20

State 20:
typed_ty_var -> raw_var COLON TYPE . [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_ty_var -> raw_var COLON TYPE
-- On LOWER_WORD reduce production typed_ty_var -> raw_var COLON TYPE
-- On LEFT_PAREN reduce production typed_ty_var -> raw_var COLON TYPE
-- On DOT reduce production typed_ty_var -> raw_var COLON TYPE

State 21:
nonempty_list(typed_ty_var) -> typed_ty_var nonempty_list(typed_ty_var) . [ DOT ]
-- On DOT reduce production nonempty_list(typed_ty_var) -> typed_ty_var nonempty_list(typed_ty_var)

State 22:
term -> PI nonempty_list(typed_ty_var) . DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On DOT shift to state 23

State 23:
term -> PI nonempty_list(typed_ty_var) DOT . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 114
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 24:
meta_var -> META_VAR . raw_var [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 25

State 25:
meta_var -> META_VAR raw_var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production meta_var -> META_VAR raw_var
-- On WILDCARD reduce production meta_var -> META_VAR raw_var
-- On VERTICAL_BAR reduce production meta_var -> META_VAR raw_var
-- On UPPER_WORD reduce production meta_var -> META_VAR raw_var
-- On TYPE reduce production meta_var -> META_VAR raw_var
-- On THEN reduce production meta_var -> META_VAR raw_var
-- On SUBSET reduce production meta_var -> META_VAR raw_var
-- On SEMI_COLON reduce production meta_var -> META_VAR raw_var
-- On RIGHT_PAREN reduce production meta_var -> META_VAR raw_var
-- On QUOTIENT reduce production meta_var -> META_VAR raw_var
-- On PROP reduce production meta_var -> META_VAR raw_var
-- On PARTIAL_QUOTIENT reduce production meta_var -> META_VAR raw_var
-- On META_VAR reduce production meta_var -> META_VAR raw_var
-- On MATCH reduce production meta_var -> META_VAR raw_var
-- On LOWER_WORD reduce production meta_var -> META_VAR raw_var
-- On LOGIC_TRUE reduce production meta_var -> META_VAR raw_var
-- On LOGIC_OR reduce production meta_var -> META_VAR raw_var
-- On LOGIC_NEQ reduce production meta_var -> META_VAR raw_var
-- On LOGIC_IMPLY reduce production meta_var -> META_VAR raw_var
-- On LOGIC_FALSE reduce production meta_var -> META_VAR raw_var
-- On LOGIC_EQ reduce production meta_var -> META_VAR raw_var
-- On LOGIC_AND reduce production meta_var -> META_VAR raw_var
-- On LEFT_PAREN reduce production meta_var -> META_VAR raw_var
-- On LEFT_BRACKET reduce production meta_var -> META_VAR raw_var
-- On IN reduce production meta_var -> META_VAR raw_var
-- On EQDEF reduce production meta_var -> META_VAR raw_var
-- On EOI reduce production meta_var -> META_VAR raw_var
-- On END reduce production meta_var -> META_VAR raw_var
-- On ELSE reduce production meta_var -> META_VAR raw_var
-- On DOT reduce production meta_var -> META_VAR raw_var
-- On AT reduce production meta_var -> META_VAR raw_var
-- On ASSERTING reduce production meta_var -> META_VAR raw_var
-- On ARROW reduce production meta_var -> META_VAR raw_var
-- On AND reduce production meta_var -> META_VAR raw_var
-- On ABSTRACT reduce production meta_var -> META_VAR raw_var

State 26:
atomic_term -> MATCH . term WITH cases(term) END [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 96
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 27:
const -> LOGIC_TRUE . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production const -> LOGIC_TRUE
-- On WILDCARD reduce production const -> LOGIC_TRUE
-- On VERTICAL_BAR reduce production const -> LOGIC_TRUE
-- On UPPER_WORD reduce production const -> LOGIC_TRUE
-- On TYPE reduce production const -> LOGIC_TRUE
-- On THEN reduce production const -> LOGIC_TRUE
-- On SUBSET reduce production const -> LOGIC_TRUE
-- On SEMI_COLON reduce production const -> LOGIC_TRUE
-- On RIGHT_PAREN reduce production const -> LOGIC_TRUE
-- On QUOTIENT reduce production const -> LOGIC_TRUE
-- On PROP reduce production const -> LOGIC_TRUE
-- On PARTIAL_QUOTIENT reduce production const -> LOGIC_TRUE
-- On META_VAR reduce production const -> LOGIC_TRUE
-- On MATCH reduce production const -> LOGIC_TRUE
-- On LOWER_WORD reduce production const -> LOGIC_TRUE
-- On LOGIC_TRUE reduce production const -> LOGIC_TRUE
-- On LOGIC_OR reduce production const -> LOGIC_TRUE
-- On LOGIC_NEQ reduce production const -> LOGIC_TRUE
-- On LOGIC_IMPLY reduce production const -> LOGIC_TRUE
-- On LOGIC_FALSE reduce production const -> LOGIC_TRUE
-- On LOGIC_EQ reduce production const -> LOGIC_TRUE
-- On LOGIC_AND reduce production const -> LOGIC_TRUE
-- On LEFT_PAREN reduce production const -> LOGIC_TRUE
-- On LEFT_BRACKET reduce production const -> LOGIC_TRUE
-- On IN reduce production const -> LOGIC_TRUE
-- On EQDEF reduce production const -> LOGIC_TRUE
-- On EOI reduce production const -> LOGIC_TRUE
-- On END reduce production const -> LOGIC_TRUE
-- On ELSE reduce production const -> LOGIC_TRUE
-- On DOT reduce production const -> LOGIC_TRUE
-- On AT reduce production const -> LOGIC_TRUE
-- On ASSERTING reduce production const -> LOGIC_TRUE
-- On ARROW reduce production const -> LOGIC_TRUE
-- On AND reduce production const -> LOGIC_TRUE
-- On ABSTRACT reduce production const -> LOGIC_TRUE

State 28:
apply_term -> LOGIC_NOT . apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 95

State 29:
const -> LOGIC_FALSE . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production const -> LOGIC_FALSE
-- On WILDCARD reduce production const -> LOGIC_FALSE
-- On VERTICAL_BAR reduce production const -> LOGIC_FALSE
-- On UPPER_WORD reduce production const -> LOGIC_FALSE
-- On TYPE reduce production const -> LOGIC_FALSE
-- On THEN reduce production const -> LOGIC_FALSE
-- On SUBSET reduce production const -> LOGIC_FALSE
-- On SEMI_COLON reduce production const -> LOGIC_FALSE
-- On RIGHT_PAREN reduce production const -> LOGIC_FALSE
-- On QUOTIENT reduce production const -> LOGIC_FALSE
-- On PROP reduce production const -> LOGIC_FALSE
-- On PARTIAL_QUOTIENT reduce production const -> LOGIC_FALSE
-- On META_VAR reduce production const -> LOGIC_FALSE
-- On MATCH reduce production const -> LOGIC_FALSE
-- On LOWER_WORD reduce production const -> LOGIC_FALSE
-- On LOGIC_TRUE reduce production const -> LOGIC_FALSE
-- On LOGIC_OR reduce production const -> LOGIC_FALSE
-- On LOGIC_NEQ reduce production const -> LOGIC_FALSE
-- On LOGIC_IMPLY reduce production const -> LOGIC_FALSE
-- On LOGIC_FALSE reduce production const -> LOGIC_FALSE
-- On LOGIC_EQ reduce production const -> LOGIC_FALSE
-- On LOGIC_AND reduce production const -> LOGIC_FALSE
-- On LEFT_PAREN reduce production const -> LOGIC_FALSE
-- On LEFT_BRACKET reduce production const -> LOGIC_FALSE
-- On IN reduce production const -> LOGIC_FALSE
-- On EQDEF reduce production const -> LOGIC_FALSE
-- On EOI reduce production const -> LOGIC_FALSE
-- On END reduce production const -> LOGIC_FALSE
-- On ELSE reduce production const -> LOGIC_FALSE
-- On DOT reduce production const -> LOGIC_FALSE
-- On AT reduce production const -> LOGIC_FALSE
-- On ASSERTING reduce production const -> LOGIC_FALSE
-- On ARROW reduce production const -> LOGIC_FALSE
-- On AND reduce production const -> LOGIC_FALSE
-- On ABSTRACT reduce production const -> LOGIC_FALSE

State 30:
atomic_term -> LEFT_PAREN . term RIGHT_PAREN [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 93
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 31:
term -> LOGIC_FORALL . nonempty_list(typed_var) DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 32
-- On typed_var shift to state 36
-- On raw_var shift to state 37
-- On nonempty_list(typed_var) shift to state 90

State 32:
typed_var -> LEFT_PAREN . raw_var COLON term RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 33

State 33:
typed_var -> LEFT_PAREN raw_var . COLON term RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On COLON shift to state 34

State 34:
typed_var -> LEFT_PAREN raw_var COLON . term RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 88
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 35:
term -> LOGIC_EXISTS . nonempty_list(typed_var) DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 32
-- On typed_var shift to state 36
-- On raw_var shift to state 37
-- On nonempty_list(typed_var) shift to state 39

State 36:
nonempty_list(typed_var) -> typed_var . [ DOT ]
nonempty_list(typed_var) -> typed_var . nonempty_list(typed_var) [ DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 32
-- On typed_var shift to state 36
-- On raw_var shift to state 37
-- On nonempty_list(typed_var) shift to state 38
-- On DOT reduce production nonempty_list(typed_var) -> typed_var

State 37:
typed_var -> raw_var . [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_var -> raw_var
-- On LOWER_WORD reduce production typed_var -> raw_var
-- On LEFT_PAREN reduce production typed_var -> raw_var
-- On DOT reduce production typed_var -> raw_var

State 38:
nonempty_list(typed_var) -> typed_var nonempty_list(typed_var) . [ DOT ]
-- On DOT reduce production nonempty_list(typed_var) -> typed_var nonempty_list(typed_var)

State 39:
term -> LOGIC_EXISTS nonempty_list(typed_var) . DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On DOT shift to state 40

State 40:
term -> LOGIC_EXISTS nonempty_list(typed_var) DOT . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 87
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 41:
term -> LET . raw_var EQDEF term IN term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 42

State 42:
term -> LET raw_var . EQDEF term IN term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On EQDEF shift to state 43

State 43:
term -> LET raw_var EQDEF . term IN term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 84
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 44:
term -> IF . term THEN term ELSE term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 79
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 45:
term -> FUN . nonempty_list(typed_var) DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On LEFT_PAREN shift to state 32
-- On typed_var shift to state 36
-- On raw_var shift to state 37
-- On nonempty_list(typed_var) shift to state 46

State 46:
term -> FUN nonempty_list(typed_var) . DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On DOT shift to state 47

State 47:
term -> FUN nonempty_list(typed_var) DOT . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 51
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 48:
at_var -> AT . raw_var [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 49

State 49:
at_var -> AT raw_var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production at_var -> AT raw_var
-- On WILDCARD reduce production at_var -> AT raw_var
-- On VERTICAL_BAR reduce production at_var -> AT raw_var
-- On UPPER_WORD reduce production at_var -> AT raw_var
-- On TYPE reduce production at_var -> AT raw_var
-- On THEN reduce production at_var -> AT raw_var
-- On SUBSET reduce production at_var -> AT raw_var
-- On SEMI_COLON reduce production at_var -> AT raw_var
-- On RIGHT_PAREN reduce production at_var -> AT raw_var
-- On QUOTIENT reduce production at_var -> AT raw_var
-- On PROP reduce production at_var -> AT raw_var
-- On PARTIAL_QUOTIENT reduce production at_var -> AT raw_var
-- On META_VAR reduce production at_var -> AT raw_var
-- On MATCH reduce production at_var -> AT raw_var
-- On LOWER_WORD reduce production at_var -> AT raw_var
-- On LOGIC_TRUE reduce production at_var -> AT raw_var
-- On LOGIC_OR reduce production at_var -> AT raw_var
-- On LOGIC_NEQ reduce production at_var -> AT raw_var
-- On LOGIC_IMPLY reduce production at_var -> AT raw_var
-- On LOGIC_FALSE reduce production at_var -> AT raw_var
-- On LOGIC_EQ reduce production at_var -> AT raw_var
-- On LOGIC_AND reduce production at_var -> AT raw_var
-- On LEFT_PAREN reduce production at_var -> AT raw_var
-- On LEFT_BRACKET reduce production at_var -> AT raw_var
-- On IN reduce production at_var -> AT raw_var
-- On EQDEF reduce production at_var -> AT raw_var
-- On EOI reduce production at_var -> AT raw_var
-- On END reduce production at_var -> AT raw_var
-- On ELSE reduce production at_var -> AT raw_var
-- On DOT reduce production at_var -> AT raw_var
-- On AT reduce production at_var -> AT raw_var
-- On ASSERTING reduce production at_var -> AT raw_var
-- On ARROW reduce production at_var -> AT raw_var
-- On AND reduce production at_var -> AT raw_var
-- On ABSTRACT reduce production at_var -> AT raw_var

State 50:
atomic_term -> var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> var
-- On WILDCARD reduce production atomic_term -> var
-- On VERTICAL_BAR reduce production atomic_term -> var
-- On UPPER_WORD reduce production atomic_term -> var
-- On TYPE reduce production atomic_term -> var
-- On THEN reduce production atomic_term -> var
-- On SUBSET reduce production atomic_term -> var
-- On SEMI_COLON reduce production atomic_term -> var
-- On RIGHT_PAREN reduce production atomic_term -> var
-- On QUOTIENT reduce production atomic_term -> var
-- On PROP reduce production atomic_term -> var
-- On PARTIAL_QUOTIENT reduce production atomic_term -> var
-- On META_VAR reduce production atomic_term -> var
-- On MATCH reduce production atomic_term -> var
-- On LOWER_WORD reduce production atomic_term -> var
-- On LOGIC_TRUE reduce production atomic_term -> var
-- On LOGIC_OR reduce production atomic_term -> var
-- On LOGIC_NEQ reduce production atomic_term -> var
-- On LOGIC_IMPLY reduce production atomic_term -> var
-- On LOGIC_FALSE reduce production atomic_term -> var
-- On LOGIC_EQ reduce production atomic_term -> var
-- On LOGIC_AND reduce production atomic_term -> var
-- On LEFT_PAREN reduce production atomic_term -> var
-- On LEFT_BRACKET reduce production atomic_term -> var
-- On IN reduce production atomic_term -> var
-- On EQDEF reduce production atomic_term -> var
-- On EOI reduce production atomic_term -> var
-- On END reduce production atomic_term -> var
-- On ELSE reduce production atomic_term -> var
-- On DOT reduce production atomic_term -> var
-- On AT reduce production atomic_term -> var
-- On ASSERTING reduce production atomic_term -> var
-- On ARROW reduce production atomic_term -> var
-- On AND reduce production atomic_term -> var
-- On ABSTRACT reduce production atomic_term -> var

State 51:
term -> FUN nonempty_list(typed_var) DOT term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On VERTICAL_BAR reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On THEN reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On SUBSET reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On SEMI_COLON reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On RIGHT_PAREN reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On QUOTIENT reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On PARTIAL_QUOTIENT reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On LEFT_BRACKET reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On IN reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On EQDEF reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On EOI reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On END reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On ELSE reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On DOT reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On AND reduce production term -> FUN nonempty_list(typed_var) DOT term
-- On ABSTRACT reduce production term -> FUN nonempty_list(typed_var) DOT term

State 52:
var -> raw_var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production var -> raw_var
-- On WILDCARD reduce production var -> raw_var
-- On VERTICAL_BAR reduce production var -> raw_var
-- On UPPER_WORD reduce production var -> raw_var
-- On TYPE reduce production var -> raw_var
-- On THEN reduce production var -> raw_var
-- On SUBSET reduce production var -> raw_var
-- On SEMI_COLON reduce production var -> raw_var
-- On RIGHT_PAREN reduce production var -> raw_var
-- On QUOTIENT reduce production var -> raw_var
-- On PROP reduce production var -> raw_var
-- On PARTIAL_QUOTIENT reduce production var -> raw_var
-- On META_VAR reduce production var -> raw_var
-- On MATCH reduce production var -> raw_var
-- On LOWER_WORD reduce production var -> raw_var
-- On LOGIC_TRUE reduce production var -> raw_var
-- On LOGIC_OR reduce production var -> raw_var
-- On LOGIC_NEQ reduce production var -> raw_var
-- On LOGIC_IMPLY reduce production var -> raw_var
-- On LOGIC_FALSE reduce production var -> raw_var
-- On LOGIC_EQ reduce production var -> raw_var
-- On LOGIC_AND reduce production var -> raw_var
-- On LEFT_PAREN reduce production var -> raw_var
-- On LEFT_BRACKET reduce production var -> raw_var
-- On IN reduce production var -> raw_var
-- On EQDEF reduce production var -> raw_var
-- On EOI reduce production var -> raw_var
-- On END reduce production var -> raw_var
-- On ELSE reduce production var -> raw_var
-- On DOT reduce production var -> raw_var
-- On AT reduce production var -> raw_var
-- On ASSERTING reduce production var -> raw_var
-- On ARROW reduce production var -> raw_var
-- On AND reduce production var -> raw_var
-- On ABSTRACT reduce production var -> raw_var

State 53:
term -> or_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> or_term
-- On VERTICAL_BAR reduce production term -> or_term
-- On THEN reduce production term -> or_term
-- On SUBSET reduce production term -> or_term
-- On SEMI_COLON reduce production term -> or_term
-- On RIGHT_PAREN reduce production term -> or_term
-- On QUOTIENT reduce production term -> or_term
-- On PARTIAL_QUOTIENT reduce production term -> or_term
-- On LEFT_BRACKET reduce production term -> or_term
-- On IN reduce production term -> or_term
-- On EQDEF reduce production term -> or_term
-- On EOI reduce production term -> or_term
-- On END reduce production term -> or_term
-- On ELSE reduce production term -> or_term
-- On DOT reduce production term -> or_term
-- On AND reduce production term -> or_term
-- On ABSTRACT reduce production term -> or_term

State 54:
atomic_term -> meta_var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> meta_var
-- On WILDCARD reduce production atomic_term -> meta_var
-- On VERTICAL_BAR reduce production atomic_term -> meta_var
-- On UPPER_WORD reduce production atomic_term -> meta_var
-- On TYPE reduce production atomic_term -> meta_var
-- On THEN reduce production atomic_term -> meta_var
-- On SUBSET reduce production atomic_term -> meta_var
-- On SEMI_COLON reduce production atomic_term -> meta_var
-- On RIGHT_PAREN reduce production atomic_term -> meta_var
-- On QUOTIENT reduce production atomic_term -> meta_var
-- On PROP reduce production atomic_term -> meta_var
-- On PARTIAL_QUOTIENT reduce production atomic_term -> meta_var
-- On META_VAR reduce production atomic_term -> meta_var
-- On MATCH reduce production atomic_term -> meta_var
-- On LOWER_WORD reduce production atomic_term -> meta_var
-- On LOGIC_TRUE reduce production atomic_term -> meta_var
-- On LOGIC_OR reduce production atomic_term -> meta_var
-- On LOGIC_NEQ reduce production atomic_term -> meta_var
-- On LOGIC_IMPLY reduce production atomic_term -> meta_var
-- On LOGIC_FALSE reduce production atomic_term -> meta_var
-- On LOGIC_EQ reduce production atomic_term -> meta_var
-- On LOGIC_AND reduce production atomic_term -> meta_var
-- On LEFT_PAREN reduce production atomic_term -> meta_var
-- On LEFT_BRACKET reduce production atomic_term -> meta_var
-- On IN reduce production atomic_term -> meta_var
-- On EQDEF reduce production atomic_term -> meta_var
-- On EOI reduce production atomic_term -> meta_var
-- On END reduce production atomic_term -> meta_var
-- On ELSE reduce production atomic_term -> meta_var
-- On DOT reduce production atomic_term -> meta_var
-- On AT reduce production atomic_term -> meta_var
-- On ASSERTING reduce production atomic_term -> meta_var
-- On ARROW reduce production atomic_term -> meta_var
-- On AND reduce production atomic_term -> meta_var
-- On ABSTRACT reduce production atomic_term -> meta_var

State 55:
and_term -> eq_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
and_term -> eq_term . LOGIC_AND and_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On LOGIC_AND shift to state 56
-- On WITH reduce production and_term -> eq_term
-- On VERTICAL_BAR reduce production and_term -> eq_term
-- On THEN reduce production and_term -> eq_term
-- On SUBSET reduce production and_term -> eq_term
-- On SEMI_COLON reduce production and_term -> eq_term
-- On RIGHT_PAREN reduce production and_term -> eq_term
-- On QUOTIENT reduce production and_term -> eq_term
-- On PARTIAL_QUOTIENT reduce production and_term -> eq_term
-- On LOGIC_OR reduce production and_term -> eq_term
-- On LOGIC_IMPLY reduce production and_term -> eq_term
-- On LEFT_BRACKET reduce production and_term -> eq_term
-- On IN reduce production and_term -> eq_term
-- On EQDEF reduce production and_term -> eq_term
-- On EOI reduce production and_term -> eq_term
-- On END reduce production and_term -> eq_term
-- On ELSE reduce production and_term -> eq_term
-- On DOT reduce production and_term -> eq_term
-- On AND reduce production and_term -> eq_term
-- On ABSTRACT reduce production and_term -> eq_term

State 56:
and_term -> eq_term LOGIC_AND . and_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 63
-- On and_term shift to state 68

State 57:
atomic_term -> const . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> const
-- On WILDCARD reduce production atomic_term -> const
-- On VERTICAL_BAR reduce production atomic_term -> const
-- On UPPER_WORD reduce production atomic_term -> const
-- On TYPE reduce production atomic_term -> const
-- On THEN reduce production atomic_term -> const
-- On SUBSET reduce production atomic_term -> const
-- On SEMI_COLON reduce production atomic_term -> const
-- On RIGHT_PAREN reduce production atomic_term -> const
-- On QUOTIENT reduce production atomic_term -> const
-- On PROP reduce production atomic_term -> const
-- On PARTIAL_QUOTIENT reduce production atomic_term -> const
-- On META_VAR reduce production atomic_term -> const
-- On MATCH reduce production atomic_term -> const
-- On LOWER_WORD reduce production atomic_term -> const
-- On LOGIC_TRUE reduce production atomic_term -> const
-- On LOGIC_OR reduce production atomic_term -> const
-- On LOGIC_NEQ reduce production atomic_term -> const
-- On LOGIC_IMPLY reduce production atomic_term -> const
-- On LOGIC_FALSE reduce production atomic_term -> const
-- On LOGIC_EQ reduce production atomic_term -> const
-- On LOGIC_AND reduce production atomic_term -> const
-- On LEFT_PAREN reduce production atomic_term -> const
-- On LEFT_BRACKET reduce production atomic_term -> const
-- On IN reduce production atomic_term -> const
-- On EQDEF reduce production atomic_term -> const
-- On EOI reduce production atomic_term -> const
-- On END reduce production atomic_term -> const
-- On ELSE reduce production atomic_term -> const
-- On DOT reduce production atomic_term -> const
-- On AT reduce production atomic_term -> const
-- On ASSERTING reduce production atomic_term -> const
-- On ARROW reduce production atomic_term -> const
-- On AND reduce production atomic_term -> const
-- On ABSTRACT reduce production atomic_term -> const

State 58:
apply_term -> atomic_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
apply_term -> atomic_term . nonempty_list(atomic_term) [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On nonempty_list(atomic_term) shift to state 59
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 60
-- On at_var shift to state 62
-- On WITH reduce production apply_term -> atomic_term
-- On VERTICAL_BAR reduce production apply_term -> atomic_term
-- On THEN reduce production apply_term -> atomic_term
-- On SUBSET reduce production apply_term -> atomic_term
-- On SEMI_COLON reduce production apply_term -> atomic_term
-- On RIGHT_PAREN reduce production apply_term -> atomic_term
-- On QUOTIENT reduce production apply_term -> atomic_term
-- On PARTIAL_QUOTIENT reduce production apply_term -> atomic_term
-- On LOGIC_OR reduce production apply_term -> atomic_term
-- On LOGIC_NEQ reduce production apply_term -> atomic_term
-- On LOGIC_IMPLY reduce production apply_term -> atomic_term
-- On LOGIC_EQ reduce production apply_term -> atomic_term
-- On LOGIC_AND reduce production apply_term -> atomic_term
-- On LEFT_BRACKET reduce production apply_term -> atomic_term
-- On IN reduce production apply_term -> atomic_term
-- On EQDEF reduce production apply_term -> atomic_term
-- On EOI reduce production apply_term -> atomic_term
-- On END reduce production apply_term -> atomic_term
-- On ELSE reduce production apply_term -> atomic_term
-- On DOT reduce production apply_term -> atomic_term
-- On ASSERTING reduce production apply_term -> atomic_term
-- On ARROW reduce production apply_term -> atomic_term
-- On AND reduce production apply_term -> atomic_term
-- On ABSTRACT reduce production apply_term -> atomic_term

State 59:
apply_term -> atomic_term nonempty_list(atomic_term) . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On VERTICAL_BAR reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On THEN reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On SUBSET reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On SEMI_COLON reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On RIGHT_PAREN reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On QUOTIENT reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On PARTIAL_QUOTIENT reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_OR reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_NEQ reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_IMPLY reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_EQ reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_AND reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On LEFT_BRACKET reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On IN reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On EQDEF reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On EOI reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On END reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On ELSE reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On DOT reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On ASSERTING reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On ARROW reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On AND reduce production apply_term -> atomic_term nonempty_list(atomic_term)
-- On ABSTRACT reduce production apply_term -> atomic_term nonempty_list(atomic_term)

State 60:
nonempty_list(atomic_term) -> atomic_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
nonempty_list(atomic_term) -> atomic_term . nonempty_list(atomic_term) [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On nonempty_list(atomic_term) shift to state 61
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 60
-- On at_var shift to state 62
-- On WITH reduce production nonempty_list(atomic_term) -> atomic_term
-- On VERTICAL_BAR reduce production nonempty_list(atomic_term) -> atomic_term
-- On THEN reduce production nonempty_list(atomic_term) -> atomic_term
-- On SUBSET reduce production nonempty_list(atomic_term) -> atomic_term
-- On SEMI_COLON reduce production nonempty_list(atomic_term) -> atomic_term
-- On RIGHT_PAREN reduce production nonempty_list(atomic_term) -> atomic_term
-- On QUOTIENT reduce production nonempty_list(atomic_term) -> atomic_term
-- On PARTIAL_QUOTIENT reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_OR reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_NEQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_IMPLY reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_EQ reduce production nonempty_list(atomic_term) -> atomic_term
-- On LOGIC_AND reduce production nonempty_list(atomic_term) -> atomic_term
-- On LEFT_BRACKET reduce production nonempty_list(atomic_term) -> atomic_term
-- On IN reduce production nonempty_list(atomic_term) -> atomic_term
-- On EQDEF reduce production nonempty_list(atomic_term) -> atomic_term
-- On EOI reduce production nonempty_list(atomic_term) -> atomic_term
-- On END reduce production nonempty_list(atomic_term) -> atomic_term
-- On ELSE reduce production nonempty_list(atomic_term) -> atomic_term
-- On DOT reduce production nonempty_list(atomic_term) -> atomic_term
-- On ASSERTING reduce production nonempty_list(atomic_term) -> atomic_term
-- On ARROW reduce production nonempty_list(atomic_term) -> atomic_term
-- On AND reduce production nonempty_list(atomic_term) -> atomic_term
-- On ABSTRACT reduce production nonempty_list(atomic_term) -> atomic_term

State 61:
nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term) . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On VERTICAL_BAR reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On THEN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On SUBSET reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On SEMI_COLON reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On RIGHT_PAREN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On QUOTIENT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On PARTIAL_QUOTIENT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_OR reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_NEQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_IMPLY reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_EQ reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LOGIC_AND reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On LEFT_BRACKET reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On IN reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On EQDEF reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On EOI reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On END reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On ELSE reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On DOT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On ASSERTING reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On ARROW reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On AND reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)
-- On ABSTRACT reduce production nonempty_list(atomic_term) -> atomic_term nonempty_list(atomic_term)

State 62:
atomic_term -> at_var . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> at_var
-- On WILDCARD reduce production atomic_term -> at_var
-- On VERTICAL_BAR reduce production atomic_term -> at_var
-- On UPPER_WORD reduce production atomic_term -> at_var
-- On TYPE reduce production atomic_term -> at_var
-- On THEN reduce production atomic_term -> at_var
-- On SUBSET reduce production atomic_term -> at_var
-- On SEMI_COLON reduce production atomic_term -> at_var
-- On RIGHT_PAREN reduce production atomic_term -> at_var
-- On QUOTIENT reduce production atomic_term -> at_var
-- On PROP reduce production atomic_term -> at_var
-- On PARTIAL_QUOTIENT reduce production atomic_term -> at_var
-- On META_VAR reduce production atomic_term -> at_var
-- On MATCH reduce production atomic_term -> at_var
-- On LOWER_WORD reduce production atomic_term -> at_var
-- On LOGIC_TRUE reduce production atomic_term -> at_var
-- On LOGIC_OR reduce production atomic_term -> at_var
-- On LOGIC_NEQ reduce production atomic_term -> at_var
-- On LOGIC_IMPLY reduce production atomic_term -> at_var
-- On LOGIC_FALSE reduce production atomic_term -> at_var
-- On LOGIC_EQ reduce production atomic_term -> at_var
-- On LOGIC_AND reduce production atomic_term -> at_var
-- On LEFT_PAREN reduce production atomic_term -> at_var
-- On LEFT_BRACKET reduce production atomic_term -> at_var
-- On IN reduce production atomic_term -> at_var
-- On EQDEF reduce production atomic_term -> at_var
-- On EOI reduce production atomic_term -> at_var
-- On END reduce production atomic_term -> at_var
-- On ELSE reduce production atomic_term -> at_var
-- On DOT reduce production atomic_term -> at_var
-- On AT reduce production atomic_term -> at_var
-- On ASSERTING reduce production atomic_term -> at_var
-- On ARROW reduce production atomic_term -> at_var
-- On AND reduce production atomic_term -> at_var
-- On ABSTRACT reduce production atomic_term -> at_var

State 63:
eq_term -> apply_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
eq_term -> apply_term . LOGIC_EQ apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
eq_term -> apply_term . LOGIC_NEQ apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On LOGIC_NEQ shift to state 64
-- On LOGIC_EQ shift to state 66
-- On WITH reduce production eq_term -> apply_term
-- On VERTICAL_BAR reduce production eq_term -> apply_term
-- On THEN reduce production eq_term -> apply_term
-- On SUBSET reduce production eq_term -> apply_term
-- On SEMI_COLON reduce production eq_term -> apply_term
-- On RIGHT_PAREN reduce production eq_term -> apply_term
-- On QUOTIENT reduce production eq_term -> apply_term
-- On PARTIAL_QUOTIENT reduce production eq_term -> apply_term
-- On LOGIC_OR reduce production eq_term -> apply_term
-- On LOGIC_IMPLY reduce production eq_term -> apply_term
-- On LOGIC_AND reduce production eq_term -> apply_term
-- On LEFT_BRACKET reduce production eq_term -> apply_term
-- On IN reduce production eq_term -> apply_term
-- On EQDEF reduce production eq_term -> apply_term
-- On EOI reduce production eq_term -> apply_term
-- On END reduce production eq_term -> apply_term
-- On ELSE reduce production eq_term -> apply_term
-- On DOT reduce production eq_term -> apply_term
-- On AND reduce production eq_term -> apply_term
-- On ABSTRACT reduce production eq_term -> apply_term

State 64:
eq_term -> apply_term LOGIC_NEQ . apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 65

State 65:
eq_term -> apply_term LOGIC_NEQ apply_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On VERTICAL_BAR reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On THEN reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On SUBSET reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On SEMI_COLON reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On RIGHT_PAREN reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On QUOTIENT reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On PARTIAL_QUOTIENT reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On LOGIC_OR reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On LOGIC_IMPLY reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On LOGIC_AND reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On LEFT_BRACKET reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On IN reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On EQDEF reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On EOI reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On END reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On ELSE reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On DOT reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On AND reduce production eq_term -> apply_term LOGIC_NEQ apply_term
-- On ABSTRACT reduce production eq_term -> apply_term LOGIC_NEQ apply_term

State 66:
eq_term -> apply_term LOGIC_EQ . apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 67

State 67:
eq_term -> apply_term LOGIC_EQ apply_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On VERTICAL_BAR reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On THEN reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On SUBSET reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On SEMI_COLON reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On RIGHT_PAREN reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On QUOTIENT reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On PARTIAL_QUOTIENT reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On LOGIC_OR reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On LOGIC_IMPLY reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On LOGIC_AND reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On LEFT_BRACKET reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On IN reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On EQDEF reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On EOI reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On END reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On ELSE reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On DOT reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On AND reduce production eq_term -> apply_term LOGIC_EQ apply_term
-- On ABSTRACT reduce production eq_term -> apply_term LOGIC_EQ apply_term

State 68:
and_term -> eq_term LOGIC_AND and_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production and_term -> eq_term LOGIC_AND and_term
-- On VERTICAL_BAR reduce production and_term -> eq_term LOGIC_AND and_term
-- On THEN reduce production and_term -> eq_term LOGIC_AND and_term
-- On SUBSET reduce production and_term -> eq_term LOGIC_AND and_term
-- On SEMI_COLON reduce production and_term -> eq_term LOGIC_AND and_term
-- On RIGHT_PAREN reduce production and_term -> eq_term LOGIC_AND and_term
-- On QUOTIENT reduce production and_term -> eq_term LOGIC_AND and_term
-- On PARTIAL_QUOTIENT reduce production and_term -> eq_term LOGIC_AND and_term
-- On LOGIC_OR reduce production and_term -> eq_term LOGIC_AND and_term
-- On LOGIC_IMPLY reduce production and_term -> eq_term LOGIC_AND and_term
-- On LEFT_BRACKET reduce production and_term -> eq_term LOGIC_AND and_term
-- On IN reduce production and_term -> eq_term LOGIC_AND and_term
-- On EQDEF reduce production and_term -> eq_term LOGIC_AND and_term
-- On EOI reduce production and_term -> eq_term LOGIC_AND and_term
-- On END reduce production and_term -> eq_term LOGIC_AND and_term
-- On ELSE reduce production and_term -> eq_term LOGIC_AND and_term
-- On DOT reduce production and_term -> eq_term LOGIC_AND and_term
-- On AND reduce production and_term -> eq_term LOGIC_AND and_term
-- On ABSTRACT reduce production and_term -> eq_term LOGIC_AND and_term

State 69:
eq_term -> apply_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
eq_term -> apply_term . LOGIC_EQ apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
eq_term -> apply_term . LOGIC_NEQ apply_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
term -> apply_term . ASSERTING term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
term -> apply_term . ARROW term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On LOGIC_NEQ shift to state 64
-- On LOGIC_EQ shift to state 66
-- On ASSERTING shift to state 70
-- On ARROW shift to state 77
-- On WITH reduce production eq_term -> apply_term
-- On VERTICAL_BAR reduce production eq_term -> apply_term
-- On THEN reduce production eq_term -> apply_term
-- On SUBSET reduce production eq_term -> apply_term
-- On SEMI_COLON reduce production eq_term -> apply_term
-- On RIGHT_PAREN reduce production eq_term -> apply_term
-- On QUOTIENT reduce production eq_term -> apply_term
-- On PARTIAL_QUOTIENT reduce production eq_term -> apply_term
-- On LOGIC_OR reduce production eq_term -> apply_term
-- On LOGIC_IMPLY reduce production eq_term -> apply_term
-- On LOGIC_AND reduce production eq_term -> apply_term
-- On LEFT_BRACKET reduce production eq_term -> apply_term
-- On IN reduce production eq_term -> apply_term
-- On EQDEF reduce production eq_term -> apply_term
-- On EOI reduce production eq_term -> apply_term
-- On END reduce production eq_term -> apply_term
-- On ELSE reduce production eq_term -> apply_term
-- On DOT reduce production eq_term -> apply_term
-- On AND reduce production eq_term -> apply_term
-- On ABSTRACT reduce production eq_term -> apply_term

State 70:
term -> apply_term ASSERTING . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 71
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 71:
term -> apply_term ASSERTING term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> apply_term ASSERTING term
-- On VERTICAL_BAR reduce production term -> apply_term ASSERTING term
-- On THEN reduce production term -> apply_term ASSERTING term
-- On SUBSET reduce production term -> apply_term ASSERTING term
-- On SEMI_COLON reduce production term -> apply_term ASSERTING term
-- On RIGHT_PAREN reduce production term -> apply_term ASSERTING term
-- On QUOTIENT reduce production term -> apply_term ASSERTING term
-- On PARTIAL_QUOTIENT reduce production term -> apply_term ASSERTING term
-- On LEFT_BRACKET reduce production term -> apply_term ASSERTING term
-- On IN reduce production term -> apply_term ASSERTING term
-- On EQDEF reduce production term -> apply_term ASSERTING term
-- On EOI reduce production term -> apply_term ASSERTING term
-- On END reduce production term -> apply_term ASSERTING term
-- On ELSE reduce production term -> apply_term ASSERTING term
-- On DOT reduce production term -> apply_term ASSERTING term
-- On AND reduce production term -> apply_term ASSERTING term
-- On ABSTRACT reduce production term -> apply_term ASSERTING term

State 72:
or_term -> and_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
or_term -> and_term . LOGIC_OR or_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
or_term -> and_term . LOGIC_IMPLY or_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On LOGIC_OR shift to state 73
-- On LOGIC_IMPLY shift to state 75
-- On WITH reduce production or_term -> and_term
-- On VERTICAL_BAR reduce production or_term -> and_term
-- On THEN reduce production or_term -> and_term
-- On SUBSET reduce production or_term -> and_term
-- On SEMI_COLON reduce production or_term -> and_term
-- On RIGHT_PAREN reduce production or_term -> and_term
-- On QUOTIENT reduce production or_term -> and_term
-- On PARTIAL_QUOTIENT reduce production or_term -> and_term
-- On LEFT_BRACKET reduce production or_term -> and_term
-- On IN reduce production or_term -> and_term
-- On EQDEF reduce production or_term -> and_term
-- On EOI reduce production or_term -> and_term
-- On END reduce production or_term -> and_term
-- On ELSE reduce production or_term -> and_term
-- On DOT reduce production or_term -> and_term
-- On AND reduce production or_term -> and_term
-- On ABSTRACT reduce production or_term -> and_term

State 73:
or_term -> and_term LOGIC_OR . or_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On or_term shift to state 74
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 63
-- On and_term shift to state 72

State 74:
or_term -> and_term LOGIC_OR or_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production or_term -> and_term LOGIC_OR or_term
-- On VERTICAL_BAR reduce production or_term -> and_term LOGIC_OR or_term
-- On THEN reduce production or_term -> and_term LOGIC_OR or_term
-- On SUBSET reduce production or_term -> and_term LOGIC_OR or_term
-- On SEMI_COLON reduce production or_term -> and_term LOGIC_OR or_term
-- On RIGHT_PAREN reduce production or_term -> and_term LOGIC_OR or_term
-- On QUOTIENT reduce production or_term -> and_term LOGIC_OR or_term
-- On PARTIAL_QUOTIENT reduce production or_term -> and_term LOGIC_OR or_term
-- On LEFT_BRACKET reduce production or_term -> and_term LOGIC_OR or_term
-- On IN reduce production or_term -> and_term LOGIC_OR or_term
-- On EQDEF reduce production or_term -> and_term LOGIC_OR or_term
-- On EOI reduce production or_term -> and_term LOGIC_OR or_term
-- On END reduce production or_term -> and_term LOGIC_OR or_term
-- On ELSE reduce production or_term -> and_term LOGIC_OR or_term
-- On DOT reduce production or_term -> and_term LOGIC_OR or_term
-- On AND reduce production or_term -> and_term LOGIC_OR or_term
-- On ABSTRACT reduce production or_term -> and_term LOGIC_OR or_term

State 75:
or_term -> and_term LOGIC_IMPLY . or_term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On or_term shift to state 76
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 63
-- On and_term shift to state 72

State 76:
or_term -> and_term LOGIC_IMPLY or_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On VERTICAL_BAR reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On THEN reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On SUBSET reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On SEMI_COLON reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On RIGHT_PAREN reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On QUOTIENT reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On PARTIAL_QUOTIENT reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On LEFT_BRACKET reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On IN reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On EQDEF reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On EOI reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On END reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On ELSE reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On DOT reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On AND reduce production or_term -> and_term LOGIC_IMPLY or_term
-- On ABSTRACT reduce production or_term -> and_term LOGIC_IMPLY or_term

State 77:
term -> apply_term ARROW . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 78
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 78:
term -> apply_term ARROW term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> apply_term ARROW term
-- On VERTICAL_BAR reduce production term -> apply_term ARROW term
-- On THEN reduce production term -> apply_term ARROW term
-- On SUBSET reduce production term -> apply_term ARROW term
-- On SEMI_COLON reduce production term -> apply_term ARROW term
-- On RIGHT_PAREN reduce production term -> apply_term ARROW term
-- On QUOTIENT reduce production term -> apply_term ARROW term
-- On PARTIAL_QUOTIENT reduce production term -> apply_term ARROW term
-- On LEFT_BRACKET reduce production term -> apply_term ARROW term
-- On IN reduce production term -> apply_term ARROW term
-- On EQDEF reduce production term -> apply_term ARROW term
-- On EOI reduce production term -> apply_term ARROW term
-- On END reduce production term -> apply_term ARROW term
-- On ELSE reduce production term -> apply_term ARROW term
-- On DOT reduce production term -> apply_term ARROW term
-- On AND reduce production term -> apply_term ARROW term
-- On ABSTRACT reduce production term -> apply_term ARROW term

State 79:
term -> IF term . THEN term ELSE term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On THEN shift to state 80

State 80:
term -> IF term THEN . term ELSE term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 81
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 81:
term -> IF term THEN term . ELSE term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On ELSE shift to state 82

State 82:
term -> IF term THEN term ELSE . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 83
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 83:
term -> IF term THEN term ELSE term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> IF term THEN term ELSE term
-- On VERTICAL_BAR reduce production term -> IF term THEN term ELSE term
-- On THEN reduce production term -> IF term THEN term ELSE term
-- On SUBSET reduce production term -> IF term THEN term ELSE term
-- On SEMI_COLON reduce production term -> IF term THEN term ELSE term
-- On RIGHT_PAREN reduce production term -> IF term THEN term ELSE term
-- On QUOTIENT reduce production term -> IF term THEN term ELSE term
-- On PARTIAL_QUOTIENT reduce production term -> IF term THEN term ELSE term
-- On LEFT_BRACKET reduce production term -> IF term THEN term ELSE term
-- On IN reduce production term -> IF term THEN term ELSE term
-- On EQDEF reduce production term -> IF term THEN term ELSE term
-- On EOI reduce production term -> IF term THEN term ELSE term
-- On END reduce production term -> IF term THEN term ELSE term
-- On ELSE reduce production term -> IF term THEN term ELSE term
-- On DOT reduce production term -> IF term THEN term ELSE term
-- On AND reduce production term -> IF term THEN term ELSE term
-- On ABSTRACT reduce production term -> IF term THEN term ELSE term

State 84:
term -> LET raw_var EQDEF term . IN term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On IN shift to state 85

State 85:
term -> LET raw_var EQDEF term IN . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 86
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 86:
term -> LET raw_var EQDEF term IN term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> LET raw_var EQDEF term IN term
-- On VERTICAL_BAR reduce production term -> LET raw_var EQDEF term IN term
-- On THEN reduce production term -> LET raw_var EQDEF term IN term
-- On SUBSET reduce production term -> LET raw_var EQDEF term IN term
-- On SEMI_COLON reduce production term -> LET raw_var EQDEF term IN term
-- On RIGHT_PAREN reduce production term -> LET raw_var EQDEF term IN term
-- On QUOTIENT reduce production term -> LET raw_var EQDEF term IN term
-- On PARTIAL_QUOTIENT reduce production term -> LET raw_var EQDEF term IN term
-- On LEFT_BRACKET reduce production term -> LET raw_var EQDEF term IN term
-- On IN reduce production term -> LET raw_var EQDEF term IN term
-- On EQDEF reduce production term -> LET raw_var EQDEF term IN term
-- On EOI reduce production term -> LET raw_var EQDEF term IN term
-- On END reduce production term -> LET raw_var EQDEF term IN term
-- On ELSE reduce production term -> LET raw_var EQDEF term IN term
-- On DOT reduce production term -> LET raw_var EQDEF term IN term
-- On AND reduce production term -> LET raw_var EQDEF term IN term
-- On ABSTRACT reduce production term -> LET raw_var EQDEF term IN term

State 87:
term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On VERTICAL_BAR reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On THEN reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On SUBSET reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On SEMI_COLON reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On RIGHT_PAREN reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On QUOTIENT reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On PARTIAL_QUOTIENT reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On LEFT_BRACKET reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On IN reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On EQDEF reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On EOI reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On END reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On ELSE reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On DOT reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On AND reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term
-- On ABSTRACT reduce production term -> LOGIC_EXISTS nonempty_list(typed_var) DOT term

State 88:
typed_var -> LEFT_PAREN raw_var COLON term . RIGHT_PAREN [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On RIGHT_PAREN shift to state 89

State 89:
typed_var -> LEFT_PAREN raw_var COLON term RIGHT_PAREN . [ UPPER_WORD LOWER_WORD LEFT_PAREN DOT ]
-- On UPPER_WORD reduce production typed_var -> LEFT_PAREN raw_var COLON term RIGHT_PAREN
-- On LOWER_WORD reduce production typed_var -> LEFT_PAREN raw_var COLON term RIGHT_PAREN
-- On LEFT_PAREN reduce production typed_var -> LEFT_PAREN raw_var COLON term RIGHT_PAREN
-- On DOT reduce production typed_var -> LEFT_PAREN raw_var COLON term RIGHT_PAREN

State 90:
term -> LOGIC_FORALL nonempty_list(typed_var) . DOT term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On DOT shift to state 91

State 91:
term -> LOGIC_FORALL nonempty_list(typed_var) DOT . term [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 92
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 92:
term -> LOGIC_FORALL nonempty_list(typed_var) DOT term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On VERTICAL_BAR reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On THEN reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On SUBSET reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On SEMI_COLON reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On RIGHT_PAREN reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On QUOTIENT reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On PARTIAL_QUOTIENT reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On LEFT_BRACKET reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On IN reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On EQDEF reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On EOI reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On END reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On ELSE reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On DOT reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On AND reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term
-- On ABSTRACT reduce production term -> LOGIC_FORALL nonempty_list(typed_var) DOT term

State 93:
atomic_term -> LEFT_PAREN term . RIGHT_PAREN [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On RIGHT_PAREN shift to state 94

State 94:
atomic_term -> LEFT_PAREN term RIGHT_PAREN . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On WILDCARD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On VERTICAL_BAR reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On UPPER_WORD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On TYPE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On THEN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On SUBSET reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On SEMI_COLON reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On RIGHT_PAREN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On QUOTIENT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On PROP reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On PARTIAL_QUOTIENT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On META_VAR reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On MATCH reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOWER_WORD reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_TRUE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_OR reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_NEQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_IMPLY reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_FALSE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_EQ reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LOGIC_AND reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LEFT_PAREN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On LEFT_BRACKET reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On IN reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On EQDEF reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On EOI reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On END reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On ELSE reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On DOT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On AT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On ASSERTING reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On ARROW reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On AND reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN
-- On ABSTRACT reduce production atomic_term -> LEFT_PAREN term RIGHT_PAREN

State 95:
apply_term -> LOGIC_NOT apply_term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production apply_term -> LOGIC_NOT apply_term
-- On VERTICAL_BAR reduce production apply_term -> LOGIC_NOT apply_term
-- On THEN reduce production apply_term -> LOGIC_NOT apply_term
-- On SUBSET reduce production apply_term -> LOGIC_NOT apply_term
-- On SEMI_COLON reduce production apply_term -> LOGIC_NOT apply_term
-- On RIGHT_PAREN reduce production apply_term -> LOGIC_NOT apply_term
-- On QUOTIENT reduce production apply_term -> LOGIC_NOT apply_term
-- On PARTIAL_QUOTIENT reduce production apply_term -> LOGIC_NOT apply_term
-- On LOGIC_OR reduce production apply_term -> LOGIC_NOT apply_term
-- On LOGIC_NEQ reduce production apply_term -> LOGIC_NOT apply_term
-- On LOGIC_IMPLY reduce production apply_term -> LOGIC_NOT apply_term
-- On LOGIC_EQ reduce production apply_term -> LOGIC_NOT apply_term
-- On LOGIC_AND reduce production apply_term -> LOGIC_NOT apply_term
-- On LEFT_BRACKET reduce production apply_term -> LOGIC_NOT apply_term
-- On IN reduce production apply_term -> LOGIC_NOT apply_term
-- On EQDEF reduce production apply_term -> LOGIC_NOT apply_term
-- On EOI reduce production apply_term -> LOGIC_NOT apply_term
-- On END reduce production apply_term -> LOGIC_NOT apply_term
-- On ELSE reduce production apply_term -> LOGIC_NOT apply_term
-- On DOT reduce production apply_term -> LOGIC_NOT apply_term
-- On ASSERTING reduce production apply_term -> LOGIC_NOT apply_term
-- On ARROW reduce production apply_term -> LOGIC_NOT apply_term
-- On AND reduce production apply_term -> LOGIC_NOT apply_term
-- On ABSTRACT reduce production apply_term -> LOGIC_NOT apply_term

State 96:
atomic_term -> MATCH term . WITH cases(term) END [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH shift to state 97

State 97:
atomic_term -> MATCH term WITH . cases(term) END [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On VERTICAL_BAR shift to state 98
-- On option(VERTICAL_BAR) shift to state 99
-- On cases(term) shift to state 112
-- On UPPER_WORD reduce production option(VERTICAL_BAR) ->
-- On LOWER_WORD reduce production option(VERTICAL_BAR) ->

State 98:
option(VERTICAL_BAR) -> VERTICAL_BAR . [ UPPER_WORD LOWER_WORD ]
-- On UPPER_WORD reduce production option(VERTICAL_BAR) -> VERTICAL_BAR
-- On LOWER_WORD reduce production option(VERTICAL_BAR) -> VERTICAL_BAR

State 99:
cases(term) -> option(VERTICAL_BAR) . separated_nonempty_list(VERTICAL_BAR,case(term)) [ END ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(VERTICAL_BAR,case(term)) shift to state 100
-- On raw_var shift to state 101
-- On case(term) shift to state 109

State 100:
cases(term) -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,case(term)) . [ END ]
-- On END reduce production cases(term) -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,case(term))

State 101:
case(term) -> raw_var . list(var_or_wildcard) ARROW term [ VERTICAL_BAR END ]
-- On WILDCARD shift to state 102
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On var_or_wildcard shift to state 103
-- On raw_var shift to state 104
-- On list(var_or_wildcard) shift to state 106
-- On ARROW reduce production list(var_or_wildcard) ->

State 102:
var_or_wildcard -> WILDCARD . [ WILDCARD UPPER_WORD LOWER_WORD ARROW ]
-- On WILDCARD reduce production var_or_wildcard -> WILDCARD
-- On UPPER_WORD reduce production var_or_wildcard -> WILDCARD
-- On LOWER_WORD reduce production var_or_wildcard -> WILDCARD
-- On ARROW reduce production var_or_wildcard -> WILDCARD

State 103:
list(var_or_wildcard) -> var_or_wildcard . list(var_or_wildcard) [ ARROW ]
-- On WILDCARD shift to state 102
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On var_or_wildcard shift to state 103
-- On raw_var shift to state 104
-- On list(var_or_wildcard) shift to state 105
-- On ARROW reduce production list(var_or_wildcard) ->

State 104:
var_or_wildcard -> raw_var . [ WILDCARD UPPER_WORD LOWER_WORD ARROW ]
-- On WILDCARD reduce production var_or_wildcard -> raw_var
-- On UPPER_WORD reduce production var_or_wildcard -> raw_var
-- On LOWER_WORD reduce production var_or_wildcard -> raw_var
-- On ARROW reduce production var_or_wildcard -> raw_var

State 105:
list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard) . [ ARROW ]
-- On ARROW reduce production list(var_or_wildcard) -> var_or_wildcard list(var_or_wildcard)

State 106:
case(term) -> raw_var list(var_or_wildcard) . ARROW term [ VERTICAL_BAR END ]
-- On ARROW shift to state 107

State 107:
case(term) -> raw_var list(var_or_wildcard) ARROW . term [ VERTICAL_BAR END ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 108
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 108:
case(term) -> raw_var list(var_or_wildcard) ARROW term . [ VERTICAL_BAR END ]
-- On VERTICAL_BAR reduce production case(term) -> raw_var list(var_or_wildcard) ARROW term
-- On END reduce production case(term) -> raw_var list(var_or_wildcard) ARROW term

State 109:
separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term) . [ END ]
separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term) . VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,case(term)) [ END ]
-- On VERTICAL_BAR shift to state 110
-- On END reduce production separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term)

State 110:
separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term) VERTICAL_BAR . separated_nonempty_list(VERTICAL_BAR,case(term)) [ END ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(VERTICAL_BAR,case(term)) shift to state 111
-- On raw_var shift to state 101
-- On case(term) shift to state 109

State 111:
separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term) VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,case(term)) . [ END ]
-- On END reduce production separated_nonempty_list(VERTICAL_BAR,case(term)) -> case(term) VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,case(term))

State 112:
atomic_term -> MATCH term WITH cases(term) . END [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On END shift to state 113

State 113:
atomic_term -> MATCH term WITH cases(term) END . [ WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT ]
-- On WITH reduce production atomic_term -> MATCH term WITH cases(term) END
-- On WILDCARD reduce production atomic_term -> MATCH term WITH cases(term) END
-- On VERTICAL_BAR reduce production atomic_term -> MATCH term WITH cases(term) END
-- On UPPER_WORD reduce production atomic_term -> MATCH term WITH cases(term) END
-- On TYPE reduce production atomic_term -> MATCH term WITH cases(term) END
-- On THEN reduce production atomic_term -> MATCH term WITH cases(term) END
-- On SUBSET reduce production atomic_term -> MATCH term WITH cases(term) END
-- On SEMI_COLON reduce production atomic_term -> MATCH term WITH cases(term) END
-- On RIGHT_PAREN reduce production atomic_term -> MATCH term WITH cases(term) END
-- On QUOTIENT reduce production atomic_term -> MATCH term WITH cases(term) END
-- On PROP reduce production atomic_term -> MATCH term WITH cases(term) END
-- On PARTIAL_QUOTIENT reduce production atomic_term -> MATCH term WITH cases(term) END
-- On META_VAR reduce production atomic_term -> MATCH term WITH cases(term) END
-- On MATCH reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOWER_WORD reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_TRUE reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_OR reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_NEQ reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_IMPLY reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_FALSE reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_EQ reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LOGIC_AND reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LEFT_PAREN reduce production atomic_term -> MATCH term WITH cases(term) END
-- On LEFT_BRACKET reduce production atomic_term -> MATCH term WITH cases(term) END
-- On IN reduce production atomic_term -> MATCH term WITH cases(term) END
-- On EQDEF reduce production atomic_term -> MATCH term WITH cases(term) END
-- On EOI reduce production atomic_term -> MATCH term WITH cases(term) END
-- On END reduce production atomic_term -> MATCH term WITH cases(term) END
-- On ELSE reduce production atomic_term -> MATCH term WITH cases(term) END
-- On DOT reduce production atomic_term -> MATCH term WITH cases(term) END
-- On AT reduce production atomic_term -> MATCH term WITH cases(term) END
-- On ASSERTING reduce production atomic_term -> MATCH term WITH cases(term) END
-- On ARROW reduce production atomic_term -> MATCH term WITH cases(term) END
-- On AND reduce production atomic_term -> MATCH term WITH cases(term) END
-- On ABSTRACT reduce production atomic_term -> MATCH term WITH cases(term) END

State 114:
term -> PI nonempty_list(typed_ty_var) DOT term . [ WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT ]
-- On WITH reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On VERTICAL_BAR reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On THEN reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On SUBSET reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On SEMI_COLON reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On RIGHT_PAREN reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On QUOTIENT reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On PARTIAL_QUOTIENT reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On LEFT_BRACKET reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On IN reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On EQDEF reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On EOI reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On END reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On ELSE reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On DOT reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On AND reduce production term -> PI nonempty_list(typed_ty_var) DOT term
-- On ABSTRACT reduce production term -> PI nonempty_list(typed_ty_var) DOT term

State 115:
statement -> VAL raw_var COLON term . decl_attributes DOT [ EOI ]
-- On LEFT_BRACKET shift to state 116
-- On decl_attributes shift to state 127
-- On DOT reduce production decl_attributes ->

State 116:
decl_attributes -> LEFT_BRACKET . separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) RIGHT_BRACKET [ DOT ]
-- On UPPER_WORD shift to state 117
-- On LOWER_WORD shift to state 118
-- On INTEGER shift to state 119
-- On separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) shift to state 120
-- On nonempty_list(decl_attribute_element) shift to state 122
-- On decl_attribute_element shift to state 125

State 117:
decl_attribute_element -> UPPER_WORD . [ UPPER_WORD SEMI_COLON RIGHT_BRACKET LOWER_WORD INTEGER ]
-- On UPPER_WORD reduce production decl_attribute_element -> UPPER_WORD
-- On SEMI_COLON reduce production decl_attribute_element -> UPPER_WORD
-- On RIGHT_BRACKET reduce production decl_attribute_element -> UPPER_WORD
-- On LOWER_WORD reduce production decl_attribute_element -> UPPER_WORD
-- On INTEGER reduce production decl_attribute_element -> UPPER_WORD

State 118:
decl_attribute_element -> LOWER_WORD . [ UPPER_WORD SEMI_COLON RIGHT_BRACKET LOWER_WORD INTEGER ]
-- On UPPER_WORD reduce production decl_attribute_element -> LOWER_WORD
-- On SEMI_COLON reduce production decl_attribute_element -> LOWER_WORD
-- On RIGHT_BRACKET reduce production decl_attribute_element -> LOWER_WORD
-- On LOWER_WORD reduce production decl_attribute_element -> LOWER_WORD
-- On INTEGER reduce production decl_attribute_element -> LOWER_WORD

State 119:
decl_attribute_element -> INTEGER . [ UPPER_WORD SEMI_COLON RIGHT_BRACKET LOWER_WORD INTEGER ]
-- On UPPER_WORD reduce production decl_attribute_element -> INTEGER
-- On SEMI_COLON reduce production decl_attribute_element -> INTEGER
-- On RIGHT_BRACKET reduce production decl_attribute_element -> INTEGER
-- On LOWER_WORD reduce production decl_attribute_element -> INTEGER
-- On INTEGER reduce production decl_attribute_element -> INTEGER

State 120:
decl_attributes -> LEFT_BRACKET separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) . RIGHT_BRACKET [ DOT ]
-- On RIGHT_BRACKET shift to state 121

State 121:
decl_attributes -> LEFT_BRACKET separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) RIGHT_BRACKET . [ DOT ]
-- On DOT reduce production decl_attributes -> LEFT_BRACKET separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) RIGHT_BRACKET

State 122:
separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element) . [ RIGHT_BRACKET ]
separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element) . SEMI_COLON separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) [ RIGHT_BRACKET ]
-- On SEMI_COLON shift to state 123
-- On RIGHT_BRACKET reduce production separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element)

State 123:
separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element) SEMI_COLON . separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) [ RIGHT_BRACKET ]
-- On UPPER_WORD shift to state 117
-- On LOWER_WORD shift to state 118
-- On INTEGER shift to state 119
-- On separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) shift to state 124
-- On nonempty_list(decl_attribute_element) shift to state 122
-- On decl_attribute_element shift to state 125

State 124:
separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element) SEMI_COLON separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) . [ RIGHT_BRACKET ]
-- On RIGHT_BRACKET reduce production separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element)) -> nonempty_list(decl_attribute_element) SEMI_COLON separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element))

State 125:
nonempty_list(decl_attribute_element) -> decl_attribute_element . [ SEMI_COLON RIGHT_BRACKET ]
nonempty_list(decl_attribute_element) -> decl_attribute_element . nonempty_list(decl_attribute_element) [ SEMI_COLON RIGHT_BRACKET ]
-- On UPPER_WORD shift to state 117
-- On LOWER_WORD shift to state 118
-- On INTEGER shift to state 119
-- On nonempty_list(decl_attribute_element) shift to state 126
-- On decl_attribute_element shift to state 125
-- On SEMI_COLON reduce production nonempty_list(decl_attribute_element) -> decl_attribute_element
-- On RIGHT_BRACKET reduce production nonempty_list(decl_attribute_element) -> decl_attribute_element

State 126:
nonempty_list(decl_attribute_element) -> decl_attribute_element nonempty_list(decl_attribute_element) . [ SEMI_COLON RIGHT_BRACKET ]
-- On SEMI_COLON reduce production nonempty_list(decl_attribute_element) -> decl_attribute_element nonempty_list(decl_attribute_element)
-- On RIGHT_BRACKET reduce production nonempty_list(decl_attribute_element) -> decl_attribute_element nonempty_list(decl_attribute_element)

State 127:
statement -> VAL raw_var COLON term decl_attributes . DOT [ EOI ]
-- On DOT shift to state 128

State 128:
statement -> VAL raw_var COLON term decl_attributes DOT . [ EOI ]
-- On EOI reduce production statement -> VAL raw_var COLON term decl_attributes DOT

State 129:
statement -> SPEC . spec_defs DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On spec_defs shift to state 130
-- On separated_nonempty_list(AND,defined_symbol) shift to state 132
-- On raw_var shift to state 138
-- On defined_symbol shift to state 141

State 130:
statement -> SPEC spec_defs . DOT [ EOI ]
-- On DOT shift to state 131

State 131:
statement -> SPEC spec_defs DOT . [ EOI ]
-- On EOI reduce production statement -> SPEC spec_defs DOT

State 132:
spec_defs -> separated_nonempty_list(AND,defined_symbol) . EQDEF separated_nonempty_list(SEMI_COLON,term) [ DOT ]
-- On EQDEF shift to state 133

State 133:
spec_defs -> separated_nonempty_list(AND,defined_symbol) EQDEF . separated_nonempty_list(SEMI_COLON,term) [ DOT ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 137
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 134:
separated_nonempty_list(SEMI_COLON,term) -> term . [ DOT AND ]
separated_nonempty_list(SEMI_COLON,term) -> term . SEMI_COLON separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On SEMI_COLON shift to state 135
-- On DOT reduce production separated_nonempty_list(SEMI_COLON,term) -> term
-- On AND reduce production separated_nonempty_list(SEMI_COLON,term) -> term

State 135:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 136
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 136:
separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
-- On DOT reduce production separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term)
-- On AND reduce production separated_nonempty_list(SEMI_COLON,term) -> term SEMI_COLON separated_nonempty_list(SEMI_COLON,term)

State 137:
spec_defs -> separated_nonempty_list(AND,defined_symbol) EQDEF separated_nonempty_list(SEMI_COLON,term) . [ DOT ]
-- On DOT reduce production spec_defs -> separated_nonempty_list(AND,defined_symbol) EQDEF separated_nonempty_list(SEMI_COLON,term)

State 138:
defined_symbol -> raw_var . COLON term [ EQDEF AND ]
-- On COLON shift to state 139

State 139:
defined_symbol -> raw_var COLON . term [ EQDEF AND ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 140
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 140:
defined_symbol -> raw_var COLON term . [ EQDEF AND ]
-- On EQDEF reduce production defined_symbol -> raw_var COLON term
-- On AND reduce production defined_symbol -> raw_var COLON term

State 141:
separated_nonempty_list(AND,defined_symbol) -> defined_symbol . [ EQDEF ]
separated_nonempty_list(AND,defined_symbol) -> defined_symbol . AND separated_nonempty_list(AND,defined_symbol) [ EQDEF ]
-- On AND shift to state 142
-- On EQDEF reduce production separated_nonempty_list(AND,defined_symbol) -> defined_symbol

State 142:
separated_nonempty_list(AND,defined_symbol) -> defined_symbol AND . separated_nonempty_list(AND,defined_symbol) [ EQDEF ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,defined_symbol) shift to state 143
-- On raw_var shift to state 138
-- On defined_symbol shift to state 141

State 143:
separated_nonempty_list(AND,defined_symbol) -> defined_symbol AND separated_nonempty_list(AND,defined_symbol) . [ EQDEF ]
-- On EQDEF reduce production separated_nonempty_list(AND,defined_symbol) -> defined_symbol AND separated_nonempty_list(AND,defined_symbol)

State 144:
statement -> REC . rec_defs DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,rec_def) shift to state 145
-- On rec_defs shift to state 146
-- On rec_def shift to state 148
-- On raw_var shift to state 138
-- On defined_symbol shift to state 151

State 145:
rec_defs -> separated_nonempty_list(AND,rec_def) . [ DOT ]
-- On DOT reduce production rec_defs -> separated_nonempty_list(AND,rec_def)

State 146:
statement -> REC rec_defs . DOT [ EOI ]
-- On DOT shift to state 147

State 147:
statement -> REC rec_defs DOT . [ EOI ]
-- On EOI reduce production statement -> REC rec_defs DOT

State 148:
separated_nonempty_list(AND,rec_def) -> rec_def . [ DOT ]
separated_nonempty_list(AND,rec_def) -> rec_def . AND separated_nonempty_list(AND,rec_def) [ DOT ]
-- On AND shift to state 149
-- On DOT reduce production separated_nonempty_list(AND,rec_def) -> rec_def

State 149:
separated_nonempty_list(AND,rec_def) -> rec_def AND . separated_nonempty_list(AND,rec_def) [ DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,rec_def) shift to state 150
-- On rec_def shift to state 148
-- On raw_var shift to state 138
-- On defined_symbol shift to state 151

State 150:
separated_nonempty_list(AND,rec_def) -> rec_def AND separated_nonempty_list(AND,rec_def) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND,rec_def) -> rec_def AND separated_nonempty_list(AND,rec_def)

State 151:
rec_def -> defined_symbol . EQDEF separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On EQDEF shift to state 152

State 152:
rec_def -> defined_symbol EQDEF . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 153
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 153:
rec_def -> defined_symbol EQDEF separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
-- On DOT reduce production rec_def -> defined_symbol EQDEF separated_nonempty_list(SEMI_COLON,term)
-- On AND reduce production rec_def -> defined_symbol EQDEF separated_nonempty_list(SEMI_COLON,term)

State 154:
statement -> PRED . wf_attribute mutual_preds DOT [ EOI ]
-- On LEFT_BRACKET shift to state 155
-- On wf_attribute shift to state 158
-- On UPPER_WORD reduce production wf_attribute ->
-- On LOWER_WORD reduce production wf_attribute ->

State 155:
wf_attribute -> LEFT_BRACKET . WF_ATTRIBUTE RIGHT_BRACKET [ UPPER_WORD LOWER_WORD ]
-- On WF_ATTRIBUTE shift to state 156

State 156:
wf_attribute -> LEFT_BRACKET WF_ATTRIBUTE . RIGHT_BRACKET [ UPPER_WORD LOWER_WORD ]
-- On RIGHT_BRACKET shift to state 157

State 157:
wf_attribute -> LEFT_BRACKET WF_ATTRIBUTE RIGHT_BRACKET . [ UPPER_WORD LOWER_WORD ]
-- On UPPER_WORD reduce production wf_attribute -> LEFT_BRACKET WF_ATTRIBUTE RIGHT_BRACKET
-- On LOWER_WORD reduce production wf_attribute -> LEFT_BRACKET WF_ATTRIBUTE RIGHT_BRACKET

State 158:
statement -> PRED wf_attribute . mutual_preds DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,pred_def) shift to state 159
-- On raw_var shift to state 160
-- On pred_def shift to state 165
-- On mutual_preds shift to state 168

State 159:
mutual_preds -> separated_nonempty_list(AND,pred_def) . [ DOT ]
-- On DOT reduce production mutual_preds -> separated_nonempty_list(AND,pred_def)

State 160:
pred_def -> raw_var . COLON term EQDEF separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On COLON shift to state 161

State 161:
pred_def -> raw_var COLON . term EQDEF separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 162
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 162:
pred_def -> raw_var COLON term . EQDEF separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On EQDEF shift to state 163

State 163:
pred_def -> raw_var COLON term EQDEF . separated_nonempty_list(SEMI_COLON,term) [ DOT AND ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 164
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 164:
pred_def -> raw_var COLON term EQDEF separated_nonempty_list(SEMI_COLON,term) . [ DOT AND ]
-- On DOT reduce production pred_def -> raw_var COLON term EQDEF separated_nonempty_list(SEMI_COLON,term)
-- On AND reduce production pred_def -> raw_var COLON term EQDEF separated_nonempty_list(SEMI_COLON,term)

State 165:
separated_nonempty_list(AND,pred_def) -> pred_def . [ DOT ]
separated_nonempty_list(AND,pred_def) -> pred_def . AND separated_nonempty_list(AND,pred_def) [ DOT ]
-- On AND shift to state 166
-- On DOT reduce production separated_nonempty_list(AND,pred_def) -> pred_def

State 166:
separated_nonempty_list(AND,pred_def) -> pred_def AND . separated_nonempty_list(AND,pred_def) [ DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,pred_def) shift to state 167
-- On raw_var shift to state 160
-- On pred_def shift to state 165

State 167:
separated_nonempty_list(AND,pred_def) -> pred_def AND separated_nonempty_list(AND,pred_def) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND,pred_def) -> pred_def AND separated_nonempty_list(AND,pred_def)

State 168:
statement -> PRED wf_attribute mutual_preds . DOT [ EOI ]
-- On DOT shift to state 169

State 169:
statement -> PRED wf_attribute mutual_preds DOT . [ EOI ]
-- On EOI reduce production statement -> PRED wf_attribute mutual_preds DOT

State 170:
statement -> INCLUDE . FILEPATH DOT [ EOI ]
-- On FILEPATH shift to state 171

State 171:
statement -> INCLUDE FILEPATH . DOT [ EOI ]
-- On DOT shift to state 172

State 172:
statement -> INCLUDE FILEPATH DOT . [ EOI ]
-- On EOI reduce production statement -> INCLUDE FILEPATH DOT

State 173:
statement -> GOAL . term DOT [ EOI ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 174
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 174:
statement -> GOAL term . DOT [ EOI ]
-- On DOT shift to state 175

State 175:
statement -> GOAL term DOT . [ EOI ]
-- On EOI reduce production statement -> GOAL term DOT

State 176:
statement -> DATA . mutual_types DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On type_def shift to state 177
-- On separated_nonempty_list(AND,type_def) shift to state 195
-- On raw_var shift to state 180
-- On mutual_types shift to state 196

State 177:
separated_nonempty_list(AND,type_def) -> type_def . [ DOT ]
separated_nonempty_list(AND,type_def) -> type_def . AND separated_nonempty_list(AND,type_def) [ DOT ]
-- On AND shift to state 178
-- On DOT reduce production separated_nonempty_list(AND,type_def) -> type_def

State 178:
separated_nonempty_list(AND,type_def) -> type_def AND . separated_nonempty_list(AND,type_def) [ DOT ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On type_def shift to state 177
-- On separated_nonempty_list(AND,type_def) shift to state 179
-- On raw_var shift to state 180

State 179:
separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def) . [ DOT ]
-- On DOT reduce production separated_nonempty_list(AND,type_def) -> type_def AND separated_nonempty_list(AND,type_def)

State 180:
type_def -> raw_var . list(raw_var) EQDEF constructors [ DOT AND ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 181
-- On list(raw_var) shift to state 183
-- On EQDEF reduce production list(raw_var) ->

State 181:
list(raw_var) -> raw_var . list(raw_var) [ EQDEF ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 181
-- On list(raw_var) shift to state 182
-- On EQDEF reduce production list(raw_var) ->

State 182:
list(raw_var) -> raw_var list(raw_var) . [ EQDEF ]
-- On EQDEF reduce production list(raw_var) -> raw_var list(raw_var)

State 183:
type_def -> raw_var list(raw_var) . EQDEF constructors [ DOT AND ]
-- On EQDEF shift to state 184

State 184:
type_def -> raw_var list(raw_var) EQDEF . constructors [ DOT AND ]
-- On VERTICAL_BAR shift to state 98
-- On option(VERTICAL_BAR) shift to state 185
-- On constructors shift to state 194
-- On UPPER_WORD reduce production option(VERTICAL_BAR) ->
-- On LOWER_WORD reduce production option(VERTICAL_BAR) ->

State 185:
constructors -> option(VERTICAL_BAR) . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 186
-- On raw_var shift to state 187
-- On constructor shift to state 191

State 186:
constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
-- On DOT reduce production constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor)
-- On AND reduce production constructors -> option(VERTICAL_BAR) separated_nonempty_list(VERTICAL_BAR,constructor)

State 187:
constructor -> raw_var . list(atomic_term) [ VERTICAL_BAR DOT AND ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On list(atomic_term) shift to state 188
-- On const shift to state 57
-- On atomic_term shift to state 189
-- On at_var shift to state 62
-- On VERTICAL_BAR reduce production list(atomic_term) ->
-- On DOT reduce production list(atomic_term) ->
-- On AND reduce production list(atomic_term) ->

State 188:
constructor -> raw_var list(atomic_term) . [ VERTICAL_BAR DOT AND ]
-- On VERTICAL_BAR reduce production constructor -> raw_var list(atomic_term)
-- On DOT reduce production constructor -> raw_var list(atomic_term)
-- On AND reduce production constructor -> raw_var list(atomic_term)

State 189:
list(atomic_term) -> atomic_term . list(atomic_term) [ VERTICAL_BAR DOT AND ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On list(atomic_term) shift to state 190
-- On const shift to state 57
-- On atomic_term shift to state 189
-- On at_var shift to state 62
-- On VERTICAL_BAR reduce production list(atomic_term) ->
-- On DOT reduce production list(atomic_term) ->
-- On AND reduce production list(atomic_term) ->

State 190:
list(atomic_term) -> atomic_term list(atomic_term) . [ VERTICAL_BAR DOT AND ]
-- On VERTICAL_BAR reduce production list(atomic_term) -> atomic_term list(atomic_term)
-- On DOT reduce production list(atomic_term) -> atomic_term list(atomic_term)
-- On AND reduce production list(atomic_term) -> atomic_term list(atomic_term)

State 191:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . [ DOT AND ]
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor . VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On VERTICAL_BAR shift to state 192
-- On DOT reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor
-- On AND reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor

State 192:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR . separated_nonempty_list(VERTICAL_BAR,constructor) [ DOT AND ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(VERTICAL_BAR,constructor) shift to state 193
-- On raw_var shift to state 187
-- On constructor shift to state 191

State 193:
separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor) . [ DOT AND ]
-- On DOT reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor)
-- On AND reduce production separated_nonempty_list(VERTICAL_BAR,constructor) -> constructor VERTICAL_BAR separated_nonempty_list(VERTICAL_BAR,constructor)

State 194:
type_def -> raw_var list(raw_var) EQDEF constructors . [ DOT AND ]
-- On DOT reduce production type_def -> raw_var list(raw_var) EQDEF constructors
-- On AND reduce production type_def -> raw_var list(raw_var) EQDEF constructors

State 195:
mutual_types -> separated_nonempty_list(AND,type_def) . [ DOT ]
-- On DOT reduce production mutual_types -> separated_nonempty_list(AND,type_def)

State 196:
statement -> DATA mutual_types . DOT [ EOI ]
-- On DOT shift to state 197

State 197:
statement -> DATA mutual_types DOT . [ EOI ]
-- On EOI reduce production statement -> DATA mutual_types DOT

State 198:
statement -> COPY . raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 199

State 199:
statement -> COPY raw_var . list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 181
-- On list(raw_var) shift to state 200
-- On EQDEF reduce production list(raw_var) ->

State 200:
statement -> COPY raw_var list(raw_var) . EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On EQDEF shift to state 201

State 201:
statement -> COPY raw_var list(raw_var) EQDEF . term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 202
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 202:
statement -> COPY raw_var list(raw_var) EQDEF term . copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On SUBSET shift to state 203
-- On QUOTIENT shift to state 205
-- On PARTIAL_QUOTIENT shift to state 207
-- On copy_wrt shift to state 209
-- On ABSTRACT reduce production copy_wrt ->

State 203:
copy_wrt -> SUBSET . atomic_term [ ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 204
-- On at_var shift to state 62

State 204:
copy_wrt -> SUBSET atomic_term . [ ABSTRACT ]
-- On ABSTRACT reduce production copy_wrt -> SUBSET atomic_term

State 205:
copy_wrt -> QUOTIENT . atomic_term [ ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 206
-- On at_var shift to state 62

State 206:
copy_wrt -> QUOTIENT atomic_term . [ ABSTRACT ]
-- On ABSTRACT reduce production copy_wrt -> QUOTIENT atomic_term

State 207:
copy_wrt -> PARTIAL_QUOTIENT . atomic_term [ ABSTRACT ]
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_FALSE shift to state 29
-- On LEFT_PAREN shift to state 30
-- On AT shift to state 48
-- On var shift to state 50
-- On raw_var shift to state 52
-- On meta_var shift to state 54
-- On const shift to state 57
-- On atomic_term shift to state 208
-- On at_var shift to state 62

State 208:
copy_wrt -> PARTIAL_QUOTIENT atomic_term . [ ABSTRACT ]
-- On ABSTRACT reduce production copy_wrt -> PARTIAL_QUOTIENT atomic_term

State 209:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt . ABSTRACT raw_var CONCRETE raw_var DOT [ EOI ]
-- On ABSTRACT shift to state 210

State 210:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT . raw_var CONCRETE raw_var DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 211

State 211:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var . CONCRETE raw_var DOT [ EOI ]
-- On CONCRETE shift to state 212

State 212:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE . raw_var DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 213

State 213:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var . DOT [ EOI ]
-- On DOT shift to state 214

State 214:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT . [ EOI ]
-- On EOI reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT

State 215:
statement -> COPRED . wf_attribute mutual_preds DOT [ EOI ]
-- On LEFT_BRACKET shift to state 155
-- On wf_attribute shift to state 216
-- On UPPER_WORD reduce production wf_attribute ->
-- On LOWER_WORD reduce production wf_attribute ->

State 216:
statement -> COPRED wf_attribute . mutual_preds DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,pred_def) shift to state 159
-- On raw_var shift to state 160
-- On pred_def shift to state 165
-- On mutual_preds shift to state 217

State 217:
statement -> COPRED wf_attribute mutual_preds . DOT [ EOI ]
-- On DOT shift to state 218

State 218:
statement -> COPRED wf_attribute mutual_preds DOT . [ EOI ]
-- On EOI reduce production statement -> COPRED wf_attribute mutual_preds DOT

State 219:
statement -> CODATA . mutual_types DOT [ EOI ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On type_def shift to state 177
-- On separated_nonempty_list(AND,type_def) shift to state 195
-- On raw_var shift to state 180
-- On mutual_types shift to state 220

State 220:
statement -> CODATA mutual_types . DOT [ EOI ]
-- On DOT shift to state 221

State 221:
statement -> CODATA mutual_types DOT . [ EOI ]
-- On EOI reduce production statement -> CODATA mutual_types DOT

State 222:
statement -> AXIOM . separated_nonempty_list(SEMI_COLON,term) DOT [ EOI ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 223
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 223:
statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) . DOT [ EOI ]
-- On DOT shift to state 224

State 224:
statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT . [ EOI ]
-- On EOI reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT

State 225:
parse_statement -> statement . EOI [ # ]
-- On EOI shift to state 226

State 226:
parse_statement -> statement EOI . [ # ]
-- On # reduce production parse_statement -> statement EOI

State 227:
parse_statement' -> parse_statement . [ # ]
-- On # accept parse_statement

State 228:
parse_statement_list' -> . parse_statement_list [ # ]
-- On error shift to state 229
-- On VAL shift to state 230
-- On SPEC shift to state 236
-- On REC shift to state 239
-- On PRED shift to state 242
-- On INCLUDE shift to state 246
-- On GOAL shift to state 249
-- On DATA shift to state 252
-- On COPY shift to state 255
-- On COPRED shift to state 266
-- On CODATA shift to state 270
-- On AXIOM shift to state 273
-- On statement shift to state 276
-- On parse_statement_list shift to state 278
-- On list(statement) shift to state 279
-- On EOI reduce production list(statement) ->

State 229:
statement -> error . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> error
-- On VAL reduce production statement -> error
-- On SPEC reduce production statement -> error
-- On REC reduce production statement -> error
-- On PRED reduce production statement -> error
-- On INCLUDE reduce production statement -> error
-- On GOAL reduce production statement -> error
-- On EOI reduce production statement -> error
-- On DATA reduce production statement -> error
-- On COPY reduce production statement -> error
-- On COPRED reduce production statement -> error
-- On CODATA reduce production statement -> error
-- On AXIOM reduce production statement -> error

State 230:
statement -> VAL . raw_var COLON term decl_attributes DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 231

State 231:
statement -> VAL raw_var . COLON term decl_attributes DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On COLON shift to state 232

State 232:
statement -> VAL raw_var COLON . term decl_attributes DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 233
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 233:
statement -> VAL raw_var COLON term . decl_attributes DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On LEFT_BRACKET shift to state 116
-- On decl_attributes shift to state 234
-- On DOT reduce production decl_attributes ->

State 234:
statement -> VAL raw_var COLON term decl_attributes . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 235

State 235:
statement -> VAL raw_var COLON term decl_attributes DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On VAL reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On SPEC reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On REC reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On PRED reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On INCLUDE reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On GOAL reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On EOI reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On DATA reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On COPY reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On COPRED reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On CODATA reduce production statement -> VAL raw_var COLON term decl_attributes DOT
-- On AXIOM reduce production statement -> VAL raw_var COLON term decl_attributes DOT

State 236:
statement -> SPEC . spec_defs DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On spec_defs shift to state 237
-- On separated_nonempty_list(AND,defined_symbol) shift to state 132
-- On raw_var shift to state 138
-- On defined_symbol shift to state 141

State 237:
statement -> SPEC spec_defs . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 238

State 238:
statement -> SPEC spec_defs DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> SPEC spec_defs DOT
-- On VAL reduce production statement -> SPEC spec_defs DOT
-- On SPEC reduce production statement -> SPEC spec_defs DOT
-- On REC reduce production statement -> SPEC spec_defs DOT
-- On PRED reduce production statement -> SPEC spec_defs DOT
-- On INCLUDE reduce production statement -> SPEC spec_defs DOT
-- On GOAL reduce production statement -> SPEC spec_defs DOT
-- On EOI reduce production statement -> SPEC spec_defs DOT
-- On DATA reduce production statement -> SPEC spec_defs DOT
-- On COPY reduce production statement -> SPEC spec_defs DOT
-- On COPRED reduce production statement -> SPEC spec_defs DOT
-- On CODATA reduce production statement -> SPEC spec_defs DOT
-- On AXIOM reduce production statement -> SPEC spec_defs DOT

State 239:
statement -> REC . rec_defs DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,rec_def) shift to state 145
-- On rec_defs shift to state 240
-- On rec_def shift to state 148
-- On raw_var shift to state 138
-- On defined_symbol shift to state 151

State 240:
statement -> REC rec_defs . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 241

State 241:
statement -> REC rec_defs DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> REC rec_defs DOT
-- On VAL reduce production statement -> REC rec_defs DOT
-- On SPEC reduce production statement -> REC rec_defs DOT
-- On REC reduce production statement -> REC rec_defs DOT
-- On PRED reduce production statement -> REC rec_defs DOT
-- On INCLUDE reduce production statement -> REC rec_defs DOT
-- On GOAL reduce production statement -> REC rec_defs DOT
-- On EOI reduce production statement -> REC rec_defs DOT
-- On DATA reduce production statement -> REC rec_defs DOT
-- On COPY reduce production statement -> REC rec_defs DOT
-- On COPRED reduce production statement -> REC rec_defs DOT
-- On CODATA reduce production statement -> REC rec_defs DOT
-- On AXIOM reduce production statement -> REC rec_defs DOT

State 242:
statement -> PRED . wf_attribute mutual_preds DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On LEFT_BRACKET shift to state 155
-- On wf_attribute shift to state 243
-- On UPPER_WORD reduce production wf_attribute ->
-- On LOWER_WORD reduce production wf_attribute ->

State 243:
statement -> PRED wf_attribute . mutual_preds DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,pred_def) shift to state 159
-- On raw_var shift to state 160
-- On pred_def shift to state 165
-- On mutual_preds shift to state 244

State 244:
statement -> PRED wf_attribute mutual_preds . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 245

State 245:
statement -> PRED wf_attribute mutual_preds DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On VAL reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On SPEC reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On REC reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On PRED reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On INCLUDE reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On GOAL reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On EOI reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On DATA reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On COPY reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On COPRED reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On CODATA reduce production statement -> PRED wf_attribute mutual_preds DOT
-- On AXIOM reduce production statement -> PRED wf_attribute mutual_preds DOT

State 246:
statement -> INCLUDE . FILEPATH DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On FILEPATH shift to state 247

State 247:
statement -> INCLUDE FILEPATH . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 248

State 248:
statement -> INCLUDE FILEPATH DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> INCLUDE FILEPATH DOT
-- On VAL reduce production statement -> INCLUDE FILEPATH DOT
-- On SPEC reduce production statement -> INCLUDE FILEPATH DOT
-- On REC reduce production statement -> INCLUDE FILEPATH DOT
-- On PRED reduce production statement -> INCLUDE FILEPATH DOT
-- On INCLUDE reduce production statement -> INCLUDE FILEPATH DOT
-- On GOAL reduce production statement -> INCLUDE FILEPATH DOT
-- On EOI reduce production statement -> INCLUDE FILEPATH DOT
-- On DATA reduce production statement -> INCLUDE FILEPATH DOT
-- On COPY reduce production statement -> INCLUDE FILEPATH DOT
-- On COPRED reduce production statement -> INCLUDE FILEPATH DOT
-- On CODATA reduce production statement -> INCLUDE FILEPATH DOT
-- On AXIOM reduce production statement -> INCLUDE FILEPATH DOT

State 249:
statement -> GOAL . term DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 250
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 250:
statement -> GOAL term . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 251

State 251:
statement -> GOAL term DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> GOAL term DOT
-- On VAL reduce production statement -> GOAL term DOT
-- On SPEC reduce production statement -> GOAL term DOT
-- On REC reduce production statement -> GOAL term DOT
-- On PRED reduce production statement -> GOAL term DOT
-- On INCLUDE reduce production statement -> GOAL term DOT
-- On GOAL reduce production statement -> GOAL term DOT
-- On EOI reduce production statement -> GOAL term DOT
-- On DATA reduce production statement -> GOAL term DOT
-- On COPY reduce production statement -> GOAL term DOT
-- On COPRED reduce production statement -> GOAL term DOT
-- On CODATA reduce production statement -> GOAL term DOT
-- On AXIOM reduce production statement -> GOAL term DOT

State 252:
statement -> DATA . mutual_types DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On type_def shift to state 177
-- On separated_nonempty_list(AND,type_def) shift to state 195
-- On raw_var shift to state 180
-- On mutual_types shift to state 253

State 253:
statement -> DATA mutual_types . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 254

State 254:
statement -> DATA mutual_types DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> DATA mutual_types DOT
-- On VAL reduce production statement -> DATA mutual_types DOT
-- On SPEC reduce production statement -> DATA mutual_types DOT
-- On REC reduce production statement -> DATA mutual_types DOT
-- On PRED reduce production statement -> DATA mutual_types DOT
-- On INCLUDE reduce production statement -> DATA mutual_types DOT
-- On GOAL reduce production statement -> DATA mutual_types DOT
-- On EOI reduce production statement -> DATA mutual_types DOT
-- On DATA reduce production statement -> DATA mutual_types DOT
-- On COPY reduce production statement -> DATA mutual_types DOT
-- On COPRED reduce production statement -> DATA mutual_types DOT
-- On CODATA reduce production statement -> DATA mutual_types DOT
-- On AXIOM reduce production statement -> DATA mutual_types DOT

State 255:
statement -> COPY . raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 256

State 256:
statement -> COPY raw_var . list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 181
-- On list(raw_var) shift to state 257
-- On EQDEF reduce production list(raw_var) ->

State 257:
statement -> COPY raw_var list(raw_var) . EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On EQDEF shift to state 258

State 258:
statement -> COPY raw_var list(raw_var) EQDEF . term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 259
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 259:
statement -> COPY raw_var list(raw_var) EQDEF term . copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On SUBSET shift to state 203
-- On QUOTIENT shift to state 205
-- On PARTIAL_QUOTIENT shift to state 207
-- On copy_wrt shift to state 260
-- On ABSTRACT reduce production copy_wrt ->

State 260:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt . ABSTRACT raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On ABSTRACT shift to state 261

State 261:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT . raw_var CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 262

State 262:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var . CONCRETE raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On CONCRETE shift to state 263

State 263:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE . raw_var DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On raw_var shift to state 264

State 264:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 265

State 265:
statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On VAL reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On SPEC reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On REC reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On PRED reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On INCLUDE reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On GOAL reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On EOI reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On DATA reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On COPY reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On COPRED reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On CODATA reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT
-- On AXIOM reduce production statement -> COPY raw_var list(raw_var) EQDEF term copy_wrt ABSTRACT raw_var CONCRETE raw_var DOT

State 266:
statement -> COPRED . wf_attribute mutual_preds DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On LEFT_BRACKET shift to state 155
-- On wf_attribute shift to state 267
-- On UPPER_WORD reduce production wf_attribute ->
-- On LOWER_WORD reduce production wf_attribute ->

State 267:
statement -> COPRED wf_attribute . mutual_preds DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On separated_nonempty_list(AND,pred_def) shift to state 159
-- On raw_var shift to state 160
-- On pred_def shift to state 165
-- On mutual_preds shift to state 268

State 268:
statement -> COPRED wf_attribute mutual_preds . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 269

State 269:
statement -> COPRED wf_attribute mutual_preds DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On VAL reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On SPEC reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On REC reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On PRED reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On INCLUDE reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On GOAL reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On EOI reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On DATA reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On COPY reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On COPRED reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On CODATA reduce production statement -> COPRED wf_attribute mutual_preds DOT
-- On AXIOM reduce production statement -> COPRED wf_attribute mutual_preds DOT

State 270:
statement -> CODATA . mutual_types DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On UPPER_WORD shift to state 3
-- On LOWER_WORD shift to state 4
-- On type_def shift to state 177
-- On separated_nonempty_list(AND,type_def) shift to state 195
-- On raw_var shift to state 180
-- On mutual_types shift to state 271

State 271:
statement -> CODATA mutual_types . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 272

State 272:
statement -> CODATA mutual_types DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> CODATA mutual_types DOT
-- On VAL reduce production statement -> CODATA mutual_types DOT
-- On SPEC reduce production statement -> CODATA mutual_types DOT
-- On REC reduce production statement -> CODATA mutual_types DOT
-- On PRED reduce production statement -> CODATA mutual_types DOT
-- On INCLUDE reduce production statement -> CODATA mutual_types DOT
-- On GOAL reduce production statement -> CODATA mutual_types DOT
-- On EOI reduce production statement -> CODATA mutual_types DOT
-- On DATA reduce production statement -> CODATA mutual_types DOT
-- On COPY reduce production statement -> CODATA mutual_types DOT
-- On COPRED reduce production statement -> CODATA mutual_types DOT
-- On CODATA reduce production statement -> CODATA mutual_types DOT
-- On AXIOM reduce production statement -> CODATA mutual_types DOT

State 273:
statement -> AXIOM . separated_nonempty_list(SEMI_COLON,term) DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 134
-- On separated_nonempty_list(SEMI_COLON,term) shift to state 274
-- On raw_var shift to state 52
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 274:
statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) . DOT [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On DOT shift to state 275

State 275:
statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT . [ error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM ]
-- On error reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On VAL reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On SPEC reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On REC reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On PRED reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On INCLUDE reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On GOAL reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On EOI reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On DATA reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On COPY reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On COPRED reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On CODATA reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT
-- On AXIOM reduce production statement -> AXIOM separated_nonempty_list(SEMI_COLON,term) DOT

State 276:
list(statement) -> statement . list(statement) [ EOI ]
-- On error shift to state 229
-- On VAL shift to state 230
-- On SPEC shift to state 236
-- On REC shift to state 239
-- On PRED shift to state 242
-- On INCLUDE shift to state 246
-- On GOAL shift to state 249
-- On DATA shift to state 252
-- On COPY shift to state 255
-- On COPRED shift to state 266
-- On CODATA shift to state 270
-- On AXIOM shift to state 273
-- On statement shift to state 276
-- On list(statement) shift to state 277
-- On EOI reduce production list(statement) ->

State 277:
list(statement) -> statement list(statement) . [ EOI ]
-- On EOI reduce production list(statement) -> statement list(statement)

State 278:
parse_statement_list' -> parse_statement_list . [ # ]
-- On # accept parse_statement_list

State 279:
parse_statement_list -> list(statement) . EOI [ # ]
-- On EOI shift to state 280

State 280:
parse_statement_list -> list(statement) EOI . [ # ]
-- On # reduce production parse_statement_list -> list(statement) EOI

State 281:
parse_term' -> . parse_term [ # ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 282
-- On raw_var shift to state 52
-- On parse_term shift to state 284
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 282:
parse_term -> term . EOI [ # ]
-- On EOI shift to state 283

State 283:
parse_term -> term EOI . [ # ]
-- On # reduce production parse_term -> term EOI

State 284:
parse_term' -> parse_term . [ # ]
-- On # accept parse_term

State 285:
parse_ty' -> . parse_ty [ # ]
-- On error shift to state 7
-- On WILDCARD shift to state 8
-- On UPPER_WORD shift to state 3
-- On TYPE shift to state 9
-- On PROP shift to state 10
-- On PI shift to state 11
-- On META_VAR shift to state 24
-- On MATCH shift to state 26
-- On LOWER_WORD shift to state 4
-- On LOGIC_TRUE shift to state 27
-- On LOGIC_NOT shift to state 28
-- On LOGIC_FORALL shift to state 31
-- On LOGIC_FALSE shift to state 29
-- On LOGIC_EXISTS shift to state 35
-- On LET shift to state 41
-- On LEFT_PAREN shift to state 30
-- On IF shift to state 44
-- On FUN shift to state 45
-- On AT shift to state 48
-- On var shift to state 50
-- On term shift to state 286
-- On raw_var shift to state 52
-- On parse_ty shift to state 288
-- On or_term shift to state 53
-- On meta_var shift to state 54
-- On eq_term shift to state 55
-- On const shift to state 57
-- On atomic_term shift to state 58
-- On at_var shift to state 62
-- On apply_term shift to state 69
-- On and_term shift to state 72

State 286:
parse_ty -> term . EOI [ # ]
-- On EOI shift to state 287

State 287:
parse_ty -> term EOI . [ # ]
-- On # reduce production parse_ty -> term EOI

State 288:
parse_ty' -> parse_ty . [ # ]
-- On # accept parse_ty

