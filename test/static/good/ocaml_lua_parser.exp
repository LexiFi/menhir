Grammar has 31 nonterminal symbols, among which 1 start symbols.
Grammar has 52 terminal symbols.
Grammar has 106 productions.
nullable(varlist) = false
nullable(var) = false
nullable(tableconstructor) = false
nullable(statlist) = true
nullable(stat) = false
nullable(retstat) = false
nullable(prog) = false
nullable(primary) = false
nullable(parlist) = false
nullable(namelist) = false
nullable(label) = false
nullable(key) = false
nullable(ident) = false
nullable(functiondef) = false
nullable(functioncall) = false
nullable(funcname) = false
nullable(funcbody) = false
nullable(fname) = false
nullable(fieldsep) = false
nullable(fields) = false
nullable(fieldlist) = false
nullable(field) = false
nullable(explist) = false
nullable(exp) = false
nullable(elseifps) = false
nullable(elseifp) = false
nullable(chunk) = true
nullable(bracket) = false
nullable(block) = true
nullable(args) = false
nullable(OSC) = true
first(varlist) = LPAR IDENT
first(var) = LPAR IDENT
first(tableconstructor) = LCB
first(statlist) = WHILE SEMI REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR DO DCOLON
first(stat) = WHILE REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR DO DCOLON
first(retstat) = RETURN BREAK
first(prog) = WHILE SEMI RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF DO DCOLON BREAK
first(primary) = STR_CONST NUM_CONST LPAR LCB FUNCTION ELLIPSIS BOOL
first(parlist) = IDENT ELLIPSIS
first(namelist) = IDENT
first(label) = DCOLON
first(key) = LB DOT
first(ident) = IDENT
first(functiondef) = FUNCTION
first(functioncall) = LPAR IDENT
first(funcname) = IDENT
first(funcbody) = LPAR
first(fname) = IDENT
first(fieldsep) = SEMI COMMA
first(fields) = STR_CONST NUM_CONST NOT MINUS LPAR LCB LB IDENT HASH FUNCTION ELLIPSIS BOOL
first(fieldlist) = STR_CONST NUM_CONST NOT MINUS LPAR LCB LB IDENT HASH FUNCTION ELLIPSIS BOOL
first(field) = STR_CONST NUM_CONST NOT MINUS LPAR LCB LB IDENT HASH FUNCTION ELLIPSIS BOOL
first(explist) = STR_CONST NUM_CONST NOT MINUS LPAR LCB IDENT HASH FUNCTION ELLIPSIS BOOL
first(exp) = STR_CONST NUM_CONST NOT MINUS LPAR LCB IDENT HASH FUNCTION ELLIPSIS BOOL
first(elseifps) = ELSEIF
first(elseifp) = ELSEIF
first(chunk) = WHILE SEMI RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR DO DCOLON BREAK
first(bracket) = LPAR
first(block) = WHILE SEMI RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR DO DCOLON BREAK
first(args) = STR_CONST LPAR LCB
first(OSC) = SEMI
minimal(varlist) = (* 1 *) IDENT
minimal(var) = (* 1 *) IDENT
minimal(tableconstructor) = (* 2 *) LCB RCB
minimal(statlist) = (* 0 *)
minimal(stat) = (* 2 *) IDENT STR_CONST
minimal(retstat) = (* 1 *) RETURN
minimal(prog) = (* 1 *) EOF
minimal(primary) = (* 1 *) BOOL
minimal(parlist) = (* 1 *) IDENT
minimal(namelist) = (* 1 *) IDENT
minimal(label) = (* 3 *) DCOLON IDENT DCOLON
minimal(key) = (* 2 *) DOT IDENT
minimal(ident) = (* 1 *) IDENT
minimal(functiondef) = (* 4 *) FUNCTION LPAR RPAR END
minimal(functioncall) = (* 2 *) IDENT STR_CONST
minimal(funcname) = (* 1 *) IDENT
minimal(funcbody) = (* 3 *) LPAR RPAR END
minimal(fname) = (* 1 *) IDENT
minimal(fieldsep) = (* 1 *) COMMA
minimal(fields) = (* 1 *) BOOL
minimal(fieldlist) = (* 1 *) BOOL
minimal(field) = (* 1 *) BOOL
minimal(explist) = (* 1 *) BOOL
minimal(exp) = (* 1 *) BOOL
minimal(elseifps) = (* 3 *) ELSEIF BOOL THEN
minimal(elseifp) = (* 3 *) ELSEIF BOOL THEN
minimal(chunk) = (* 0 *)
minimal(bracket) = (* 3 *) LPAR BOOL RPAR
minimal(block) = (* 0 *)
minimal(args) = (* 1 *) STR_CONST
minimal(OSC) = (* 0 *)
follow(varlist) = COMMA ASSIGN
follow(var) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK ASSIGN AND
follow(tableconstructor) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK AND
follow(statlist) = WHILE UNTIL RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON BREAK
follow(stat) = WHILE UNTIL SEMI RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON BREAK
follow(retstat) = UNTIL SEMI EOF END ELSEIF ELSE
follow(prog) = #
follow(primary) = WHILE UNTIL THEN SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV DCOLON COMMA CAT CARAT BREAK AND
follow(parlist) = RPAR
follow(namelist) = WHILE UNTIL SEMI RPAR RETURN REPEAT LPAR LOCAL IN IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON COMMA BREAK ASSIGN
follow(label) = WHILE UNTIL SEMI RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON BREAK
follow(key) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK ASSIGN AND
follow(ident) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IN IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK ASSIGN AND
follow(functiondef) = WHILE UNTIL THEN SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV DCOLON COMMA CAT CARAT BREAK AND
follow(functioncall) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK AND
follow(funcname) = LPAR
follow(funcbody) = WHILE UNTIL THEN SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV DCOLON COMMA CAT CARAT BREAK AND
follow(fname) = LPAR DOT COLON
follow(fieldsep) = STR_CONST RCB NUM_CONST NOT MINUS LPAR LCB LB IDENT HASH FUNCTION ELLIPSIS BOOL
follow(fields) = SEMI RCB COMMA
follow(fieldlist) = RCB
follow(field) = SEMI RCB COMMA
follow(explist) = WHILE UNTIL SEMI RPAR RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON COMMA BREAK
follow(exp) = WHILE UNTIL THEN SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DO DIV DCOLON COMMA CAT CARAT BREAK AND
follow(elseifps) = END ELSEIF ELSE
follow(elseifp) = END ELSEIF ELSE
follow(chunk) = UNTIL EOF END ELSEIF ELSE
follow(bracket) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK AND
follow(block) = UNTIL END ELSEIF ELSE
follow(args) = WHILE UNTIL THEN STR_CONST SEMI RPAR RETURN REPEAT RCB RB PLUS OR NE MULT MOD MINUS LT LPAR LOCAL LE LCB LB IF IDENT GT GOTO GE FUNCTION FOR EQ EOF END ELSEIF ELSE DOT DO DIV DCOLON COMMA COLON CAT CARAT BREAK AND
follow(OSC) = WHILE UNTIL RETURN REPEAT LPAR LOCAL IF IDENT GOTO FUNCTION FOR EOF END ELSEIF ELSE DO DCOLON BREAK
Built an LR(0) automaton with 213 states.
The grammar is not SLR(1) -- 24 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 213 states.
274 shift/reduce conflicts were silently solved.
66 out of 213 states have a default reduction.
86 out of 213 states are represented.
0 out of 86 symbols keep track of their start position.
0 out of 86 symbols keep track of their end position.
56 out of 107 productions exploit shiftreduce optimization.
356 functions before inlining, 70 functions after inlining.
