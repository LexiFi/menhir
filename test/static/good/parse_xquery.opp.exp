File "parse_xquery.mly", line 212, characters 7-15:
Warning: the token ASSERTAS is unused.
File "parse_xquery.mly", line 152, characters 19-30:
Warning: the token ATTLISTDECL is unused.
File "parse_xquery.mly", line 153, characters 7-16:
Warning: the token BEGINDECL is unused.
File "parse_xquery.mly", line 153, characters 25-33:
Warning: the token BODYDECL is unused.
File "parse_xquery.mly", line 260, characters 7-12:
Warning: the token COLON is unused.
File "parse_xquery.mly", line 118, characters 7-14:
Warning: the token DOCTYPE is unused.
File "parse_xquery.mly", line 118, characters 15-27:
Warning: the token DOCTYPECLOSE is unused.
File "parse_xquery.mly", line 119, characters 19-31:
Warning: the token DTDDECLCLOSE is unused.
File "parse_xquery.mly", line 119, characters 7-18:
Warning: the token DTDDECLOPEN is unused.
File "parse_xquery.mly", line 152, characters 7-18:
Warning: the token ELEMENTDECL is unused.
File "parse_xquery.mly", line 153, characters 17-24:
Warning: the token ENDDECL is unused.
File "parse_xquery.mly", line 152, characters 31-41:
Warning: the token ENTITYDECL is unused.
File "parse_xquery.mly", line 151, characters 24-29:
Warning: the token FIXED is unused.
File "parse_xquery.mly", line 151, characters 16-23:
Warning: the token IMPLIED is unused.
File "parse_xquery.mly", line 269, characters 17-22:
Warning: the token IRPAR is unused.
File "parse_xquery.mly", line 198, characters 31-35:
Warning: the token ITEM is unused.
File "parse_xquery.mly", line 279, characters 7-15:
Warning: the token LEXERROR is unused.
File "parse_xquery.mly", line 185, characters 32-52:
Warning: the token NAMESPACENCNAMECURLY is unused.
File "parse_xquery.mly", line 150, characters 32-39:
Warning: the token NMTOKEN is unused.
File "parse_xquery.mly", line 198, characters 26-30:
Warning: the token NODE is unused.
File "parse_xquery.mly", line 152, characters 42-54:
Warning: the token NOTATIONDECL is unused.
File "parse_xquery.mly", line 151, characters 30-36:
Warning: the token PCDATA is unused.
File "parse_xquery.mly", line 149, characters 7-14:
Warning: the token PERCENT is unused.
File "parse_xquery.mly", line 148, characters 32-37:
Warning: the token PEREF is unused.
File "parse_xquery.mly", line 151, characters 7-15:
Warning: the token REQUIRED is unused.
File "parse_xquery.mly", line 231, characters 7-21:
Warning: the token SNAPDELETENODE is unused.
File "parse_xquery.mly", line 231, characters 22-36:
Warning: the token SNAPINSERTNODE is unused.
File "parse_xquery.mly", line 231, characters 37-51:
Warning: the token SNAPRENAMENODE is unused.
File "parse_xquery.mly", line 232, characters 7-22:
Warning: the token SNAPREPLACENODE is unused.
File "parse_xquery.mly", line 232, characters 23-45:
Warning: the token SNAPREPLACEVALUEOFNODE is unused.
File "parse_xquery.mly", line 198, characters 7-11:
Warning: the token TYPE is unused.
File "parse_xquery.mly", line 289, characters 6-11:
Warning: the token WHILE is unused.
File "parse_xquery.mly", line 115, characters 16-25:
Warning: the token XDECLNAME is unused.
File "parse_xquery.mly", line 114, characters 43-55:
Warning: the token XDOUBLEQUOTE is unused.
File "parse_xquery.mly", line 116, characters 16-25:
Warning: the token XENCODING is unused.
File "parse_xquery.mly", line 114, characters 7-12:
Warning: the token XMLPI is unused.
File "parse_xquery.mly", line 111, characters 32-39:
Warning: the token XNCNAME is unused.
File "parse_xquery.mly", line 110, characters 32-38:
Warning: the token XQNAME is unused.
File "parse_xquery.mly", line 114, characters 22-29:
Warning: the token XSDDECL is unused.
File "parse_xquery.mly", line 114, characters 30-42:
Warning: the token XSINGLEQUOTE is unused.
File "parse_xquery.mly", line 112, characters 29-36:
Warning: the token XSTRING is unused.
File "parse_xquery.mly", line 114, characters 13-21:
Warning: the token XVERSION is unused.
%{

open Namespace_names
open Datatypes
open Datatypes_util

open Xquery_common_ast

open Xquery_ast
open Xquery_ast_util

open Xquery_type_ast
open Xquery_type_ast_util

open Error
open Finfo

open Format

(* Checks the XQuery version *)

let parsing_interface = ref false

let check_version s e =
  begin
    match e with
    | None -> ()
    | Some e ->
	ignore(Encoding.encoding_of_string e)
  end;
  begin
    if s = Conf.xquery_version
    then ()
    else raise (Query (Unknown ("XQuery version " ^ s ^ " not supported")))
  end

(* Checks consitency between opening and closing tags *)

let same_tag os cs =
  if (os = cs)
  then ()
  else
    raise (Query (Parsing (Finfo.parsing_locinfo (),
			   "Opening tag: "
			   ^ (Namespace_names.string_of_uqname os)
			   ^ " and closing tag: "
			   ^ (Namespace_names.string_of_uqname cs)
			   ^ " mismatched")))

(* Checks only one statement in main module *)

let single_statement () =
  if (!Conf.xquery_conformance)
  then
    raise (Query (Unknown "Main module should have a single expression"))
  else
    ()

(* In case of abbreviated syntax, tells you which axis to use from the nodekind test *)

let make_axis_from_nt nt =
  match nt with
  | (PNodeKindTest (AttributeKind _)) -> Attribute
  | _ -> Child

(* Deals with entity references in XQuery *)

let xquery_parse_context =
  let proc_ctxt = Processing_context.default_processing_context() in
  Parse_context.build_xquery_parse_context proc_ctxt

let wrap_p f =
  if Conf.is_xqueryp() || Conf.is_dxq()
  then f ()
  else raise (Query (Toplevel_Error "XQueryP tokens found, please use -language xqueryp or -language dxq"))

let wrap_dxq f =
  if Conf.is_dxq()
  then f ()
  else raise (Query (Toplevel_Error "DXQ tokens found, please use -language dxq"))

let check_pragma_content content =
  if (((String.length content) > 0) && (String.get content 0 != ' ')) then
    raise (Query (Parsing (Finfo.parsing_locinfo (),
			   "Pragma QName and content must be separated by a whitespace")))


%}
%start extype
%start interface
%start librarymodule
%start mainmodule
%start prolog
%start statement
%start stringlit
%start xquerymodule
%token AFTER
%token AMPERSAND
%token AND
%token ANYSTRINGLPAR
%token AS
%token ASCENDING
%token ASFIRST
%token ASLAST
%token ASSERTAS
%token AT
%token ATSERVER
%token ATSIGN
%token ATTLISTDECL
%token ATTRGROUP
%token ATTRIBUTE
%token ATTRIBUTECURLY
%token ATTRIBUTELPAR
%token <Namespace_names.uqname> ATTRIBUTEQNAMECURLY
%token <Datatypes.xs_untyped> ATTRIBUTETEXT
%token <Datatypes.xs_untyped> ATTRIBUTETEXTLCURLY
%token <Xquery_common_ast.axis> AXIS
%token BAR
%token BEFORE
%token BEGINDECL
%token BODYDECL
%token BOX
%token CASE
%token CASTABLEAS
%token CASTAS
%token COLLATION
%token COLON
%token COLONEQUALS
%token COMMA
%token COMMENT
%token COMMENTCURLY
%token COMMENTLPAR
%token COPYDOLLAR
%token COPYLCURLY
%token <Decimal._decimal> DECIMAL
%token <Namespace_names.uqname> DECLAREATTRGROUP
%token <Namespace_names.uqname> DECLAREATTRIBUTE
%token DECLAREBASEURI
%token DECLAREBOUNDARYSPACE
%token <Namespace_names.uqname> DECLARECOMPLEXTYPE
%token DECLARECONSTRUCTION
%token DECLARECOPYNAMESPACES
%token DECLAREDEFAULTCOLLATION
%token DECLAREDEFAULTELEMENT
%token DECLAREDEFAULTFUNCTION
%token DECLAREDEFAULTORDER
%token DECLAREDOLLAR
%token <Namespace_names.uqname> DECLAREELEMENT
%token DECLAREFUNCTION
%token <Namespace_names.uqname> DECLAREGROUP
%token DECLARENAMEINDEX
%token DECLARENAMESPACE
%token DECLAREOPTION
%token DECLAREORDERING
%token DECLARESCHEMALCURLY
%token DECLARESERVER
%token <Namespace_names.uqname> DECLARESIMPLETYPE
%token DECLAREUPDATINGFUNCTION
%token DECLAREVALUEINDEX
%token DECLAREVARIABLE
%token DEFAULT
%token DEFAULTELEMENT
%token DELETENODE
%token DESCENDING
%token DIV
%token DO
%token DOCTYPE
%token DOCTYPECLOSE
%token DOCUMENT
%token DOCUMENTCURLY
%token DOCUMENTNODELPAR
%token DOLLAR
%token DOT
%token DOTDOT
%token <float> DOUBLE
%token DTDDECLCLOSE
%token DTDDECLOPEN
%token ELEMENT
%token ELEMENTCURLY
%token ELEMENTDECL
%token ELEMENTLPAR
%token <Namespace_names.uqname> ELEMENTQNAMECURLY
%token ELSE
%token EMPTY
%token EMPTYSEQUENCELPAR
%token ENCODING
%token ENDDECL
%token ENTITYDECL
%token EOF
%token EQ
%token EQUALS
%token EVALCLOSURE
%token EVERYDOLLAR
%token EXCEPT
%token EXTENDS
%token EXTERNAL
%token FIXED
%token FOLLOWS
%token FORDOLLAR
%token FORSERVER
%token FROMSERVER
%token <Namespace_names.uqname> FUNCTIONNAMELPAR
%token GREATEST
%token GROUP
%token GT
%token GTE
%token GTEQUALS
%token GTOP
%token IDIV
%token IFLPAR
%token IMPLEMENT
%token IMPLIED
%token IMPORTINTERFACE
%token IMPORTMODULE
%token IMPORTSCHEMA
%token IMPORTSERVICE
%token IN
%token INHERIT
%token INSERTNODE
%token INSTANCEOF
%token <Decimal._integer> INT
%token INTERFACENAMESPACE
%token INTERSECT
%token INTO
%token IPLUS
%token IRPAR
%token IS
%token ISTAR
%token ITEM
%token ITEMLPAR
%token LBRACK
%token LCLOSINGTAG
%token LCURLY
%token LEAST
%token LETDOLLAR
%token LETSERVER
%token LETVARDOLLAR
%token LEXERROR
%token LISTOF
%token LOPENINGCOMMENT
%token LOPENINGTAG
%token LPAR
%token LT
%token LTE
%token LTEQUALS
%token LTOP
%token MINUS
%token MIXED
%token MOD
%token MODIFY
%token MODULENAMESPACE
%token MULT
%token NAMESPACE
%token <Namespace_names.ncname> NAMESPACENCNAMECURLY
%token <Namespace_names.ncname> NCNAME
%token <Namespace_names.ncname> NCNAMESTAR
%token NE
%token NILLABLE
%token <Namespace_names.ncname> NMTOKEN
%token NODE
%token NODELPAR
%token NOINHERIT
%token NONE
%token NOPRESERVE
%token NOTATIONDECL
%token NOTEQUALS
%token NUMERICLPAR
%token OFSIMPLETYPE
%token OFTYPE
%token <Namespace_names.ncname> OPENINGPI
%token OR
%token ORDERBY
%token ORDERED
%token ORDEREDCURLY
%token PCDATA
%token PERCENT
%token <Namespace_names.ncname> PEREF
%token PICURLY
%token <Namespace_names.ncname> PINCNAMECURLY
%token PLUS
%token <Namespace_names.uqname * string> PRAGMA
%token PRECEDES
%token PRESERVE
%token PROCESSINGINSTRUCTION
%token PROCESSINGINSTRUCTIONLPAR
%token <Namespace_names.uqname> QNAME
%token <Namespace_names.uqname> QNAMEPLUS
%token <Namespace_names.uqname> QNAMEQUESTION
%token <Namespace_names.uqname> QNAMESTAR
%token QUESTION
%token RBRACK
%token RCLOSINGTAG
%token RCURLY
%token REMPTYELEMENT
%token RENAMENODE
%token REPLACENODE
%token REPLACEVALUEOFNODE
%token REQUIRED
%token RESTRICTS
%token RETURN
%token ROPENINGTAG
%token RPAR
%token S
%token SATISFIES
%token SCHEMAATTRIBUTELPAR
%token SCHEMAELEMENTLPAR
%token SEMICOLON
%token SETDOLLAR
%token SLASH
%token SLASHSLASH
%token SNAPDELETENODE
%token SNAPINSERTNODE
%token SNAPLCURLY
%token SNAPLCURLYORDERED
%token SNAPRENAMENODE
%token SNAPREPLACENODE
%token SNAPREPLACEVALUEOFNODE
%token SOMEDOLLAR
%token STABLEORDERBY
%token STAR
%token <Namespace_names.ncname> STARNCNAME
%token <string> STRING
%token STRIP
%token SUBSTITUTESFOR
%token TEXT
%token <Datatypes.xs_untyped * int> TEXTCHARREF
%token <Datatypes.xs_untyped> TEXTCLOSINGPI
%token TEXTCURLY
%token <Datatypes.xs_untyped * string> TEXTENTITYREF
%token <Datatypes.xs_untyped> TEXTLCLOSINGTAG
%token <Datatypes.xs_untyped> TEXTLCURLY
%token <Datatypes.xs_untyped> TEXTLOPENINGCOMMENT
%token <Datatypes.xs_untyped> TEXTLOPENINGTAG
%token TEXTLPAR
%token <Datatypes.xs_untyped * Namespace_names.ncname> TEXTOPENINGPI
%token <Datatypes.xs_untyped> TEXTRCLOSINGCOMMENT
%token THEN
%token TO
%token TREATAS
%token TYPE
%token TYPELPAR
%token TYPESWITCHLPAR
%token UNION
%token UNIONOF
%token UNORDERED
%token UNORDEREDCURLY
%token VALIDATELAXLCURLY
%token VALIDATELCURLY
%token VALIDATESTRICTLCURLY
%token <Namespace_names.uqname> VARNAME
%token WHERE
%token WHILELPAR
%token WITH
%token <string> XDECLNAME
%token XDOUBLEQUOTE
%token <string> XENCODING
%token XMLPI
%token <Namespace_names.ncname> XNCNAME
%token <Namespace_names.uqname> XQNAME
%token XQUERYVERSION
%token XSDDECL
%token XSINGLEQUOTE
%token <Datatypes.xs_string> XSTRING
%token XVERSION
%left COMMA
%left AFTER AS ASFIRST ASLAST BEFORE DELETENODE INSERTNODE INTO RENAMENODE REPLACENODE REPLACEVALUEOFNODE WITH
%left BOX COLONEQUALS DO ELSE EVALCLOSURE EVERYDOLLAR FORDOLLAR IFLPAR LETDOLLAR LETVARDOLLAR RETURN SATISFIES SETDOLLAR SOMEDOLLAR THEN TYPESWITCHLPAR WHERE WHILE
%left OR
%left AND
%left BAR
%left AMPERSAND
%left EQ EQUALS FOLLOWS GT GTE GTEQUALS GTOP IS LT LTE LTEQUALS LTOP NE NOTEQUALS PRECEDES
%left TO
%left MINUS PLUS
%left DIV IDIV MOD MULT
%left EBAR UNION
%left EXCEPT INTERSECT
%left INSTANCEOF
%left TREATAS
%left CASTABLEAS
%left CASTAS
%left SLASH SLASHSLASH
%left LBRACK RBRACK
%nonassoc UNARY
%nonassoc QUESTION
%nonassoc STAR
%nonassoc AXIS
%nonassoc ATSIGN
%type <(Xquery_type_ast.xtype option * Xquery_type_ast.xtype)> extype
%type <Xquery_ast.interface> interface
%type <Xquery_ast.library_module> librarymodule
%type <Xquery_ast.main_module> mainmodule
%type <Xquery_ast.prolog> prolog
%type <Xquery_ast.statement> statement
%type <string> stringlit
%type <Xquery_ast.xmodule> xquerymodule
%%

xquerymodule:
  _1 = mainmodule
    {      ( EMainModule _1 )}
| _1 = librarymodule
    {      ( ELibraryModule _1 )}

opt_version:
  
    {      ( () )}
| _1 = XQUERYVERSION _2 = STRING _3 = opt_encoding _4 = SEMICOLON
    {      ( let version = _2 in
        let encoding = _3 in
        check_version version encoding )}

opt_encoding:
  
    {      ( None )}
| _1 = ENCODING _2 = STRING
    {      ( let s = _2 in
        begin
	  ignore(Encoding.encoding_of_string s);
	  Some _2
	end )}

mainmodule:
  _1 = opt_version _2 = prolog _3 = statements _4 = EOF
    {      ( let prolog = _2
        and statements = _3 in
(* Still allowing main modules without statements for now
        if statements = []
        then
	  raise (Query (Parsing (Finfo.parsing_locinfo (),
				 "Main module does not contain any statement")))
        else
*)
      { pmain_module_prolog     = prolog;
	pmain_module_statements = statements } )}

librarymodule:
  _1 = opt_version _2 = moduledecl _3 = prolog _4 = EOF
    {      ( let moddecl = _2 in
        let prolog = _3 in
        { plibrary_module_decl = moddecl;
	  plibrary_module_prolog = prolog } )}

moduledecl:
  _1 = MODULENAMESPACE _2 = NCNAME _3 = EQUALS _4 = STRING _5 = opt_interface _6 = SEMICOLON
    {      ( (_2,_4,_5) )}

opt_interface:
  
    {      ( None )}
| _1 = IMPLEMENT _2 = STRING
    {      ( Some (_2, None) )}
| _1 = IMPLEMENT _2 = STRING _3 = AT _4 = STRING
    {      ( Some (_2, Some _4) )}

interface:
  _1 = opt_version _2 = interfacedecl _3 = prolog _4 = EOF
    {      ( (* Woe is me --- hacking a global variable into the parser *)
        parsing_interface := false;
	let infdecl = _2 and
            prolog = _3
	in
	if (prolog.pprolog_indices != []) then
	  raise (Query (Parsing (Finfo.parsing_locinfo (),
				 "Interface may not contain indices")))
	else
	  let interface_prolog =
	    { iprolog_xschemas = prolog.pprolog_xschemas;
	      iprolog_contexts = prolog.pprolog_contexts;
	      iprolog_funcvars = prolog.pprolog_funcvars;
	    }
	  in
	  { pinterface_decl   = infdecl;
	    pinterface_prolog = interface_prolog
	  }
      )}

interfacedecl:
  _1 = INTERFACENAMESPACE _2 = NCNAME _3 = EQUALS _4 = STRING _5 = SEMICOLON
    {      ( parsing_interface := true;
	(_2,_4)
      )}

prolog:
  _1 = setters_and_first_declaration_list _2 = second_declaration_list
    {      ( let (nsd1,nsd2,issds) = _1 in
        let (vfd,kd) = _2 in
	  { pprolog_xschemas = issds;
	    pprolog_contexts = nsd1@nsd2;
	    pprolog_funcvars = vfd;
	    pprolog_indices = kd } )}

setters_and_first_declaration_list:
  
    {      ( ([],[],[]) )}
| _1 = DECLAREBOUNDARYSPACE _2 = STRIP _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EXmlSpaceDecl Strip) :: nsd,nsd2,issds) )}
| _1 = DECLAREBOUNDARYSPACE _2 = PRESERVE _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EXmlSpaceDecl Preserve) :: nsd,nsd2,issds) )}
| _1 = DECLAREDEFAULTCOLLATION _2 = STRING _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EDefaultCollationDecl _2) :: nsd,nsd2,issds) )}
| _1 = DECLAREBASEURI _2 = STRING _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EBaseURIDecl _2) :: nsd,nsd2,issds) )}
| _1 = DECLARECONSTRUCTION _2 = STRIP _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EConstructionDecl Strip) :: nsd,nsd2,issds) )}
| _1 = DECLARECONSTRUCTION _2 = PRESERVE _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EConstructionDecl Preserve) :: nsd,nsd2,issds) )}
| _1 = DECLAREORDERING _2 = ORDERED _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EOrderingDecl Ordered) :: nsd,nsd2,issds) )}
| _1 = DECLAREORDERING _2 = UNORDERED _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _4 in
        (mkcontext_decl (EOrderingDecl Unordered) :: nsd,nsd2,issds) )}
| _1 = DECLAREDEFAULTORDER _2 = EMPTY _3 = GREATEST _4 = SEMICOLON _5 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _5 in
        (mkcontext_decl (EDefaultEmptyOrderDecl EmptyGreatest) :: nsd,nsd2,issds) )}
| _1 = DECLAREDEFAULTORDER _2 = EMPTY _3 = LEAST _4 = SEMICOLON _5 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _5 in
        (mkcontext_decl (EDefaultEmptyOrderDecl EmptyLeast) :: nsd,nsd2,issds) )}
| _1 = DECLARECOPYNAMESPACES _2 = PRESERVE _3 = COMMA _4 = INHERIT _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _6 in
        (mkcontext_decl (ECopyNamespacesDecl (NSPreserve,NSInherit)) :: nsd,nsd2,issds) )}
| _1 = DECLARECOPYNAMESPACES _2 = NOPRESERVE _3 = COMMA _4 = INHERIT _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _6 in
        (mkcontext_decl (ECopyNamespacesDecl (NSNoPreserve,NSInherit)) :: nsd,nsd2,issds) )}
| _1 = DECLARECOPYNAMESPACES _2 = PRESERVE _3 = COMMA _4 = NOINHERIT _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _6 in
        (mkcontext_decl (ECopyNamespacesDecl (NSPreserve,NSNoInherit)) :: nsd,nsd2,issds) )}
| _1 = DECLARECOPYNAMESPACES _2 = NOPRESERVE _3 = COMMA _4 = NOINHERIT _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd,nsd2,issds) = _6 in
        (mkcontext_decl (ECopyNamespacesDecl (NSNoPreserve,NSNoInherit)) :: nsd,nsd2,issds) )}
| _1 = DECLAREDEFAULTELEMENT _2 = NAMESPACE _3 = STRING _4 = SEMICOLON _5 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _5 in
        (nsd1,mkcontext_decl (EDefaultElementNamespaceDecl (NSUri _3)) :: nsd,issds) )}
| _1 = DECLAREDEFAULTFUNCTION _2 = NAMESPACE _3 = STRING _4 = SEMICOLON _5 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _5 in
        (nsd1,mkcontext_decl (EDefaultFunctionNamespaceDecl (NSUri _3)) :: nsd,issds) )}
| _1 = IMPORTSCHEMA _2 = STRING _3 = SEMICOLON _4 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _4 in
        (nsd1,mkcontext_decl (ESchemaDecl (None,_2,None)) :: nsd, issds) )}
| _1 = IMPORTSCHEMA _2 = STRING _3 = AT _4 = STRING _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _6 in
        (nsd1,mkcontext_decl (ESchemaDecl (None,_2,Some _4)) :: nsd, issds) )}
| _1 = IMPORTSCHEMA _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = SEMICOLON _7 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _7 in
        (nsd1,mkcontext_decl (ESchemaDecl (Some (NSPrefix _3),_5,None)) :: nsd, issds) )}
| _1 = IMPORTSCHEMA _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = AT _7 = STRING _8 = SEMICOLON _9 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _9 in
        (nsd1,mkcontext_decl (ESchemaDecl (Some (NSPrefix _3),_5,Some _7)) :: nsd, issds) )}
| _1 = IMPORTSCHEMA _2 = DEFAULTELEMENT _3 = NAMESPACE _4 = STRING _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _6 in
        (nsd1,mkcontext_decl (ESchemaDecl (Some NSDefaultElementPrefix,_4,None)):: nsd, issds) )}
| _1 = IMPORTSCHEMA _2 = DEFAULTELEMENT _3 = NAMESPACE _4 = STRING _5 = AT _6 = STRING _7 = SEMICOLON _8 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _8 in
        (nsd1,mkcontext_decl (ESchemaDecl (Some NSDefaultElementPrefix,_4,Some _6)):: nsd, issds) )}
| _1 = IMPORTMODULE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = SEMICOLON _7 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _7 in
        (nsd1, mkcontext_decl (EImportModuleDecl (_3,_5, None)) :: nsd, issds) )}
| _1 = IMPORTMODULE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = AT _7 = STRING _8 = SEMICOLON _9 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _9 in
        (nsd1, mkcontext_decl (EImportModuleDecl (_3,_5, Some _7)) :: nsd, issds) )}
| _1 = IMPORTINTERFACE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = SEMICOLON _7 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _7 in
        (nsd1, mkcontext_decl (EImportInterfaceDecl (_3,_5, None)) :: nsd, issds) )}
| _1 = IMPORTINTERFACE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = AT _7 = STRING _8 = SEMICOLON _9 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _9 in
        (nsd1, mkcontext_decl (EImportInterfaceDecl (_3,_5, Some _7)) :: nsd, issds) )}
| _1 = IMPORTSERVICE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _6 in
        (nsd1, mkcontext_decl (EImportServiceDecl (_3,_5, None)) :: nsd, issds) )}
| _1 = IMPORTSERVICE _2 = NAMESPACE _3 = NCNAME _4 = EQUALS _5 = STRING _6 = AT _7 = STRING _8 = SEMICOLON _9 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _9 in
        (nsd1, mkcontext_decl (EImportServiceDecl (_3,_5, Some _7)) :: nsd, issds) )}
| _1 = DECLARENAMESPACE _2 = NCNAME _3 = EQUALS _4 = STRING _5 = SEMICOLON _6 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,issds) = _6 in
        (nsd1,mkcontext_decl (ENamespaceDecl (_2,NSUri _4)) :: nsd, issds) )}
| _1 = schema_decl _2 = setters_and_first_declaration_list
    {      ( let (nsd1,nsd,schemas) = _2 in
        let one_schema = _1 in
        (nsd1,nsd, one_schema :: schemas) )}

second_declaration_list:
  
    {      ( ([],[]) )}
| _1 = DECLAREVARIABLE _2 = qname _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr _6 = SEMICOLON _7 = second_declaration_list
    {      ( let (vfd,kd) = _7 in
        let varname = _2 in
	let st = _3 in
        let expr = EVarUser (mkexpr (EList _5)) in
        let newvd = mkvar_decl (varname,st,expr) in
        ((VarDef newvd) :: vfd, kd) )}
| _1 = DECLAREVARIABLE _2 = qname _3 = opt_type_declaration _4 = EXTERNAL _5 = SEMICOLON _6 = second_declaration_list
    {      ( let (vfd,kd) = _6 in
        let varname = match _2 with
          | (NSPrefix nc, lcname) -> if (!parsing_interface) then (NSInterfacePrefix nc, lcname) else _2
	  | _ -> if (!parsing_interface) then raise (Query(Parsing(Finfo.parsing_locinfo (),"Invalid QName"))) else _2
	in
	let st = _3 in
        let expr = if (!parsing_interface) then EVarInterface else EVarExternal in
        let newvd = mkvar_decl (varname,st,expr) in
        ((VarDef newvd) :: vfd, kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = RPAR _4 = LCURLY _5 = block _6 = RCURLY _7 = SEMICOLON _8 = second_declaration_list
    {      (   let (vfd,kd) = _8 in
          let expr = _5 in
          let newfd = mkfunction_def (_2,[],([],None),EFunctionUser expr, _1) in
	    ((FunDef newfd) :: vfd, kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = paramlist _4 = RPAR _5 = LCURLY _6 = block _7 = RCURLY _8 = SEMICOLON _9 = second_declaration_list
    {      (   let (vfd,kd) = _9 in
          let (input_types,input_vars) = _3 in
          let expr = _6 in
          let newfd = mkfunction_def (_2,input_vars,(input_types,None),EFunctionUser expr, _1) in
	    ((FunDef newfd) :: vfd, kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = RPAR _4 = AS _5 = sequencetype _6 = LCURLY _7 = block _8 = RCURLY _9 = SEMICOLON _10 = second_declaration_list
    {      (   let (vfd,kd) = _10 in
          let expr = _7 in
          let newfd = mkfunction_def (_2,[],([],Some _5),EFunctionUser expr, _1) in
	    ((FunDef newfd) :: vfd, kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = paramlist _4 = RPAR _5 = AS _6 = sequencetype _7 = LCURLY _8 = block _9 = RCURLY _10 = SEMICOLON _11 = second_declaration_list
    {      (
	let (vfd,kd) = _11 in
	let (input_types,input_vars) = _3 in
	let expr = _8 in
	let newfd = mkfunction_def (_2,input_vars,(input_types,Some _6),EFunctionUser expr, _1) in
	  ((FunDef newfd :: vfd), kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = RPAR _4 = AS _5 = sequencetype _6 = EXTERNAL _7 = SEMICOLON _8 = second_declaration_list
    {      ( let (vfd,kd) = _8 in
        let funkind = if (!parsing_interface) then EFunctionInterface else EFunctionBltIn in
        let fname = match _2 with
          | (NSPrefix nc, lcname) -> if (!parsing_interface) then (NSInterfacePrefix nc, lcname) else _2
	  | _ -> if (!parsing_interface) then raise (Query(Parsing(Finfo.parsing_locinfo (),"Invalid QName"))) else _2
	in
        let newfd = mkfunction_def (fname,[],([],Some _5), funkind, _1) in
	((FunDef newfd :: vfd),kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = paramlist _4 = RPAR _5 = AS _6 = sequencetype _7 = EXTERNAL _8 = SEMICOLON _9 = second_declaration_list
    {      ( let (vfd,kd) = _9 in
        let (input_types,input_vars) = _3 in
        let funkind = if (!parsing_interface) then EFunctionInterface else EFunctionBltIn in
        let fname = match _2 with
          | (NSPrefix nc, lcname) -> if (!parsing_interface) then (NSInterfacePrefix nc, lcname) else _2
	  | _ -> if (!parsing_interface) then raise (Query(Parsing(Finfo.parsing_locinfo (),"Invalid QName"))) else _2
	in
        let newfd = mkfunction_def (fname,input_vars,(input_types,Some _6), funkind, _1) in
	((FunDef newfd :: vfd), kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = RPAR _4 = EXTERNAL _5 = SEMICOLON _6 = second_declaration_list
    {      ( let (vfd,kd) = _6 in
        let funkind = if (!parsing_interface) then EFunctionInterface else EFunctionBltIn  in
        let fname = match _2 with
          | (NSPrefix nc, lcname) -> if (!parsing_interface) then (NSInterfacePrefix nc, lcname) else _2
	  | _ -> if (!parsing_interface) then raise (Query(Parsing(Finfo.parsing_locinfo (),"Invalid QName"))) else _2
	in
        let newfd = mkfunction_def (fname,[],([],None), funkind, _1) in
	((FunDef newfd :: vfd), kd) )}
| _1 = start_declare_fun _2 = FUNCTIONNAMELPAR _3 = paramlist _4 = RPAR _5 = EXTERNAL _6 = SEMICOLON _7 = second_declaration_list
    {      ( let (vfd,kd) = _7 in
        let (input_types,input_vars) = _3 in
        let funkind = if (!parsing_interface) then EFunctionInterface else EFunctionBltIn in
        let fname = match _2 with
          | (NSPrefix nc, lcname) -> if (!parsing_interface) then (NSInterfacePrefix nc, lcname) else _2
	  | _ -> if (!parsing_interface) then raise (Query(Parsing(Finfo.parsing_locinfo (),"Invalid QName"))) else _2
	in
        let newfd = mkfunction_def (fname,input_vars,(input_types,None), funkind, _1) in
	((FunDef newfd :: vfd), kd) )}
| _1 = DECLARESERVER _2 = NCNAME _3 = IMPLEMENT _4 = NCNAME _5 = AT _6 = expr_single _7 = SEMICOLON _8 = second_declaration_list
    {      ( let (vfd,kd) = _8 in
        let serverdef = mkserver_decl (_2,_4,_6)
	in wrap_dxq (fun () -> ((ServerDef serverdef)::vfd, kd))
      )}
| _1 = DECLAREOPTION _2 = qname _3 = STRING _4 = SEMICOLON _5 = second_declaration_list
    {      ( let (vfd,kd) = _5 in
        ((OptionDecl (_2,_3)) :: vfd,kd) )}
| _1 = DECLAREVALUEINDEX _2 = STRING _3 = LCURLY _4 = expr _5 = RCURLY _6 = LCURLY _7 = expr _8 = RCURLY _9 = SEMICOLON _10 = second_declaration_list
    {      ( let (vfd,kd) = _10 in
        let indexname = _2 in
        let expr1 = mkexpr (EList _4) in
        let expr2 = mkexpr (EList _7) in
        let newindex = mkindex_def (ValueIndex (indexname,expr1,expr2)) in
        (vfd, newindex :: kd) )}
| _1 = DECLARENAMEINDEX _2 = qname _3 = SEMICOLON _4 = second_declaration_list
    {      ( let (vfd,kd) = _4 in
        let name = _2 in
        let newindex = mkindex_def (NameIndex name) in
        (vfd, newindex :: kd) )}

statements:
  
    {      ( single_statement (); [] )}
| _1 = statement
    {      ( _1 :: [] )}
| _1 = statement _2 = SEMICOLON _3 = statements
    {      ( single_statement (); _1 :: _3  )}

statement:
  _1 = expr
    {      ( mkexpr (EList _1) )}

paramlist:
  _1 = param
    {      ( let (t,v) = _1 in
        (t :: [], v :: []) )}
| _1 = param _2 = COMMA _3 = paramlist
    {      ( let (t,v) = _1
        and (pt,pv) = _3 in
        (t :: pt, v :: pv) )}

param:
  _1 = variable _2 = AS _3 = sequencetype
    {      ( (Some _3,_1) )}
| _1 = variable
    {      ( (None,_1) )}

expr_single:
  _1 = expr_single _2 = OR _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEOr,_3)) )}
| _1 = expr_single _2 = AND _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEAnd,_3)) )}
| _1 = expr_single _2 = PRECEDES _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEPrecedes,_3)) )}
| _1 = expr_single _2 = FOLLOWS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEFollows,_3)) )}
| _1 = for_let_clause _2 = where_order_clause _3 = return_clause
    {      ( let fl = _1
        and (where,order) = _2
        and return = _3 in
        mkexpr (EFLWOR (fl,where,order,return)) )}
| _1 = IFLPAR _2 = expr _3 = RPAR _4 = THEN _5 = expr_single _6 = ELSE _7 = expr_single
    {      ( let expr = mkexpr (EList _2) in
        mkexpr (EIf (expr, _5, _7)) )}
| _1 = SOMEDOLLAR _2 = bindings _3 = SATISFIES _4 = expr_single
    {      ( mkexpr (ESome (_2, _4)) )}
| _1 = EVERYDOLLAR _2 = bindings _3 = SATISFIES _4 = expr_single
    {      ( mkexpr (EEvery (_2, _4)) )}
| _1 = TYPESWITCHLPAR _2 = expr _3 = RPAR _4 = case_clause_list
    {      ( let expr = mkexpr (EList _2) in
        mkexpr (ETypeswitch (expr, _4)) )}
| _1 = expr_single _2 = EQ _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEEq,_3)) )}
| _1 = expr_single _2 = EQUALS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEEqual,_3)) )}
| _1 = expr_single _2 = IS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEIs,_3)) )}
| _1 = expr_single _2 = NE _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BENEq,_3)) )}
| _1 = expr_single _2 = NOTEQUALS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BENEqual,_3)) )}
| _1 = expr_single _2 = LT _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BELt,_3)) )}
| _1 = expr_single _2 = GT _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEGt,_3)) )}
| _1 = expr_single _2 = LTOP _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BELtOp,_3)) )}
| _1 = expr_single _2 = GTOP _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEGtOp,_3)) )}
| _1 = expr_single _2 = LTE _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BELte,_3)) )}
| _1 = expr_single _2 = GTE _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEGte,_3)) )}
| _1 = expr_single _2 = LTEQUALS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BELteq,_3)) )}
| _1 = expr_single _2 = GTEQUALS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEGteq,_3)) )}
| _1 = expr_single _2 = INSTANCEOF _3 = sequencetype
    {      ( mkexpr (EInstanceOf (_1,_3)) )}
| _1 = expr_single _2 = TO _3 = expr_single
    {      ( mkexpr (ERange (_1,_3)) )}
| _1 = expr_single _2 = PLUS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEPlus,_3)) )}
| _1 = expr_single _2 = MINUS _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEMinus,_3)) )}
| _1 = expr_single _2 = MULT _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEMult,_3)) )}
| _1 = expr_single _2 = DIV _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEDiv,_3)) )}
| _1 = expr_single _2 = IDIV _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEIDiv,_3)) )}
| _1 = expr_single _2 = MOD _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEMod,_3)) )}
| _1 = MINUS _2 = expr_single %prec UNARY
    {      ( mkexpr (EUnaryOp(UEMinus,_2)) )}
| _1 = PLUS _2 = expr_single %prec UNARY
    {      ( mkexpr (EUnaryOp(UEPlus,_2)) )}
| _1 = expr_single _2 = UNION _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEUnion,_3)) )}
| _1 = expr_single _2 = BAR _3 = expr_single %prec EBAR
    {      ( mkexpr (EBinaryOp(_1,BEBar,_3)) )}
| _1 = expr_single _2 = INTERSECT _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEIntersect,_3)) )}
| _1 = expr_single _2 = EXCEPT _3 = expr_single
    {      ( mkexpr (EBinaryOp(_1,BEExcept,_3)) )}
| _1 = expr_single _2 = CASTABLEAS _3 = singletype
    {      ( mkexpr (ECastable (_1,_3)) )}
| _1 = expr_single _2 = CASTAS _3 = sequencetype
    {      ( mkexpr (ECast (_1,_3)) )}
| _1 = expr_single _2 = TREATAS _3 = sequencetype
    {      ( mkexpr (ETreat (_1,_3)) )}
| _1 = pathexpr
    {      ( _1 )}
| _1 = DELETENODE _2 = expr_single
    {      ( mkexpr (EDelete (NoSnap,_2)) )}
| _1 = INSERTNODE _2 = expr_single _3 = INTO _4 = expr_single
    {      ( mkexpr (EInsert (NoSnap,_2,EInto _4)) )}
| _1 = INSERTNODE _2 = expr_single _3 = ASLAST _4 = INTO _5 = expr_single
    {      ( mkexpr (EInsert (NoSnap,_2,EAsLastInto _5)) )}
| _1 = INSERTNODE _2 = expr_single _3 = ASFIRST _4 = INTO _5 = expr_single
    {      ( mkexpr (EInsert (NoSnap,_2,EAsFirstInto _5)) )}
| _1 = INSERTNODE _2 = expr_single _3 = AFTER _4 = expr_single
    {      ( mkexpr (EInsert (NoSnap,_2,EAfter _4)) )}
| _1 = INSERTNODE _2 = expr_single _3 = BEFORE _4 = expr_single
    {      ( mkexpr (EInsert (NoSnap,_2,EBefore _4)) )}
| _1 = RENAMENODE _2 = expr_single _3 = AS _4 = expr_single
    {      ( mkexpr (ERename (NoSnap,_2,_4)) )}
| _1 = REPLACENODE _2 = expr_single _3 = WITH _4 = expr_single
    {      ( mkexpr (EReplace (NoSnap, Normal_Replace, _2, _4)) )}
| _1 = REPLACEVALUEOFNODE _2 = expr_single _3 = WITH _4 = expr_single
    {      ( mkexpr (EReplace (NoSnap, Value_Of_Replace, _2, _4)) )}
| _1 = transform_copy_clause _2 = modify_clause _3 = return_clause
    {      ( mkexpr (ETransform (_1, _2, _3)) )}
| _1 = WHILELPAR _2 = expr_single _3 = RPAR _4 = RETURN _5 = expr_single
    {      ( wrap_p (fun () -> mkexpr (EWhile(_2, _5))) )}
| _1 = LETVARDOLLAR _2 = qname _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr_single _6 = return_clause
    {      ( wrap_p (fun () -> mkexpr(ELetvar(_3,_2,_5,_6))) )}
| _1 = SETDOLLAR _2 = qname _3 = COLONEQUALS _4 = expr_single
    {      ( wrap_p (fun() -> mkexpr(ESet(_2,_4))) )}
| _1 = LETSERVER _2 = NCNAME _3 = IMPLEMENT _4 = NCNAME _5 = AT _6 = expr_single _7 = RETURN _8 = expr_single
    {      ( wrap_dxq (fun () -> mkexpr (ELetServerImplement(_2,_4,_6,_8))) )}
| _1 = FROMSERVER _2 = NCNAME _3 = RETURN _4 = expr_single
    {      ( wrap_dxq (fun () -> mkexpr (EExecute(false,_2,_4))) )}
| _1 = ATSERVER _2 = NCNAME _3 = DO _4 = expr_single
    {      ( wrap_dxq (fun () -> mkexpr (EExecute(true,_2,_4))) )}
| _1 = FORSERVER _2 = NCNAME _3 = IMPLEMENT _4 = NCNAME _5 = BOX _6 = expr_single
    {      ( wrap_dxq (fun () -> mkexpr (EForServerClose(_2,_4,_6))) )}
| _1 = EVALCLOSURE _2 = expr_single
    {      ( wrap_dxq (fun () -> mkexpr (EEvalClosure(_2))) )}

collation:
  
    {      ( None )}
| _1 = COLLATION _2 = STRING
    {      ( Some _2 )}

sortspeclist:
  _1 = sortspec _2 = collation
    {      ( let (a,b,c) = _1 in
        (a,b,c,_2) :: [] )}
| _1 = sortspec _2 = collation _3 = COMMA _4 = sortspeclist
    {      ( let (a,b,c) = _1 in
        (a,b,c,_2) :: _4 )}

sortspec:
  _1 = expr_single
    {      ( (_1,Ascending,None) )}
| _1 = expr_single _2 = ASCENDING
    {      ( (_1,Ascending,None) )}
| _1 = expr_single _2 = DESCENDING
    {      ( (_1,Descending,None) )}
| _1 = expr_single _2 = EMPTY _3 = GREATEST
    {      ( (_1,Ascending,Some EmptyGreatest) )}
| _1 = expr_single _2 = ASCENDING _3 = EMPTY _4 = GREATEST
    {      ( (_1,Ascending,Some EmptyGreatest) )}
| _1 = expr_single _2 = DESCENDING _3 = EMPTY _4 = GREATEST
    {      ( (_1,Descending,Some EmptyGreatest) )}
| _1 = expr_single _2 = EMPTY _3 = LEAST
    {      ( (_1,Ascending,Some EmptyLeast) )}
| _1 = expr_single _2 = ASCENDING _3 = EMPTY _4 = LEAST
    {      ( (_1,Ascending,Some EmptyLeast) )}
| _1 = expr_single _2 = DESCENDING _3 = EMPTY _4 = LEAST
    {      ( (_1,Descending,Some EmptyLeast) )}

bindings:
  _1 = qname _2 = opt_type_declaration _3 = IN _4 = expr_single
    {      (  [(_2, _1, _4)] )}
| _1 = qname _2 = opt_type_declaration _3 = IN _4 = expr_single _5 = COMMA _6 = DOLLAR _7 = bindings
    {      (  (_2, _1, _4) :: _7 )}

opt_positional_var:
  
    {      ( None )}
| _1 = AT _2 = variable
    {      ( Some _2 )}

for_let_clause:
  _1 = FORDOLLAR _2 = qname _3 = opt_type_declaration _4 = opt_positional_var _5 = IN _6 = expr_single _7 = for_clause
    {      ( (mkfl_expr (EFor (_3, _2, _4, _6))) :: _7 )}
| _1 = LETDOLLAR _2 = qname _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr_single _6 = let_clause
    {      ( (mkfl_expr (ELet (_3, _2, _5))) :: _6 )}

for_clause:
  
    {      ( [] )}
| _1 = COMMA _2 = variable _3 = opt_type_declaration _4 = opt_positional_var _5 = IN _6 = expr_single _7 = for_clause
    {      ( (mkfl_expr (EFor (_3, _2, _4, _6))) :: _7 )}
| _1 = for_let_clause
    {      ( _1 )}

let_clause:
  
    {      ( [] )}
| _1 = COMMA _2 = variable _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr_single _6 = let_clause
    {      ( (mkfl_expr (ELet (_3, _2, _5))) :: _6 )}
| _1 = for_let_clause
    {      ( _1 )}

where_order_clause:
  
    {      ( (None,None) )}
| _1 = where_clause
    {      ( (Some _1,None) )}
| _1 = order_clause
    {      ( (None, Some _1) )}
| _1 = where_clause _2 = order_clause
    {      ( (Some _1, Some _2) )}

where_clause:
  _1 = WHERE _2 = expr_single
    {      ( _2 )}

order_clause:
  _1 = ORDERBY _2 = sortspeclist
    {      ( (NonStable, _2) )}
| _1 = STABLEORDERBY _2 = sortspeclist
    {      ( (Stable, _2) )}

return_clause:
  _1 = RETURN _2 = expr_single
    {      ( _2 )}

opt_variable:
  
    {      ( None )}
| _1 = variable
    {      ( Some _1 )}

opt_variable_as:
  
    {      ( None )}
| _1 = variable _2 = AS
    {      ( Some _1 )}

case_clause_list:
  _1 = CASE _2 = opt_variable_as _3 = sequencetype _4 = RETURN _5 = expr_single _6 = DEFAULT _7 = opt_variable _8 = RETURN _9 = expr_single
    {      ( (mkpattern (Case (_3)), _2, _5) :: (mkpattern (Default), _7, _9) :: [] )}
| _1 = CASE _2 = opt_variable_as _3 = sequencetype _4 = RETURN _5 = expr_single _6 = case_clause_list
    {      ( (mkpattern (Case (_3)), _2, _5) :: _6 )}

pathexpr:
  _1 = relativepathexpr
    {      ( _1 )}
| _1 = SLASH
    {      ( mkexpr ERoot )}
| _1 = SLASH _2 = relativepathexpr
    {      ( match _2.pexpr_desc with
        | EPath(PSlash(e1, e2)) ->
            mkexpr (EPath(PSlash(mkexpr (EPath(PSlash(mkexpr ERoot, e1))), e2)))
	| EPath(PSlashSlash(e1, e2)) ->
            mkexpr (EPath(PSlashSlash(mkexpr (EPath(PSlash(mkexpr ERoot, e1))), e2)))
	| _ -> mkexpr (EPath (PSlash(mkexpr ERoot, _2))) )}
| _1 = SLASHSLASH _2 = relativepathexpr
    {      ( match _2.pexpr_desc with
        | EPath(PSlash(e1, e2)) ->
            mkexpr(EPath(PSlash(mkexpr (EPath(PSlashSlash(mkexpr ERoot,e1))),e2)))
	| EPath(PSlashSlash(e1, e2)) ->
            mkexpr(EPath(PSlashSlash(mkexpr (EPath(PSlashSlash(mkexpr ERoot,e1))),e2)))
	| _ -> mkexpr (EPath (PSlashSlash(mkexpr ERoot, _2))) )}

relativepathexpr:
  _1 = stepexpr
    {      ( _1 )}
| _1 = relativepathexpr _2 = SLASH _3 = stepexpr
    {      ( mkexpr (EPath (PSlash(_1, _3))) )}
| _1 = relativepathexpr _2 = SLASHSLASH _3 = stepexpr
    {      ( mkexpr (EPath (PSlashSlash(_1, _3))) )}

stepexpr:
  _1 = axisstepexpr
    {      ( _1 )}
| _1 = otherstepexpr
    {      ( _1 )}

axisstepexpr:
  _1 = AXIS _2 = nodetest
    {      ( let axis = _1 in
        mkexpr (EPath(PAxis (axis,_2))) )}
| _1 = AXIS _2 = nodetest _3 = stepqualifiers
    {      ( let axis = _1 in
        let axis_expr = mkexpr (EPath(PAxis (axis,_2))) in
        mkexpr (EPath(PStepQualifiers (false,axis_expr,_3))) )}
| _1 = ATSIGN _2 = nodetest
    {      ( mkexpr (EPath(PAxis (Attribute,_2))) )}
| _1 = ATSIGN _2 = nodetest _3 = stepqualifiers
    {      ( let axis_expr = mkexpr (EPath(PAxis (Attribute,_2))) in
        mkexpr (EPath(PStepQualifiers (false,axis_expr,_3))) )}

otherstepexpr:
  _1 = primaryexpr
    {      ( _1 )}
| _1 = primaryexpr _2 = stepqualifiers
    {      ( mkexpr (EPath (PStepQualifiers (true,_1,_2))) )}

stepqualifiers:
  _1 = LBRACK _2 = expr _3 = RBRACK
    {      ( let expr = mkexpr (EList _2) in
        (mkstep_qualifier (PredicateQualifier expr)) :: [] )}
| _1 = LBRACK _2 = expr _3 = RBRACK _4 = stepqualifiers
    {      ( let expr = mkexpr (EList _2) in
        (mkstep_qualifier (PredicateQualifier expr)) :: _4 )}

transform_copy_clause:
  _1 = COPYDOLLAR _2 = qname _3 = COLONEQUALS _4 = expr_single _5 = copyvar_clause
    {      ( (mkcopyvar_expr (_2, _4)) :: _5 )}

copyvar_clause:
  
    {      ( [] )}
| _1 = COMMA _2 = variable _3 = COLONEQUALS _4 = expr_single _5 = copyvar_clause
    {      ( (mkcopyvar_expr (_2, _4)) :: _5 )}

modify_clause:
  _1 = MODIFY _2 = expr_single
    {      ( _2 )}

primaryexpr:
  _1 = DOT
    {      ( mkexpr ESelf )}
| _1 = DOTDOT
    {      ( mkexpr EParent )}
| _1 = nodetest
    {      ( let nt = _1 in
        let axis = make_axis_from_nt nt in
        mkexpr (EPath(PAxis (axis,_1))) )}
| _1 = variable
    {      ( mkexpr (EVar _1) )}
| _1 = literal
    {      ( _1 )}
| _1 = FUNCTIONNAMELPAR _2 = RPAR
    {      ( mkexpr (EApp (_1,[])) )}
| _1 = FUNCTIONNAMELPAR _2 = expr _3 = RPAR
    {      ( mkexpr (EApp (_1,_2)) )}
| _1 = LPAR _2 = RPAR
    {      ( mkexpr (EList []) )}
| _1 = LPAR _2 = expr _3 = RPAR
    {      ( mkexpr (EList _2) )}
| _1 = VALIDATELCURLY _2 = expr _3 = RCURLY
    {      ( let expr = mkexpr (EList _2) in
        mkexpr (EValidate (None,expr)) )}
| _1 = VALIDATESTRICTLCURLY _2 = expr _3 = RCURLY
    {      ( let expr = mkexpr (EList _2) in
        mkexpr (EValidate (Some Strict,expr)) )}
| _1 = VALIDATELAXLCURLY _2 = expr _3 = RCURLY
    {      ( let expr = mkexpr (EList _2) in
        mkexpr (EValidate (Some Lax,expr)) )}
| _1 = DOCUMENTCURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EDocument _2) )}
| _1 = TEXTCURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (ETextComputed [mkexpr (EEnclosed (mkexpr (EList _2)))]) )}
| _1 = ELEMENTQNAMECURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EElemFixed (_1,[],_2)) )}
| _1 = ELEMENTQNAMECURLY _2 = RCURLY
    {      ( mkexpr (EElemFixed (_1,[],[])) )}
| _1 = ATTRIBUTEQNAMECURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EAttrFixed (_1,[mkexpr (EEnclosed (mkexpr (EList _2)))])) )}
| _1 = ATTRIBUTEQNAMECURLY _2 = RCURLY
    {      ( mkexpr (EAttrFixed (_1,[])) )}
| _1 = ELEMENTCURLY _2 = expr _3 = RCURLY _4 = LCURLY _5 = expr _6 = RCURLY
    {      ( mkexpr (EElemComputed (_2, _5)) )}
| _1 = ELEMENTCURLY _2 = expr _3 = RCURLY _4 = LCURLY _5 = RCURLY
    {      ( mkexpr (EElemComputed (_2, [])) )}
| _1 = ATTRIBUTECURLY _2 = expr _3 = RCURLY _4 = LCURLY _5 = expr _6 = RCURLY
    {      ( mkexpr (EAttrComputed (_2, _5)) )}
| _1 = ATTRIBUTECURLY _2 = expr _3 = RCURLY _4 = LCURLY _5 = RCURLY
    {      ( mkexpr (EAttrComputed (_2, [])) )}
| _1 = LOPENINGTAG _2 = qname _3 = attrlist _4 = REMPTYELEMENT
    {      ( mkexpr (EElemFixed (_2, _3, [])) )}
| _1 = LOPENINGTAG _2 = qname _3 = attrlist _4 = ROPENINGTAG _5 = elementcontent _6 = qname _7 = opt_whitespace _8 = RCLOSINGTAG
    {      ( let os = _2
	and cs = _6 in
        same_tag os cs;
        mkexpr (EElemFixed (os, _3, _5)) )}
| _1 = OPENINGPI _2 = TEXTCLOSINGPI
    {      ( mkexpr (EPI (_1,_2)) )}
| _1 = LOPENINGCOMMENT _2 = TEXTRCLOSINGCOMMENT
    {      ( mkexpr (EComment _2) )}
| _1 = COMMENTCURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (ECommentComputed _2) )}
| _1 = PICURLY _2 = expr _3 = RCURLY _4 = LCURLY _5 = expr _6 = RCURLY
    {      ( mkexpr (EPIComputed (_2, _5)) )}
| _1 = PINCNAMECURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EPIComputed([mkexpr (EScalar (StringLiteral _1))], _2)) )}
| _1 = PINCNAMECURLY _2 = RCURLY
    {      ( mkexpr (EPIComputed([mkexpr (EScalar (StringLiteral _1))], [])) )}
| _1 = ORDEREDCURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EOrdered _2) )}
| _1 = UNORDEREDCURLY _2 = expr _3 = RCURLY
    {      ( mkexpr (EUnordered _2) )}
| _1 = extensionexpr
    {      ( mkexpr (EList _1) )}
| _1 = COPYLCURLY _2 = expr_single _3 = RCURLY
    {      ( mkexpr (ECopy _2) )}
| _1 = SNAPLCURLY _2 = expr _3 = RCURLY
    {      ( let expr = mkexpr (EList _2) in
	  mkexpr (ESnap (Snap_Unordered_Deterministic, expr)) )}
| _1 = SNAPLCURLYORDERED _2 = expr _3 = RCURLY
    {      ( let expr = mkexpr (EList _2) in
	  mkexpr (ESnap (Snap_Ordered_Deterministic, expr)) )}
| _1 = LCURLY _2 = block _3 = RCURLY
    {      ( wrap_p (fun () -> _2) )}

extensionexpr:
  _1 = PRAGMA _2 = LCURLY _3 = expr _4 = RCURLY
    {      ( let (name,content) = _1 in
        check_pragma_content content;
        mkexpr (EPragma(name,content,_3)) :: [] )}
| _1 = PRAGMA _2 = extensionexpr
    {      ( let (name,content) = _1 in
        check_pragma_content content;
        mkexpr (EPragma(name,content,_2)) :: [] )}

expr:
  _1 = expr_single
    {      ( _1 :: [] )}
| _1 = expr_single _2 = COMMA _3 = expr
    {      ( _1 :: _3 )}

block:
  _1 = block_decl_list _2 = block_exprs
    {      ( mkexpr(EBlock (_1,_2)) )}

block_exprs:
  _1 = expr _2 = SEMICOLON _3 = block_exprs
    {      ( wrap_p (fun () -> (mkexpr (EList _1)) :: _3) )}
| _1 = expr
    {      ( mkexpr (EList _1) :: [] )}

block_sub_decl:
  
    {      ([])}
| _1 = COMMA _2 = variable _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr_single _6 = block_sub_decl
    {      ( (mkblock_decl_expr (_3,_2,_5)) :: _6 )}

block_decl:
  _1 = DECLAREDOLLAR _2 = qname _3 = opt_type_declaration _4 = COLONEQUALS _5 = expr_single _6 = block_sub_decl
    {      ( (mkblock_decl_expr (_3,_2,_5)) :: _6 )}

block_decl_list:
  _1 = block_decl _2 = SEMICOLON _3 = block_decl_list
    {      ( wrap_p (fun () -> _1 @ _3 ))}
| 
    {      ( [] )}

variable:
  _1 = VARNAME
    {      ( _1 )}
| _1 = DOLLAR _2 = qname
    {      ( _2 )}

literal:
  _1 = numericliteral
    {      ( _1 )}
| _1 = stringliteral
    {      ( _1 )}

numericliteral:
  _1 = integer
    {      ( mkexpr (EScalar (IntegerLiteral _1)) )}
| _1 = decimal
    {      ( mkexpr (EScalar (DecimalLiteral _1)) )}
| _1 = DOUBLE
    {      ( mkexpr (EScalar (DoubleLiteral _1)) )}

stringliteral:
  _1 = STRING
    {      ( mkexpr (EScalar (StringLiteral _1)) )}

nodetest:
  _1 = nametest
    {      ( (PNameTest _1) )}
| _1 = kindtest _2 = RPAR
    {      ( (PNodeKindTest (_1)) )}

nametest:
  _1 = qname
    {      ( _1 )}
| _1 = wildcard
    {      ( _1 )}

qname:
  _1 = NCNAME
    {      ( (NSDefaultElementPrefix,_1) )}
| _1 = QNAME
    {      ( _1 )}

wildcard:
  _1 = STAR
    {      ( (NSWildcardPrefix,"*") )}
| _1 = NCNAMESTAR
    {      ( (NSPrefix _1,"*") )}
| _1 = STARNCNAME
    {      ( (NSWildcardPrefix, _1) )}

attrlist:
  
    {      ( [] )}
| _1 = S
    {      ( [] )}
| _1 = S _2 = qname _3 = eq _4 = attributecontent _5 = attrlist
    {      ( let previous_attributes = _5 in
        let qname = _2 in
        let real_att_content =
          let att_content = _4 in
	  if att_content = []
          then [(mkexpr (EText ""))]
	  else att_content
        in
        (mkexpr (EAttrFixed (qname,real_att_content))) :: previous_attributes )}

attributecontent:
  _1 = ATTRIBUTETEXT
    {      ( let text = _1 in
        if text = "" then
	  []
	else
	  (mkexpr (EText _1)) :: [] )}
| _1 = ATTRIBUTETEXTLCURLY _2 = expr _3 = RCURLY _4 = attributecontent
    {      (
        (mkexpr (EText _1)) :: (mkexpr (EEnclosed (mkexpr (EList _2)))) :: _4
      )}
| _1 = TEXTCHARREF _2 = attributecontent
    {      ( let (text,charref) = _1 in
        (mkexpr (EText text)) :: (mkexpr (ECharRef charref)) :: _2 )}
| _1 = TEXTENTITYREF _2 = attributecontent
    {      ( let (text,entityref) = _1 in
        let entity_ref_text = Parse_context.get_general_entity xquery_parse_context (Finfo.parsing_locinfo ()) entityref in
	(mkexpr (EText text)) :: (mkexpr (EText entity_ref_text)) :: _2 )}

elementcontent:
  _1 = TEXTLCLOSINGTAG
    {      ( (mkexpr (EText _1)) :: [] )}
| _1 = LCLOSINGTAG
    {      ( [] )}
| _1 = TEXTLCURLY _2 = expr _3 = RCURLY _4 = elementcontent
    {      ( (mkexpr (EText _1)) :: (mkexpr (EEnclosed(mkexpr (EList _2)))) :: _4 )}
| _1 = TEXTLOPENINGTAG _2 = qname _3 = attrlist _4 = REMPTYELEMENT _5 = elementcontent
    {      ( (mkexpr (EText _1)) :: (mkexpr (EElemFixed (_2, _3, []))) :: _5 )}
| _1 = TEXTLOPENINGTAG _2 = qname _3 = attrlist _4 = ROPENINGTAG _5 = elementcontent _6 = qname _7 = opt_whitespace _8 = RCLOSINGTAG _9 = elementcontent
    {      ( let os = _2
	and cs = _6 in
        same_tag os cs;
        (mkexpr (EText _1)) :: (mkexpr (EElemFixed (_2, _3, _5))) :: _9 )}
| _1 = TEXTOPENINGPI _2 = TEXTCLOSINGPI _3 = elementcontent
    {      ( let (text,target_pi) = _1
	in (mkexpr (EText text)) :: (mkexpr (EPI (target_pi, _2))) :: _3 )}
| _1 = TEXTLOPENINGCOMMENT _2 = TEXTRCLOSINGCOMMENT _3 = elementcontent
    {      ( (mkexpr (EText _1)) :: (mkexpr (EComment (_2))) :: _3 )}
| _1 = TEXTCHARREF _2 = elementcontent
    {      ( let (text,charref) = _1 in
        (mkexpr (EText text)) :: (mkexpr (ECharRef charref)) :: _2 )}
| _1 = TEXTENTITYREF _2 = elementcontent
    {      ( let (text,entityref) = _1 in
        let entity_ref_text = Parse_context.get_general_entity xquery_parse_context (Finfo.parsing_locinfo ()) entityref in
        (mkexpr (EText text)) :: (mkexpr (EText entity_ref_text)) :: _2 )}

opt_whitespace:
  
    {      ( () )}
| _1 = S
    {      ( () )}

eq:
  _1 = EQUALS
    {           ( () )}
| _1 = S _2 = EQUALS
    {             ( () )}
| _1 = EQUALS _2 = S
    {             ( () )}
| _1 = S _2 = EQUALS _3 = S
    {               ( () )}

start_declare_fun:
  _1 = DECLAREFUNCTION
    {      ( NonUpdating )}
| _1 = DECLAREUPDATINGFUNCTION
    {      ( Updating )}

nillable:
  
    {      ( NonNillable )}
| _1 = NILLABLE
    {      ( Nillable )}

nested_stype_spec:
  _1 = qname
    {      ( mkstype_specifier (STypeRef _1) )}
| _1 = stype_derivation
    {      ( mkstype_specifier (SAnonymous _1) )}

stype_specifier_union:
  _1 = NONE
    {      ( [] )}
| _1 = nested_stype_spec
    {      ( _1 :: [] )}
| _1 = nested_stype_spec _2 = BAR _3 = stype_specifier_union
    {      ( _1 :: _3 )}

stype_derivation:
  _1 = RESTRICTS _2 = nested_stype_spec
    {      ( SRestriction _2 )}
| _1 = LISTOF _2 = nested_stype_spec
    {      ( SList _2 )}
| _1 = UNIONOF _2 = LCURLY _3 = stype_specifier_union _4 = RCURLY
    {      ( SUnion _3 )}

stype_specifier:
  _1 = OFSIMPLETYPE _2 = qname
    {      ( let ssd = STypeRef _2 in
        mkstype_specifier ssd )}
| _1 = stype_derivation
    {      ( let ssd = SAnonymous _1 in
        mkstype_specifier ssd )}

deriv_mixed:
  
    {      ( (None,NonMixed) )}
| _1 = MIXED
    {      ( (None,Mixed) )}
| _1 = RESTRICTS _2 = qname
    {      ( (Some (TRestriction _2), NonMixed) )}
| _1 = EXTENDS _2 = qname
    {      ( (Some (TExtension _2), NonMixed) )}
| _1 = RESTRICTS _2 = qname _3 = MIXED
    {      ( (Some (TRestriction _2), Mixed) )}
| _1 = EXTENDS _2 = qname _3 = MIXED
    {      ( (Some (TExtension _2), Mixed) )}

extype:
  _1 = xtype
    {      ( (None,_1) )}
| _1 = xtype _2 = SEMICOLON _3 = axtype
    {      ( (Some _1,_3) )}

ctype_derivation:
  _1 = deriv_mixed _2 = LCURLY _3 = extype _4 = RCURLY
    {      ( let (deriv,mixed) = _1 in
        let (attr_xtype,elem_xtype) = _3 in
        (deriv,attr_xtype,mixed,elem_xtype) )}

ctype_specifier:
  _1 = OFTYPE _2 = qname
    {      ( let csd = TTypeRef _2 in
        mkctype_specifier csd )}
| _1 = ctype_derivation
    {      ( let csd = TAnonymous _1 in
        mkctype_specifier csd )}

xtype_specifier:
  _1 = stype_specifier
    {      ( TSpecSimple _1 )}
| _1 = ctype_specifier
    {      ( TSpecComplex _1 )}

axtype:
  _1 = ATTRIBUTE _2 = qname
    {      ( mkxtype (TAttributeRef (_2)) )}
| _1 = ATTRIBUTE _2 = nameclass _3 = stype_specifier
    {      ( mkxtype (TAttributeLocal (_2,_3)) )}
| _1 = ATTRGROUP _2 = qname
    {      ( mkxtype (TAttrGroupRef _2) )}
| _1 = axtype _2 = QUESTION
    {      ( mkxtype (TBound (_1,Occurrence.occurs 0, Occurrence.occurs 1)) )}
| _1 = axtype _2 = COMMA _3 = axtype
    {      ( mkxtype (TSequence (_1,_3)) )}
| _1 = LPAR _2 = RPAR
    {      ( mkxtype TEmpty )}
| _1 = axtype _2 = AMPERSAND _3 = axtype
    {      ( mkxtype (TInterleave (_1,_3)) )}
| _1 = LPAR _2 = axtype _3 = RPAR
    {      ( _2 )}

xtype:
  _1 = qname
    {      ( mkxtype (TAtomicRef _1) )}
| _1 = ELEMENT _2 = qname
    {      ( mkxtype (TElementRef _2) )}
| _1 = ELEMENT _2 = nameclass _3 = nillable _4 = xtype_specifier
    {      ( mkxtype (TElementLocal (_2, _3, _4)) )}
| _1 = DOCUMENT _2 = LCURLY _3 = xtype _4 = RCURLY
    {      ( mkxtype (TDocument _3) )}
| _1 = TEXT
    {      ( mkxtype (TText) )}
| _1 = PROCESSINGINSTRUCTION
    {      ( mkxtype (TProcessingInstruction) )}
| _1 = COMMENT
    {      ( mkxtype (TComment) )}
| _1 = GROUP _2 = qname
    {      ( mkxtype (TGroupRef _2) )}
| _1 = ATTRGROUP _2 = qname
    {      ( mkxtype (TAttrGroupRef _2) )}
| _1 = xtype _2 = STAR
    {      ( mkxtype (TBound (_1,Occurrence.occurs 0, Occurrence.unbounded)) )}
| _1 = xtype _2 = PLUS
    {      ( mkxtype (TBound (_1,Occurrence.occurs 1, Occurrence.unbounded)) )}
| _1 = xtype _2 = QUESTION
    {      ( mkxtype (TBound (_1,Occurrence.occurs 0, Occurrence.occurs 1)) )}
| _1 = xtype _2 = COMMA _3 = xtype
    {      ( mkxtype (TSequence (_1,_3)) )}
| _1 = LPAR _2 = RPAR
    {      ( mkxtype TEmpty )}
| _1 = xtype _2 = BAR _3 = xtype
    {      ( mkxtype (TChoice (_1,_3)) )}
| _1 = NONE
    {      ( mkxtype TNone )}
| _1 = xtype _2 = AMPERSAND _3 = xtype
    {      ( mkxtype (TInterleave (_1,_3)) )}
| _1 = LPAR _2 = xtype _3 = RPAR
    {      ( _2 )}

sequencetype:
  _1 = EMPTYSEQUENCELPAR _2 = RPAR
    {      ( mksequencetype(ITEmpty, None) )}
| _1 = qname_occurrence
    {      ( _1 )}
| _1 = itemtype _2 = RPAR _3 = item_occurrence
    {      ( mksequencetype(_1, _3) )}

item_occurrence:
  
    {    ( None )}
| _1 = ISTAR
    {      ( Some(Occurrence.occurs 0, Occurrence.unbounded) )}
| _1 = IPLUS
    {      ( Some(Occurrence.occurs 1, Occurrence.unbounded) )}
| _1 = QUESTION
    {      ( Some(Occurrence.occurs 0, Occurrence.occurs 1) )}

singletype:
  _1 = QNAME
    {      ( mksequencetype(ITAtomic _1,None) )}
| _1 = QNAMEQUESTION
    {      ( mksequencetype(ITAtomic _1,Some(Occurrence.occurs 0, Occurrence.occurs 1)) )}

opt_type_declaration:
  
    {      ( None )}
| _1 = AS _2 = sequencetype
    {      ( Some _2 )}

optelementref:
  
    {      ( None )}
| _1 = STAR
    {      ( None )}
| _1 = qname
    {      ( (Some (_1,None)) )}
| _1 = STAR _2 = COMMA _3 = qname
    {      ( (Some ((NSWildcardPrefix,"*"), Some _3)) )}
| _1 = qname _2 = COMMA _3 = qname
    {      ( (Some (_1,Some _3)) )}

optattributeref:
  
    {      ( None )}
| _1 = STAR
    {      ( None )}
| _1 = qname
    {      ( (Some (_1,None)) )}
| _1 = STAR _2 = COMMA _3 = qname
    {      ( (Some ((NSWildcardPrefix,"*"), Some _3)) )}
| _1 = qname _2 = COMMA _3 = qname
    {      ( (Some (_1,Some _3)) )}

qname_occurrence:
  _1 = QNAME
    {      ( mksequencetype(ITAtomic _1,None) )}
| _1 = QNAMESTAR
    {      ( mksequencetype(ITAtomic _1,Some(Occurrence.occurs 0, Occurrence.unbounded)) )}
| _1 = QNAMEPLUS
    {      ( mksequencetype(ITAtomic _1,Some(Occurrence.occurs 1, Occurrence.unbounded)) )}
| _1 = QNAMEQUESTION
    {      ( mksequencetype(ITAtomic _1,Some(Occurrence.occurs 0, Occurrence.occurs 1)) )}

documentnode_kindtest:
  _1 = ELEMENTLPAR _2 = optelementref _3 = RPAR
    {      ( (ElementTest _2) )}
| _1 = SCHEMAELEMENTLPAR _2 = qname _3 = RPAR
    {      ( (SchemaElementTest _2) )}

kindtest:
  _1 = ELEMENTLPAR _2 = optelementref
    {      ( ElementKind (ElementTest _2) )}
| _1 = SCHEMAELEMENTLPAR _2 = qname
    {      ( ElementKind (SchemaElementTest _2) )}
| _1 = ATTRIBUTELPAR _2 = optattributeref
    {      ( AttributeKind (AttributeTest _2) )}
| _1 = SCHEMAATTRIBUTELPAR _2 = qname
    {      ( AttributeKind (SchemaAttributeTest _2) )}
| _1 = NODELPAR
    {      ( AnyKind )}
| _1 = TEXTLPAR
    {      ( TextKind )}
| _1 = COMMENTLPAR
    {      ( CommentKind )}
| _1 = PROCESSINGINSTRUCTIONLPAR
    {      ( PIKind None )}
| _1 = PROCESSINGINSTRUCTIONLPAR _2 = NCNAME
    {      ( PIKind (Some _2) )}
| _1 = PROCESSINGINSTRUCTIONLPAR _2 = STRING
    {      ( let ncname = Datatypes_util.normalize_pi_test _2 in PIKind (Some ncname) )}
| _1 = DOCUMENTNODELPAR
    {      ( DocumentKind (None) )}
| _1 = DOCUMENTNODELPAR _2 = documentnode_kindtest
    {      ( DocumentKind (Some (_2)) )}

itemtype:
  _1 = kindtest
    {      ( ITKindTest _1 )}
| _1 = TYPELPAR _2 = qname
    {      ( ITTypeRef _2 )}
| _1 = ITEMLPAR
    {      ( ITItem )}
| _1 = NUMERICLPAR
    {      ( ITNumeric )}
| _1 = ANYSTRINGLPAR
    {      ( ITAnyString )}

substitutes_for_nillable:
  
    {      ( (TNonSubstitutesFor,NonNillable) )}
| _1 = SUBSTITUTESFOR _2 = qname
    {      ( (TSubstitutesFor _2,NonNillable) )}
| _1 = NILLABLE
    {      ( (TNonSubstitutesFor,Nillable) )}
| _1 = SUBSTITUTESFOR _2 = qname _3 = NILLABLE
    {      ( (TSubstitutesFor _2,Nillable) )}

xelem_derivation:
  _1 = substitutes_for_nillable _2 = xtype_specifier
    {      ( let (sf,nil) = _1 in
        (sf,nil,_2) )}

namespace_decls:
  
    {      ( [] )}
| _1 = DECLARENAMESPACE _2 = NCNAME _3 = EQUALS _4 = STRING _5 = SEMICOLON _6 = namespace_decls
    {      ( (_2,NSUri _4) :: _6 )}

type_decls:
  
    {      ( [] )}
| _1 = typedefinition _2 = type_decls
    {      ( _1 :: _2 )}

typedefinition:
  _1 = DECLAREATTRIBUTE _2 = stype_specifier _3 = SEMICOLON
    {      ( mkissd (TAttributeDecl (_1,_2)) )}
| _1 = DECLAREELEMENT _2 = xelem_derivation _3 = SEMICOLON
    {      ( mkissd (TElementDecl (_1,_2)) )}
| _1 = DECLARESIMPLETYPE _2 = stype_derivation _3 = SEMICOLON
    {      ( mkissd (TTypeDecl (_1,TSimpleDerivation _2)) )}
| _1 = DECLARECOMPLEXTYPE _2 = ctype_derivation _3 = SEMICOLON
    {      ( mkissd (TTypeDecl (_1,TComplexDerivation _2)) )}
| _1 = DECLAREGROUP _2 = LCURLY _3 = xtype _4 = RCURLY _5 = SEMICOLON
    {      ( mkissd (TGroupDecl (_1,_3)) )}
| _1 = DECLAREATTRGROUP _2 = LCURLY _3 = axtype _4 = RCURLY _5 = SEMICOLON
    {      ( mkissd (TAttrGroupDecl (_1,_3)) )}

schema_decl:
  _1 = DECLARESCHEMALCURLY _2 = namespace_decls _3 = schema_decls _4 = type_decls _5 = RCURLY _6 = SEMICOLON
    {      ( let nss = _2
        and schemas = _3
        and issds = _4 in
        fmkschema schemas nss issds )}

schema_decls:
  
    {      ( [] )}
| _1 = schema_decl _2 = schema_decls
    {      ( _1 :: _2 )}

nameclass:
  _1 = qname
    {      ( _1 )}
| _1 = wildcard
    {      ( _1 )}

integer:
  _1 = INT
    {        ( _1 )}

decimal:
  _1 = DECIMAL
    {            ( _1 )}

stringlit:
  _1 = STRING
    {           ( _1 )}

%%
