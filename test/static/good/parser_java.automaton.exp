State 0:
## Known stack suffix:
##
## LR(1) items:
goal' -> . goal [ # ]
## Transitions:
-- On PACKAGE shift to state 1
-- On package_declaration_opt shift to state 33
-- On package_declaration shift to state 753
-- On goal shift to state 754
-- On compilation_unit shift to state 755
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production package_declaration_opt ->

State 1:
## Known stack suffix:
## PACKAGE
## LR(1) items:
package_declaration -> PACKAGE . name SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On name shift to state 3
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 2:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT2 LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EXTENDS EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT2 LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EXTENDS EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production identifier -> IDENTIFIER

State 3:
## Known stack suffix:
## PACKAGE name
## LR(1) items:
name -> name . DOT identifier_ [ SM DOT ]
name -> name . DOT LT2 type_arguments GT identifier_ [ SM DOT ]
package_declaration -> PACKAGE name . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 4
-- On DOT shift to state 5
## Reductions:

State 4:
## Known stack suffix:
## PACKAGE name SM
## LR(1) items:
package_declaration -> PACKAGE name SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production package_declaration -> PACKAGE name SM

State 5:
## Known stack suffix:
## name DOT
## LR(1) items:
name -> name DOT . identifier_ [ XOR VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE OR_OR OR NOT_EQ NATIVE LT LP LE LC LB_RB LB INTERFACE INSTANCEOF IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ ENUM DOTS DOT COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
name -> name DOT . LT2 type_arguments GT identifier_ [ XOR VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE OR_OR OR NOT_EQ NATIVE LT LP LE LC LB_RB LB INTERFACE INSTANCEOF IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ ENUM DOTS DOT COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
-- On LT2 shift to state 6
-- On IDENTIFIER shift to state 2
-- On identifier_ shift to state 32
-- On identifier shift to state 15
## Reductions:

State 6:
## Known stack suffix:
## name DOT LT2
## LR(1) items:
name -> name DOT LT2 . type_arguments GT identifier_ [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On COND shift to state 8
-- On type_arguments shift to state 29
-- On type_argument shift to state 26
-- On reference_type shift to state 21
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 7:
## Known stack suffix:
## PRIMITIVE_TYPE
## LR(1) items:
primitive_type -> PRIMITIVE_TYPE . [ RP LC LB_RB LB IMPLEMENTS IDENTIFIER DOTS DOT ]
## Transitions:
## Reductions:
-- On RP LC LB_RB LB IMPLEMENTS IDENTIFIER DOTS DOT
--   reduce production primitive_type -> PRIMITIVE_TYPE

State 8:
## Known stack suffix:
## COND
## LR(1) items:
type_argument -> COND . [ GT CM ]
type_argument -> COND . EXTENDS reference_type [ GT CM ]
type_argument -> COND . SUPER reference_type [ GT CM ]
## Transitions:
-- On SUPER shift to state 9
-- On EXTENDS shift to state 27
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND

State 9:
## Known stack suffix:
## COND SUPER
## LR(1) items:
type_argument -> COND SUPER . reference_type [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 10
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 10:
## Known stack suffix:
## COND SUPER reference_type
## LR(1) items:
type_argument -> COND SUPER reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND SUPER reference_type

State 11:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 12
## Reductions:

State 12:
## Known stack suffix:
## primitive_type LB_RB
## LR(1) items:
array_type -> primitive_type LB_RB . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND
--   reduce production array_type -> primitive_type LB_RB

State 13:
## Known stack suffix:
## name
## LR(1) items:
class_or_interface_type -> name . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS COND COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND ]
name -> name . DOT LT2 type_arguments GT identifier_ [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 5
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS COND COLON CM AND_AND AND
--   reduce production class_or_interface_type -> name

State 14:
## Known stack suffix:
## identifier_
## LR(1) items:
name -> identifier_ . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production name -> identifier_

State 15:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
identifier_ -> identifier . LT2 type_arguments GT [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
-- On LT2 shift to state 16
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production identifier_ -> identifier

State 16:
## Known stack suffix:
## identifier LT2
## LR(1) items:
identifier_ -> identifier LT2 . type_arguments GT [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On COND shift to state 8
-- On type_arguments shift to state 17
-- On type_argument shift to state 26
-- On reference_type shift to state 21
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 17:
## Known stack suffix:
## identifier LT2 type_arguments
## LR(1) items:
identifier_ -> identifier LT2 type_arguments . GT [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
type_arguments -> type_arguments . CM type_argument [ GT CM ]
## Transitions:
-- On GT shift to state 18
-- On CM shift to state 19
## Reductions:

State 18:
## Known stack suffix:
## identifier LT2 type_arguments GT
## LR(1) items:
identifier_ -> identifier LT2 type_arguments GT . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production identifier_ -> identifier LT2 type_arguments GT

State 19:
## Known stack suffix:
## type_arguments CM
## LR(1) items:
type_arguments -> type_arguments CM . type_argument [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On COND shift to state 8
-- On type_argument shift to state 20
-- On reference_type shift to state 21
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 20:
## Known stack suffix:
## type_arguments CM type_argument
## LR(1) items:
type_arguments -> type_arguments CM type_argument . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_arguments -> type_arguments CM type_argument

State 21:
## Known stack suffix:
## reference_type
## LR(1) items:
type_argument -> reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> reference_type

State 22:
## Known stack suffix:
## class_or_interface_type
## LR(1) items:
array_type -> class_or_interface_type . LB_RB [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
reference_type -> class_or_interface_type . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 23
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production reference_type -> class_or_interface_type

State 23:
## Known stack suffix:
## class_or_interface_type LB_RB
## LR(1) items:
array_type -> class_or_interface_type LB_RB . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND
--   reduce production array_type -> class_or_interface_type LB_RB

State 24:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
reference_type -> array_type . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 25
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production reference_type -> array_type

State 25:
## Known stack suffix:
## array_type LB_RB
## LR(1) items:
array_type -> array_type LB_RB . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND
--   reduce production array_type -> array_type LB_RB

State 26:
## Known stack suffix:
## type_argument
## LR(1) items:
type_arguments -> type_argument . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_arguments -> type_argument

State 27:
## Known stack suffix:
## COND EXTENDS
## LR(1) items:
type_argument -> COND EXTENDS . reference_type [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 28
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 28:
## Known stack suffix:
## COND EXTENDS reference_type
## LR(1) items:
type_argument -> COND EXTENDS reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND EXTENDS reference_type

State 29:
## Known stack suffix:
## name DOT LT2 type_arguments
## LR(1) items:
name -> name DOT LT2 type_arguments . GT identifier_ [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
type_arguments -> type_arguments . CM type_argument [ GT CM ]
## Transitions:
-- On GT shift to state 30
-- On CM shift to state 19
## Reductions:

State 30:
## Known stack suffix:
## name DOT LT2 type_arguments GT
## LR(1) items:
name -> name DOT LT2 type_arguments GT . identifier_ [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier_ shift to state 31
-- On identifier shift to state 15
## Reductions:

State 31:
## Known stack suffix:
## name DOT LT2 type_arguments GT identifier_
## LR(1) items:
name -> name DOT LT2 type_arguments GT identifier_ . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production name -> name DOT LT2 type_arguments GT identifier_

State 32:
## Known stack suffix:
## name DOT identifier_
## LR(1) items:
name -> name DOT identifier_ . [ XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
--   reduce production name -> name DOT identifier_

State 33:
## Known stack suffix:
## package_declaration_opt
## LR(1) items:
compilation_unit -> package_declaration_opt . import_declarations_opt type_declarations_opt [ EOF ]
## Transitions:
-- On IMPORT shift to state 34
-- On import_declarations_opt shift to state 42
-- On import_declarations shift to state 750
-- On import_declaration shift to state 752
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declarations_opt ->

State 34:
## Known stack suffix:
## IMPORT
## LR(1) items:
import_declaration -> IMPORT . static_opt name SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
import_declaration -> IMPORT . static_opt name DOT TIMES SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On STATIC shift to state 35
-- On static_opt shift to state 36
## Reductions:
-- On IDENTIFIER
--   reduce production static_opt ->

State 35:
## Known stack suffix:
## STATIC
## LR(1) items:
static_opt -> STATIC . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production static_opt -> STATIC

State 36:
## Known stack suffix:
## IMPORT static_opt
## LR(1) items:
import_declaration -> IMPORT static_opt . name SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
import_declaration -> IMPORT static_opt . name DOT TIMES SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On name shift to state 37
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 37:
## Known stack suffix:
## IMPORT static_opt name
## LR(1) items:
import_declaration -> IMPORT static_opt name . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
import_declaration -> IMPORT static_opt name . DOT TIMES SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
name -> name . DOT identifier_ [ SM DOT ]
name -> name . DOT LT2 type_arguments GT identifier_ [ SM DOT ]
## Transitions:
-- On SM shift to state 38
-- On DOT shift to state 39
## Reductions:

State 38:
## Known stack suffix:
## IMPORT static_opt name SM
## LR(1) items:
import_declaration -> IMPORT static_opt name SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declaration -> IMPORT static_opt name SM

State 39:
## Known stack suffix:
## IMPORT static_opt name DOT
## LR(1) items:
import_declaration -> IMPORT static_opt name DOT . TIMES SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
name -> name DOT . identifier_ [ SM DOT ]
name -> name DOT . LT2 type_arguments GT identifier_ [ SM DOT ]
## Transitions:
-- On TIMES shift to state 40
-- On LT2 shift to state 6
-- On IDENTIFIER shift to state 2
-- On identifier_ shift to state 32
-- On identifier shift to state 15
## Reductions:

State 40:
## Known stack suffix:
## IMPORT static_opt name DOT TIMES
## LR(1) items:
import_declaration -> IMPORT static_opt name DOT TIMES . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## IMPORT static_opt name DOT TIMES SM
## LR(1) items:
import_declaration -> IMPORT static_opt name DOT TIMES SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declaration -> IMPORT static_opt name DOT TIMES SM

State 42:
## Known stack suffix:
## package_declaration_opt import_declarations_opt
## LR(1) items:
compilation_unit -> package_declaration_opt import_declarations_opt . type_declarations_opt [ EOF ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 48
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On type_declarations_opt shift to state 741
-- On type_declarations shift to state 742
-- On type_declaration shift to state 749
-- On modifiers_opt shift to state 744
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_declaration shift to state 745
-- On enum_declaration shift to state 746
-- On class_declaration shift to state 747
-- On annotation_type_declaration shift to state 748
-- On annotation shift to state 365
## Reductions:
-- On INTERFACE ENUM CLASS
--   reduce production modifiers_opt ->
-- On EOF
--   reduce production type_declarations_opt ->

State 43:
## Known stack suffix:
## VOLATILE
## LR(1) items:
modifier -> VOLATILE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> VOLATILE

State 44:
## Known stack suffix:
## TRANSIENT
## LR(1) items:
modifier -> TRANSIENT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> TRANSIENT

State 45:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
modifier -> SYNCHRONIZED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> SYNCHRONIZED

State 46:
## Known stack suffix:
## STRICTFP
## LR(1) items:
modifier -> STRICTFP . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> STRICTFP

State 47:
## Known stack suffix:
## STATIC
## LR(1) items:
modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> STATIC

State 48:
## Known stack suffix:
## SM
## LR(1) items:
type_declaration -> SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declaration -> SM

State 49:
## Known stack suffix:
## PUBLIC
## LR(1) items:
modifier -> PUBLIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> PUBLIC

State 50:
## Known stack suffix:
## PROTECTED
## LR(1) items:
modifier -> PROTECTED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> PROTECTED

State 51:
## Known stack suffix:
## PRIVATE
## LR(1) items:
modifier -> PRIVATE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> PRIVATE

State 52:
## Known stack suffix:
## NATIVE
## LR(1) items:
modifier -> NATIVE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> NATIVE

State 53:
## Known stack suffix:
## FINAL
## LR(1) items:
modifier -> FINAL . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> FINAL

State 54:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . name [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
annotation -> AT . name LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
annotation_type_declaration -> AT . INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On INTERFACE shift to state 55
-- On IDENTIFIER shift to state 2
-- On name shift to state 97
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 55:
## Known stack suffix:
## AT INTERFACE
## LR(1) items:
annotation_type_declaration -> AT INTERFACE . identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 56
## Reductions:

State 56:
## Known stack suffix:
## AT INTERFACE identifier
## LR(1) items:
annotation_type_declaration -> AT INTERFACE identifier . annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 57
-- On annotation_type_body shift to state 740
## Reductions:

State 57:
## Known stack suffix:
## LC
## LR(1) items:
annotation_type_body -> LC . annotation_type_element_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 59
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_declaration shift to state 730
-- On enum_declaration shift to state 731
-- On class_declaration shift to state 732
-- On annotation_type_element_rest shift to state 733
-- On annotation_type_element_declarations_opt shift to state 734
-- On annotation_type_element_declarations shift to state 736
-- On annotation_type_element_declaration shift to state 739
-- On annotation_type_declaration shift to state 738
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production annotation_type_element_declarations_opt ->
-- On PRIMITIVE_TYPE INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 58:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
modifier -> ABSTRACT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> ABSTRACT

State 59:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
annotation_type_element_rest -> modifiers_opt . type_java identifier annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
class_declaration -> modifiers_opt . CLASS identifier type_parameters_opt super_opt interfaces_opt class_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
enum_declaration -> modifiers_opt . ENUM identifier interfaces_opt enum_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_declaration -> modifiers_opt . INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On INTERFACE shift to state 60
-- On IDENTIFIER shift to state 2
-- On ENUM shift to state 492
-- On CLASS shift to state 449
-- On type_java shift to state 722
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 60:
## Known stack suffix:
## modifiers_opt INTERFACE
## LR(1) items:
interface_declaration -> modifiers_opt INTERFACE . identifier type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## modifiers_opt INTERFACE identifier
## LR(1) items:
interface_declaration -> modifiers_opt INTERFACE identifier . type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LT shift to state 62
-- On type_parameters_opt shift to state 75
-- On type_parameters shift to state 464
## Reductions:
-- On LC EXTENDS
--   reduce production type_parameters_opt ->

State 62:
## Known stack suffix:
## LT
## LR(1) items:
type_parameters -> LT . type_parameters_bis GT [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On type_parameters_bis shift to state 63
-- On type_parameter shift to state 74
-- On identifier shift to state 67
## Reductions:

State 63:
## Known stack suffix:
## LT type_parameters_bis
## LR(1) items:
type_parameters -> LT type_parameters_bis . GT [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS ]
type_parameters_bis -> type_parameters_bis . CM type_parameter [ GT CM ]
## Transitions:
-- On GT shift to state 64
-- On CM shift to state 65
## Reductions:

State 64:
## Known stack suffix:
## LT type_parameters_bis GT
## LR(1) items:
type_parameters -> LT type_parameters_bis GT . [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS ]
## Transitions:
## Reductions:
-- On VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS
--   reduce production type_parameters -> LT type_parameters_bis GT

State 65:
## Known stack suffix:
## type_parameters_bis CM
## LR(1) items:
type_parameters_bis -> type_parameters_bis CM . type_parameter [ GT CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On type_parameter shift to state 66
-- On identifier shift to state 67
## Reductions:

State 66:
## Known stack suffix:
## type_parameters_bis CM type_parameter
## LR(1) items:
type_parameters_bis -> type_parameters_bis CM type_parameter . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_parameters_bis -> type_parameters_bis CM type_parameter

State 67:
## Known stack suffix:
## identifier
## LR(1) items:
type_parameter -> identifier . [ GT CM ]
type_parameter -> identifier . EXTENDS bound [ GT CM ]
## Transitions:
-- On EXTENDS shift to state 68
## Reductions:
-- On GT CM
--   reduce production type_parameter -> identifier

State 68:
## Known stack suffix:
## identifier EXTENDS
## LR(1) items:
type_parameter -> identifier EXTENDS . bound [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 69
-- On ref_type_and_list shift to state 70
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On bound shift to state 73
-- On array_type shift to state 24
## Reductions:

State 69:
## Known stack suffix:
## reference_type
## LR(1) items:
ref_type_and_list -> reference_type . [ GT CM AND ]
## Transitions:
## Reductions:
-- On GT CM AND
--   reduce production ref_type_and_list -> reference_type

State 70:
## Known stack suffix:
## ref_type_and_list
## LR(1) items:
bound -> ref_type_and_list . [ GT CM ]
ref_type_and_list -> ref_type_and_list . AND reference_type [ GT CM AND ]
## Transitions:
-- On AND shift to state 71
## Reductions:
-- On GT CM
--   reduce production bound -> ref_type_and_list

State 71:
## Known stack suffix:
## ref_type_and_list AND
## LR(1) items:
ref_type_and_list -> ref_type_and_list AND . reference_type [ GT CM AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 72
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 72:
## Known stack suffix:
## ref_type_and_list AND reference_type
## LR(1) items:
ref_type_and_list -> ref_type_and_list AND reference_type . [ GT CM AND ]
## Transitions:
## Reductions:
-- On GT CM AND
--   reduce production ref_type_and_list -> ref_type_and_list AND reference_type

State 73:
## Known stack suffix:
## identifier EXTENDS bound
## LR(1) items:
type_parameter -> identifier EXTENDS bound . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_parameter -> identifier EXTENDS bound

State 74:
## Known stack suffix:
## type_parameter
## LR(1) items:
type_parameters_bis -> type_parameter . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_parameters_bis -> type_parameter

State 75:
## Known stack suffix:
## modifiers_opt INTERFACE identifier type_parameters_opt
## LR(1) items:
interface_declaration -> modifiers_opt INTERFACE identifier type_parameters_opt . extends_interfaces_opt interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On EXTENDS shift to state 76
-- On extends_interfaces_opt shift to state 78
-- On extends_interfaces shift to state 719
## Reductions:
-- On LC
--   reduce production extends_interfaces_opt ->

State 76:
## Known stack suffix:
## EXTENDS
## LR(1) items:
extends_interfaces -> EXTENDS . reference_type [ LC CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 77
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 77:
## Known stack suffix:
## EXTENDS reference_type
## LR(1) items:
extends_interfaces -> EXTENDS reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production extends_interfaces -> EXTENDS reference_type

State 78:
## Known stack suffix:
## modifiers_opt INTERFACE identifier type_parameters_opt extends_interfaces_opt
## LR(1) items:
interface_declaration -> modifiers_opt INTERFACE identifier type_parameters_opt extends_interfaces_opt . interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 79
-- On interface_body shift to state 718
## Reductions:

State 79:
## Known stack suffix:
## LC
## LR(1) items:
interface_body -> LC . interface_member_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 80
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 81
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_member_declarations_opt shift to state 706
-- On interface_member_declarations shift to state 708
-- On interface_member_declaration shift to state 717
-- On interface_generic_method_decl shift to state 710
-- On interface_declaration shift to state 711
-- On enum_declaration shift to state 712
-- On constant_declaration shift to state 713
-- On class_declaration shift to state 714
-- On annotation_type_declaration shift to state 715
-- On annotation shift to state 365
-- On abstract_method_declaration shift to state 716
## Reductions:
-- On RC
--   reduce production interface_member_declarations_opt ->
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 80:
## Known stack suffix:
## SM
## LR(1) items:
interface_member_declaration -> SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> SM

State 81:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
abstract_method_declaration -> modifiers_opt . type_java method_declarator throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
abstract_method_declaration -> modifiers_opt . VOID method_declarator throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
class_declaration -> modifiers_opt . CLASS identifier type_parameters_opt super_opt interfaces_opt class_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
constant_declaration -> modifiers_opt . type_java variable_declarators SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
enum_declaration -> modifiers_opt . ENUM identifier interfaces_opt enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_declaration -> modifiers_opt . INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers_opt . type_parameters type_java identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers_opt . type_parameters VOID identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 82
-- On PRIMITIVE_TYPE shift to state 7
-- On LT shift to state 62
-- On INTERFACE shift to state 60
-- On IDENTIFIER shift to state 2
-- On ENUM shift to state 492
-- On CLASS shift to state 449
-- On type_parameters shift to state 690
-- On type_java shift to state 700
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 82:
## Known stack suffix:
## modifiers_opt VOID
## LR(1) items:
abstract_method_declaration -> modifiers_opt VOID . method_declarator throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On method_declarator shift to state 83
-- On identifier shift to state 93
## Reductions:

State 83:
## Known stack suffix:
## modifiers_opt VOID method_declarator
## LR(1) items:
abstract_method_declaration -> modifiers_opt VOID method_declarator . throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
method_declarator -> method_declarator . LB_RB [ THROWS SM LB_RB ]
## Transitions:
-- On THROWS shift to state 84
-- On LB_RB shift to state 89
-- On throws_opt shift to state 90
-- On throws shift to state 92
## Reductions:
-- On SM
--   reduce production throws_opt ->

State 84:
## Known stack suffix:
## THROWS
## LR(1) items:
throws -> THROWS . qualified_ident_list [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On qualified_ident_list shift to state 85
-- On name shift to state 88
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 85:
## Known stack suffix:
## THROWS qualified_ident_list
## LR(1) items:
qualified_ident_list -> qualified_ident_list . CM name [ SM LC CM ]
throws -> THROWS qualified_ident_list . [ SM LC ]
## Transitions:
-- On CM shift to state 86
## Reductions:
-- On SM LC
--   reduce production throws -> THROWS qualified_ident_list

State 86:
## Known stack suffix:
## qualified_ident_list CM
## LR(1) items:
qualified_ident_list -> qualified_ident_list CM . name [ SM LC CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On name shift to state 87
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 87:
## Known stack suffix:
## qualified_ident_list CM name
## LR(1) items:
name -> name . DOT identifier_ [ SM LC DOT CM ]
name -> name . DOT LT2 type_arguments GT identifier_ [ SM LC DOT CM ]
qualified_ident_list -> qualified_ident_list CM name . [ SM LC CM ]
## Transitions:
-- On DOT shift to state 5
## Reductions:
-- On SM LC CM
--   reduce production qualified_ident_list -> qualified_ident_list CM name

State 88:
## Known stack suffix:
## name
## LR(1) items:
name -> name . DOT identifier_ [ SM LC DOT CM ]
name -> name . DOT LT2 type_arguments GT identifier_ [ SM LC DOT CM ]
qualified_ident_list -> name . [ SM LC CM ]
## Transitions:
-- On DOT shift to state 5
## Reductions:
-- On SM LC CM
--   reduce production qualified_ident_list -> name

State 89:
## Known stack suffix:
## method_declarator LB_RB
## LR(1) items:
method_declarator -> method_declarator LB_RB . [ THROWS SM LC LB_RB ]
## Transitions:
## Reductions:
-- On THROWS SM LC LB_RB
--   reduce production method_declarator -> method_declarator LB_RB

State 90:
## Known stack suffix:
## modifiers_opt VOID method_declarator throws_opt
## LR(1) items:
abstract_method_declaration -> modifiers_opt VOID method_declarator throws_opt . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## modifiers_opt VOID method_declarator throws_opt SM
## LR(1) items:
abstract_method_declaration -> modifiers_opt VOID method_declarator throws_opt SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production abstract_method_declaration -> modifiers_opt VOID method_declarator throws_opt SM

State 92:
## Known stack suffix:
## throws
## LR(1) items:
throws_opt -> throws . [ SM LC ]
## Transitions:
## Reductions:
-- On SM LC
--   reduce production throws_opt -> throws

State 93:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator -> identifier . LP formal_parameter_list_opt RP [ THROWS SM LC LB_RB ]
## Transitions:
-- On LP shift to state 94
## Reductions:

State 94:
## Known stack suffix:
## identifier LP
## LR(1) items:
method_declarator -> identifier LP . formal_parameter_list_opt RP [ THROWS SM LC LB_RB ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifiers_opt shift to state 251
-- On variable_modifiers shift to state 262
-- On variable_modifier shift to state 265
-- On formal_parameter_list_opt shift to state 688
-- On formal_parameter_list shift to state 554
-- On formal_parameter shift to state 557
-- On annotation shift to state 264
## Reductions:
-- On RP
--   reduce production formal_parameter_list_opt ->
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt ->

State 95:
## Known stack suffix:
## FINAL
## LR(1) items:
variable_modifier -> FINAL . [ PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifier -> FINAL

State 96:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . name [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL CM CLASS AT ABSTRACT ]
annotation -> AT . name LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL CM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On name shift to state 97
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 97:
## Known stack suffix:
## AT name
## LR(1) items:
annotation -> AT name . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT ]
annotation -> AT name . LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT ]
name -> name . DOT identifier_ [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LP INTERFACE IDENTIFIER FINAL ENUM DOT CM CLASS AT ABSTRACT ]
name -> name . DOT LT2 type_arguments GT identifier_ [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LP INTERFACE IDENTIFIER FINAL ENUM DOT CM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 98
-- On DOT shift to state 5
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT
--   reduce production annotation -> AT name

State 98:
## Known stack suffix:
## AT name LP
## LR(1) items:
annotation -> AT name LP . annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 660
-- On IDENTIFIER shift to state 2
-- On AT shift to state 96
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 662
-- On primary shift to state 665
-- On name shift to state 667
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 677
-- On field_access shift to state 158
-- On expr1 shift to state 668
-- On element_value_pairs shift to state 680
-- On element_value_pair shift to state 684
-- On element_value_array_initializer shift to state 673
-- On element_value shift to state 685
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On annotation_element shift to state 686
-- On annotation shift to state 675
## Reductions:
-- On RP
--   reduce production annotation_element ->

State 99:
## Known stack suffix:
## VOID
## LR(1) items:
class_literal -> VOID . DOT CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 100
## Reductions:

State 100:
## Known stack suffix:
## VOID DOT
## LR(1) items:
class_literal -> VOID DOT . CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 101
## Reductions:

State 101:
## Known stack suffix:
## VOID DOT CLASS
## LR(1) items:
class_literal -> VOID DOT CLASS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_literal -> VOID DOT CLASS

State 102:
## Known stack suffix:
## TString
## LR(1) items:
literal -> TString . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production literal -> TString

State 103:
## Known stack suffix:
## TInt
## LR(1) items:
literal -> TInt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production literal -> TInt

State 104:
## Known stack suffix:
## THIS
## LR(1) items:
primary_no_new_array -> THIS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> THIS

State 105:
## Known stack suffix:
## TFloat
## LR(1) items:
literal -> TFloat . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production literal -> TFloat

State 106:
## Known stack suffix:
## TChar
## LR(1) items:
literal -> TChar . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production literal -> TChar

State 107:
## Known stack suffix:
## SUPER
## LR(1) items:
field_access -> SUPER . DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> SUPER . DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 108
## Reductions:

State 108:
## Known stack suffix:
## SUPER DOT
## LR(1) items:
field_access -> SUPER DOT . identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> SUPER DOT . identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 109
## Reductions:

State 109:
## Known stack suffix:
## SUPER DOT identifier
## LR(1) items:
field_access -> SUPER DOT identifier . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> SUPER DOT identifier . LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 110
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production field_access -> SUPER DOT identifier

State 110:
## Known stack suffix:
## SUPER DOT identifier LP
## LR(1) items:
method_invocation -> SUPER DOT identifier LP . argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 658
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 111:
## Known stack suffix:
## PLUS
## LR(1) items:
unary_expression -> PLUS . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 657
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 112:
## Known stack suffix:
## NOT
## LR(1) items:
unary_expression_not_plus_minus -> NOT . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 656
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 113:
## Known stack suffix:
## NEW
## LR(1) items:
array_creation_expression -> NEW . primitive_type dim_exprs dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_creation_expression -> NEW . name dim_exprs dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_creation_expression -> NEW . primitive_type dims array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_creation_expression -> NEW . name dims array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_instance_creation_expression -> NEW . name LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On primitive_type shift to state 114
-- On name shift to state 647
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 114:
## Known stack suffix:
## NEW primitive_type
## LR(1) items:
array_creation_expression -> NEW primitive_type . dim_exprs dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_creation_expression -> NEW primitive_type . dims array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 115
-- On LB shift to state 116
-- On dims shift to state 639
-- On dim_exprs shift to state 642
-- On dim_expr shift to state 646
## Reductions:

State 115:
## Known stack suffix:
## LB_RB
## LR(1) items:
dims -> LB_RB . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dims -> LB_RB

State 116:
## Known stack suffix:
## LB
## LR(1) items:
dim_expr -> LB . expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 637
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 117:
## Known stack suffix:
## MINUS
## LR(1) items:
unary_expression -> MINUS . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 636
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 118:
## Known stack suffix:
## LP
## LR(1) items:
cast_expression -> LP . primitive_type RP unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . expression RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . array_type RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP . expression RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 627
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 630
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 633
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 119:
## Known stack suffix:
## LITERAL
## LR(1) items:
literal -> LITERAL . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production literal -> LITERAL

State 120:
## Known stack suffix:
## INCR
## LR(1) items:
pre_increment_expression -> INCR . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 626
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 121:
## Known stack suffix:
## DECR
## LR(1) items:
pre_decrement_expression -> DECR . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 625
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 122:
## Known stack suffix:
## COMPL
## LR(1) items:
unary_expression_not_plus_minus -> COMPL . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 124
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 123:
## Known stack suffix:
## unary_expression_not_plus_minus
## LR(1) items:
unary_expression -> unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> unary_expression_not_plus_minus

State 124:
## Known stack suffix:
## COMPL unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> COMPL unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> COMPL unary_expression

State 125:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ LB_RB DOT ]
class_literal -> primitive_type . DOT CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 12
-- On DOT shift to state 126
## Reductions:

State 126:
## Known stack suffix:
## primitive_type DOT
## LR(1) items:
class_literal -> primitive_type DOT . CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 127
## Reductions:

State 127:
## Known stack suffix:
## primitive_type DOT CLASS
## LR(1) items:
class_literal -> primitive_type DOT CLASS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_literal -> primitive_type DOT CLASS

State 128:
## Known stack suffix:
## primary_no_new_array
## LR(1) items:
array_access -> primary_no_new_array . LB expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
primary -> primary_no_new_array . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB shift to state 129
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary -> primary_no_new_array

State 129:
## Known stack suffix:
## primary_no_new_array LB
## LR(1) items:
array_access -> primary_no_new_array LB . expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 623
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 130:
## Known stack suffix:
## unary_expression
## LR(1) items:
multiplicative_expression -> unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> unary_expression

State 131:
## Known stack suffix:
## shift_expression
## LR(1) items:
relational_expression -> shift_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 132
-- On SRS shift to state 141
-- On LS shift to state 185
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> shift_expression

State 132:
## Known stack suffix:
## shift_expression URS
## LR(1) items:
shift_expression -> shift_expression URS . additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 622
## Reductions:

State 133:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
field_access -> primary . DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> primary . DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
postfix_expression -> primary . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 134
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> primary

State 134:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_expression -> primary DOT . NEW identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
field_access -> primary DOT . identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> primary DOT . identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On NEW shift to state 135
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 594
## Reductions:

State 135:
## Known stack suffix:
## primary DOT NEW
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW . identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 136
## Reductions:

State 136:
## Known stack suffix:
## primary DOT NEW identifier
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier . LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 137
## Reductions:

State 137:
## Known stack suffix:
## primary DOT NEW identifier LP
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP . argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 619
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 138:
## Known stack suffix:
## relational_expression
## LR(1) items:
equality_expression -> relational_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 139
-- On LE shift to state 183
-- On INSTANCEOF shift to state 192
-- On GT shift to state 194
-- On GE shift to state 196
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND
--   reduce production equality_expression -> relational_expression

State 139:
## Known stack suffix:
## relational_expression LT
## LR(1) items:
relational_expression -> relational_expression LT . shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 140
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 140:
## Known stack suffix:
## relational_expression LT shift_expression
## LR(1) items:
relational_expression -> relational_expression LT shift_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 132
-- On SRS shift to state 141
-- On LS shift to state 185
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression LT shift_expression

State 141:
## Known stack suffix:
## shift_expression SRS
## LR(1) items:
shift_expression -> shift_expression SRS . additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 618
## Reductions:

State 142:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
unary_expression -> pre_increment_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> pre_increment_expression

State 143:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
unary_expression -> pre_decrement_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> pre_decrement_expression

State 144:
## Known stack suffix:
## postfix_expression
## LR(1) items:
post_decrement_expression -> postfix_expression . DECR [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
post_increment_expression -> postfix_expression . INCR [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
unary_expression_not_plus_minus -> postfix_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On INCR shift to state 145
-- On DECR shift to state 146
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> postfix_expression

State 145:
## Known stack suffix:
## postfix_expression INCR
## LR(1) items:
post_increment_expression -> postfix_expression INCR . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production post_increment_expression -> postfix_expression INCR

State 146:
## Known stack suffix:
## postfix_expression DECR
## LR(1) items:
post_decrement_expression -> postfix_expression DECR . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production post_decrement_expression -> postfix_expression DECR

State 147:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> post_increment_expression

State 148:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> post_decrement_expression

State 149:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_instance_creation_expression -> name . DOT NEW identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_literal -> name . DOT CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_or_interface_type -> name . [ LB_RB ]
field_access -> name . DOT SUPER DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name . LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name . DOT SUPER DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name . DOT LT2 type_arguments GT identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
postfix_expression -> name . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
primary_no_new_array -> name . DOT THIS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 150
-- On LB shift to state 152
-- On DOT shift to state 223
## Reductions:
-- On LB_RB
--   reduce production class_or_interface_type -> name
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> name

State 150:
## Known stack suffix:
## name LP
## LR(1) items:
method_invocation -> name LP . argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 616
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 151:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_instance_creation_expression -> name . DOT NEW identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_literal -> name . DOT CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_or_interface_type -> name . [ LB_RB IDENTIFIER ]
field_access -> name . DOT SUPER DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
left_hand_side -> name . [ OPERATOR_EQ EQ ]
method_invocation -> name . LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name . DOT SUPER DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name . DOT LT2 type_arguments GT identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
postfix_expression -> name . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND ]
primary_no_new_array -> name . DOT THIS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 150
-- On LB shift to state 152
-- On DOT shift to state 223
## Reductions:
-- On LB_RB IDENTIFIER
--   reduce production class_or_interface_type -> name
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> name
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> name

State 152:
## Known stack suffix:
## name LB
## LR(1) items:
array_access -> name LB . expression RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 221
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 153:
## Known stack suffix:
## multiplicative_expression
## LR(1) items:
additive_expression -> multiplicative_expression . [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 154
-- On MOD shift to state 168
-- On DIV shift to state 170
## Reductions:
-- On XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production additive_expression -> multiplicative_expression

State 154:
## Known stack suffix:
## multiplicative_expression TIMES
## LR(1) items:
multiplicative_expression -> multiplicative_expression TIMES . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 155
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 155:
## Known stack suffix:
## multiplicative_expression TIMES unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression TIMES unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression TIMES unary_expression

State 156:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> method_invocation

State 157:
## Known stack suffix:
## literal
## LR(1) items:
primary_no_new_array -> literal . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> literal

State 158:
## Known stack suffix:
## field_access
## LR(1) items:
primary_no_new_array -> field_access . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> field_access

State 159:
## Known stack suffix:
## class_or_interface_type
## LR(1) items:
array_type -> class_or_interface_type . LB_RB [ RP LB_RB DOT ]
## Transitions:
-- On LB_RB shift to state 23
## Reductions:

State 160:
## Known stack suffix:
## class_literal
## LR(1) items:
primary_no_new_array -> class_literal . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> class_literal

State 161:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> class_instance_creation_expression

State 162:
## Known stack suffix:
## cast_expression
## LR(1) items:
unary_expression_not_plus_minus -> cast_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> cast_expression

State 163:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ LB_RB DOT ]
class_literal -> array_type . DOT CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 25
-- On DOT shift to state 164
## Reductions:

State 164:
## Known stack suffix:
## array_type DOT
## LR(1) items:
class_literal -> array_type DOT . CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## array_type DOT CLASS
## LR(1) items:
class_literal -> array_type DOT CLASS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_literal -> array_type DOT CLASS

State 166:
## Known stack suffix:
## array_creation_expression
## LR(1) items:
primary -> array_creation_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary -> array_creation_expression

State 167:
## Known stack suffix:
## array_access
## LR(1) items:
primary_no_new_array -> array_access . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> array_access

State 168:
## Known stack suffix:
## multiplicative_expression MOD
## LR(1) items:
multiplicative_expression -> multiplicative_expression MOD . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 169
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 169:
## Known stack suffix:
## multiplicative_expression MOD unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression MOD unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression MOD unary_expression

State 170:
## Known stack suffix:
## multiplicative_expression DIV
## LR(1) items:
multiplicative_expression -> multiplicative_expression DIV . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 171
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 171:
## Known stack suffix:
## multiplicative_expression DIV unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression DIV unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression DIV unary_expression

State 172:
## Known stack suffix:
## left_hand_side
## LR(1) items:
assignment -> left_hand_side . assignment_operator assignment_expression [ SM RP RC RB COLON CM ]
## Transitions:
-- On OPERATOR_EQ shift to state 173
-- On EQ shift to state 174
-- On assignment_operator shift to state 175
## Reductions:

State 173:
## Known stack suffix:
## OPERATOR_EQ
## LR(1) items:
assignment_operator -> OPERATOR_EQ . [ VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL ]
## Transitions:
## Reductions:
-- On VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
--   reduce production assignment_operator -> OPERATOR_EQ

State 174:
## Known stack suffix:
## EQ
## LR(1) items:
assignment_operator -> EQ . [ VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL ]
## Transitions:
## Reductions:
-- On VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
--   reduce production assignment_operator -> EQ

State 175:
## Known stack suffix:
## left_hand_side assignment_operator
## LR(1) items:
assignment -> left_hand_side assignment_operator . assignment_expression [ SM RP RC RB COLON CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 220
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 176:
## Known stack suffix:
## inclusive_or_expression
## LR(1) items:
conditional_and_expression -> inclusive_or_expression . [ SM RP RC RB OR_OR COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On OR shift to state 177
## Reductions:
-- On SM RP RC RB OR_OR COND COLON CM AND_AND
--   reduce production conditional_and_expression -> inclusive_or_expression

State 177:
## Known stack suffix:
## inclusive_or_expression OR
## LR(1) items:
inclusive_or_expression -> inclusive_or_expression OR . exclusive_or_expression [ SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On exclusive_or_expression shift to state 178
-- On equality_expression shift to state 180
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 178:
## Known stack suffix:
## inclusive_or_expression OR exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . XOR and_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression . [ SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On XOR shift to state 179
## Reductions:
-- On SM RP RC RB OR_OR OR COND COLON CM AND_AND
--   reduce production inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression

State 179:
## Known stack suffix:
## exclusive_or_expression XOR
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression XOR . and_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On equality_expression shift to state 180
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On and_expression shift to state 200
-- On additive_expression shift to state 191
## Reductions:

State 180:
## Known stack suffix:
## equality_expression
## LR(1) items:
and_expression -> equality_expression . [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . NOT_EQ relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On NOT_EQ shift to state 181
-- On EQ_EQ shift to state 198
## Reductions:
-- On XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND
--   reduce production and_expression -> equality_expression

State 181:
## Known stack suffix:
## equality_expression NOT_EQ
## LR(1) items:
equality_expression -> equality_expression NOT_EQ . relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 182
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 182:
## Known stack suffix:
## equality_expression NOT_EQ relational_expression
## LR(1) items:
equality_expression -> equality_expression NOT_EQ relational_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 139
-- On LE shift to state 183
-- On INSTANCEOF shift to state 192
-- On GT shift to state 194
-- On GE shift to state 196
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND
--   reduce production equality_expression -> equality_expression NOT_EQ relational_expression

State 183:
## Known stack suffix:
## relational_expression LE
## LR(1) items:
relational_expression -> relational_expression LE . shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 184
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 184:
## Known stack suffix:
## relational_expression LE shift_expression
## LR(1) items:
relational_expression -> relational_expression LE shift_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 132
-- On SRS shift to state 141
-- On LS shift to state 185
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression LE shift_expression

State 185:
## Known stack suffix:
## shift_expression LS
## LR(1) items:
shift_expression -> shift_expression LS . additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 186
## Reductions:

State 186:
## Known stack suffix:
## shift_expression LS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression LS additive_expression . [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 187
-- On MINUS shift to state 189
## Reductions:
-- On XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression LS additive_expression

State 187:
## Known stack suffix:
## additive_expression PLUS
## LR(1) items:
additive_expression -> additive_expression PLUS . multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 188
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 188:
## Known stack suffix:
## additive_expression PLUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression PLUS multiplicative_expression . [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 154
-- On MOD shift to state 168
-- On DIV shift to state 170
## Reductions:
-- On XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression PLUS multiplicative_expression

State 189:
## Known stack suffix:
## additive_expression MINUS
## LR(1) items:
additive_expression -> additive_expression MINUS . multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 190
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 190:
## Known stack suffix:
## additive_expression MINUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression MINUS multiplicative_expression . [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 154
-- On MOD shift to state 168
-- On DIV shift to state 170
## Reductions:
-- On XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression MINUS multiplicative_expression

State 191:
## Known stack suffix:
## additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> additive_expression . [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 187
-- On MINUS shift to state 189
## Reductions:
-- On XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production shift_expression -> additive_expression

State 192:
## Known stack suffix:
## relational_expression INSTANCEOF
## LR(1) items:
relational_expression -> relational_expression INSTANCEOF . reference_type [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 193
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 193:
## Known stack suffix:
## relational_expression INSTANCEOF reference_type
## LR(1) items:
relational_expression -> relational_expression INSTANCEOF reference_type . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression INSTANCEOF reference_type

State 194:
## Known stack suffix:
## relational_expression GT
## LR(1) items:
relational_expression -> relational_expression GT . shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 195
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 195:
## Known stack suffix:
## relational_expression GT shift_expression
## LR(1) items:
relational_expression -> relational_expression GT shift_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 132
-- On SRS shift to state 141
-- On LS shift to state 185
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression GT shift_expression

State 196:
## Known stack suffix:
## relational_expression GE
## LR(1) items:
relational_expression -> relational_expression GE . shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 197
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 197:
## Known stack suffix:
## relational_expression GE shift_expression
## LR(1) items:
relational_expression -> relational_expression GE shift_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 132
-- On SRS shift to state 141
-- On LS shift to state 185
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression GE shift_expression

State 198:
## Known stack suffix:
## equality_expression EQ_EQ
## LR(1) items:
equality_expression -> equality_expression EQ_EQ . relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 199
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 199:
## Known stack suffix:
## equality_expression EQ_EQ relational_expression
## LR(1) items:
equality_expression -> equality_expression EQ_EQ relational_expression . [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 139
-- On LE shift to state 183
-- On INSTANCEOF shift to state 192
-- On GT shift to state 194
-- On GE shift to state 196
## Reductions:
-- On XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND
--   reduce production equality_expression -> equality_expression EQ_EQ relational_expression

State 200:
## Known stack suffix:
## exclusive_or_expression XOR and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND ]
exclusive_or_expression -> exclusive_or_expression XOR and_expression . [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On AND shift to state 201
## Reductions:
-- On XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND
--   reduce production exclusive_or_expression -> exclusive_or_expression XOR and_expression

State 201:
## Known stack suffix:
## and_expression AND
## LR(1) items:
and_expression -> and_expression AND . equality_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On equality_expression shift to state 202
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On additive_expression shift to state 191
## Reductions:

State 202:
## Known stack suffix:
## and_expression AND equality_expression
## LR(1) items:
and_expression -> and_expression AND equality_expression . [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . NOT_EQ relational_expression [ XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On NOT_EQ shift to state 181
-- On EQ_EQ shift to state 198
## Reductions:
-- On XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND
--   reduce production and_expression -> and_expression AND equality_expression

State 203:
## Known stack suffix:
## and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND ]
exclusive_or_expression -> and_expression . [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On AND shift to state 201
## Reductions:
-- On XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND
--   reduce production exclusive_or_expression -> and_expression

State 204:
## Known stack suffix:
## field_access
## LR(1) items:
left_hand_side -> field_access . [ OPERATOR_EQ EQ ]
primary_no_new_array -> field_access . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> field_access
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> field_access

State 205:
## Known stack suffix:
## exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . XOR and_expression [ XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
inclusive_or_expression -> exclusive_or_expression . [ SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On XOR shift to state 179
## Reductions:
-- On SM RP RC RB OR_OR OR COND COLON CM AND_AND
--   reduce production inclusive_or_expression -> exclusive_or_expression

State 206:
## Known stack suffix:
## conditional_or_expression
## LR(1) items:
conditional_expression -> conditional_or_expression . [ SM RP RC RB COLON CM ]
conditional_expression -> conditional_or_expression . COND expression COLON conditional_expression [ SM RP RC RB COLON CM ]
conditional_or_expression -> conditional_or_expression . OR_OR conditional_and_expression [ SM RP RC RB OR_OR COND COLON CM ]
## Transitions:
-- On OR_OR shift to state 207
-- On COND shift to state 211
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production conditional_expression -> conditional_or_expression

State 207:
## Known stack suffix:
## conditional_or_expression OR_OR
## LR(1) items:
conditional_or_expression -> conditional_or_expression OR_OR . conditional_and_expression [ SM RP RC RB OR_OR COND COLON CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_and_expression shift to state 208
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 208:
## Known stack suffix:
## conditional_or_expression OR_OR conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SM RP RC RB OR_OR COND COLON CM AND_AND ]
conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression . [ SM RP RC RB OR_OR COND COLON CM ]
## Transitions:
-- On AND_AND shift to state 209
## Reductions:
-- On SM RP RC RB OR_OR COND COLON CM
--   reduce production conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression

State 209:
## Known stack suffix:
## conditional_and_expression AND_AND
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND . inclusive_or_expression [ SM RP RC RB OR_OR COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On inclusive_or_expression shift to state 210
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 210:
## Known stack suffix:
## conditional_and_expression AND_AND inclusive_or_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression . [ SM RP RC RB OR_OR COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SM RP RC RB OR_OR OR COND COLON CM AND_AND ]
## Transitions:
-- On OR shift to state 177
## Reductions:
-- On SM RP RC RB OR_OR COND COLON CM AND_AND
--   reduce production conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression

State 211:
## Known stack suffix:
## conditional_or_expression COND
## LR(1) items:
conditional_expression -> conditional_or_expression COND . expression COLON conditional_expression [ SM RP RC RB COLON CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 212
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 212:
## Known stack suffix:
## conditional_or_expression COND expression
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression . COLON conditional_expression [ SM RP RC RB COLON CM ]
## Transitions:
-- On COLON shift to state 213
## Reductions:

State 213:
## Known stack suffix:
## conditional_or_expression COND expression COLON
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression COLON . conditional_expression [ SM RP RC RB COLON CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 214
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 214:
## Known stack suffix:
## conditional_or_expression COND expression COLON conditional_expression
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression COLON conditional_expression . [ SM RP RC RB COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production conditional_expression -> conditional_or_expression COND expression COLON conditional_expression

State 215:
## Known stack suffix:
## conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SM RP RC RB OR_OR COND COLON CM AND_AND ]
conditional_or_expression -> conditional_and_expression . [ SM RP RC RB OR_OR COND COLON CM ]
## Transitions:
-- On AND_AND shift to state 209
## Reductions:
-- On SM RP RC RB OR_OR COND COLON CM
--   reduce production conditional_or_expression -> conditional_and_expression

State 216:
## Known stack suffix:
## conditional_expression
## LR(1) items:
assignment_expression -> conditional_expression . [ SM RP RC RB COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production assignment_expression -> conditional_expression

State 217:
## Known stack suffix:
## assignment_expression
## LR(1) items:
expression -> assignment_expression . [ SM RP RC RB COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production expression -> assignment_expression

State 218:
## Known stack suffix:
## assignment
## LR(1) items:
assignment_expression -> assignment . [ SM RP RC RB COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production assignment_expression -> assignment

State 219:
## Known stack suffix:
## array_access
## LR(1) items:
left_hand_side -> array_access . [ OPERATOR_EQ EQ ]
primary_no_new_array -> array_access . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> array_access
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> array_access

State 220:
## Known stack suffix:
## left_hand_side assignment_operator assignment_expression
## LR(1) items:
assignment -> left_hand_side assignment_operator assignment_expression . [ SM RP RC RB COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RC RB COLON CM
--   reduce production assignment -> left_hand_side assignment_operator assignment_expression

State 221:
## Known stack suffix:
## name LB expression
## LR(1) items:
array_access -> name LB expression . RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## name LB expression RB
## LR(1) items:
array_access -> name LB expression RB . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_access -> name LB expression RB

State 223:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_expression -> name DOT . NEW identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_literal -> name DOT . CLASS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
field_access -> name DOT . SUPER DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name DOT . SUPER DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name DOT . identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name DOT . LT2 type_arguments GT identifier_ [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
primary_no_new_array -> name DOT . THIS [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On THIS shift to state 224
-- On SUPER shift to state 225
-- On NEW shift to state 235
-- On LT2 shift to state 6
-- On IDENTIFIER shift to state 2
-- On CLASS shift to state 605
-- On identifier_ shift to state 32
-- On identifier shift to state 15
## Reductions:

State 224:
## Known stack suffix:
## name DOT THIS
## LR(1) items:
primary_no_new_array -> name DOT THIS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> name DOT THIS

State 225:
## Known stack suffix:
## name DOT SUPER
## LR(1) items:
field_access -> name DOT SUPER . DOT identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER . DOT identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 226
## Reductions:

State 226:
## Known stack suffix:
## name DOT SUPER DOT
## LR(1) items:
field_access -> name DOT SUPER DOT . identifier [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER DOT . identifier LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 227
## Reductions:

State 227:
## Known stack suffix:
## name DOT SUPER DOT identifier
## LR(1) items:
field_access -> name DOT SUPER DOT identifier . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER DOT identifier . LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 228
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production field_access -> name DOT SUPER DOT identifier

State 228:
## Known stack suffix:
## name DOT SUPER DOT identifier LP
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP . argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 230
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 229:
## Known stack suffix:
## expression
## LR(1) items:
argument_list -> expression . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production argument_list -> expression

State 230:
## Known stack suffix:
## name DOT SUPER DOT identifier LP argument_list_opt
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP argument_list_opt . RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 231
## Reductions:

State 231:
## Known stack suffix:
## name DOT SUPER DOT identifier LP argument_list_opt RP
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP argument_list_opt RP . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production method_invocation -> name DOT SUPER DOT identifier LP argument_list_opt RP

State 232:
## Known stack suffix:
## argument_list
## LR(1) items:
argument_list -> argument_list . CM expression [ RP CM ]
argument_list_opt -> argument_list . [ RP ]
## Transitions:
-- On CM shift to state 233
## Reductions:
-- On RP
--   reduce production argument_list_opt -> argument_list

State 233:
## Known stack suffix:
## argument_list CM
## LR(1) items:
argument_list -> argument_list CM . expression [ RP CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 234
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 234:
## Known stack suffix:
## argument_list CM expression
## LR(1) items:
argument_list -> argument_list CM expression . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production argument_list -> argument_list CM expression

State 235:
## Known stack suffix:
## name DOT NEW
## LR(1) items:
class_instance_creation_expression -> name DOT NEW . identifier LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## name DOT NEW identifier
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier . LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 237
## Reductions:

State 237:
## Known stack suffix:
## name DOT NEW identifier LP
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP . argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 238
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 238:
## Known stack suffix:
## name DOT NEW identifier LP argument_list_opt
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP argument_list_opt . RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## name DOT NEW identifier LP argument_list_opt RP
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP argument_list_opt RP . class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 240
-- On class_body_opt shift to state 614
-- On class_body shift to state 615
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_body_opt ->

State 240:
## Known stack suffix:
## LC
## LR(1) items:
class_body -> LC . class_body_declarations_opt RC [ XOR WHILE VOLATILE VOID URS TString TRY TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR NOT_EQ NEW NATIVE MOD MINUS LT LS LP LITERAL LE LC LB INTERFACE INSTANCEOF INCR IF IDENTIFIER GT GE FOR FINAL EQ_EQ EOF ENUM DOT DO DIV DEFAULT DECR CONTINUE COND COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 241
-- On SM shift to state 486
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On LC shift to state 242
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On static_initializer shift to state 487
-- On modifiers_opt shift to state 488
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On method_header shift to state 502
-- On method_declaration shift to state 506
-- On interface_declaration shift to state 507
-- On instance_initializer shift to state 508
-- On generic_method_or_constructor_decl shift to state 509
-- On field_declaration shift to state 510
-- On enum_declaration shift to state 511
-- On constructor_declaration shift to state 512
-- On class_member_declaration shift to state 513
-- On class_declaration shift to state 514
-- On class_body_declarations_opt shift to state 612
-- On class_body_declarations shift to state 516
-- On class_body_declaration shift to state 520
-- On block shift to state 518
-- On annotation_type_declaration shift to state 519
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production class_body_declarations_opt ->
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 241:
## Known stack suffix:
## STATIC
## LR(1) items:
modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
static_initializer -> STATIC . block [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 242
-- On block shift to state 485
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> STATIC

State 242:
## Known stack suffix:
## LC
## LR(1) items:
block -> LC . block_statements_opt RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINALLY FINAL ENUM ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statements_opt shift to state 482
-- On block_statements shift to state 484
-- On block_statement shift to state 473
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production block_statements_opt ->
-- On CLASS
--   reduce production modifiers_opt ->

State 243:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## WHILE LP
## LR(1) items:
while_statement -> WHILE LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 245
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 245:
## Known stack suffix:
## WHILE LP expression
## LR(1) items:
while_statement -> WHILE LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 246
## Reductions:

State 246:
## Known stack suffix:
## WHILE LP expression RP
## LR(1) items:
while_statement -> WHILE LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 442
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 247:
## Known stack suffix:
## TRY
## LR(1) items:
try_statement -> TRY . block catches [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
try_statement -> TRY . block catches_opt finally [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 242
-- On block shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## TRY block
## LR(1) items:
try_statement -> TRY block . catches [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
try_statement -> TRY block . catches_opt finally [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 249
-- On catches_opt shift to state 271
-- On catches shift to state 275
-- On catch_clause shift to state 277
## Reductions:
-- On FINALLY
--   reduce production catches_opt ->

State 249:
## Known stack suffix:
## CATCH
## LR(1) items:
catch_clause -> CATCH . LP formal_parameter RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH . LP formal_parameter RP empty_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## CATCH LP
## LR(1) items:
catch_clause -> CATCH LP . formal_parameter RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP . formal_parameter RP empty_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifiers_opt shift to state 251
-- On variable_modifiers shift to state 262
-- On variable_modifier shift to state 265
-- On formal_parameter shift to state 266
-- On annotation shift to state 264
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt ->

State 251:
## Known stack suffix:
## variable_modifiers_opt
## LR(1) items:
formal_parameter -> variable_modifiers_opt . type_java variable_declarator_id_bis [ RP CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On type_java shift to state 252
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 252:
## Known stack suffix:
## variable_modifiers_opt type_java
## LR(1) items:
formal_parameter -> variable_modifiers_opt type_java . variable_declarator_id_bis [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On DOTS shift to state 253
-- On variable_declarator_id_bis shift to state 257
-- On variable_declarator_id shift to state 258
-- On identifier shift to state 256
## Reductions:

State 253:
## Known stack suffix:
## DOTS
## LR(1) items:
variable_declarator_id_bis -> DOTS . variable_declarator_id [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarator_id shift to state 254
-- On identifier shift to state 256
## Reductions:

State 254:
## Known stack suffix:
## DOTS variable_declarator_id
## LR(1) items:
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
variable_declarator_id_bis -> DOTS variable_declarator_id . [ RP CM ]
## Transitions:
-- On LB_RB shift to state 255
## Reductions:
-- On RP CM
--   reduce production variable_declarator_id_bis -> DOTS variable_declarator_id

State 255:
## Known stack suffix:
## variable_declarator_id LB_RB
## LR(1) items:
variable_declarator_id -> variable_declarator_id LB_RB . [ SM RP LB_RB EQ COLON CM ]
## Transitions:
## Reductions:
-- On SM RP LB_RB EQ COLON CM
--   reduce production variable_declarator_id -> variable_declarator_id LB_RB

State 256:
## Known stack suffix:
## identifier
## LR(1) items:
variable_declarator_id -> identifier . [ SM RP LB_RB EQ COLON CM ]
## Transitions:
## Reductions:
-- On SM RP LB_RB EQ COLON CM
--   reduce production variable_declarator_id -> identifier

State 257:
## Known stack suffix:
## variable_modifiers_opt type_java variable_declarator_id_bis
## LR(1) items:
formal_parameter -> variable_modifiers_opt type_java variable_declarator_id_bis . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production formal_parameter -> variable_modifiers_opt type_java variable_declarator_id_bis

State 258:
## Known stack suffix:
## variable_declarator_id
## LR(1) items:
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
variable_declarator_id_bis -> variable_declarator_id . [ RP CM ]
## Transitions:
-- On LB_RB shift to state 255
## Reductions:
-- On RP CM
--   reduce production variable_declarator_id_bis -> variable_declarator_id

State 259:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ LC LB_RB IMPLEMENTS IDENTIFIER DOTS ]
type_java -> primitive_type . [ LC IMPLEMENTS IDENTIFIER DOTS ]
## Transitions:
-- On LB_RB shift to state 12
## Reductions:
-- On LC IMPLEMENTS IDENTIFIER DOTS
--   reduce production type_java -> primitive_type

State 260:
## Known stack suffix:
## class_or_interface_type
## LR(1) items:
array_type -> class_or_interface_type . LB_RB [ LC LB_RB IMPLEMENTS IDENTIFIER DOTS DOT ]
type_java -> class_or_interface_type . [ LC IMPLEMENTS IDENTIFIER DOTS ]
## Transitions:
-- On LB_RB shift to state 23
## Reductions:
-- On LC IMPLEMENTS IDENTIFIER DOTS
--   reduce production type_java -> class_or_interface_type

State 261:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ LC LB_RB IMPLEMENTS IDENTIFIER DOTS ]
type_java -> array_type . [ LC IMPLEMENTS IDENTIFIER DOTS ]
## Transitions:
-- On LB_RB shift to state 25
## Reductions:
-- On LC IMPLEMENTS IDENTIFIER DOTS
--   reduce production type_java -> array_type

State 262:
## Known stack suffix:
## variable_modifiers
## LR(1) items:
variable_modifiers -> variable_modifiers . variable_modifier [ PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
variable_modifiers_opt -> variable_modifiers . [ PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifier shift to state 263
-- On annotation shift to state 264
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt -> variable_modifiers

State 263:
## Known stack suffix:
## variable_modifiers variable_modifier
## LR(1) items:
variable_modifiers -> variable_modifiers variable_modifier . [ PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifiers -> variable_modifiers variable_modifier

State 264:
## Known stack suffix:
## annotation
## LR(1) items:
variable_modifier -> annotation . [ PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifier -> annotation

State 265:
## Known stack suffix:
## variable_modifier
## LR(1) items:
variable_modifiers -> variable_modifier . [ PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifiers -> variable_modifier

State 266:
## Known stack suffix:
## CATCH LP formal_parameter
## LR(1) items:
catch_clause -> CATCH LP formal_parameter . RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP formal_parameter . RP empty_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## CATCH LP formal_parameter RP
## LR(1) items:
catch_clause -> CATCH LP formal_parameter RP . block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP formal_parameter RP . empty_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 268
-- On LC shift to state 242
-- On empty_statement shift to state 269
-- On block shift to state 270
## Reductions:

State 268:
## Known stack suffix:
## SM
## LR(1) items:
empty_statement -> SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production empty_statement -> SM

State 269:
## Known stack suffix:
## CATCH LP formal_parameter RP empty_statement
## LR(1) items:
catch_clause -> CATCH LP formal_parameter RP empty_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catch_clause -> CATCH LP formal_parameter RP empty_statement

State 270:
## Known stack suffix:
## CATCH LP formal_parameter RP block
## LR(1) items:
catch_clause -> CATCH LP formal_parameter RP block . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catch_clause -> CATCH LP formal_parameter RP block

State 271:
## Known stack suffix:
## TRY block catches_opt
## LR(1) items:
try_statement -> TRY block catches_opt . finally [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 272
-- On finally shift to state 274
## Reductions:

State 272:
## Known stack suffix:
## FINALLY
## LR(1) items:
finally -> FINALLY . block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 242
-- On block shift to state 273
## Reductions:

State 273:
## Known stack suffix:
## FINALLY block
## LR(1) items:
finally -> FINALLY block . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production finally -> FINALLY block

State 274:
## Known stack suffix:
## TRY block catches_opt finally
## LR(1) items:
try_statement -> TRY block catches_opt finally . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block catches_opt finally

State 275:
## Known stack suffix:
## TRY block catches
## LR(1) items:
catches -> catches . catch_clause [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catches_opt -> catches . [ FINALLY ]
try_statement -> TRY block catches . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 249
-- On catch_clause shift to state 276
## Reductions:
-- On FINALLY
--   reduce production catches_opt -> catches
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block catches

State 276:
## Known stack suffix:
## catches catch_clause
## LR(1) items:
catches -> catches catch_clause . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catches -> catches catch_clause

State 277:
## Known stack suffix:
## catch_clause
## LR(1) items:
catches -> catch_clause . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catches -> catch_clause

State 278:
## Known stack suffix:
## THROW
## LR(1) items:
throw_statement -> THROW . expression SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 279
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 279:
## Known stack suffix:
## THROW expression
## LR(1) items:
throw_statement -> THROW expression . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 280
## Reductions:

State 280:
## Known stack suffix:
## THROW expression SM
## LR(1) items:
throw_statement -> THROW expression SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production throw_statement -> THROW expression SM

State 281:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
synchronized_statement -> SYNCHRONIZED . LP expression RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 282
## Reductions:

State 282:
## Known stack suffix:
## SYNCHRONIZED LP
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP . expression RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 283
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 283:
## Known stack suffix:
## SYNCHRONIZED LP expression
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression . RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## SYNCHRONIZED LP expression RP
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression RP . block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 242
-- On block shift to state 285
## Reductions:

State 285:
## Known stack suffix:
## SYNCHRONIZED LP expression RP block
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression RP block . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production synchronized_statement -> SYNCHRONIZED LP expression RP block

State 286:
## Known stack suffix:
## SWITCH
## LR(1) items:
switch_statement -> SWITCH . LP expression RP switch_block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 287
## Reductions:

State 287:
## Known stack suffix:
## SWITCH LP
## LR(1) items:
switch_statement -> SWITCH LP . expression RP switch_block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 288
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 288:
## Known stack suffix:
## SWITCH LP expression
## LR(1) items:
switch_statement -> SWITCH LP expression . RP switch_block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## SWITCH LP expression RP
## LR(1) items:
switch_statement -> SWITCH LP expression RP . switch_block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 290
-- On switch_block shift to state 481
## Reductions:

State 290:
## Known stack suffix:
## LC
## LR(1) items:
switch_block -> LC . RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . switch_labels RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . switch_block_statement_groups RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . switch_block_statement_groups switch_labels RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 291
-- On DEFAULT shift to state 292
-- On CASE shift to state 294
-- On switch_labels shift to state 298
-- On switch_label shift to state 474
-- On switch_block_statement_groups shift to state 475
-- On switch_block_statement_group shift to state 480
## Reductions:

State 291:
## Known stack suffix:
## LC RC
## LR(1) items:
switch_block -> LC RC . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC RC

State 292:
## Known stack suffix:
## DEFAULT
## LR(1) items:
switch_label -> DEFAULT . COLON [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 293
## Reductions:

State 293:
## Known stack suffix:
## DEFAULT COLON
## LR(1) items:
switch_label -> DEFAULT COLON . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_label -> DEFAULT COLON

State 294:
## Known stack suffix:
## CASE
## LR(1) items:
switch_label -> CASE . constant_expression COLON [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 295
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On constant_expression shift to state 296
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 295:
## Known stack suffix:
## expression
## LR(1) items:
constant_expression -> expression . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production constant_expression -> expression

State 296:
## Known stack suffix:
## CASE constant_expression
## LR(1) items:
switch_label -> CASE constant_expression . COLON [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## CASE constant_expression COLON
## LR(1) items:
switch_label -> CASE constant_expression COLON . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_label -> CASE constant_expression COLON

State 298:
## Known stack suffix:
## LC switch_labels
## LR(1) items:
switch_block -> LC switch_labels . RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_group -> switch_labels . block_statements [ RC DEFAULT CASE ]
switch_labels -> switch_labels . switch_label [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On RC shift to state 304
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DEFAULT shift to state 292
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On CASE shift to state 294
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On switch_label shift to state 446
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statements shift to state 471
-- On block_statement shift to state 473
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On CLASS
--   reduce production modifiers_opt ->

State 299:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
modifier -> SYNCHRONIZED . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL CLASS AT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED . LP expression RP block [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 282
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL CLASS AT ABSTRACT
--   reduce production modifier -> SYNCHRONIZED

State 300:
## Known stack suffix:
## RETURN
## LR(1) items:
return_statement -> RETURN . expression_opt SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression_opt shift to state 301
-- On expression shift to state 303
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On SM
--   reduce production expression_opt ->

State 301:
## Known stack suffix:
## RETURN expression_opt
## LR(1) items:
return_statement -> RETURN expression_opt . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 302
## Reductions:

State 302:
## Known stack suffix:
## RETURN expression_opt SM
## LR(1) items:
return_statement -> RETURN expression_opt SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production return_statement -> RETURN expression_opt SM

State 303:
## Known stack suffix:
## expression
## LR(1) items:
expression_opt -> expression . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production expression_opt -> expression

State 304:
## Known stack suffix:
## LC switch_labels RC
## LR(1) items:
switch_block -> LC switch_labels RC . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC switch_labels RC

State 305:
## Known stack suffix:
## LP
## LR(1) items:
primary_no_new_array -> LP . expression RP [ SM RP RC PLUS LB INCR DOT DECR CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 306
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 306:
## Known stack suffix:
## LP expression
## LR(1) items:
primary_no_new_array -> LP expression . RP [ SM RP RC PLUS LB INCR DOT DECR CM ]
## Transitions:
-- On RP shift to state 307
## Reductions:

State 307:
## Known stack suffix:
## LP expression RP
## LR(1) items:
primary_no_new_array -> LP expression RP . [ SM RP RC PLUS LB INCR DOT DECR CM ]
## Transitions:
## Reductions:
-- On SM RP RC PLUS LB INCR DOT DECR CM
--   reduce production primary_no_new_array -> LP expression RP

State 308:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LP expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 309
## Reductions:

State 309:
## Known stack suffix:
## IF LP
## LR(1) items:
if_then_else_statement -> IF LP . expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 310
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 310:
## Known stack suffix:
## IF LP expression
## LR(1) items:
if_then_else_statement -> IF LP expression . RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 311
## Reductions:

State 311:
## Known stack suffix:
## IF LP expression RP
## LR(1) items:
if_then_else_statement -> IF LP expression RP . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 443
-- On statement_expression shift to state 403
-- On statement shift to state 440
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 312:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE . LP expression RP statement_no_short_if [ ELSE ]
## Transitions:
-- On LP shift to state 313
## Reductions:

State 313:
## Known stack suffix:
## WHILE LP
## LR(1) items:
while_statement -> WHILE LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP . expression RP statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 314
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 314:
## Known stack suffix:
## WHILE LP expression
## LR(1) items:
while_statement -> WHILE LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP expression . RP statement_no_short_if [ ELSE ]
## Transitions:
-- On RP shift to state 315
## Reductions:

State 315:
## Known stack suffix:
## WHILE LP expression RP
## LR(1) items:
while_statement -> WHILE LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP expression RP . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 441
-- On statement_expression shift to state 403
-- On statement shift to state 442
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 316:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LP expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF . LP expression RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## IF LP
## LR(1) items:
if_then_else_statement -> IF LP . expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP . expression RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 318
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 318:
## Known stack suffix:
## IF LP expression
## LR(1) items:
if_then_else_statement -> IF LP expression . RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression . RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## IF LP expression RP
## LR(1) items:
if_then_else_statement -> IF LP expression RP . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP . statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 436
-- On statement_expression shift to state 403
-- On statement shift to state 440
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 320:
## Known stack suffix:
## FOR
## LR(1) items:
for_statement -> FOR . LP for_control RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR . LP for_control RP statement_no_short_if [ ELSE ]
## Transitions:
-- On LP shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## FOR LP
## LR(1) items:
for_statement -> FOR LP . for_control RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP . for_control RP statement_no_short_if [ ELSE ]
## Transitions:
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 45
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On FINAL shift to state 53
-- On DECR shift to state 121
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On type_java shift to state 322
-- On statement_expression_list shift to state 346
-- On statement_expression shift to state 357
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers shift to state 359
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration shift to state 367
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On for_var_control shift to state 368
-- On for_init_opt shift to state 369
-- On for_init shift to state 376
-- On for_control shift to state 377
-- On field_access shift to state 204
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On SM
--   reduce production for_init_opt ->

State 322:
## Known stack suffix:
## type_java
## LR(1) items:
for_var_control -> type_java . variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> type_java . variable_declarators [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 323
-- On variable_declarator_id shift to state 341
-- On variable_declarator shift to state 345
-- On identifier shift to state 256
## Reductions:

State 323:
## Known stack suffix:
## type_java variable_declarators
## LR(1) items:
local_variable_declaration -> type_java variable_declarators . [ SM ]
variable_declarators -> variable_declarators . CM variable_declarator [ SM CM ]
## Transitions:
-- On CM shift to state 324
## Reductions:
-- On SM
--   reduce production local_variable_declaration -> type_java variable_declarators

State 324:
## Known stack suffix:
## variable_declarators CM
## LR(1) items:
variable_declarators -> variable_declarators CM . variable_declarator [ SM CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarator_id shift to state 325
-- On variable_declarator shift to state 340
-- On identifier shift to state 256
## Reductions:

State 325:
## Known stack suffix:
## variable_declarator_id
## LR(1) items:
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ CM ]
## Transitions:
-- On LB_RB shift to state 255
-- On EQ shift to state 326
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 326:
## Known stack suffix:
## variable_declarator_id EQ
## LR(1) items:
variable_declarator -> variable_declarator_id EQ . variable_initializer [ SM CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On LC shift to state 327
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On variable_initializer shift to state 339
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 332
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_initializer shift to state 333
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 327:
## Known stack suffix:
## LC
## LR(1) items:
array_initializer -> LC . comma_opt RC [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_initializer -> LC . variable_initializers comma_opt RC [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On LC shift to state 327
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On CM shift to state 328
-- On variable_initializers shift to state 329
-- On variable_initializer shift to state 336
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 332
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On comma_opt shift to state 337
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_initializer shift to state 333
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RC
--   reduce production comma_opt ->

State 328:
## Known stack suffix:
## CM
## LR(1) items:
comma_opt -> CM . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production comma_opt -> CM

State 329:
## Known stack suffix:
## LC variable_initializers
## LR(1) items:
array_initializer -> LC variable_initializers . comma_opt RC [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
variable_initializers -> variable_initializers . CM variable_initializer [ RC CM ]
## Transitions:
-- On CM shift to state 330
-- On comma_opt shift to state 334
## Reductions:
-- On RC
--   reduce production comma_opt ->

State 330:
## Known stack suffix:
## variable_initializers CM
## LR(1) items:
comma_opt -> CM . [ RC ]
variable_initializers -> variable_initializers CM . variable_initializer [ RC CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On LC shift to state 327
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On variable_initializer shift to state 331
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 332
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_initializer shift to state 333
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RC
--   reduce production comma_opt -> CM

State 331:
## Known stack suffix:
## variable_initializers CM variable_initializer
## LR(1) items:
variable_initializers -> variable_initializers CM variable_initializer . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production variable_initializers -> variable_initializers CM variable_initializer

State 332:
## Known stack suffix:
## expression
## LR(1) items:
variable_initializer -> expression . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production variable_initializer -> expression

State 333:
## Known stack suffix:
## array_initializer
## LR(1) items:
variable_initializer -> array_initializer . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production variable_initializer -> array_initializer

State 334:
## Known stack suffix:
## LC variable_initializers comma_opt
## LR(1) items:
array_initializer -> LC variable_initializers comma_opt . RC [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RC shift to state 335
## Reductions:

State 335:
## Known stack suffix:
## LC variable_initializers comma_opt RC
## LR(1) items:
array_initializer -> LC variable_initializers comma_opt RC . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_initializer -> LC variable_initializers comma_opt RC

State 336:
## Known stack suffix:
## variable_initializer
## LR(1) items:
variable_initializers -> variable_initializer . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production variable_initializers -> variable_initializer

State 337:
## Known stack suffix:
## LC comma_opt
## LR(1) items:
array_initializer -> LC comma_opt . RC [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RC shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## LC comma_opt RC
## LR(1) items:
array_initializer -> LC comma_opt RC . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_initializer -> LC comma_opt RC

State 339:
## Known stack suffix:
## variable_declarator_id EQ variable_initializer
## LR(1) items:
variable_declarator -> variable_declarator_id EQ variable_initializer . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id EQ variable_initializer

State 340:
## Known stack suffix:
## variable_declarators CM variable_declarator
## LR(1) items:
variable_declarators -> variable_declarators CM variable_declarator . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production variable_declarators -> variable_declarators CM variable_declarator

State 341:
## Known stack suffix:
## type_java variable_declarator_id
## LR(1) items:
for_var_control -> type_java variable_declarator_id . for_var_control_rest [ RP ]
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ COLON CM ]
## Transitions:
-- On LB_RB shift to state 255
-- On EQ shift to state 326
-- On COLON shift to state 342
-- On for_var_control_rest shift to state 344
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 342:
## Known stack suffix:
## COLON
## LR(1) items:
for_var_control_rest -> COLON . expression [ RP ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 343
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 343:
## Known stack suffix:
## COLON expression
## LR(1) items:
for_var_control_rest -> COLON expression . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control_rest -> COLON expression

State 344:
## Known stack suffix:
## type_java variable_declarator_id for_var_control_rest
## LR(1) items:
for_var_control -> type_java variable_declarator_id for_var_control_rest . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control -> type_java variable_declarator_id for_var_control_rest

State 345:
## Known stack suffix:
## variable_declarator
## LR(1) items:
variable_declarators -> variable_declarator . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production variable_declarators -> variable_declarator

State 346:
## Known stack suffix:
## statement_expression_list
## LR(1) items:
for_init -> statement_expression_list . [ SM ]
statement_expression_list -> statement_expression_list . CM statement_expression [ SM CM ]
## Transitions:
-- On CM shift to state 347
## Reductions:
-- On SM
--   reduce production for_init -> statement_expression_list

State 347:
## Known stack suffix:
## statement_expression_list CM
## LR(1) items:
statement_expression_list -> statement_expression_list CM . statement_expression [ SM RP CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On statement_expression shift to state 348
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 348:
## Known stack suffix:
## statement_expression_list CM statement_expression
## LR(1) items:
statement_expression_list -> statement_expression_list CM statement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression_list -> statement_expression_list CM statement_expression

State 349:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
statement_expression -> pre_increment_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> pre_increment_expression

State 350:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
statement_expression -> pre_decrement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> pre_decrement_expression

State 351:
## Known stack suffix:
## postfix_expression
## LR(1) items:
post_decrement_expression -> postfix_expression . DECR [ SM RP INCR DECR CM ]
post_increment_expression -> postfix_expression . INCR [ SM RP INCR DECR CM ]
## Transitions:
-- On INCR shift to state 145
-- On DECR shift to state 146
## Reductions:

State 352:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ INCR DECR ]
statement_expression -> post_increment_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On INCR DECR
--   reduce production postfix_expression -> post_increment_expression
-- On SM RP CM
--   reduce production statement_expression -> post_increment_expression

State 353:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ INCR DECR ]
statement_expression -> post_decrement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On INCR DECR
--   reduce production postfix_expression -> post_decrement_expression
-- On SM RP CM
--   reduce production statement_expression -> post_decrement_expression

State 354:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ LB INCR DOT DECR ]
statement_expression -> method_invocation . [ SM RP CM ]
## Transitions:
## Reductions:
-- On LB INCR DOT DECR
--   reduce production primary_no_new_array -> method_invocation
-- On SM RP CM
--   reduce production statement_expression -> method_invocation

State 355:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ LB INCR DOT DECR ]
statement_expression -> class_instance_creation_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On LB INCR DOT DECR
--   reduce production primary_no_new_array -> class_instance_creation_expression
-- On SM RP CM
--   reduce production statement_expression -> class_instance_creation_expression

State 356:
## Known stack suffix:
## assignment
## LR(1) items:
statement_expression -> assignment . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> assignment

State 357:
## Known stack suffix:
## statement_expression
## LR(1) items:
statement_expression_list -> statement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression_list -> statement_expression

State 358:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ LB_RB IDENTIFIER DOT ]
class_literal -> primitive_type . DOT CLASS [ LB INCR DOT DECR ]
type_java -> primitive_type . [ IDENTIFIER ]
## Transitions:
-- On LB_RB shift to state 12
-- On DOT shift to state 126
## Reductions:
-- On IDENTIFIER
--   reduce production type_java -> primitive_type

State 359:
## Known stack suffix:
## modifiers
## LR(1) items:
for_var_control -> modifiers . type_java variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> modifiers . type_java variable_declarators [ SM ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NATIVE shift to state 52
-- On IDENTIFIER shift to state 2
-- On FINAL shift to state 53
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On type_java shift to state 360
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On modifier shift to state 364
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
-- On annotation shift to state 365
## Reductions:

State 360:
## Known stack suffix:
## modifiers type_java
## LR(1) items:
for_var_control -> modifiers type_java . variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> modifiers type_java . variable_declarators [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 361
-- On variable_declarator_id shift to state 362
-- On variable_declarator shift to state 345
-- On identifier shift to state 256
## Reductions:

State 361:
## Known stack suffix:
## modifiers type_java variable_declarators
## LR(1) items:
local_variable_declaration -> modifiers type_java variable_declarators . [ SM ]
variable_declarators -> variable_declarators . CM variable_declarator [ SM CM ]
## Transitions:
-- On CM shift to state 324
## Reductions:
-- On SM
--   reduce production local_variable_declaration -> modifiers type_java variable_declarators

State 362:
## Known stack suffix:
## modifiers type_java variable_declarator_id
## LR(1) items:
for_var_control -> modifiers type_java variable_declarator_id . for_var_control_rest [ RP ]
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ COLON CM ]
## Transitions:
-- On LB_RB shift to state 255
-- On EQ shift to state 326
-- On COLON shift to state 342
-- On for_var_control_rest shift to state 363
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 363:
## Known stack suffix:
## modifiers type_java variable_declarator_id for_var_control_rest
## LR(1) items:
for_var_control -> modifiers type_java variable_declarator_id for_var_control_rest . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control -> modifiers type_java variable_declarator_id for_var_control_rest

State 364:
## Known stack suffix:
## modifiers modifier
## LR(1) items:
modifiers -> modifiers modifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifiers -> modifiers modifier

State 365:
## Known stack suffix:
## annotation
## LR(1) items:
modifier -> annotation . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifier -> annotation

State 366:
## Known stack suffix:
## modifier
## LR(1) items:
modifiers -> modifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production modifiers -> modifier

State 367:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
for_init -> local_variable_declaration . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production for_init -> local_variable_declaration

State 368:
## Known stack suffix:
## for_var_control
## LR(1) items:
for_control -> for_var_control . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_control -> for_var_control

State 369:
## Known stack suffix:
## for_init_opt
## LR(1) items:
for_control -> for_init_opt . SM expression_opt SM for_update_opt [ RP ]
## Transitions:
-- On SM shift to state 370
## Reductions:

State 370:
## Known stack suffix:
## for_init_opt SM
## LR(1) items:
for_control -> for_init_opt SM . expression_opt SM for_update_opt [ RP ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression_opt shift to state 371
-- On expression shift to state 303
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On SM
--   reduce production expression_opt ->

State 371:
## Known stack suffix:
## for_init_opt SM expression_opt
## LR(1) items:
for_control -> for_init_opt SM expression_opt . SM for_update_opt [ RP ]
## Transitions:
-- On SM shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## for_init_opt SM expression_opt SM
## LR(1) items:
for_control -> for_init_opt SM expression_opt SM . for_update_opt [ RP ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On statement_expression_list shift to state 373
-- On statement_expression shift to state 357
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On for_update_opt shift to state 374
-- On for_update shift to state 375
-- On field_access shift to state 204
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:
-- On RP
--   reduce production for_update_opt ->

State 373:
## Known stack suffix:
## statement_expression_list
## LR(1) items:
for_update -> statement_expression_list . [ RP ]
statement_expression_list -> statement_expression_list . CM statement_expression [ RP CM ]
## Transitions:
-- On CM shift to state 347
## Reductions:
-- On RP
--   reduce production for_update -> statement_expression_list

State 374:
## Known stack suffix:
## for_init_opt SM expression_opt SM for_update_opt
## LR(1) items:
for_control -> for_init_opt SM expression_opt SM for_update_opt . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_control -> for_init_opt SM expression_opt SM for_update_opt

State 375:
## Known stack suffix:
## for_update
## LR(1) items:
for_update_opt -> for_update . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_update_opt -> for_update

State 376:
## Known stack suffix:
## for_init
## LR(1) items:
for_init_opt -> for_init . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production for_init_opt -> for_init

State 377:
## Known stack suffix:
## FOR LP for_control
## LR(1) items:
for_statement -> FOR LP for_control . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP for_control . RP statement_no_short_if [ ELSE ]
## Transitions:
-- On RP shift to state 378
## Reductions:

State 378:
## Known stack suffix:
## FOR LP for_control RP
## LR(1) items:
for_statement -> FOR LP for_control RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP for_control RP . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 429
-- On statement_expression shift to state 403
-- On statement shift to state 405
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 379:
## Known stack suffix:
## DO
## LR(1) items:
do_statement -> DO . statement WHILE LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 421
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 380:
## Known stack suffix:
## FOR
## LR(1) items:
for_statement -> FOR . LP for_control RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 381
## Reductions:

State 381:
## Known stack suffix:
## FOR LP
## LR(1) items:
for_statement -> FOR LP . for_control RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 45
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On FINAL shift to state 53
-- On DECR shift to state 121
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On type_java shift to state 322
-- On statement_expression_list shift to state 346
-- On statement_expression shift to state 357
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers shift to state 359
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration shift to state 367
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On for_var_control shift to state 368
-- On for_init_opt shift to state 369
-- On for_init shift to state 376
-- On for_control shift to state 382
-- On field_access shift to state 204
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On SM
--   reduce production for_init_opt ->

State 382:
## Known stack suffix:
## FOR LP for_control
## LR(1) items:
for_statement -> FOR LP for_control . RP statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 383
## Reductions:

State 383:
## Known stack suffix:
## FOR LP for_control RP
## LR(1) items:
for_statement -> FOR LP for_control RP . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 405
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 384:
## Known stack suffix:
## CONTINUE
## LR(1) items:
continue_statement -> CONTINUE . identifier_opt SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier_opt shift to state 385
-- On identifier shift to state 387
## Reductions:
-- On SM
--   reduce production identifier_opt ->

State 385:
## Known stack suffix:
## CONTINUE identifier_opt
## LR(1) items:
continue_statement -> CONTINUE identifier_opt . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## CONTINUE identifier_opt SM
## LR(1) items:
continue_statement -> CONTINUE identifier_opt SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production continue_statement -> CONTINUE identifier_opt SM

State 387:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_opt -> identifier . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production identifier_opt -> identifier

State 388:
## Known stack suffix:
## BREAK
## LR(1) items:
break_statement -> BREAK . identifier_opt SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier_opt shift to state 389
-- On identifier shift to state 387
## Reductions:
-- On SM
--   reduce production identifier_opt ->

State 389:
## Known stack suffix:
## BREAK identifier_opt
## LR(1) items:
break_statement -> BREAK identifier_opt . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## BREAK identifier_opt SM
## LR(1) items:
break_statement -> BREAK identifier_opt SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production break_statement -> BREAK identifier_opt SM

State 391:
## Known stack suffix:
## ASSERT
## LR(1) items:
statement_without_trailing_substatement -> ASSERT . expression SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_without_trailing_substatement -> ASSERT . expression COLON expression SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 392
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 392:
## Known stack suffix:
## ASSERT expression
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_without_trailing_substatement -> ASSERT expression . COLON expression SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 393
-- On COLON shift to state 394
## Reductions:

State 393:
## Known stack suffix:
## ASSERT expression SM
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> ASSERT expression SM

State 394:
## Known stack suffix:
## ASSERT expression COLON
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON . expression SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 395
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 395:
## Known stack suffix:
## ASSERT expression COLON expression
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON expression . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 396
## Reductions:

State 396:
## Known stack suffix:
## ASSERT expression COLON expression SM
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON expression SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> ASSERT expression COLON expression SM

State 397:
## Known stack suffix:
## while_statement
## LR(1) items:
statement -> while_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> while_statement

State 398:
## Known stack suffix:
## try_statement
## LR(1) items:
statement_without_trailing_substatement -> try_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> try_statement

State 399:
## Known stack suffix:
## throw_statement
## LR(1) items:
statement_without_trailing_substatement -> throw_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> throw_statement

State 400:
## Known stack suffix:
## synchronized_statement
## LR(1) items:
statement_without_trailing_substatement -> synchronized_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> synchronized_statement

State 401:
## Known stack suffix:
## switch_statement
## LR(1) items:
statement_without_trailing_substatement -> switch_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> switch_statement

State 402:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> statement_without_trailing_substatement

State 403:
## Known stack suffix:
## statement_expression
## LR(1) items:
expression_statement -> statement_expression . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 404
## Reductions:

State 404:
## Known stack suffix:
## statement_expression SM
## LR(1) items:
expression_statement -> statement_expression SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production expression_statement -> statement_expression SM

State 405:
## Known stack suffix:
## FOR LP for_control RP statement
## LR(1) items:
for_statement -> FOR LP for_control RP statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production for_statement -> FOR LP for_control RP statement

State 406:
## Known stack suffix:
## return_statement
## LR(1) items:
statement_without_trailing_substatement -> return_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> return_statement

State 407:
## Known stack suffix:
## labeled_statement
## LR(1) items:
statement -> labeled_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> labeled_statement

State 408:
## Known stack suffix:
## if_then_statement
## LR(1) items:
statement -> if_then_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> if_then_statement

State 409:
## Known stack suffix:
## if_then_else_statement
## LR(1) items:
statement -> if_then_else_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> if_then_else_statement

State 410:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
identifier_ -> identifier . LT2 type_arguments GT [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
labeled_statement -> identifier . COLON statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LT2 shift to state 16
-- On COLON shift to state 411
## Reductions:
-- On OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR
--   reduce production identifier_ -> identifier

State 411:
## Known stack suffix:
## identifier COLON
## LR(1) items:
labeled_statement -> identifier COLON . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 412
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 412:
## Known stack suffix:
## identifier COLON statement
## LR(1) items:
labeled_statement -> identifier COLON statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production labeled_statement -> identifier COLON statement

State 413:
## Known stack suffix:
## for_statement
## LR(1) items:
statement -> for_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> for_statement

State 414:
## Known stack suffix:
## expression_statement
## LR(1) items:
statement_without_trailing_substatement -> expression_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> expression_statement

State 415:
## Known stack suffix:
## empty_statement
## LR(1) items:
statement_without_trailing_substatement -> empty_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> empty_statement

State 416:
## Known stack suffix:
## do_statement
## LR(1) items:
statement_without_trailing_substatement -> do_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> do_statement

State 417:
## Known stack suffix:
## continue_statement
## LR(1) items:
statement_without_trailing_substatement -> continue_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> continue_statement

State 418:
## Known stack suffix:
## break_statement
## LR(1) items:
statement_without_trailing_substatement -> break_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> break_statement

State 419:
## Known stack suffix:
## block
## LR(1) items:
statement_without_trailing_substatement -> block . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> block

State 420:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ LB_RB IDENTIFIER DOT ]
class_literal -> array_type . DOT CLASS [ LB INCR DOT DECR ]
type_java -> array_type . [ IDENTIFIER ]
## Transitions:
-- On LB_RB shift to state 25
-- On DOT shift to state 164
## Reductions:
-- On IDENTIFIER
--   reduce production type_java -> array_type

State 421:
## Known stack suffix:
## DO statement
## LR(1) items:
do_statement -> DO statement . WHILE LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 422
## Reductions:

State 422:
## Known stack suffix:
## DO statement WHILE
## LR(1) items:
do_statement -> DO statement WHILE . LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 423
## Reductions:

State 423:
## Known stack suffix:
## DO statement WHILE LP
## LR(1) items:
do_statement -> DO statement WHILE LP . expression RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 424
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:

State 424:
## Known stack suffix:
## DO statement WHILE LP expression
## LR(1) items:
do_statement -> DO statement WHILE LP expression . RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 425
## Reductions:

State 425:
## Known stack suffix:
## DO statement WHILE LP expression RP
## LR(1) items:
do_statement -> DO statement WHILE LP expression RP . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 426
## Reductions:

State 426:
## Known stack suffix:
## DO statement WHILE LP expression RP SM
## LR(1) items:
do_statement -> DO statement WHILE LP expression RP SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production do_statement -> DO statement WHILE LP expression RP SM

State 427:
## Known stack suffix:
## while_statement_no_short_if
## LR(1) items:
statement_no_short_if -> while_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> while_statement_no_short_if

State 428:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_no_short_if -> statement_without_trailing_substatement . [ ELSE ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> statement_without_trailing_substatement
-- On ELSE
--   reduce production statement_no_short_if -> statement_without_trailing_substatement

State 429:
## Known stack suffix:
## FOR LP for_control RP statement_no_short_if
## LR(1) items:
for_statement_no_short_if -> FOR LP for_control RP statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production for_statement_no_short_if -> FOR LP for_control RP statement_no_short_if

State 430:
## Known stack suffix:
## labeled_statement_no_short_if
## LR(1) items:
statement_no_short_if -> labeled_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> labeled_statement_no_short_if

State 431:
## Known stack suffix:
## if_then_else_statement_no_short_if
## LR(1) items:
statement_no_short_if -> if_then_else_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> if_then_else_statement_no_short_if

State 432:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR ]
identifier_ -> identifier . LT2 type_arguments GT [ OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR ]
labeled_statement -> identifier . COLON statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
labeled_statement_no_short_if -> identifier . COLON statement_no_short_if [ ELSE ]
## Transitions:
-- On LT2 shift to state 16
-- On COLON shift to state 433
## Reductions:
-- On OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR
--   reduce production identifier_ -> identifier

State 433:
## Known stack suffix:
## identifier COLON
## LR(1) items:
labeled_statement -> identifier COLON . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
labeled_statement_no_short_if -> identifier COLON . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 434
-- On statement_expression shift to state 403
-- On statement shift to state 412
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 434:
## Known stack suffix:
## identifier COLON statement_no_short_if
## LR(1) items:
labeled_statement_no_short_if -> identifier COLON statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production labeled_statement_no_short_if -> identifier COLON statement_no_short_if

State 435:
## Known stack suffix:
## for_statement_no_short_if
## LR(1) items:
statement_no_short_if -> for_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> for_statement_no_short_if

State 436:
## Known stack suffix:
## IF LP expression RP statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if . ELSE statement_no_short_if [ ELSE ]
## Transitions:
-- On ELSE shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 312
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 316
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 320
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement_no_short_if shift to state 427
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 428
-- On statement_no_short_if shift to state 438
-- On statement_expression shift to state 403
-- On statement shift to state 439
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement_no_short_if shift to state 430
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement_no_short_if shift to state 431
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 432
-- On for_statement_no_short_if shift to state 435
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 438:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE statement_no_short_if
## LR(1) items:
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE statement_no_short_if

State 439:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE statement
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE statement

State 440:
## Known stack suffix:
## IF LP expression RP statement
## LR(1) items:
if_then_statement -> IF LP expression RP statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production if_then_statement -> IF LP expression RP statement

State 441:
## Known stack suffix:
## WHILE LP expression RP statement_no_short_if
## LR(1) items:
while_statement_no_short_if -> WHILE LP expression RP statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production while_statement_no_short_if -> WHILE LP expression RP statement_no_short_if

State 442:
## Known stack suffix:
## WHILE LP expression RP statement
## LR(1) items:
while_statement -> WHILE LP expression RP statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production while_statement -> WHILE LP expression RP statement

State 443:
## Known stack suffix:
## IF LP expression RP statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On ELSE shift to state 444
## Reductions:

State 444:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 281
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On ASSERT shift to state 391
-- On while_statement shift to state 397
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 439
-- On return_statement shift to state 406
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On method_invocation shift to state 354
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On break_statement shift to state 418
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
## Reductions:

State 445:
## Known stack suffix:
## type_java
## LR(1) items:
local_variable_declaration -> type_java . variable_declarators [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 323
-- On variable_declarator_id shift to state 325
-- On variable_declarator shift to state 345
-- On identifier shift to state 256
## Reductions:

State 446:
## Known stack suffix:
## switch_labels switch_label
## LR(1) items:
switch_labels -> switch_labels switch_label . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_labels -> switch_labels switch_label

State 447:
## Known stack suffix:
## statement
## LR(1) items:
block_statement -> statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> statement

State 448:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
class_declaration -> modifiers_opt . CLASS identifier type_parameters_opt super_opt interfaces_opt class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CLASS shift to state 449
## Reductions:

State 449:
## Known stack suffix:
## modifiers_opt CLASS
## LR(1) items:
class_declaration -> modifiers_opt CLASS . identifier type_parameters_opt super_opt interfaces_opt class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 450
## Reductions:

State 450:
## Known stack suffix:
## modifiers_opt CLASS identifier
## LR(1) items:
class_declaration -> modifiers_opt CLASS identifier . type_parameters_opt super_opt interfaces_opt class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LT shift to state 62
-- On type_parameters_opt shift to state 451
-- On type_parameters shift to state 464
## Reductions:
-- On LC IMPLEMENTS EXTENDS
--   reduce production type_parameters_opt ->

State 451:
## Known stack suffix:
## modifiers_opt CLASS identifier type_parameters_opt
## LR(1) items:
class_declaration -> modifiers_opt CLASS identifier type_parameters_opt . super_opt interfaces_opt class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On EXTENDS shift to state 452
-- On super_opt shift to state 454
-- On super shift to state 463
## Reductions:
-- On LC IMPLEMENTS
--   reduce production super_opt ->

State 452:
## Known stack suffix:
## EXTENDS
## LR(1) items:
super -> EXTENDS . type_java [ LC IMPLEMENTS ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On type_java shift to state 453
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 453:
## Known stack suffix:
## EXTENDS type_java
## LR(1) items:
super -> EXTENDS type_java . [ LC IMPLEMENTS ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS
--   reduce production super -> EXTENDS type_java

State 454:
## Known stack suffix:
## modifiers_opt CLASS identifier type_parameters_opt super_opt
## LR(1) items:
class_declaration -> modifiers_opt CLASS identifier type_parameters_opt super_opt . interfaces_opt class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IMPLEMENTS shift to state 455
-- On interfaces_opt shift to state 460
-- On interfaces shift to state 462
## Reductions:
-- On LC
--   reduce production interfaces_opt ->

State 455:
## Known stack suffix:
## IMPLEMENTS
## LR(1) items:
interfaces -> IMPLEMENTS . ref_type_list [ LC ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 456
-- On ref_type_list shift to state 457
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 456:
## Known stack suffix:
## reference_type
## LR(1) items:
ref_type_list -> reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production ref_type_list -> reference_type

State 457:
## Known stack suffix:
## IMPLEMENTS ref_type_list
## LR(1) items:
interfaces -> IMPLEMENTS ref_type_list . [ LC ]
ref_type_list -> ref_type_list . CM reference_type [ LC CM ]
## Transitions:
-- On CM shift to state 458
## Reductions:
-- On LC
--   reduce production interfaces -> IMPLEMENTS ref_type_list

State 458:
## Known stack suffix:
## ref_type_list CM
## LR(1) items:
ref_type_list -> ref_type_list CM . reference_type [ LC CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 459
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 459:
## Known stack suffix:
## ref_type_list CM reference_type
## LR(1) items:
ref_type_list -> ref_type_list CM reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production ref_type_list -> ref_type_list CM reference_type

State 460:
## Known stack suffix:
## modifiers_opt CLASS identifier type_parameters_opt super_opt interfaces_opt
## LR(1) items:
class_declaration -> modifiers_opt CLASS identifier type_parameters_opt super_opt interfaces_opt . class_body [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 240
-- On class_body shift to state 461
## Reductions:

State 461:
## Known stack suffix:
## modifiers_opt CLASS identifier type_parameters_opt super_opt interfaces_opt class_body
## LR(1) items:
class_declaration -> modifiers_opt CLASS identifier type_parameters_opt super_opt interfaces_opt class_body . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production class_declaration -> modifiers_opt CLASS identifier type_parameters_opt super_opt interfaces_opt class_body

State 462:
## Known stack suffix:
## interfaces
## LR(1) items:
interfaces_opt -> interfaces . [ LC ]
## Transitions:
## Reductions:
-- On LC
--   reduce production interfaces_opt -> interfaces

State 463:
## Known stack suffix:
## super
## LR(1) items:
super_opt -> super . [ LC IMPLEMENTS ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS
--   reduce production super_opt -> super

State 464:
## Known stack suffix:
## type_parameters
## LR(1) items:
type_parameters_opt -> type_parameters . [ LC IMPLEMENTS EXTENDS ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS EXTENDS
--   reduce production type_parameters_opt -> type_parameters

State 465:
## Known stack suffix:
## modifiers
## LR(1) items:
local_variable_declaration -> modifiers . type_java variable_declarators [ SM ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL CLASS AT ABSTRACT ]
modifiers_opt -> modifiers . [ CLASS ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NATIVE shift to state 52
-- On IDENTIFIER shift to state 2
-- On FINAL shift to state 53
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On type_java shift to state 466
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On modifier shift to state 364
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
-- On annotation shift to state 365
## Reductions:
-- On CLASS
--   reduce production modifiers_opt -> modifiers

State 466:
## Known stack suffix:
## modifiers type_java
## LR(1) items:
local_variable_declaration -> modifiers type_java . variable_declarators [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 361
-- On variable_declarator_id shift to state 325
-- On variable_declarator shift to state 345
-- On identifier shift to state 256
## Reductions:

State 467:
## Known stack suffix:
## local_variable_declaration_statement
## LR(1) items:
block_statement -> local_variable_declaration_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> local_variable_declaration_statement

State 468:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 469
## Reductions:

State 469:
## Known stack suffix:
## local_variable_declaration SM
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production local_variable_declaration_statement -> local_variable_declaration SM

State 470:
## Known stack suffix:
## class_declaration
## LR(1) items:
block_statement -> class_declaration . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> class_declaration

State 471:
## Known stack suffix:
## switch_labels block_statements
## LR(1) items:
block_statements -> block_statements . block_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_group -> switch_labels block_statements . [ RC DEFAULT CASE ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statement shift to state 472
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On CLASS
--   reduce production modifiers_opt ->
-- On RC DEFAULT CASE
--   reduce production switch_block_statement_group -> switch_labels block_statements

State 472:
## Known stack suffix:
## block_statements block_statement
## LR(1) items:
block_statements -> block_statements block_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statements -> block_statements block_statement

State 473:
## Known stack suffix:
## block_statement
## LR(1) items:
block_statements -> block_statement . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statements -> block_statement

State 474:
## Known stack suffix:
## switch_label
## LR(1) items:
switch_labels -> switch_label . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_labels -> switch_label

State 475:
## Known stack suffix:
## LC switch_block_statement_groups
## LR(1) items:
switch_block -> LC switch_block_statement_groups . RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC switch_block_statement_groups . switch_labels RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_groups -> switch_block_statement_groups . switch_block_statement_group [ RC DEFAULT CASE ]
## Transitions:
-- On RC shift to state 476
-- On DEFAULT shift to state 292
-- On CASE shift to state 294
-- On switch_labels shift to state 477
-- On switch_label shift to state 474
-- On switch_block_statement_group shift to state 479
## Reductions:

State 476:
## Known stack suffix:
## LC switch_block_statement_groups RC
## LR(1) items:
switch_block -> LC switch_block_statement_groups RC . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC switch_block_statement_groups RC

State 477:
## Known stack suffix:
## LC switch_block_statement_groups switch_labels
## LR(1) items:
switch_block -> LC switch_block_statement_groups switch_labels . RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_group -> switch_labels . block_statements [ RC DEFAULT CASE ]
switch_labels -> switch_labels . switch_label [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On RC shift to state 478
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DEFAULT shift to state 292
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On CASE shift to state 294
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On switch_label shift to state 446
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statements shift to state 471
-- On block_statement shift to state 473
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On CLASS
--   reduce production modifiers_opt ->

State 478:
## Known stack suffix:
## LC switch_block_statement_groups switch_labels RC
## LR(1) items:
switch_block -> LC switch_block_statement_groups switch_labels RC . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC switch_block_statement_groups switch_labels RC

State 479:
## Known stack suffix:
## switch_block_statement_groups switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group . [ RC DEFAULT CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT CASE
--   reduce production switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group

State 480:
## Known stack suffix:
## switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_group . [ RC DEFAULT CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT CASE
--   reduce production switch_block_statement_groups -> switch_block_statement_group

State 481:
## Known stack suffix:
## SWITCH LP expression RP switch_block
## LR(1) items:
switch_statement -> SWITCH LP expression RP switch_block . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_statement -> SWITCH LP expression RP switch_block

State 482:
## Known stack suffix:
## LC block_statements_opt
## LR(1) items:
block -> LC block_statements_opt . RC [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINALLY FINAL ENUM ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 483
## Reductions:

State 483:
## Known stack suffix:
## LC block_statements_opt RC
## LR(1) items:
block -> LC block_statements_opt RC . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINALLY FINAL ENUM ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINALLY FINAL ENUM ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production block -> LC block_statements_opt RC

State 484:
## Known stack suffix:
## block_statements
## LR(1) items:
block_statements -> block_statements . block_statement [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
block_statements_opt -> block_statements . [ RC ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statement shift to state 472
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production block_statements_opt -> block_statements
-- On CLASS
--   reduce production modifiers_opt ->

State 485:
## Known stack suffix:
## STATIC block
## LR(1) items:
static_initializer -> STATIC block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production static_initializer -> STATIC block

State 486:
## Known stack suffix:
## SM
## LR(1) items:
class_member_declaration -> SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> SM

State 487:
## Known stack suffix:
## static_initializer
## LR(1) items:
class_body_declaration -> static_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declaration -> static_initializer

State 488:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
class_declaration -> modifiers_opt . CLASS identifier type_parameters_opt super_opt interfaces_opt class_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
constructor_declaration -> modifiers_opt . constructor_declarator throws_opt constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
enum_declaration -> modifiers_opt . ENUM identifier interfaces_opt enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
field_declaration -> modifiers_opt . type_java variable_declarators SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
generic_method_or_constructor_decl -> modifiers_opt . type_parameters generic_method_or_constructor_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_declaration -> modifiers_opt . INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
method_header -> modifiers_opt . type_java method_declarator throws_opt [ SM LC ]
method_header -> modifiers_opt . VOID method_declarator throws_opt [ SM LC ]
## Transitions:
-- On VOID shift to state 489
-- On PRIMITIVE_TYPE shift to state 7
-- On LT shift to state 62
-- On INTERFACE shift to state 60
-- On IDENTIFIER shift to state 2
-- On ENUM shift to state 492
-- On CLASS shift to state 449
-- On type_parameters shift to state 548
-- On type_java shift to state 566
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 570
-- On constructor_declarator shift to state 574
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 489:
## Known stack suffix:
## modifiers_opt VOID
## LR(1) items:
method_header -> modifiers_opt VOID . method_declarator throws_opt [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On method_declarator shift to state 490
-- On identifier shift to state 93
## Reductions:

State 490:
## Known stack suffix:
## modifiers_opt VOID method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB ]
method_header -> modifiers_opt VOID method_declarator . throws_opt [ SM LC ]
## Transitions:
-- On THROWS shift to state 84
-- On LB_RB shift to state 89
-- On throws_opt shift to state 491
-- On throws shift to state 92
## Reductions:
-- On SM LC
--   reduce production throws_opt ->

State 491:
## Known stack suffix:
## modifiers_opt VOID method_declarator throws_opt
## LR(1) items:
method_header -> modifiers_opt VOID method_declarator throws_opt . [ SM LC ]
## Transitions:
## Reductions:
-- On SM LC
--   reduce production method_header -> modifiers_opt VOID method_declarator throws_opt

State 492:
## Known stack suffix:
## modifiers_opt ENUM
## LR(1) items:
enum_declaration -> modifiers_opt ENUM . identifier interfaces_opt enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 493
## Reductions:

State 493:
## Known stack suffix:
## modifiers_opt ENUM identifier
## LR(1) items:
enum_declaration -> modifiers_opt ENUM identifier . interfaces_opt enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IMPLEMENTS shift to state 455
-- On interfaces_opt shift to state 494
-- On interfaces shift to state 462
## Reductions:
-- On LC
--   reduce production interfaces_opt ->

State 494:
## Known stack suffix:
## modifiers_opt ENUM identifier interfaces_opt
## LR(1) items:
enum_declaration -> modifiers_opt ENUM identifier interfaces_opt . enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 495
-- On enum_body shift to state 547
## Reductions:

State 495:
## Known stack suffix:
## LC
## LR(1) items:
enum_body -> LC . enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_body -> LC . enum_constants enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_body -> LC . enum_constants CM enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 496
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 521
-- On enum_constants shift to state 536
-- On enum_constant shift to state 544
-- On enum_body_declarations_opt shift to state 545
-- On enum_body_declarations shift to state 541
## Reductions:
-- On RC
--   reduce production enum_body_declarations_opt ->

State 496:
## Known stack suffix:
## SM
## LR(1) items:
enum_body_declarations -> SM . class_body_declarations_opt [ RC ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 241
-- On SM shift to state 486
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On LC shift to state 242
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On static_initializer shift to state 487
-- On modifiers_opt shift to state 488
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On method_header shift to state 502
-- On method_declaration shift to state 506
-- On interface_declaration shift to state 507
-- On instance_initializer shift to state 508
-- On generic_method_or_constructor_decl shift to state 509
-- On field_declaration shift to state 510
-- On enum_declaration shift to state 511
-- On constructor_declaration shift to state 512
-- On class_member_declaration shift to state 513
-- On class_declaration shift to state 514
-- On class_body_declarations_opt shift to state 515
-- On class_body_declarations shift to state 516
-- On class_body_declaration shift to state 520
-- On block shift to state 518
-- On annotation_type_declaration shift to state 519
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production class_body_declarations_opt ->
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 497:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
modifiers_opt -> modifiers . [ VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 498
-- On ABSTRACT shift to state 58
-- On modifier shift to state 364
-- On annotation shift to state 365
## Reductions:
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt -> modifiers

State 498:
## Known stack suffix:
## modifiers AT
## LR(1) items:
annotation -> AT . name [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
annotation -> AT . name LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
annotation_type_declaration -> modifiers AT . INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On INTERFACE shift to state 499
-- On IDENTIFIER shift to state 2
-- On name shift to state 97
-- On identifier_ shift to state 14
-- On identifier shift to state 15
## Reductions:

State 499:
## Known stack suffix:
## modifiers AT INTERFACE
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE . identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 500
## Reductions:

State 500:
## Known stack suffix:
## modifiers AT INTERFACE identifier
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE identifier . annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 57
-- On annotation_type_body shift to state 501
## Reductions:

State 501:
## Known stack suffix:
## modifiers AT INTERFACE identifier annotation_type_body
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE identifier annotation_type_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_declaration -> modifiers AT INTERFACE identifier annotation_type_body

State 502:
## Known stack suffix:
## method_header
## LR(1) items:
method_declaration -> method_header . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 503
-- On LC shift to state 242
-- On method_body shift to state 504
-- On block shift to state 505
## Reductions:

State 503:
## Known stack suffix:
## SM
## LR(1) items:
method_body -> SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production method_body -> SM

State 504:
## Known stack suffix:
## method_header method_body
## LR(1) items:
method_declaration -> method_header method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production method_declaration -> method_header method_body

State 505:
## Known stack suffix:
## block
## LR(1) items:
method_body -> block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production method_body -> block

State 506:
## Known stack suffix:
## method_declaration
## LR(1) items:
class_member_declaration -> method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> method_declaration

State 507:
## Known stack suffix:
## interface_declaration
## LR(1) items:
class_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> interface_declaration

State 508:
## Known stack suffix:
## instance_initializer
## LR(1) items:
class_body_declaration -> instance_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declaration -> instance_initializer

State 509:
## Known stack suffix:
## generic_method_or_constructor_decl
## LR(1) items:
class_member_declaration -> generic_method_or_constructor_decl . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> generic_method_or_constructor_decl

State 510:
## Known stack suffix:
## field_declaration
## LR(1) items:
class_member_declaration -> field_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> field_declaration

State 511:
## Known stack suffix:
## enum_declaration
## LR(1) items:
class_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> enum_declaration

State 512:
## Known stack suffix:
## constructor_declaration
## LR(1) items:
class_body_declaration -> constructor_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declaration -> constructor_declaration

State 513:
## Known stack suffix:
## class_member_declaration
## LR(1) items:
class_body_declaration -> class_member_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declaration -> class_member_declaration

State 514:
## Known stack suffix:
## class_declaration
## LR(1) items:
class_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> class_declaration

State 515:
## Known stack suffix:
## SM class_body_declarations_opt
## LR(1) items:
enum_body_declarations -> SM class_body_declarations_opt . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production enum_body_declarations -> SM class_body_declarations_opt

State 516:
## Known stack suffix:
## class_body_declarations
## LR(1) items:
class_body_declarations -> class_body_declarations . class_body_declaration [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
class_body_declarations_opt -> class_body_declarations . [ RC ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 241
-- On SM shift to state 486
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On LC shift to state 242
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On static_initializer shift to state 487
-- On modifiers_opt shift to state 488
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On method_header shift to state 502
-- On method_declaration shift to state 506
-- On interface_declaration shift to state 507
-- On instance_initializer shift to state 508
-- On generic_method_or_constructor_decl shift to state 509
-- On field_declaration shift to state 510
-- On enum_declaration shift to state 511
-- On constructor_declaration shift to state 512
-- On class_member_declaration shift to state 513
-- On class_declaration shift to state 514
-- On class_body_declaration shift to state 517
-- On block shift to state 518
-- On annotation_type_declaration shift to state 519
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production class_body_declarations_opt -> class_body_declarations
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 517:
## Known stack suffix:
## class_body_declarations class_body_declaration
## LR(1) items:
class_body_declarations -> class_body_declarations class_body_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declarations -> class_body_declarations class_body_declaration

State 518:
## Known stack suffix:
## block
## LR(1) items:
instance_initializer -> block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production instance_initializer -> block

State 519:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
class_member_declaration -> annotation_type_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_member_declaration -> annotation_type_declaration

State 520:
## Known stack suffix:
## class_body_declaration
## LR(1) items:
class_body_declarations -> class_body_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production class_body_declarations -> class_body_declaration

State 521:
## Known stack suffix:
## identifier
## LR(1) items:
enum_constant -> identifier . [ SM RC CM ]
enum_constant -> identifier . LP argument_list_opt RP [ SM RC CM ]
enum_constant -> identifier . LC method_declarations_opt RC [ SM RC CM ]
## Transitions:
-- On LP shift to state 522
-- On LC shift to state 525
## Reductions:
-- On SM RC CM
--   reduce production enum_constant -> identifier

State 522:
## Known stack suffix:
## identifier LP
## LR(1) items:
enum_constant -> identifier LP . argument_list_opt RP [ SM RC CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 523
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 523:
## Known stack suffix:
## identifier LP argument_list_opt
## LR(1) items:
enum_constant -> identifier LP argument_list_opt . RP [ SM RC CM ]
## Transitions:
-- On RP shift to state 524
## Reductions:

State 524:
## Known stack suffix:
## identifier LP argument_list_opt RP
## LR(1) items:
enum_constant -> identifier LP argument_list_opt RP . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production enum_constant -> identifier LP argument_list_opt RP

State 525:
## Known stack suffix:
## identifier LC
## LR(1) items:
enum_constant -> identifier LC . method_declarations_opt RC [ SM RC CM ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 526
-- On modifiers shift to state 530
-- On modifier shift to state 366
-- On method_header shift to state 502
-- On method_declarations_opt shift to state 531
-- On method_declarations shift to state 533
-- On method_declaration shift to state 535
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production method_declarations_opt ->
-- On VOID PRIMITIVE_TYPE IDENTIFIER
--   reduce production modifiers_opt ->

State 526:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
method_header -> modifiers_opt . type_java method_declarator throws_opt [ SM LC ]
method_header -> modifiers_opt . VOID method_declarator throws_opt [ SM LC ]
## Transitions:
-- On VOID shift to state 489
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On type_java shift to state 527
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 527:
## Known stack suffix:
## modifiers_opt type_java
## LR(1) items:
method_header -> modifiers_opt type_java . method_declarator throws_opt [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On method_declarator shift to state 528
-- On identifier shift to state 93
## Reductions:

State 528:
## Known stack suffix:
## modifiers_opt type_java method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB ]
method_header -> modifiers_opt type_java method_declarator . throws_opt [ SM LC ]
## Transitions:
-- On THROWS shift to state 84
-- On LB_RB shift to state 89
-- On throws_opt shift to state 529
-- On throws shift to state 92
## Reductions:
-- On SM LC
--   reduce production throws_opt ->

State 529:
## Known stack suffix:
## modifiers_opt type_java method_declarator throws_opt
## LR(1) items:
method_header -> modifiers_opt type_java method_declarator throws_opt . [ SM LC ]
## Transitions:
## Reductions:
-- On SM LC
--   reduce production method_header -> modifiers_opt type_java method_declarator throws_opt

State 530:
## Known stack suffix:
## modifiers
## LR(1) items:
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT ]
modifiers_opt -> modifiers . [ VOID PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On modifier shift to state 364
-- On annotation shift to state 365
## Reductions:
-- On VOID PRIMITIVE_TYPE IDENTIFIER
--   reduce production modifiers_opt -> modifiers

State 531:
## Known stack suffix:
## identifier LC method_declarations_opt
## LR(1) items:
enum_constant -> identifier LC method_declarations_opt . RC [ SM RC CM ]
## Transitions:
-- On RC shift to state 532
## Reductions:

State 532:
## Known stack suffix:
## identifier LC method_declarations_opt RC
## LR(1) items:
enum_constant -> identifier LC method_declarations_opt RC . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production enum_constant -> identifier LC method_declarations_opt RC

State 533:
## Known stack suffix:
## method_declarations
## LR(1) items:
method_declarations -> method_declarations . method_declaration [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT ]
method_declarations_opt -> method_declarations . [ RC ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 96
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 526
-- On modifiers shift to state 530
-- On modifier shift to state 366
-- On method_header shift to state 502
-- On method_declaration shift to state 534
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production method_declarations_opt -> method_declarations
-- On VOID PRIMITIVE_TYPE IDENTIFIER
--   reduce production modifiers_opt ->

State 534:
## Known stack suffix:
## method_declarations method_declaration
## LR(1) items:
method_declarations -> method_declarations method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
--   reduce production method_declarations -> method_declarations method_declaration

State 535:
## Known stack suffix:
## method_declaration
## LR(1) items:
method_declarations -> method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
--   reduce production method_declarations -> method_declaration

State 536:
## Known stack suffix:
## LC enum_constants
## LR(1) items:
enum_body -> LC enum_constants . enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_body -> LC enum_constants . CM enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_constants -> enum_constants . CM enum_constant [ SM RC CM ]
## Transitions:
-- On SM shift to state 496
-- On CM shift to state 537
-- On enum_body_declarations_opt shift to state 542
-- On enum_body_declarations shift to state 541
## Reductions:
-- On RC
--   reduce production enum_body_declarations_opt ->

State 537:
## Known stack suffix:
## LC enum_constants CM
## LR(1) items:
enum_body -> LC enum_constants CM . enum_body_declarations_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_constants -> enum_constants CM . enum_constant [ SM RC CM ]
## Transitions:
-- On SM shift to state 496
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 521
-- On enum_constant shift to state 538
-- On enum_body_declarations_opt shift to state 539
-- On enum_body_declarations shift to state 541
## Reductions:
-- On RC
--   reduce production enum_body_declarations_opt ->

State 538:
## Known stack suffix:
## enum_constants CM enum_constant
## LR(1) items:
enum_constants -> enum_constants CM enum_constant . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production enum_constants -> enum_constants CM enum_constant

State 539:
## Known stack suffix:
## LC enum_constants CM enum_body_declarations_opt
## LR(1) items:
enum_body -> LC enum_constants CM enum_body_declarations_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 540
## Reductions:

State 540:
## Known stack suffix:
## LC enum_constants CM enum_body_declarations_opt RC
## LR(1) items:
enum_body -> LC enum_constants CM enum_body_declarations_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production enum_body -> LC enum_constants CM enum_body_declarations_opt RC

State 541:
## Known stack suffix:
## enum_body_declarations
## LR(1) items:
enum_body_declarations_opt -> enum_body_declarations . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production enum_body_declarations_opt -> enum_body_declarations

State 542:
## Known stack suffix:
## LC enum_constants enum_body_declarations_opt
## LR(1) items:
enum_body -> LC enum_constants enum_body_declarations_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 543
## Reductions:

State 543:
## Known stack suffix:
## LC enum_constants enum_body_declarations_opt RC
## LR(1) items:
enum_body -> LC enum_constants enum_body_declarations_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production enum_body -> LC enum_constants enum_body_declarations_opt RC

State 544:
## Known stack suffix:
## enum_constant
## LR(1) items:
enum_constants -> enum_constant . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production enum_constants -> enum_constant

State 545:
## Known stack suffix:
## LC enum_body_declarations_opt
## LR(1) items:
enum_body -> LC enum_body_declarations_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 546
## Reductions:

State 546:
## Known stack suffix:
## LC enum_body_declarations_opt RC
## LR(1) items:
enum_body -> LC enum_body_declarations_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production enum_body -> LC enum_body_declarations_opt RC

State 547:
## Known stack suffix:
## modifiers_opt ENUM identifier interfaces_opt enum_body
## LR(1) items:
enum_declaration -> modifiers_opt ENUM identifier interfaces_opt enum_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production enum_declaration -> modifiers_opt ENUM identifier interfaces_opt enum_body

State 548:
## Known stack suffix:
## modifiers_opt type_parameters
## LR(1) items:
generic_method_or_constructor_decl -> modifiers_opt type_parameters . generic_method_or_constructor_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 549
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On type_java shift to state 562
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On generic_method_or_constructor_rest shift to state 565
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 549:
## Known stack suffix:
## VOID
## LR(1) items:
generic_method_or_constructor_rest -> VOID . identifier method_declarator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 550
## Reductions:

State 550:
## Known stack suffix:
## VOID identifier
## LR(1) items:
generic_method_or_constructor_rest -> VOID identifier . method_declarator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 551
-- On method_declarator_rest shift to state 558
-- On formal_parameters shift to state 559
## Reductions:

State 551:
## Known stack suffix:
## LP
## LR(1) items:
formal_parameters -> LP . formal_parameter_list_opt RP [ THROWS SM LC ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifiers_opt shift to state 251
-- On variable_modifiers shift to state 262
-- On variable_modifier shift to state 265
-- On formal_parameter_list_opt shift to state 552
-- On formal_parameter_list shift to state 554
-- On formal_parameter shift to state 557
-- On annotation shift to state 264
## Reductions:
-- On RP
--   reduce production formal_parameter_list_opt ->
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt ->

State 552:
## Known stack suffix:
## LP formal_parameter_list_opt
## LR(1) items:
formal_parameters -> LP formal_parameter_list_opt . RP [ THROWS SM LC ]
## Transitions:
-- On RP shift to state 553
## Reductions:

State 553:
## Known stack suffix:
## LP formal_parameter_list_opt RP
## LR(1) items:
formal_parameters -> LP formal_parameter_list_opt RP . [ THROWS SM LC ]
## Transitions:
## Reductions:
-- On THROWS SM LC
--   reduce production formal_parameters -> LP formal_parameter_list_opt RP

State 554:
## Known stack suffix:
## formal_parameter_list
## LR(1) items:
formal_parameter_list -> formal_parameter_list . CM formal_parameter [ RP CM ]
formal_parameter_list_opt -> formal_parameter_list . [ RP ]
## Transitions:
-- On CM shift to state 555
## Reductions:
-- On RP
--   reduce production formal_parameter_list_opt -> formal_parameter_list

State 555:
## Known stack suffix:
## formal_parameter_list CM
## LR(1) items:
formal_parameter_list -> formal_parameter_list CM . formal_parameter [ RP CM ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifiers_opt shift to state 251
-- On variable_modifiers shift to state 262
-- On variable_modifier shift to state 265
-- On formal_parameter shift to state 556
-- On annotation shift to state 264
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt ->

State 556:
## Known stack suffix:
## formal_parameter_list CM formal_parameter
## LR(1) items:
formal_parameter_list -> formal_parameter_list CM formal_parameter . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production formal_parameter_list -> formal_parameter_list CM formal_parameter

State 557:
## Known stack suffix:
## formal_parameter
## LR(1) items:
formal_parameter_list -> formal_parameter . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production formal_parameter_list -> formal_parameter

State 558:
## Known stack suffix:
## VOID identifier method_declarator_rest
## LR(1) items:
generic_method_or_constructor_rest -> VOID identifier method_declarator_rest . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_rest -> VOID identifier method_declarator_rest

State 559:
## Known stack suffix:
## formal_parameters
## LR(1) items:
method_declarator_rest -> formal_parameters . throws_opt method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 84
-- On throws_opt shift to state 560
-- On throws shift to state 92
## Reductions:
-- On SM LC
--   reduce production throws_opt ->

State 560:
## Known stack suffix:
## formal_parameters throws_opt
## LR(1) items:
method_declarator_rest -> formal_parameters throws_opt . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 503
-- On LC shift to state 242
-- On method_body shift to state 561
-- On block shift to state 505
## Reductions:

State 561:
## Known stack suffix:
## formal_parameters throws_opt method_body
## LR(1) items:
method_declarator_rest -> formal_parameters throws_opt method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production method_declarator_rest -> formal_parameters throws_opt method_body

State 562:
## Known stack suffix:
## type_java
## LR(1) items:
generic_method_or_constructor_rest -> type_java . identifier method_declarator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 563
## Reductions:

State 563:
## Known stack suffix:
## type_java identifier
## LR(1) items:
generic_method_or_constructor_rest -> type_java identifier . method_declarator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 551
-- On method_declarator_rest shift to state 564
-- On formal_parameters shift to state 559
## Reductions:

State 564:
## Known stack suffix:
## type_java identifier method_declarator_rest
## LR(1) items:
generic_method_or_constructor_rest -> type_java identifier method_declarator_rest . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_rest -> type_java identifier method_declarator_rest

State 565:
## Known stack suffix:
## modifiers_opt type_parameters generic_method_or_constructor_rest
## LR(1) items:
generic_method_or_constructor_decl -> modifiers_opt type_parameters generic_method_or_constructor_rest . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_decl -> modifiers_opt type_parameters generic_method_or_constructor_rest

State 566:
## Known stack suffix:
## modifiers_opt type_java
## LR(1) items:
field_declaration -> modifiers_opt type_java . variable_declarators SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
method_header -> modifiers_opt type_java . method_declarator throws_opt [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 567
-- On variable_declarator_id shift to state 325
-- On variable_declarator shift to state 345
-- On method_declarator shift to state 528
-- On identifier shift to state 569
## Reductions:

State 567:
## Known stack suffix:
## modifiers_opt type_java variable_declarators
## LR(1) items:
field_declaration -> modifiers_opt type_java variable_declarators . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
variable_declarators -> variable_declarators . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 568
-- On CM shift to state 324
## Reductions:

State 568:
## Known stack suffix:
## modifiers_opt type_java variable_declarators SM
## LR(1) items:
field_declaration -> modifiers_opt type_java variable_declarators SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production field_declaration -> modifiers_opt type_java variable_declarators SM

State 569:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator -> identifier . LP formal_parameter_list_opt RP [ THROWS SM LC LB_RB ]
variable_declarator_id -> identifier . [ SM LB_RB EQ CM ]
## Transitions:
-- On LP shift to state 94
## Reductions:
-- On SM LB_RB EQ CM
--   reduce production variable_declarator_id -> identifier

State 570:
## Known stack suffix:
## identifier
## LR(1) items:
constructor_declarator -> identifier . LP formal_parameter_list_opt RP [ THROWS LC ]
identifier_ -> identifier . [ LB_RB IDENTIFIER DOT ]
identifier_ -> identifier . LT2 type_arguments GT [ LB_RB IDENTIFIER DOT ]
## Transitions:
-- On LT2 shift to state 16
-- On LP shift to state 571
## Reductions:
-- On LB_RB IDENTIFIER DOT
--   reduce production identifier_ -> identifier

State 571:
## Known stack suffix:
## identifier LP
## LR(1) items:
constructor_declarator -> identifier LP . formal_parameter_list_opt RP [ THROWS LC ]
## Transitions:
-- On FINAL shift to state 95
-- On AT shift to state 96
-- On variable_modifiers_opt shift to state 251
-- On variable_modifiers shift to state 262
-- On variable_modifier shift to state 265
-- On formal_parameter_list_opt shift to state 572
-- On formal_parameter_list shift to state 554
-- On formal_parameter shift to state 557
-- On annotation shift to state 264
## Reductions:
-- On RP
--   reduce production formal_parameter_list_opt ->
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production variable_modifiers_opt ->

State 572:
## Known stack suffix:
## identifier LP formal_parameter_list_opt
## LR(1) items:
constructor_declarator -> identifier LP formal_parameter_list_opt . RP [ THROWS LC ]
## Transitions:
-- On RP shift to state 573
## Reductions:

State 573:
## Known stack suffix:
## identifier LP formal_parameter_list_opt RP
## LR(1) items:
constructor_declarator -> identifier LP formal_parameter_list_opt RP . [ THROWS LC ]
## Transitions:
## Reductions:
-- On THROWS LC
--   reduce production constructor_declarator -> identifier LP formal_parameter_list_opt RP

State 574:
## Known stack suffix:
## modifiers_opt constructor_declarator
## LR(1) items:
constructor_declaration -> modifiers_opt constructor_declarator . throws_opt constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 84
-- On throws_opt shift to state 575
-- On throws shift to state 92
## Reductions:
-- On LC
--   reduce production throws_opt ->

State 575:
## Known stack suffix:
## modifiers_opt constructor_declarator throws_opt
## LR(1) items:
constructor_declaration -> modifiers_opt constructor_declarator throws_opt . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 576
-- On constructor_body shift to state 611
## Reductions:

State 576:
## Known stack suffix:
## LC
## LR(1) items:
constructor_body -> LC . block_statements_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
constructor_body -> LC . explicit_constructor_invocation block_statements_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 577
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 582
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 587
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 598
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On explicit_constructor_invocation shift to state 606
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statements_opt shift to state 609
-- On block_statements shift to state 484
-- On block_statement shift to state 473
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production block_statements_opt ->
-- On CLASS
--   reduce production modifiers_opt ->

State 577:
## Known stack suffix:
## THIS
## LR(1) items:
explicit_constructor_invocation -> THIS . LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
primary_no_new_array -> THIS . [ LB INCR DOT DECR ]
## Transitions:
-- On LP shift to state 578
## Reductions:
-- On LB INCR DOT DECR
--   reduce production primary_no_new_array -> THIS

State 578:
## Known stack suffix:
## THIS LP
## LR(1) items:
explicit_constructor_invocation -> THIS LP . argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 579
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 579:
## Known stack suffix:
## THIS LP argument_list_opt
## LR(1) items:
explicit_constructor_invocation -> THIS LP argument_list_opt . RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 580
## Reductions:

State 580:
## Known stack suffix:
## THIS LP argument_list_opt RP
## LR(1) items:
explicit_constructor_invocation -> THIS LP argument_list_opt RP . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 581
## Reductions:

State 581:
## Known stack suffix:
## THIS LP argument_list_opt RP SM
## LR(1) items:
explicit_constructor_invocation -> THIS LP argument_list_opt RP SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> THIS LP argument_list_opt RP SM

State 582:
## Known stack suffix:
## SUPER
## LR(1) items:
explicit_constructor_invocation -> SUPER . LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> SUPER . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
method_invocation -> SUPER . DOT identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
## Transitions:
-- On LP shift to state 583
-- On DOT shift to state 108
## Reductions:

State 583:
## Known stack suffix:
## SUPER LP
## LR(1) items:
explicit_constructor_invocation -> SUPER LP . argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 584
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 584:
## Known stack suffix:
## SUPER LP argument_list_opt
## LR(1) items:
explicit_constructor_invocation -> SUPER LP argument_list_opt . RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 585
## Reductions:

State 585:
## Known stack suffix:
## SUPER LP argument_list_opt RP
## LR(1) items:
explicit_constructor_invocation -> SUPER LP argument_list_opt RP . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 586
## Reductions:

State 586:
## Known stack suffix:
## SUPER LP argument_list_opt RP SM
## LR(1) items:
explicit_constructor_invocation -> SUPER LP argument_list_opt RP SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> SUPER LP argument_list_opt RP SM

State 587:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP argument_list_opt RP class_body_opt [ SM LB INCR DOT DECR ]
explicit_constructor_invocation -> primary . DOT SUPER LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> primary . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
method_invocation -> primary . DOT identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
postfix_expression -> primary . [ INCR DECR ]
## Transitions:
-- On DOT shift to state 588
## Reductions:
-- On INCR DECR
--   reduce production postfix_expression -> primary

State 588:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_expression -> primary DOT . NEW identifier LP argument_list_opt RP class_body_opt [ SM LB INCR DOT DECR ]
explicit_constructor_invocation -> primary DOT . SUPER LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> primary DOT . identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
method_invocation -> primary DOT . identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
## Transitions:
-- On SUPER shift to state 589
-- On NEW shift to state 135
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 594
## Reductions:

State 589:
## Known stack suffix:
## primary DOT SUPER
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER . LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 590
## Reductions:

State 590:
## Known stack suffix:
## primary DOT SUPER LP
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP . argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 591
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 591:
## Known stack suffix:
## primary DOT SUPER LP argument_list_opt
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP argument_list_opt . RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 592
## Reductions:

State 592:
## Known stack suffix:
## primary DOT SUPER LP argument_list_opt RP
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP argument_list_opt RP . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## primary DOT SUPER LP argument_list_opt RP SM
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP argument_list_opt RP SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> primary DOT SUPER LP argument_list_opt RP SM

State 594:
## Known stack suffix:
## primary DOT identifier
## LR(1) items:
field_access -> primary DOT identifier . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
method_invocation -> primary DOT identifier . LP argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 595
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production field_access -> primary DOT identifier

State 595:
## Known stack suffix:
## primary DOT identifier LP
## LR(1) items:
method_invocation -> primary DOT identifier LP . argument_list_opt RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 596
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 596:
## Known stack suffix:
## primary DOT identifier LP argument_list_opt
## LR(1) items:
method_invocation -> primary DOT identifier LP argument_list_opt . RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## primary DOT identifier LP argument_list_opt RP
## LR(1) items:
method_invocation -> primary DOT identifier LP argument_list_opt RP . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production method_invocation -> primary DOT identifier LP argument_list_opt RP

State 598:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ OPERATOR_EQ LB INCR EQ DOT DECR ]
class_instance_creation_expression -> name . DOT NEW identifier LP argument_list_opt RP class_body_opt [ SM LB INCR DOT DECR ]
class_literal -> name . DOT CLASS [ LB INCR DOT DECR ]
class_or_interface_type -> name . [ LB_RB IDENTIFIER ]
explicit_constructor_invocation -> name . DOT SUPER LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name . DOT SUPER DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
left_hand_side -> name . [ OPERATOR_EQ EQ ]
method_invocation -> name . LP argument_list_opt RP [ SM LB INCR DOT DECR ]
method_invocation -> name . DOT SUPER DOT identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
name -> name . DOT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
name -> name . DOT LT2 type_arguments GT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
postfix_expression -> name . [ INCR DECR ]
primary_no_new_array -> name . DOT THIS [ LB INCR DOT DECR ]
## Transitions:
-- On LP shift to state 150
-- On LB shift to state 152
-- On DOT shift to state 599
## Reductions:
-- On LB_RB IDENTIFIER
--   reduce production class_or_interface_type -> name
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> name
-- On INCR DECR
--   reduce production postfix_expression -> name

State 599:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_expression -> name DOT . NEW identifier LP argument_list_opt RP class_body_opt [ SM LB INCR DOT DECR ]
class_literal -> name DOT . CLASS [ LB INCR DOT DECR ]
explicit_constructor_invocation -> name DOT . SUPER LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name DOT . SUPER DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
method_invocation -> name DOT . SUPER DOT identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
name -> name DOT . identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
name -> name DOT . LT2 type_arguments GT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR ]
primary_no_new_array -> name DOT . THIS [ LB INCR DOT DECR ]
## Transitions:
-- On THIS shift to state 224
-- On SUPER shift to state 600
-- On NEW shift to state 235
-- On LT2 shift to state 6
-- On IDENTIFIER shift to state 2
-- On CLASS shift to state 605
-- On identifier_ shift to state 32
-- On identifier shift to state 15
## Reductions:

State 600:
## Known stack suffix:
## name DOT SUPER
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER . LP argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name DOT SUPER . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR ]
method_invocation -> name DOT SUPER . DOT identifier LP argument_list_opt RP [ SM LB INCR DOT DECR ]
## Transitions:
-- On LP shift to state 601
-- On DOT shift to state 226
## Reductions:

State 601:
## Known stack suffix:
## name DOT SUPER LP
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP . argument_list_opt RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 602
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 602:
## Known stack suffix:
## name DOT SUPER LP argument_list_opt
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP argument_list_opt . RP SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 603
## Reductions:

State 603:
## Known stack suffix:
## name DOT SUPER LP argument_list_opt RP
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP argument_list_opt RP . SM [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 604
## Reductions:

State 604:
## Known stack suffix:
## name DOT SUPER LP argument_list_opt RP SM
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP argument_list_opt RP SM . [ WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> name DOT SUPER LP argument_list_opt RP SM

State 605:
## Known stack suffix:
## name DOT CLASS
## LR(1) items:
class_literal -> name DOT CLASS . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_literal -> name DOT CLASS

State 606:
## Known stack suffix:
## LC explicit_constructor_invocation
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation . block_statements_opt RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 243
-- On VOLATILE shift to state 43
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TRY shift to state 247
-- On TRANSIENT shift to state 44
-- On TInt shift to state 103
-- On THROW shift to state 278
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SYNCHRONIZED shift to state 299
-- On SWITCH shift to state 286
-- On SUPER shift to state 107
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 268
-- On RETURN shift to state 300
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On NATIVE shift to state 52
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 242
-- On INCR shift to state 120
-- On IF shift to state 308
-- On IDENTIFIER shift to state 2
-- On FOR shift to state 380
-- On FINAL shift to state 53
-- On DO shift to state 379
-- On DECR shift to state 121
-- On CONTINUE shift to state 384
-- On BREAK shift to state 388
-- On AT shift to state 96
-- On ASSERT shift to state 391
-- On ABSTRACT shift to state 58
-- On while_statement shift to state 397
-- On type_java shift to state 445
-- On try_statement shift to state 398
-- On throw_statement shift to state 399
-- On synchronized_statement shift to state 400
-- On switch_statement shift to state 401
-- On statement_without_trailing_substatement shift to state 402
-- On statement_expression shift to state 403
-- On statement shift to state 447
-- On return_statement shift to state 406
-- On primitive_type shift to state 358
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 349
-- On pre_decrement_expression shift to state 350
-- On postfix_expression shift to state 351
-- On post_increment_expression shift to state 352
-- On post_decrement_expression shift to state 353
-- On name shift to state 151
-- On modifiers_opt shift to state 448
-- On modifiers shift to state 465
-- On modifier shift to state 366
-- On method_invocation shift to state 354
-- On local_variable_declaration_statement shift to state 467
-- On local_variable_declaration shift to state 468
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On labeled_statement shift to state 407
-- On if_then_statement shift to state 408
-- On if_then_else_statement shift to state 409
-- On identifier_ shift to state 14
-- On identifier shift to state 410
-- On for_statement shift to state 413
-- On field_access shift to state 204
-- On expression_statement shift to state 414
-- On empty_statement shift to state 415
-- On do_statement shift to state 416
-- On continue_statement shift to state 417
-- On class_or_interface_type shift to state 260
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 355
-- On class_declaration shift to state 470
-- On break_statement shift to state 418
-- On block_statements_opt shift to state 607
-- On block_statements shift to state 484
-- On block_statement shift to state 473
-- On block shift to state 419
-- On assignment shift to state 356
-- On array_type shift to state 420
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production block_statements_opt ->
-- On CLASS
--   reduce production modifiers_opt ->

State 607:
## Known stack suffix:
## LC explicit_constructor_invocation block_statements_opt
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation block_statements_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 608
## Reductions:

State 608:
## Known stack suffix:
## LC explicit_constructor_invocation block_statements_opt RC
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation block_statements_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production constructor_body -> LC explicit_constructor_invocation block_statements_opt RC

State 609:
## Known stack suffix:
## LC block_statements_opt
## LR(1) items:
constructor_body -> LC block_statements_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 610
## Reductions:

State 610:
## Known stack suffix:
## LC block_statements_opt RC
## LR(1) items:
constructor_body -> LC block_statements_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production constructor_body -> LC block_statements_opt RC

State 611:
## Known stack suffix:
## modifiers_opt constructor_declarator throws_opt constructor_body
## LR(1) items:
constructor_declaration -> modifiers_opt constructor_declarator throws_opt constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production constructor_declaration -> modifiers_opt constructor_declarator throws_opt constructor_body

State 612:
## Known stack suffix:
## LC class_body_declarations_opt
## LR(1) items:
class_body -> LC class_body_declarations_opt . RC [ XOR WHILE VOLATILE VOID URS TString TRY TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR NOT_EQ NEW NATIVE MOD MINUS LT LS LP LITERAL LE LC LB INTERFACE INSTANCEOF INCR IF IDENTIFIER GT GE FOR FINAL EQ_EQ EOF ENUM DOT DO DIV DEFAULT DECR CONTINUE COND COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On RC shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## LC class_body_declarations_opt RC
## LR(1) items:
class_body -> LC class_body_declarations_opt RC . [ XOR WHILE VOLATILE VOID URS TString TRY TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR NOT_EQ NEW NATIVE MOD MINUS LT LS LP LITERAL LE LC LB INTERFACE INSTANCEOF INCR IF IDENTIFIER GT GE FOR FINAL EQ_EQ EOF ENUM DOT DO DIV DEFAULT DECR CONTINUE COND COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR WHILE VOLATILE VOID URS TString TRY TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR NOT_EQ NEW NATIVE MOD MINUS LT LS LP LITERAL LE LC LB INTERFACE INSTANCEOF INCR IF IDENTIFIER GT GE FOR FINAL EQ_EQ EOF ENUM DOT DO DIV DEFAULT DECR CONTINUE COND COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT
--   reduce production class_body -> LC class_body_declarations_opt RC

State 614:
## Known stack suffix:
## name DOT NEW identifier LP argument_list_opt RP class_body_opt
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP argument_list_opt RP class_body_opt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> name DOT NEW identifier LP argument_list_opt RP class_body_opt

State 615:
## Known stack suffix:
## class_body
## LR(1) items:
class_body_opt -> class_body . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_body_opt -> class_body

State 616:
## Known stack suffix:
## name LP argument_list_opt
## LR(1) items:
method_invocation -> name LP argument_list_opt . RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 617
## Reductions:

State 617:
## Known stack suffix:
## name LP argument_list_opt RP
## LR(1) items:
method_invocation -> name LP argument_list_opt RP . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production method_invocation -> name LP argument_list_opt RP

State 618:
## Known stack suffix:
## shift_expression SRS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression SRS additive_expression . [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 187
-- On MINUS shift to state 189
## Reductions:
-- On XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression SRS additive_expression

State 619:
## Known stack suffix:
## primary DOT NEW identifier LP argument_list_opt
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP argument_list_opt . RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 620
## Reductions:

State 620:
## Known stack suffix:
## primary DOT NEW identifier LP argument_list_opt RP
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP argument_list_opt RP . class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 240
-- On class_body_opt shift to state 621
-- On class_body shift to state 615
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_body_opt ->

State 621:
## Known stack suffix:
## primary DOT NEW identifier LP argument_list_opt RP class_body_opt
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP argument_list_opt RP class_body_opt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> primary DOT NEW identifier LP argument_list_opt RP class_body_opt

State 622:
## Known stack suffix:
## shift_expression URS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
shift_expression -> shift_expression URS additive_expression . [ XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 187
-- On MINUS shift to state 189
## Reductions:
-- On XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression URS additive_expression

State 623:
## Known stack suffix:
## primary_no_new_array LB expression
## LR(1) items:
array_access -> primary_no_new_array LB expression . RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 624
## Reductions:

State 624:
## Known stack suffix:
## primary_no_new_array LB expression RB
## LR(1) items:
array_access -> primary_no_new_array LB expression RB . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_access -> primary_no_new_array LB expression RB

State 625:
## Known stack suffix:
## DECR unary_expression
## LR(1) items:
pre_decrement_expression -> DECR unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production pre_decrement_expression -> DECR unary_expression

State 626:
## Known stack suffix:
## INCR unary_expression
## LR(1) items:
pre_increment_expression -> INCR unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production pre_increment_expression -> INCR unary_expression

State 627:
## Known stack suffix:
## LP primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ RP LB_RB DOT ]
cast_expression -> LP primitive_type . RP unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
class_literal -> primitive_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND AND_AND AND ]
## Transitions:
-- On RP shift to state 628
-- On LB_RB shift to state 12
-- On DOT shift to state 126
## Reductions:

State 628:
## Known stack suffix:
## LP primitive_type RP
## LR(1) items:
cast_expression -> LP primitive_type RP . unary_expression [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 629
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 629:
## Known stack suffix:
## LP primitive_type RP unary_expression
## LR(1) items:
cast_expression -> LP primitive_type RP unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP primitive_type RP unary_expression

State 630:
## Known stack suffix:
## LP expression
## LR(1) items:
cast_expression -> LP expression . RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP expression . RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 631
## Reductions:

State 631:
## Known stack suffix:
## LP expression RP
## LR(1) items:
cast_expression -> LP expression RP . unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP expression RP . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On IDENTIFIER shift to state 2
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 632
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production primary_no_new_array -> LP expression RP

State 632:
## Known stack suffix:
## LP expression RP unary_expression_not_plus_minus
## LR(1) items:
cast_expression -> LP expression RP unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP expression RP unary_expression_not_plus_minus

State 633:
## Known stack suffix:
## LP array_type
## LR(1) items:
array_type -> array_type . LB_RB [ RP LB_RB DOT ]
cast_expression -> LP array_type . RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
class_literal -> array_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND AND_AND AND ]
## Transitions:
-- On RP shift to state 634
-- On LB_RB shift to state 25
-- On DOT shift to state 164
## Reductions:

State 634:
## Known stack suffix:
## LP array_type RP
## LR(1) items:
cast_expression -> LP array_type RP . unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On IDENTIFIER shift to state 2
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 635
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 149
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 635:
## Known stack suffix:
## LP array_type RP unary_expression_not_plus_minus
## LR(1) items:
cast_expression -> LP array_type RP unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP array_type RP unary_expression_not_plus_minus

State 636:
## Known stack suffix:
## MINUS unary_expression
## LR(1) items:
unary_expression -> MINUS unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> MINUS unary_expression

State 637:
## Known stack suffix:
## LB expression
## LR(1) items:
dim_expr -> LB expression . RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## LB expression RB
## LR(1) items:
dim_expr -> LB expression RB . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dim_expr -> LB expression RB

State 639:
## Known stack suffix:
## NEW primitive_type dims
## LR(1) items:
array_creation_expression -> NEW primitive_type dims . array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
dims -> dims . LB_RB [ LC LB_RB ]
## Transitions:
-- On LC shift to state 327
-- On LB_RB shift to state 640
-- On array_initializer shift to state 641
## Reductions:

State 640:
## Known stack suffix:
## dims LB_RB
## LR(1) items:
dims -> dims LB_RB . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dims -> dims LB_RB

State 641:
## Known stack suffix:
## NEW primitive_type dims array_initializer
## LR(1) items:
array_creation_expression -> NEW primitive_type dims array_initializer . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW primitive_type dims array_initializer

State 642:
## Known stack suffix:
## NEW primitive_type dim_exprs
## LR(1) items:
array_creation_expression -> NEW primitive_type dim_exprs . dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 115
-- On LB shift to state 116
-- On dims_opt shift to state 643
-- On dims shift to state 644
-- On dim_expr shift to state 645
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dims_opt ->

State 643:
## Known stack suffix:
## NEW primitive_type dim_exprs dims_opt
## LR(1) items:
array_creation_expression -> NEW primitive_type dim_exprs dims_opt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW primitive_type dim_exprs dims_opt

State 644:
## Known stack suffix:
## dims
## LR(1) items:
dims -> dims . LB_RB [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
dims_opt -> dims . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 640
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dims_opt -> dims

State 645:
## Known stack suffix:
## dim_exprs dim_expr
## LR(1) items:
dim_exprs -> dim_exprs dim_expr . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dim_exprs -> dim_exprs dim_expr

State 646:
## Known stack suffix:
## dim_expr
## LR(1) items:
dim_exprs -> dim_expr . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dim_exprs -> dim_expr

State 647:
## Known stack suffix:
## NEW name
## LR(1) items:
array_creation_expression -> NEW name . dim_exprs dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
array_creation_expression -> NEW name . dims array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
class_instance_creation_expression -> NEW name . LP argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ LP LB_RB LB DOT ]
name -> name . DOT LT2 type_arguments GT identifier_ [ LP LB_RB LB DOT ]
## Transitions:
-- On LP shift to state 648
-- On LB_RB shift to state 115
-- On LB shift to state 116
-- On DOT shift to state 5
-- On dims shift to state 652
-- On dim_exprs shift to state 654
-- On dim_expr shift to state 646
## Reductions:

State 648:
## Known stack suffix:
## NEW name LP
## LR(1) items:
class_instance_creation_expression -> NEW name LP . argument_list_opt RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On PLUS shift to state 111
-- On NOT shift to state 112
-- On NEW shift to state 113
-- On MINUS shift to state 117
-- On LP shift to state 118
-- On LITERAL shift to state 119
-- On INCR shift to state 120
-- On IDENTIFIER shift to state 2
-- On DECR shift to state 121
-- On COMPL shift to state 122
-- On unary_expression_not_plus_minus shift to state 123
-- On unary_expression shift to state 130
-- On shift_expression shift to state 131
-- On relational_expression shift to state 138
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 128
-- On primary shift to state 133
-- On pre_increment_expression shift to state 142
-- On pre_decrement_expression shift to state 143
-- On postfix_expression shift to state 144
-- On post_increment_expression shift to state 147
-- On post_decrement_expression shift to state 148
-- On name shift to state 151
-- On multiplicative_expression shift to state 153
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On left_hand_side shift to state 172
-- On inclusive_or_expression shift to state 176
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 204
-- On expression shift to state 229
-- On exclusive_or_expression shift to state 205
-- On equality_expression shift to state 180
-- On conditional_or_expression shift to state 206
-- On conditional_expression shift to state 216
-- On conditional_and_expression shift to state 215
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On cast_expression shift to state 162
-- On assignment_expression shift to state 217
-- On assignment shift to state 218
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 219
-- On argument_list_opt shift to state 649
-- On argument_list shift to state 232
-- On and_expression shift to state 203
-- On additive_expression shift to state 191
## Reductions:
-- On RP
--   reduce production argument_list_opt ->

State 649:
## Known stack suffix:
## NEW name LP argument_list_opt
## LR(1) items:
class_instance_creation_expression -> NEW name LP argument_list_opt . RP class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 650
## Reductions:

State 650:
## Known stack suffix:
## NEW name LP argument_list_opt RP
## LR(1) items:
class_instance_creation_expression -> NEW name LP argument_list_opt RP . class_body_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 240
-- On class_body_opt shift to state 651
-- On class_body shift to state 615
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_body_opt ->

State 651:
## Known stack suffix:
## NEW name LP argument_list_opt RP class_body_opt
## LR(1) items:
class_instance_creation_expression -> NEW name LP argument_list_opt RP class_body_opt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> NEW name LP argument_list_opt RP class_body_opt

State 652:
## Known stack suffix:
## NEW name dims
## LR(1) items:
array_creation_expression -> NEW name dims . array_initializer [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
dims -> dims . LB_RB [ LC LB_RB ]
## Transitions:
-- On LC shift to state 327
-- On LB_RB shift to state 640
-- On array_initializer shift to state 653
## Reductions:

State 653:
## Known stack suffix:
## NEW name dims array_initializer
## LR(1) items:
array_creation_expression -> NEW name dims array_initializer . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW name dims array_initializer

State 654:
## Known stack suffix:
## NEW name dim_exprs
## LR(1) items:
array_creation_expression -> NEW name dim_exprs . dims_opt [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
dim_exprs -> dim_exprs . dim_expr [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 115
-- On LB shift to state 116
-- On dims_opt shift to state 655
-- On dims shift to state 644
-- On dim_expr shift to state 645
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production dims_opt ->

State 655:
## Known stack suffix:
## NEW name dim_exprs dims_opt
## LR(1) items:
array_creation_expression -> NEW name dim_exprs dims_opt . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW name dim_exprs dims_opt

State 656:
## Known stack suffix:
## NOT unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> NOT unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> NOT unary_expression

State 657:
## Known stack suffix:
## PLUS unary_expression
## LR(1) items:
unary_expression -> PLUS unary_expression . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> PLUS unary_expression

State 658:
## Known stack suffix:
## SUPER DOT identifier LP argument_list_opt
## LR(1) items:
method_invocation -> SUPER DOT identifier LP argument_list_opt . RP [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 659
## Reductions:

State 659:
## Known stack suffix:
## SUPER DOT identifier LP argument_list_opt RP
## LR(1) items:
method_invocation -> SUPER DOT identifier LP argument_list_opt RP . [ XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
--   reduce production method_invocation -> SUPER DOT identifier LP argument_list_opt RP

State 660:
## Known stack suffix:
## LC
## LR(1) items:
element_value_array_initializer -> LC . RC [ SM RP RC CM ]
element_value_array_initializer -> LC . element_values RC [ SM RP RC CM ]
element_value_array_initializer -> LC . element_values CM RC [ SM RP RC CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On RC shift to state 661
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 660
-- On IDENTIFIER shift to state 2
-- On AT shift to state 96
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 662
-- On primary shift to state 665
-- On name shift to state 667
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On expr1 shift to state 668
-- On element_values shift to state 669
-- On element_value_array_initializer shift to state 673
-- On element_value shift to state 676
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On annotation shift to state 675
## Reductions:

State 661:
## Known stack suffix:
## LC RC
## LR(1) items:
element_value_array_initializer -> LC RC . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value_array_initializer -> LC RC

State 662:
## Known stack suffix:
## primary_no_new_array
## LR(1) items:
array_access -> primary_no_new_array . LB expression RB [ SM RP RC PLUS LB DOT CM ]
expr1 -> primary_no_new_array . [ SM RP RC CM ]
expr1 -> primary_no_new_array . PLUS primary_no_new_array [ SM RP RC CM ]
primary -> primary_no_new_array . [ DOT ]
## Transitions:
-- On PLUS shift to state 663
-- On LB shift to state 129
## Reductions:
-- On SM RP RC CM
--   reduce production expr1 -> primary_no_new_array
-- On DOT
--   reduce production primary -> primary_no_new_array

State 663:
## Known stack suffix:
## primary_no_new_array PLUS
## LR(1) items:
expr1 -> primary_no_new_array PLUS . primary_no_new_array [ SM RP RC CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On IDENTIFIER shift to state 2
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 664
-- On primary shift to state 665
-- On name shift to state 666
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
## Reductions:

State 664:
## Known stack suffix:
## primary_no_new_array PLUS primary_no_new_array
## LR(1) items:
array_access -> primary_no_new_array . LB expression RB [ SM RP RC LB DOT CM ]
expr1 -> primary_no_new_array PLUS primary_no_new_array . [ SM RP RC CM ]
primary -> primary_no_new_array . [ DOT ]
## Transitions:
-- On LB shift to state 129
## Reductions:
-- On SM RP RC CM
--   reduce production expr1 -> primary_no_new_array PLUS primary_no_new_array
-- On DOT
--   reduce production primary -> primary_no_new_array

State 665:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP argument_list_opt RP class_body_opt [ SM RP RC PLUS LB DOT CM ]
field_access -> primary . DOT identifier [ SM RP RC PLUS LB DOT CM ]
method_invocation -> primary . DOT identifier LP argument_list_opt RP [ SM RP RC PLUS LB DOT CM ]
## Transitions:
-- On DOT shift to state 134
## Reductions:

State 666:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ SM RP RC LB DOT CM ]
class_instance_creation_expression -> name . DOT NEW identifier LP argument_list_opt RP class_body_opt [ SM RP RC LB DOT CM ]
class_literal -> name . DOT CLASS [ SM RP RC LB DOT CM ]
class_or_interface_type -> name . [ LB_RB ]
field_access -> name . DOT SUPER DOT identifier [ SM RP RC LB DOT CM ]
method_invocation -> name . LP argument_list_opt RP [ SM RP RC LB DOT CM ]
method_invocation -> name . DOT SUPER DOT identifier LP argument_list_opt RP [ SM RP RC LB DOT CM ]
name -> name . DOT identifier_ [ LP LB_RB LB DOT ]
name -> name . DOT LT2 type_arguments GT identifier_ [ LP LB_RB LB DOT ]
primary_no_new_array -> name . DOT THIS [ SM RP RC LB DOT CM ]
## Transitions:
-- On LP shift to state 150
-- On LB shift to state 152
-- On DOT shift to state 223
## Reductions:
-- On LB_RB
--   reduce production class_or_interface_type -> name

State 667:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ SM RP RC PLUS LB DOT CM ]
class_instance_creation_expression -> name . DOT NEW identifier LP argument_list_opt RP class_body_opt [ SM RP RC PLUS LB DOT CM ]
class_literal -> name . DOT CLASS [ SM RP RC PLUS LB DOT CM ]
class_or_interface_type -> name . [ LB_RB ]
expr1 -> name . [ SM RP RC CM ]
field_access -> name . DOT SUPER DOT identifier [ SM RP RC PLUS LB DOT CM ]
method_invocation -> name . LP argument_list_opt RP [ SM RP RC PLUS LB DOT CM ]
method_invocation -> name . DOT SUPER DOT identifier LP argument_list_opt RP [ SM RP RC PLUS LB DOT CM ]
name -> name . DOT identifier_ [ SM RP RC LP LB_RB LB DOT CM ]
name -> name . DOT LT2 type_arguments GT identifier_ [ SM RP RC LP LB_RB LB DOT CM ]
primary_no_new_array -> name . DOT THIS [ SM RP RC PLUS LB DOT CM ]
## Transitions:
-- On LP shift to state 150
-- On LB shift to state 152
-- On DOT shift to state 223
## Reductions:
-- On LB_RB
--   reduce production class_or_interface_type -> name
-- On SM RP RC CM
--   reduce production expr1 -> name

State 668:
## Known stack suffix:
## expr1
## LR(1) items:
element_value -> expr1 . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> expr1

State 669:
## Known stack suffix:
## LC element_values
## LR(1) items:
element_value_array_initializer -> LC element_values . RC [ SM RP RC CM ]
element_value_array_initializer -> LC element_values . CM RC [ SM RP RC CM ]
element_values -> element_values . CM element_value [ RC CM ]
## Transitions:
-- On RC shift to state 670
-- On CM shift to state 671
## Reductions:

State 670:
## Known stack suffix:
## LC element_values RC
## LR(1) items:
element_value_array_initializer -> LC element_values RC . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value_array_initializer -> LC element_values RC

State 671:
## Known stack suffix:
## LC element_values CM
## LR(1) items:
element_value_array_initializer -> LC element_values CM . RC [ SM RP RC CM ]
element_values -> element_values CM . element_value [ RC CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On RC shift to state 672
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 660
-- On IDENTIFIER shift to state 2
-- On AT shift to state 96
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 662
-- On primary shift to state 665
-- On name shift to state 667
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On expr1 shift to state 668
-- On element_value_array_initializer shift to state 673
-- On element_value shift to state 674
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On annotation shift to state 675
## Reductions:

State 672:
## Known stack suffix:
## LC element_values CM RC
## LR(1) items:
element_value_array_initializer -> LC element_values CM RC . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value_array_initializer -> LC element_values CM RC

State 673:
## Known stack suffix:
## element_value_array_initializer
## LR(1) items:
element_value -> element_value_array_initializer . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> element_value_array_initializer

State 674:
## Known stack suffix:
## element_values CM element_value
## LR(1) items:
element_values -> element_values CM element_value . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production element_values -> element_values CM element_value

State 675:
## Known stack suffix:
## annotation
## LR(1) items:
element_value -> annotation . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> annotation

State 676:
## Known stack suffix:
## element_value
## LR(1) items:
element_values -> element_value . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production element_values -> element_value

State 677:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RP CM ]
identifier_ -> identifier . [ RP LP LB_RB LB DOT ]
identifier_ -> identifier . LT2 type_arguments GT [ RP LP LB_RB LB DOT ]
## Transitions:
-- On LT2 shift to state 16
-- On EQ shift to state 678
## Reductions:
-- On RP LP LB_RB LB DOT
--   reduce production identifier_ -> identifier

State 678:
## Known stack suffix:
## identifier EQ
## LR(1) items:
element_value_pair -> identifier EQ . element_value [ RP CM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 660
-- On IDENTIFIER shift to state 2
-- On AT shift to state 96
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 662
-- On primary shift to state 665
-- On name shift to state 667
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On expr1 shift to state 668
-- On element_value_array_initializer shift to state 673
-- On element_value shift to state 679
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On annotation shift to state 675
## Reductions:

State 679:
## Known stack suffix:
## identifier EQ element_value
## LR(1) items:
element_value_pair -> identifier EQ element_value . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production element_value_pair -> identifier EQ element_value

State 680:
## Known stack suffix:
## element_value_pairs
## LR(1) items:
annotation_element -> element_value_pairs . [ RP ]
element_value_pairs -> element_value_pairs . CM element_value_pair [ RP CM ]
## Transitions:
-- On CM shift to state 681
## Reductions:
-- On RP
--   reduce production annotation_element -> element_value_pairs

State 681:
## Known stack suffix:
## element_value_pairs CM
## LR(1) items:
element_value_pairs -> element_value_pairs CM . element_value_pair [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 682
-- On element_value_pair shift to state 683
## Reductions:

State 682:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RP CM ]
## Transitions:
-- On EQ shift to state 678
## Reductions:

State 683:
## Known stack suffix:
## element_value_pairs CM element_value_pair
## LR(1) items:
element_value_pairs -> element_value_pairs CM element_value_pair . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production element_value_pairs -> element_value_pairs CM element_value_pair

State 684:
## Known stack suffix:
## element_value_pair
## LR(1) items:
element_value_pairs -> element_value_pair . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production element_value_pairs -> element_value_pair

State 685:
## Known stack suffix:
## element_value
## LR(1) items:
annotation_element -> element_value . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production annotation_element -> element_value

State 686:
## Known stack suffix:
## AT name LP annotation_element
## LR(1) items:
annotation -> AT name LP annotation_element . RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT ]
## Transitions:
-- On RP shift to state 687
## Reductions:

State 687:
## Known stack suffix:
## AT name LP annotation_element RP
## LR(1) items:
annotation -> AT name LP annotation_element RP . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT
--   reduce production annotation -> AT name LP annotation_element RP

State 688:
## Known stack suffix:
## identifier LP formal_parameter_list_opt
## LR(1) items:
method_declarator -> identifier LP formal_parameter_list_opt . RP [ THROWS SM LC LB_RB ]
## Transitions:
-- On RP shift to state 689
## Reductions:

State 689:
## Known stack suffix:
## identifier LP formal_parameter_list_opt RP
## LR(1) items:
method_declarator -> identifier LP formal_parameter_list_opt RP . [ THROWS SM LC LB_RB ]
## Transitions:
## Reductions:
-- On THROWS SM LC LB_RB
--   reduce production method_declarator -> identifier LP formal_parameter_list_opt RP

State 690:
## Known stack suffix:
## modifiers_opt type_parameters
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters . type_java identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers_opt type_parameters . VOID identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 691
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On type_java shift to state 697
-- On primitive_type shift to state 259
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 260
-- On array_type shift to state 261
## Reductions:

State 691:
## Known stack suffix:
## modifiers_opt type_parameters VOID
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters VOID . identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 692
## Reductions:

State 692:
## Known stack suffix:
## modifiers_opt type_parameters VOID identifier
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters VOID identifier . interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 551
-- On interface_method_declator_rest shift to state 693
-- On formal_parameters shift to state 694
## Reductions:

State 693:
## Known stack suffix:
## modifiers_opt type_parameters VOID identifier interface_method_declator_rest
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters VOID identifier interface_method_declator_rest . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> modifiers_opt type_parameters VOID identifier interface_method_declator_rest

State 694:
## Known stack suffix:
## formal_parameters
## LR(1) items:
interface_method_declator_rest -> formal_parameters . throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 84
-- On throws_opt shift to state 695
-- On throws shift to state 92
## Reductions:
-- On SM
--   reduce production throws_opt ->

State 695:
## Known stack suffix:
## formal_parameters throws_opt
## LR(1) items:
interface_method_declator_rest -> formal_parameters throws_opt . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 696
## Reductions:

State 696:
## Known stack suffix:
## formal_parameters throws_opt SM
## LR(1) items:
interface_method_declator_rest -> formal_parameters throws_opt SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_method_declator_rest -> formal_parameters throws_opt SM

State 697:
## Known stack suffix:
## modifiers_opt type_parameters type_java
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters type_java . identifier interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 698
## Reductions:

State 698:
## Known stack suffix:
## modifiers_opt type_parameters type_java identifier
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters type_java identifier . interface_method_declator_rest [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 551
-- On interface_method_declator_rest shift to state 699
-- On formal_parameters shift to state 694
## Reductions:

State 699:
## Known stack suffix:
## modifiers_opt type_parameters type_java identifier interface_method_declator_rest
## LR(1) items:
interface_generic_method_decl -> modifiers_opt type_parameters type_java identifier interface_method_declator_rest . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> modifiers_opt type_parameters type_java identifier interface_method_declator_rest

State 700:
## Known stack suffix:
## modifiers_opt type_java
## LR(1) items:
abstract_method_declaration -> modifiers_opt type_java . method_declarator throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
constant_declaration -> modifiers_opt type_java . variable_declarators SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On variable_declarators shift to state 701
-- On variable_declarator_id shift to state 325
-- On variable_declarator shift to state 345
-- On method_declarator shift to state 703
-- On identifier shift to state 569
## Reductions:

State 701:
## Known stack suffix:
## modifiers_opt type_java variable_declarators
## LR(1) items:
constant_declaration -> modifiers_opt type_java variable_declarators . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
variable_declarators -> variable_declarators . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 702
-- On CM shift to state 324
## Reductions:

State 702:
## Known stack suffix:
## modifiers_opt type_java variable_declarators SM
## LR(1) items:
constant_declaration -> modifiers_opt type_java variable_declarators SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production constant_declaration -> modifiers_opt type_java variable_declarators SM

State 703:
## Known stack suffix:
## modifiers_opt type_java method_declarator
## LR(1) items:
abstract_method_declaration -> modifiers_opt type_java method_declarator . throws_opt SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
method_declarator -> method_declarator . LB_RB [ THROWS SM LB_RB ]
## Transitions:
-- On THROWS shift to state 84
-- On LB_RB shift to state 89
-- On throws_opt shift to state 704
-- On throws shift to state 92
## Reductions:
-- On SM
--   reduce production throws_opt ->

State 704:
## Known stack suffix:
## modifiers_opt type_java method_declarator throws_opt
## LR(1) items:
abstract_method_declaration -> modifiers_opt type_java method_declarator throws_opt . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 705
## Reductions:

State 705:
## Known stack suffix:
## modifiers_opt type_java method_declarator throws_opt SM
## LR(1) items:
abstract_method_declaration -> modifiers_opt type_java method_declarator throws_opt SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production abstract_method_declaration -> modifiers_opt type_java method_declarator throws_opt SM

State 706:
## Known stack suffix:
## LC interface_member_declarations_opt
## LR(1) items:
interface_body -> LC interface_member_declarations_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 707
## Reductions:

State 707:
## Known stack suffix:
## LC interface_member_declarations_opt RC
## LR(1) items:
interface_body -> LC interface_member_declarations_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production interface_body -> LC interface_member_declarations_opt RC

State 708:
## Known stack suffix:
## interface_member_declarations
## LR(1) items:
interface_member_declarations -> interface_member_declarations . interface_member_declaration [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
interface_member_declarations_opt -> interface_member_declarations . [ RC ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 80
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 81
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_member_declaration shift to state 709
-- On interface_generic_method_decl shift to state 710
-- On interface_declaration shift to state 711
-- On enum_declaration shift to state 712
-- On constant_declaration shift to state 713
-- On class_declaration shift to state 714
-- On annotation_type_declaration shift to state 715
-- On annotation shift to state 365
-- On abstract_method_declaration shift to state 716
## Reductions:
-- On RC
--   reduce production interface_member_declarations_opt -> interface_member_declarations
-- On VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 709:
## Known stack suffix:
## interface_member_declarations interface_member_declaration
## LR(1) items:
interface_member_declarations -> interface_member_declarations interface_member_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declarations -> interface_member_declarations interface_member_declaration

State 710:
## Known stack suffix:
## interface_generic_method_decl
## LR(1) items:
interface_member_declaration -> interface_generic_method_decl . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> interface_generic_method_decl

State 711:
## Known stack suffix:
## interface_declaration
## LR(1) items:
interface_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> interface_declaration

State 712:
## Known stack suffix:
## enum_declaration
## LR(1) items:
interface_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> enum_declaration

State 713:
## Known stack suffix:
## constant_declaration
## LR(1) items:
interface_member_declaration -> constant_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> constant_declaration

State 714:
## Known stack suffix:
## class_declaration
## LR(1) items:
interface_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> class_declaration

State 715:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
interface_member_declaration -> annotation_type_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> annotation_type_declaration

State 716:
## Known stack suffix:
## abstract_method_declaration
## LR(1) items:
interface_member_declaration -> abstract_method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> abstract_method_declaration

State 717:
## Known stack suffix:
## interface_member_declaration
## LR(1) items:
interface_member_declarations -> interface_member_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production interface_member_declarations -> interface_member_declaration

State 718:
## Known stack suffix:
## modifiers_opt INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body
## LR(1) items:
interface_declaration -> modifiers_opt INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production interface_declaration -> modifiers_opt INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body

State 719:
## Known stack suffix:
## extends_interfaces
## LR(1) items:
extends_interfaces -> extends_interfaces . CM reference_type [ LC CM ]
extends_interfaces_opt -> extends_interfaces . [ LC ]
## Transitions:
-- On CM shift to state 720
## Reductions:
-- On LC
--   reduce production extends_interfaces_opt -> extends_interfaces

State 720:
## Known stack suffix:
## extends_interfaces CM
## LR(1) items:
extends_interfaces -> extends_interfaces CM . reference_type [ LC CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 7
-- On IDENTIFIER shift to state 2
-- On reference_type shift to state 721
-- On primitive_type shift to state 11
-- On name shift to state 13
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On class_or_interface_type shift to state 22
-- On array_type shift to state 24
## Reductions:

State 721:
## Known stack suffix:
## extends_interfaces CM reference_type
## LR(1) items:
extends_interfaces -> extends_interfaces CM reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production extends_interfaces -> extends_interfaces CM reference_type

State 722:
## Known stack suffix:
## modifiers_opt type_java
## LR(1) items:
annotation_type_element_rest -> modifiers_opt type_java . identifier annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 2
-- On identifier shift to state 723
## Reductions:

State 723:
## Known stack suffix:
## modifiers_opt type_java identifier
## LR(1) items:
annotation_type_element_rest -> modifiers_opt type_java identifier . annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 724
-- On annotation_method_or_constant_rest shift to state 728
## Reductions:

State 724:
## Known stack suffix:
## LP
## LR(1) items:
annotation_method_or_constant_rest -> LP . RP [ SM ]
annotation_method_or_constant_rest -> LP . RP DEFAULT element_value [ SM ]
## Transitions:
-- On RP shift to state 725
## Reductions:

State 725:
## Known stack suffix:
## LP RP
## LR(1) items:
annotation_method_or_constant_rest -> LP RP . [ SM ]
annotation_method_or_constant_rest -> LP RP . DEFAULT element_value [ SM ]
## Transitions:
-- On DEFAULT shift to state 726
## Reductions:
-- On SM
--   reduce production annotation_method_or_constant_rest -> LP RP

State 726:
## Known stack suffix:
## LP RP DEFAULT
## LR(1) items:
annotation_method_or_constant_rest -> LP RP DEFAULT . element_value [ SM ]
## Transitions:
-- On VOID shift to state 99
-- On TString shift to state 102
-- On TInt shift to state 103
-- On THIS shift to state 104
-- On TFloat shift to state 105
-- On TChar shift to state 106
-- On SUPER shift to state 107
-- On PRIMITIVE_TYPE shift to state 7
-- On NEW shift to state 113
-- On LP shift to state 305
-- On LITERAL shift to state 119
-- On LC shift to state 660
-- On IDENTIFIER shift to state 2
-- On AT shift to state 96
-- On primitive_type shift to state 125
-- On primary_no_new_array shift to state 662
-- On primary shift to state 665
-- On name shift to state 667
-- On method_invocation shift to state 156
-- On literal shift to state 157
-- On identifier_ shift to state 14
-- On identifier shift to state 15
-- On field_access shift to state 158
-- On expr1 shift to state 668
-- On element_value_array_initializer shift to state 673
-- On element_value shift to state 727
-- On class_or_interface_type shift to state 159
-- On class_literal shift to state 160
-- On class_instance_creation_expression shift to state 161
-- On array_type shift to state 163
-- On array_creation_expression shift to state 166
-- On array_access shift to state 167
-- On annotation shift to state 675
## Reductions:

State 727:
## Known stack suffix:
## LP RP DEFAULT element_value
## LR(1) items:
annotation_method_or_constant_rest -> LP RP DEFAULT element_value . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production annotation_method_or_constant_rest -> LP RP DEFAULT element_value

State 728:
## Known stack suffix:
## modifiers_opt type_java identifier annotation_method_or_constant_rest
## LR(1) items:
annotation_type_element_rest -> modifiers_opt type_java identifier annotation_method_or_constant_rest . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 729
## Reductions:

State 729:
## Known stack suffix:
## modifiers_opt type_java identifier annotation_method_or_constant_rest SM
## LR(1) items:
annotation_type_element_rest -> modifiers_opt type_java identifier annotation_method_or_constant_rest SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> modifiers_opt type_java identifier annotation_method_or_constant_rest SM

State 730:
## Known stack suffix:
## interface_declaration
## LR(1) items:
annotation_type_element_rest -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> interface_declaration

State 731:
## Known stack suffix:
## enum_declaration
## LR(1) items:
annotation_type_element_rest -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> enum_declaration

State 732:
## Known stack suffix:
## class_declaration
## LR(1) items:
annotation_type_element_rest -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> class_declaration

State 733:
## Known stack suffix:
## annotation_type_element_rest
## LR(1) items:
annotation_type_element_declaration -> annotation_type_element_rest . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_declaration -> annotation_type_element_rest

State 734:
## Known stack suffix:
## LC annotation_type_element_declarations_opt
## LR(1) items:
annotation_type_body -> LC annotation_type_element_declarations_opt . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 735
## Reductions:

State 735:
## Known stack suffix:
## LC annotation_type_element_declarations_opt RC
## LR(1) items:
annotation_type_body -> LC annotation_type_element_declarations_opt RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_body -> LC annotation_type_element_declarations_opt RC

State 736:
## Known stack suffix:
## annotation_type_element_declarations
## LR(1) items:
annotation_type_element_declarations -> annotation_type_element_declarations . annotation_type_element_declaration [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
annotation_type_element_declarations_opt -> annotation_type_element_declarations . [ RC ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On modifiers_opt shift to state 59
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_declaration shift to state 730
-- On enum_declaration shift to state 731
-- On class_declaration shift to state 732
-- On annotation_type_element_rest shift to state 733
-- On annotation_type_element_declaration shift to state 737
-- On annotation_type_declaration shift to state 738
-- On annotation shift to state 365
## Reductions:
-- On RC
--   reduce production annotation_type_element_declarations_opt -> annotation_type_element_declarations
-- On PRIMITIVE_TYPE INTERFACE IDENTIFIER ENUM CLASS
--   reduce production modifiers_opt ->

State 737:
## Known stack suffix:
## annotation_type_element_declarations annotation_type_element_declaration
## LR(1) items:
annotation_type_element_declarations -> annotation_type_element_declarations annotation_type_element_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_declarations -> annotation_type_element_declarations annotation_type_element_declaration

State 738:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
annotation_type_element_rest -> annotation_type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> annotation_type_declaration

State 739:
## Known stack suffix:
## annotation_type_element_declaration
## LR(1) items:
annotation_type_element_declarations -> annotation_type_element_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_element_declarations -> annotation_type_element_declaration

State 740:
## Known stack suffix:
## AT INTERFACE identifier annotation_type_body
## LR(1) items:
annotation_type_declaration -> AT INTERFACE identifier annotation_type_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production annotation_type_declaration -> AT INTERFACE identifier annotation_type_body

State 741:
## Known stack suffix:
## package_declaration_opt import_declarations_opt type_declarations_opt
## LR(1) items:
compilation_unit -> package_declaration_opt import_declarations_opt type_declarations_opt . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production compilation_unit -> package_declaration_opt import_declarations_opt type_declarations_opt

State 742:
## Known stack suffix:
## type_declarations
## LR(1) items:
type_declarations -> type_declarations . type_declaration [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
type_declarations_opt -> type_declarations . [ EOF ]
## Transitions:
-- On VOLATILE shift to state 43
-- On TRANSIENT shift to state 44
-- On SYNCHRONIZED shift to state 45
-- On STRICTFP shift to state 46
-- On STATIC shift to state 47
-- On SM shift to state 48
-- On PUBLIC shift to state 49
-- On PROTECTED shift to state 50
-- On PRIVATE shift to state 51
-- On NATIVE shift to state 52
-- On FINAL shift to state 53
-- On AT shift to state 54
-- On ABSTRACT shift to state 58
-- On type_declaration shift to state 743
-- On modifiers_opt shift to state 744
-- On modifiers shift to state 497
-- On modifier shift to state 366
-- On interface_declaration shift to state 745
-- On enum_declaration shift to state 746
-- On class_declaration shift to state 747
-- On annotation_type_declaration shift to state 748
-- On annotation shift to state 365
## Reductions:
-- On INTERFACE ENUM CLASS
--   reduce production modifiers_opt ->
-- On EOF
--   reduce production type_declarations_opt -> type_declarations

State 743:
## Known stack suffix:
## type_declarations type_declaration
## LR(1) items:
type_declarations -> type_declarations type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declarations -> type_declarations type_declaration

State 744:
## Known stack suffix:
## modifiers_opt
## LR(1) items:
class_declaration -> modifiers_opt . CLASS identifier type_parameters_opt super_opt interfaces_opt class_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
enum_declaration -> modifiers_opt . ENUM identifier interfaces_opt enum_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
interface_declaration -> modifiers_opt . INTERFACE identifier type_parameters_opt extends_interfaces_opt interface_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On INTERFACE shift to state 60
-- On ENUM shift to state 492
-- On CLASS shift to state 449
## Reductions:

State 745:
## Known stack suffix:
## interface_declaration
## LR(1) items:
type_declaration -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declaration -> interface_declaration

State 746:
## Known stack suffix:
## enum_declaration
## LR(1) items:
type_declaration -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declaration -> enum_declaration

State 747:
## Known stack suffix:
## class_declaration
## LR(1) items:
type_declaration -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declaration -> class_declaration

State 748:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
type_declaration -> annotation_type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declaration -> annotation_type_declaration

State 749:
## Known stack suffix:
## type_declaration
## LR(1) items:
type_declarations -> type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production type_declarations -> type_declaration

State 750:
## Known stack suffix:
## import_declarations
## LR(1) items:
import_declarations -> import_declarations . import_declaration [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
import_declarations_opt -> import_declarations . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
-- On IMPORT shift to state 34
-- On import_declaration shift to state 751
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declarations_opt -> import_declarations

State 751:
## Known stack suffix:
## import_declarations import_declaration
## LR(1) items:
import_declarations -> import_declarations import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declarations -> import_declarations import_declaration

State 752:
## Known stack suffix:
## import_declaration
## LR(1) items:
import_declarations -> import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production import_declarations -> import_declaration

State 753:
## Known stack suffix:
## package_declaration
## LR(1) items:
package_declaration_opt -> package_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
--   reduce production package_declaration_opt -> package_declaration

State 754:
## Known stack suffix:
## goal
## LR(1) items:
goal' -> goal . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept goal

State 755:
## Known stack suffix:
## compilation_unit
## LR(1) items:
goal -> compilation_unit . EOF [ # ]
## Transitions:
-- On EOF shift to state 756
## Reductions:

State 756:
## Known stack suffix:
## compilation_unit EOF
## LR(1) items:
goal -> compilation_unit EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production goal -> compilation_unit EOF

