%{
open Abstest
open Lexing


%}
%start pAbstract
%start pAndEq
%start pAndT
%start pAnd_Eq
%start pAsT
%start pAsm
%start pAsrT
%start pAssertT
%start pAuto
%start pBeginT
%start pBitand
%start pBitor
%start pBool
%start pBoolean
%start pBreak
%start pByte
%start pCase
%start pCatch
%start pChar_
%start pClassT
%start pCompl
%start pConst
%start pConstCast
%start pConst_Cast
%start pConstraintT
%start pContinue
%start pData
%start pDefault
%start pDelete
%start pDeriving
%start pDoT
%start pDoneT
%start pDouble_
%start pDowntoT
%start pDynamicCast
%start pDynamic_Cast
%start pElseT
%start pEndT
%start pEnum
%start pExceptionT
%start pExplicit
%start pExtends
%start pExtern
%start pExternalT
%start pFalseT
%start pFamily
%start pFinal
%start pFinally
%start pFloat
%start pForT
%start pForall
%start pForeign
%start pFriend
%start pFunT
%start pFunctionT
%start pFunctorT
%start pGoto
%start pHiding
%start pIfT
%start pImplements
%start pImport
%start pInT
%start pIncludeT
%start pInfix
%start pInfixl
%start pInfixr
%start pInheritT
%start pInitializerT
%start pInline
%start pInstance
%start pInstanceof
%start pInt
%start pInterface
%start pLandT
%start pLazyT
%start pLetT
%start pListT
%start pLong
%start pLorT
%start pLslT
%start pLsrT
%start pLxorT
%start pMatchT
%start pMdo
%start pMethodT
%start pModT
%start pModuleT
%start pMutableT
%start pNamespace
%start pNative
%start pNewT
%start pNewtype
%start pNonrecT
%start pNot
%start pNotEq
%start pNot_Eq
%start pNull
%start pObjectT
%start pOfT
%start pOpenT
%start pOperator
%start pOrEq
%start pOrT
%start pOr_Eq
%start pPackage
%start pPattern
%start pPrivateT
%start pProc
%start pProgram
%start pProtected
%start pPublic
%start pQualified
%start pRecT
%start pRegister
%start pReinterpretCast
%start pReinterpret_Cast
%start pReturn
%start pShort
%start pSigT
%start pSigned
%start pSizeof
%start pStaticCast
%start pStatic_Cast
%start pStrictfp
%start pString_
%start pStructT
%start pSuper
%start pSwitch
%start pSynchronized
%start pTemplate
%start pThenT
%start pThis
%start pThrow
%start pThrows
%start pToT
%start pTransient
%start pTrueT
%start pTryT
%start pTypeT
%start pTypedef
%start pTypeid
%start pTypename
%start pUnion
%start pUnsigned
%start pUsing
%start pValT
%start pVirtualT
%start pVoid
%start pVolatile
%start pWcharT
%start pWchar_T
%start pWhenT
%start pWhere
%start pWhileT
%start pWithT
%start pXor
%start pXorEq
%start pXor_Eq
%token TOK_EOF
%token TOK_abstract
%token TOK_and
%token TOK_and_eq
%token TOK_as
%token TOK_asm
%token TOK_asr
%token TOK_assert
%token TOK_auto
%token TOK_begin
%token TOK_bitand
%token TOK_bitor
%token TOK_bool
%token TOK_boolean
%token TOK_break
%token TOK_byte
%token TOK_case
%token TOK_catch
%token TOK_char
%token TOK_class
%token TOK_compl
%token TOK_const
%token TOK_const_cast
%token TOK_constraint
%token TOK_continue
%token TOK_data
%token TOK_default
%token TOK_delete
%token TOK_deriving
%token TOK_do
%token TOK_done
%token TOK_double
%token TOK_downto
%token TOK_dynamic_cast
%token TOK_else
%token TOK_end
%token TOK_enum
%token TOK_exception
%token TOK_explicit
%token TOK_extends
%token TOK_extern
%token TOK_external
%token TOK_false
%token TOK_family
%token TOK_final
%token TOK_finally
%token TOK_float
%token TOK_for
%token TOK_forall
%token TOK_foreign
%token TOK_friend
%token TOK_fun
%token TOK_function
%token TOK_functor
%token TOK_goto
%token TOK_hiding
%token TOK_if
%token TOK_implements
%token TOK_import
%token TOK_in
%token TOK_include
%token TOK_infix
%token TOK_infixl
%token TOK_infixr
%token TOK_inherit
%token TOK_initializer
%token TOK_inline
%token TOK_instance
%token TOK_instanceof
%token TOK_int
%token TOK_interface
%token TOK_land
%token TOK_lazy
%token TOK_let
%token TOK_list
%token TOK_long
%token TOK_lor
%token TOK_lsl
%token TOK_lsr
%token TOK_lxor
%token TOK_match
%token TOK_mdo
%token TOK_method
%token TOK_mod
%token TOK_module
%token TOK_mutable
%token TOK_namespace
%token TOK_native
%token TOK_new
%token TOK_newtype
%token TOK_nonrec
%token TOK_not
%token TOK_not_eq
%token TOK_null
%token TOK_object
%token TOK_of
%token TOK_open
%token TOK_operator
%token TOK_or
%token TOK_or_eq
%token TOK_package
%token TOK_pattern
%token TOK_private
%token TOK_proc
%token TOK_protected
%token TOK_public
%token TOK_qualified
%token TOK_rec
%token TOK_register
%token TOK_reinterpret_cast
%token TOK_return
%token TOK_short
%token TOK_sig
%token TOK_signed
%token TOK_sizeof
%token TOK_static_cast
%token TOK_strictfp
%token TOK_string
%token TOK_struct
%token TOK_super
%token TOK_switch
%token TOK_synchronized
%token TOK_template
%token TOK_then
%token TOK_this
%token TOK_throw
%token TOK_throws
%token TOK_to
%token TOK_transient
%token TOK_true
%token TOK_try
%token TOK_type
%token TOK_typedef
%token TOK_typeid
%token TOK_typename
%token TOK_union
%token TOK_unsigned
%token TOK_using
%token TOK_val
%token TOK_virtual
%token TOK_void
%token TOK_volatile
%token TOK_wchar_t
%token TOK_when
%token TOK_where
%token TOK_while
%token TOK_with
%token TOK_xor
%token TOK_xor_eq
%type <Abstest.abstract> pAbstract
%type <Abstest.andEq> pAndEq
%type <Abstest.andT> pAndT
%type <Abstest.and_Eq> pAnd_Eq
%type <Abstest.asT> pAsT
%type <Abstest.asm> pAsm
%type <Abstest.asrT> pAsrT
%type <Abstest.assertT> pAssertT
%type <Abstest.auto> pAuto
%type <Abstest.beginT> pBeginT
%type <Abstest.bitand> pBitand
%type <Abstest.bitor> pBitor
%type <Abstest.bool> pBool
%type <Abstest.boolean> pBoolean
%type <Abstest.break> pBreak
%type <Abstest.byte> pByte
%type <Abstest.case> pCase
%type <Abstest.catch> pCatch
%type <Abstest.char_> pChar_
%type <Abstest.classT> pClassT
%type <Abstest.compl> pCompl
%type <Abstest.const> pConst
%type <Abstest.constCast> pConstCast
%type <Abstest.const_Cast> pConst_Cast
%type <Abstest.constraintT> pConstraintT
%type <Abstest.continue> pContinue
%type <Abstest.data> pData
%type <Abstest.default> pDefault
%type <Abstest.delete> pDelete
%type <Abstest.deriving> pDeriving
%type <Abstest.doT> pDoT
%type <Abstest.doneT> pDoneT
%type <Abstest.double_> pDouble_
%type <Abstest.downtoT> pDowntoT
%type <Abstest.dynamicCast> pDynamicCast
%type <Abstest.dynamic_Cast> pDynamic_Cast
%type <Abstest.elseT> pElseT
%type <Abstest.endT> pEndT
%type <Abstest.enum> pEnum
%type <Abstest.exceptionT> pExceptionT
%type <Abstest.explicit> pExplicit
%type <Abstest.extends> pExtends
%type <Abstest.extern> pExtern
%type <Abstest.externalT> pExternalT
%type <Abstest.falseT> pFalseT
%type <Abstest.family> pFamily
%type <Abstest.final> pFinal
%type <Abstest.finally> pFinally
%type <Abstest.float> pFloat
%type <Abstest.forT> pForT
%type <Abstest.forall> pForall
%type <Abstest.foreign> pForeign
%type <Abstest.friend> pFriend
%type <Abstest.funT> pFunT
%type <Abstest.functionT> pFunctionT
%type <Abstest.functorT> pFunctorT
%type <Abstest.goto> pGoto
%type <Abstest.hiding> pHiding
%type <Abstest.ifT> pIfT
%type <Abstest.implements> pImplements
%type <Abstest.import> pImport
%type <Abstest.inT> pInT
%type <Abstest.includeT> pIncludeT
%type <Abstest.infix> pInfix
%type <Abstest.infixl> pInfixl
%type <Abstest.infixr> pInfixr
%type <Abstest.inheritT> pInheritT
%type <Abstest.initializerT> pInitializerT
%type <Abstest.inline> pInline
%type <Abstest.instance> pInstance
%type <Abstest.instanceof> pInstanceof
%type <Abstest.int> pInt
%type <Abstest.interface> pInterface
%type <Abstest.landT> pLandT
%type <Abstest.lazyT> pLazyT
%type <Abstest.letT> pLetT
%type <Abstest.listT> pListT
%type <Abstest.long> pLong
%type <Abstest.lorT> pLorT
%type <Abstest.lslT> pLslT
%type <Abstest.lsrT> pLsrT
%type <Abstest.lxorT> pLxorT
%type <Abstest.matchT> pMatchT
%type <Abstest.mdo> pMdo
%type <Abstest.methodT> pMethodT
%type <Abstest.modT> pModT
%type <Abstest.moduleT> pModuleT
%type <Abstest.mutableT> pMutableT
%type <Abstest.namespace> pNamespace
%type <Abstest.native> pNative
%type <Abstest.newT> pNewT
%type <Abstest.newtype> pNewtype
%type <Abstest.nonrecT> pNonrecT
%type <Abstest.not> pNot
%type <Abstest.notEq> pNotEq
%type <Abstest.not_Eq> pNot_Eq
%type <Abstest.null> pNull
%type <Abstest.objectT> pObjectT
%type <Abstest.ofT> pOfT
%type <Abstest.openT> pOpenT
%type <Abstest.operator> pOperator
%type <Abstest.orEq> pOrEq
%type <Abstest.orT> pOrT
%type <Abstest.or_Eq> pOr_Eq
%type <Abstest.package> pPackage
%type <Abstest.pattern> pPattern
%type <Abstest.privateT> pPrivateT
%type <Abstest.proc> pProc
%type <Abstest.program> pProgram
%type <Abstest.protected> pProtected
%type <Abstest.public> pPublic
%type <Abstest.qualified> pQualified
%type <Abstest.recT> pRecT
%type <Abstest.register> pRegister
%type <Abstest.reinterpretCast> pReinterpretCast
%type <Abstest.reinterpret_Cast> pReinterpret_Cast
%type <Abstest.return> pReturn
%type <Abstest.short> pShort
%type <Abstest.sigT> pSigT
%type <Abstest.signed> pSigned
%type <Abstest.sizeof> pSizeof
%type <Abstest.staticCast> pStaticCast
%type <Abstest.static_Cast> pStatic_Cast
%type <Abstest.strictfp> pStrictfp
%type <Abstest.string_> pString_
%type <Abstest.structT> pStructT
%type <Abstest.super> pSuper
%type <Abstest.switch> pSwitch
%type <Abstest.synchronized> pSynchronized
%type <Abstest.template> pTemplate
%type <Abstest.thenT> pThenT
%type <Abstest.this> pThis
%type <Abstest.throw> pThrow
%type <Abstest.throws> pThrows
%type <Abstest.toT> pToT
%type <Abstest.transient> pTransient
%type <Abstest.trueT> pTrueT
%type <Abstest.tryT> pTryT
%type <Abstest.typeT> pTypeT
%type <Abstest.typedef> pTypedef
%type <Abstest.typeid> pTypeid
%type <Abstest.typename> pTypename
%type <Abstest.union> pUnion
%type <Abstest.unsigned> pUnsigned
%type <Abstest.using> pUsing
%type <Abstest.valT> pValT
%type <Abstest.virtualT> pVirtualT
%type <Abstest.void> pVoid
%type <Abstest.volatile> pVolatile
%type <Abstest.wcharT> pWcharT
%type <Abstest.wchar_T> pWchar_T
%type <Abstest.whenT> pWhenT
%type <Abstest.where> pWhere
%type <Abstest.whileT> pWhileT
%type <Abstest.withT> pWithT
%type <Abstest.xor> pXor
%type <Abstest.xorEq> pXorEq
%type <Abstest.xor_Eq> pXor_Eq
%%

pProgram:
  _1 = program _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAbstract:
  _1 = abstract _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAndT:
  _1 = andT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAndEq:
  _1 = andEq _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAnd_Eq:
  _1 = and_Eq _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAsT:
  _1 = asT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAsm:
  _1 = asm _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAsrT:
  _1 = asrT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAssertT:
  _1 = assertT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pAuto:
  _1 = auto _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBeginT:
  _1 = beginT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBitand:
  _1 = bitand _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBitor:
  _1 = bitor _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBool:
  _1 = bool _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBoolean:
  _1 = boolean _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pBreak:
  _1 = break _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pByte:
  _1 = byte _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pCase:
  _1 = case _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pCatch:
  _1 = catch _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pChar_:
  _1 = char_ _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pClassT:
  _1 = classT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pCompl:
  _1 = compl _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pConst:
  _1 = const _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pConstCast:
  _1 = constCast _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pConst_Cast:
  _1 = const_Cast _2 = TOK_EOF
    {                                 ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pConstraintT:
  _1 = constraintT _2 = TOK_EOF
    {                                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pContinue:
  _1 = continue _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pData:
  _1 = data _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDefault:
  _1 = default _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDelete:
  _1 = delete _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDeriving:
  _1 = deriving _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDoT:
  _1 = doT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDoneT:
  _1 = doneT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDouble_:
  _1 = double_ _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDowntoT:
  _1 = downtoT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDynamicCast:
  _1 = dynamicCast _2 = TOK_EOF
    {                                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pDynamic_Cast:
  _1 = dynamic_Cast _2 = TOK_EOF
    {                                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pElseT:
  _1 = elseT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pEndT:
  _1 = endT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pEnum:
  _1 = enum _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pExceptionT:
  _1 = exceptionT _2 = TOK_EOF
    {                                 ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pExplicit:
  _1 = explicit _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pExtends:
  _1 = extends _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pExtern:
  _1 = extern _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pExternalT:
  _1 = externalT _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFalseT:
  _1 = falseT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFamily:
  _1 = family _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFinal:
  _1 = final _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFinally:
  _1 = finally _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFloat:
  _1 = float _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pForT:
  _1 = forT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pForall:
  _1 = forall _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pForeign:
  _1 = foreign _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFriend:
  _1 = friend _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFunT:
  _1 = funT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFunctionT:
  _1 = functionT _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pFunctorT:
  _1 = functorT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pGoto:
  _1 = goto _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pHiding:
  _1 = hiding _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pIfT:
  _1 = ifT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pImplements:
  _1 = implements _2 = TOK_EOF
    {                                 ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pImport:
  _1 = import _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInT:
  _1 = inT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pIncludeT:
  _1 = includeT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInfix:
  _1 = infix _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInfixl:
  _1 = infixl _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInfixr:
  _1 = infixr _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInheritT:
  _1 = inheritT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInitializerT:
  _1 = initializerT _2 = TOK_EOF
    {                                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInline:
  _1 = inline _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInstance:
  _1 = instance _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInstanceof:
  _1 = instanceof _2 = TOK_EOF
    {                                 ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInt:
  _1 = int _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pInterface:
  _1 = interface _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLandT:
  _1 = landT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLazyT:
  _1 = lazyT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLetT:
  _1 = letT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pListT:
  _1 = listT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLong:
  _1 = long _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLorT:
  _1 = lorT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLslT:
  _1 = lslT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLsrT:
  _1 = lsrT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pLxorT:
  _1 = lxorT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pMatchT:
  _1 = matchT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pMdo:
  _1 = mdo _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pMethodT:
  _1 = methodT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pModT:
  _1 = modT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pModuleT:
  _1 = moduleT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pMutableT:
  _1 = mutableT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNamespace:
  _1 = namespace _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNative:
  _1 = native _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNewT:
  _1 = newT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNewtype:
  _1 = newtype _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNonrecT:
  _1 = nonrecT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNot:
  _1 = not _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNotEq:
  _1 = notEq _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNot_Eq:
  _1 = not_Eq _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pNull:
  _1 = null _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pObjectT:
  _1 = objectT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOfT:
  _1 = ofT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOpenT:
  _1 = openT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOperator:
  _1 = operator _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOrT:
  _1 = orT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOrEq:
  _1 = orEq _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pOr_Eq:
  _1 = or_Eq _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pPackage:
  _1 = package _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pPattern:
  _1 = pattern _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pPrivateT:
  _1 = privateT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pProc:
  _1 = proc _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pProtected:
  _1 = protected _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pPublic:
  _1 = public _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pQualified:
  _1 = qualified _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pRecT:
  _1 = recT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pRegister:
  _1 = register _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pReinterpretCast:
  _1 = reinterpretCast _2 = TOK_EOF
    {                                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pReinterpret_Cast:
  _1 = reinterpret_Cast _2 = TOK_EOF
    {                                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pReturn:
  _1 = return _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pShort:
  _1 = short _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSigT:
  _1 = sigT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSigned:
  _1 = signed _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSizeof:
  _1 = sizeof _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pStaticCast:
  _1 = staticCast _2 = TOK_EOF
    {                                 ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pStatic_Cast:
  _1 = static_Cast _2 = TOK_EOF
    {                                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pStrictfp:
  _1 = strictfp _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pString_:
  _1 = string_ _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pStructT:
  _1 = structT _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSuper:
  _1 = super _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSwitch:
  _1 = switch _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pSynchronized:
  _1 = synchronized _2 = TOK_EOF
    {                                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTemplate:
  _1 = template _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pThenT:
  _1 = thenT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pThis:
  _1 = this _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pThrow:
  _1 = throw _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pThrows:
  _1 = throws _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pToT:
  _1 = toT _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTransient:
  _1 = transient _2 = TOK_EOF
    {                               ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTrueT:
  _1 = trueT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTryT:
  _1 = tryT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTypeT:
  _1 = typeT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTypedef:
  _1 = typedef _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTypeid:
  _1 = typeid _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pTypename:
  _1 = typename _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pUnion:
  _1 = union _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pUnsigned:
  _1 = unsigned _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pUsing:
  _1 = using _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pValT:
  _1 = valT _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pVirtualT:
  _1 = virtualT _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pVoid:
  _1 = void _2 = TOK_EOF
    {                     ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pVolatile:
  _1 = volatile _2 = TOK_EOF
    {                             ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWcharT:
  _1 = wcharT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWchar_T:
  _1 = wchar_T _2 = TOK_EOF
    {                           ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWhenT:
  _1 = whenT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWhere:
  _1 = where _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWhileT:
  _1 = whileT _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pWithT:
  _1 = withT _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pXor:
  _1 = xor _2 = TOK_EOF
    {                   ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pXorEq:
  _1 = xorEq _2 = TOK_EOF
    {                       ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

pXor_Eq:
  _1 = xor_Eq _2 = TOK_EOF
    {                         ( _1 )}
| _1 = error
    {          ( raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) )}

program:
  _1 = abstract _2 = andT _3 = andEq _4 = and_Eq _5 = asT _6 = asm _7 = asrT _8 = assertT _9 = auto _10 = beginT _11 = bitand _12 = bitor _13 = bool _14 = boolean _15 = break _16 = byte _17 = case _18 = catch _19 = char_ _20 = classT _21 = compl _22 = const _23 = constCast _24 = const_Cast _25 = constraintT _26 = continue _27 = data _28 = default _29 = delete _30 = deriving _31 = doT _32 = doneT _33 = double_ _34 = downtoT _35 = dynamicCast _36 = dynamic_Cast _37 = elseT _38 = endT _39 = enum _40 = exceptionT _41 = explicit _42 = extends _43 = extern _44 = externalT _45 = falseT _46 = family _47 = final _48 = finally _49 = float _50 = forT _51 = forall _52 = foreign _53 = friend _54 = funT _55 = functionT _56 = functorT _57 = goto _58 = hiding _59 = ifT _60 = implements _61 = import _62 = inT _63 = includeT _64 = infix _65 = infixl _66 = infixr _67 = inheritT _68 = initializerT _69 = inline _70 = instance _71 = instanceof _72 = int _73 = interface _74 = landT _75 = lazyT _76 = letT _77 = listT _78 = long _79 = lorT _80 = lslT _81 = lsrT _82 = lxorT _83 = matchT _84 = mdo _85 = methodT _86 = modT _87 = moduleT _88 = mutableT _89 = namespace _90 = native _91 = newT _92 = newtype _93 = nonrecT _94 = not _95 = notEq _96 = not_Eq _97 = null _98 = objectT _99 = ofT _100 = openT _101 = operator _102 = orT _103 = orEq _104 = or_Eq _105 = package _106 = pattern _107 = privateT _108 = proc _109 = protected _110 = public _111 = qualified _112 = recT _113 = register _114 = reinterpretCast _115 = reinterpret_Cast _116 = return _117 = short _118 = sigT _119 = signed _120 = sizeof _121 = staticCast _122 = static_Cast _123 = strictfp _124 = string_ _125 = structT _126 = super _127 = switch _128 = synchronized _129 = template _130 = thenT _131 = this _132 = throw _133 = throws _134 = toT _135 = transient _136 = trueT _137 = tryT _138 = typeT _139 = typedef _140 = typeid _141 = typename _142 = union _143 = unsigned _144 = using _145 = valT _146 = virtualT _147 = void _148 = volatile _149 = wcharT _150 = wchar_T _151 = whenT _152 = where _153 = whileT _154 = withT _155 = xor _156 = xorEq _157 = xor_Eq
    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( Prg (_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, _126, _127, _128, _129, _130, _131, _132, _133, _134, _135, _136, _137, _138, _139, _140, _141, _142, _143, _144, _145, _146, _147, _148, _149, _150, _151, _152, _153, _154, _155, _156, _157) )}

abstract:
  _1 = TOK_abstract
    {                        ( Abstract_Mk  )}

andT:
  _1 = TOK_and
    {               ( And_Mk  )}

andEq:
  _1 = TOK_and_eq
    {                   ( AndEq_Mk  )}

and_Eq:
  _1 = TOK_and_eq
    {                    ( And_Eq_Mk  )}

asT:
  _1 = TOK_as
    {             ( As_Mk  )}

asm:
  _1 = TOK_asm
    {              ( Asm_Mk  )}

asrT:
  _1 = TOK_asr
    {               ( Asr_Mk  )}

assertT:
  _1 = TOK_assert
    {                     ( Assert_Mk  )}

auto:
  _1 = TOK_auto
    {                ( Auto_Mk  )}

beginT:
  _1 = TOK_begin
    {                   ( Begin_Mk  )}

bitand:
  _1 = TOK_bitand
    {                    ( Bitand_Mk  )}

bitor:
  _1 = TOK_bitor
    {                  ( Bitor_Mk  )}

bool:
  _1 = TOK_bool
    {                ( Bool_Mk  )}

boolean:
  _1 = TOK_boolean
    {                      ( Boolean_Mk  )}

break:
  _1 = TOK_break
    {                  ( Break_Mk  )}

byte:
  _1 = TOK_byte
    {                ( Byte_Mk  )}

case:
  _1 = TOK_case
    {                ( Case_Mk  )}

catch:
  _1 = TOK_catch
    {                  ( Catch_Mk  )}

char_:
  _1 = TOK_char
    {                 ( Char__Mk  )}

classT:
  _1 = TOK_class
    {                   ( Class_Mk  )}

compl:
  _1 = TOK_compl
    {                  ( Compl_Mk  )}

const:
  _1 = TOK_const
    {                  ( Const_Mk  )}

constCast:
  _1 = TOK_const_cast
    {                           ( ConstCast_Mk  )}

const_Cast:
  _1 = TOK_const_cast
    {                            ( Const_Cast_Mk  )}

constraintT:
  _1 = TOK_constraint
    {                             ( Constraint_Mk  )}

continue:
  _1 = TOK_continue
    {                        ( Continue_Mk  )}

data:
  _1 = TOK_data
    {                ( Data_Mk  )}

default:
  _1 = TOK_default
    {                      ( Default_Mk  )}

delete:
  _1 = TOK_delete
    {                    ( Delete_Mk  )}

deriving:
  _1 = TOK_deriving
    {                        ( Deriving_Mk  )}

doT:
  _1 = TOK_do
    {             ( Do_Mk  )}

doneT:
  _1 = TOK_done
    {                 ( Done_Mk  )}

double_:
  _1 = TOK_double
    {                     ( Double__Mk  )}

downtoT:
  _1 = TOK_downto
    {                     ( Downto_Mk  )}

dynamicCast:
  _1 = TOK_dynamic_cast
    {                               ( DynamicCast_Mk  )}

dynamic_Cast:
  _1 = TOK_dynamic_cast
    {                                ( Dynamic_Cast_Mk  )}

elseT:
  _1 = TOK_else
    {                 ( Else_Mk  )}

endT:
  _1 = TOK_end
    {               ( End_Mk  )}

enum:
  _1 = TOK_enum
    {                ( Enum_Mk  )}

exceptionT:
  _1 = TOK_exception
    {                           ( Exception_Mk  )}

explicit:
  _1 = TOK_explicit
    {                        ( Explicit_Mk  )}

extends:
  _1 = TOK_extends
    {                      ( Extends_Mk  )}

extern:
  _1 = TOK_extern
    {                    ( Extern_Mk  )}

externalT:
  _1 = TOK_external
    {                         ( External_Mk  )}

falseT:
  _1 = TOK_false
    {                   ( False_Mk  )}

family:
  _1 = TOK_family
    {                    ( Family_Mk  )}

final:
  _1 = TOK_final
    {                  ( Final_Mk  )}

finally:
  _1 = TOK_finally
    {                      ( Finally_Mk  )}

float:
  _1 = TOK_float
    {                  ( Float_Mk  )}

forT:
  _1 = TOK_for
    {               ( For_Mk  )}

forall:
  _1 = TOK_forall
    {                    ( Forall_Mk  )}

foreign:
  _1 = TOK_foreign
    {                      ( Foreign_Mk  )}

friend:
  _1 = TOK_friend
    {                    ( Friend_Mk  )}

funT:
  _1 = TOK_fun
    {               ( Fun_Mk  )}

functionT:
  _1 = TOK_function
    {                         ( Function_Mk  )}

functorT:
  _1 = TOK_functor
    {                       ( Functor_Mk  )}

goto:
  _1 = TOK_goto
    {                ( Goto_Mk  )}

hiding:
  _1 = TOK_hiding
    {                    ( Hiding_Mk  )}

ifT:
  _1 = TOK_if
    {             ( If_Mk  )}

implements:
  _1 = TOK_implements
    {                            ( Implements_Mk  )}

import:
  _1 = TOK_import
    {                    ( Import_Mk  )}

inT:
  _1 = TOK_in
    {             ( In_Mk  )}

includeT:
  _1 = TOK_include
    {                       ( Include_Mk  )}

infix:
  _1 = TOK_infix
    {                  ( Infix_Mk  )}

infixl:
  _1 = TOK_infixl
    {                    ( Infixl_Mk  )}

infixr:
  _1 = TOK_infixr
    {                    ( Infixr_Mk  )}

inheritT:
  _1 = TOK_inherit
    {                       ( Inherit_Mk  )}

initializerT:
  _1 = TOK_initializer
    {                               ( Initializer_Mk  )}

inline:
  _1 = TOK_inline
    {                    ( Inline_Mk  )}

instance:
  _1 = TOK_instance
    {                        ( Instance_Mk  )}

instanceof:
  _1 = TOK_instanceof
    {                            ( Instanceof_Mk  )}

int:
  _1 = TOK_int
    {              ( Int_Mk  )}

interface:
  _1 = TOK_interface
    {                          ( Interface_Mk  )}

landT:
  _1 = TOK_land
    {                 ( Land_Mk  )}

lazyT:
  _1 = TOK_lazy
    {                 ( Lazy_Mk  )}

letT:
  _1 = TOK_let
    {               ( Let_Mk  )}

listT:
  _1 = TOK_list
    {                 ( List_Mk  )}

long:
  _1 = TOK_long
    {                ( Long_Mk  )}

lorT:
  _1 = TOK_lor
    {               ( Lor_Mk  )}

lslT:
  _1 = TOK_lsl
    {               ( Lsl_Mk  )}

lsrT:
  _1 = TOK_lsr
    {               ( Lsr_Mk  )}

lxorT:
  _1 = TOK_lxor
    {                 ( Lxor_Mk  )}

matchT:
  _1 = TOK_match
    {                   ( Match_Mk  )}

mdo:
  _1 = TOK_mdo
    {              ( Mdo_Mk  )}

methodT:
  _1 = TOK_method
    {                     ( Method_Mk  )}

modT:
  _1 = TOK_mod
    {               ( Mod_Mk  )}

moduleT:
  _1 = TOK_module
    {                     ( Module_Mk  )}

mutableT:
  _1 = TOK_mutable
    {                       ( Mutable_Mk  )}

namespace:
  _1 = TOK_namespace
    {                          ( Namespace_Mk  )}

native:
  _1 = TOK_native
    {                    ( Native_Mk  )}

newT:
  _1 = TOK_new
    {               ( New_Mk  )}

newtype:
  _1 = TOK_newtype
    {                      ( Newtype_Mk  )}

nonrecT:
  _1 = TOK_nonrec
    {                     ( Nonrec_Mk  )}

not:
  _1 = TOK_not
    {              ( Not_Mk  )}

notEq:
  _1 = TOK_not_eq
    {                   ( NotEq_Mk  )}

not_Eq:
  _1 = TOK_not_eq
    {                    ( Not_Eq_Mk  )}

null:
  _1 = TOK_null
    {                ( Null_Mk  )}

objectT:
  _1 = TOK_object
    {                     ( Object_Mk  )}

ofT:
  _1 = TOK_of
    {             ( Of_Mk  )}

openT:
  _1 = TOK_open
    {                 ( Open_Mk  )}

operator:
  _1 = TOK_operator
    {                        ( Operator_Mk  )}

orT:
  _1 = TOK_or
    {             ( Or_Mk  )}

orEq:
  _1 = TOK_or_eq
    {                 ( OrEq_Mk  )}

or_Eq:
  _1 = TOK_or_eq
    {                  ( Or_Eq_Mk  )}

package:
  _1 = TOK_package
    {                      ( Package_Mk  )}

pattern:
  _1 = TOK_pattern
    {                      ( Pattern_Mk  )}

privateT:
  _1 = TOK_private
    {                       ( Private_Mk  )}

proc:
  _1 = TOK_proc
    {                ( Proc_Mk  )}

protected:
  _1 = TOK_protected
    {                          ( Protected_Mk  )}

public:
  _1 = TOK_public
    {                    ( Public_Mk  )}

qualified:
  _1 = TOK_qualified
    {                          ( Qualified_Mk  )}

recT:
  _1 = TOK_rec
    {               ( Rec_Mk  )}

register:
  _1 = TOK_register
    {                        ( Register_Mk  )}

reinterpretCast:
  _1 = TOK_reinterpret_cast
    {                                       ( ReinterpretCast_Mk  )}

reinterpret_Cast:
  _1 = TOK_reinterpret_cast
    {                                        ( Reinterpret_Cast_Mk  )}

return:
  _1 = TOK_return
    {                    ( Return_Mk  )}

short:
  _1 = TOK_short
    {                  ( Short_Mk  )}

sigT:
  _1 = TOK_sig
    {               ( Sig_Mk  )}

signed:
  _1 = TOK_signed
    {                    ( Signed_Mk  )}

sizeof:
  _1 = TOK_sizeof
    {                    ( Sizeof_Mk  )}

staticCast:
  _1 = TOK_static_cast
    {                             ( StaticCast_Mk  )}

static_Cast:
  _1 = TOK_static_cast
    {                              ( Static_Cast_Mk  )}

strictfp:
  _1 = TOK_strictfp
    {                        ( Strictfp_Mk  )}

string_:
  _1 = TOK_string
    {                     ( String__Mk  )}

structT:
  _1 = TOK_struct
    {                     ( Struct_Mk  )}

super:
  _1 = TOK_super
    {                  ( Super_Mk  )}

switch:
  _1 = TOK_switch
    {                    ( Switch_Mk  )}

synchronized:
  _1 = TOK_synchronized
    {                                ( Synchronized_Mk  )}

template:
  _1 = TOK_template
    {                        ( Template_Mk  )}

thenT:
  _1 = TOK_then
    {                 ( Then_Mk  )}

this:
  _1 = TOK_this
    {                ( This_Mk  )}

throw:
  _1 = TOK_throw
    {                  ( Throw_Mk  )}

throws:
  _1 = TOK_throws
    {                    ( Throws_Mk  )}

toT:
  _1 = TOK_to
    {             ( To_Mk  )}

transient:
  _1 = TOK_transient
    {                          ( Transient_Mk  )}

trueT:
  _1 = TOK_true
    {                 ( True_Mk  )}

tryT:
  _1 = TOK_try
    {               ( Try_Mk  )}

typeT:
  _1 = TOK_type
    {                 ( Type_Mk  )}

typedef:
  _1 = TOK_typedef
    {                      ( Typedef_Mk  )}

typeid:
  _1 = TOK_typeid
    {                    ( Typeid_Mk  )}

typename:
  _1 = TOK_typename
    {                        ( Typename_Mk  )}

union:
  _1 = TOK_union
    {                  ( Union_Mk  )}

unsigned:
  _1 = TOK_unsigned
    {                        ( Unsigned_Mk  )}

using:
  _1 = TOK_using
    {                  ( Using_Mk  )}

valT:
  _1 = TOK_val
    {               ( Val_Mk  )}

virtualT:
  _1 = TOK_virtual
    {                       ( Virtual_Mk  )}

void:
  _1 = TOK_void
    {                ( Void_Mk  )}

volatile:
  _1 = TOK_volatile
    {                        ( Volatile_Mk  )}

wcharT:
  _1 = TOK_wchar_t
    {                     ( WcharT_Mk  )}

wchar_T:
  _1 = TOK_wchar_t
    {                      ( Wchar_T_Mk  )}

whenT:
  _1 = TOK_when
    {                 ( When_Mk  )}

where:
  _1 = TOK_where
    {                  ( Where_Mk  )}

whileT:
  _1 = TOK_while
    {                   ( While_Mk  )}

withT:
  _1 = TOK_with
    {                 ( With_Mk  )}

xor:
  _1 = TOK_xor
    {              ( Xor_Mk  )}

xorEq:
  _1 = TOK_xor_eq
    {                   ( XorEq_Mk  )}

xor_Eq:
  _1 = TOK_xor_eq
    {                    ( Xor_Eq_Mk  )}

%%
